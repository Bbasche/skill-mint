import { KwilSigner, NodeKwil, Utils, WebKwil } from "@kwilteam/kwil-js";
import { JsonRpcSigner, Wallet } from "ethers";
import { Wallet as Wallet$1 } from "@near-wallet-selector/core";

//#region ../@core/src/kwil-actions/schema.d.ts
declare const DataType: typeof Utils.DataType;
interface ActionSchemaElem {
  name: string;
  type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int;
}
declare const actionSchema: Record<string, ActionSchemaElem[]>;

//#endregion
//#region ../@core/src/kwil-infra/create-kwil-client.d.ts
type KwilActions = typeof actionSchema;
type ActionName = keyof KwilActions;
type AllKwilCallAction = { [Name in ActionName]: {
  name: Name;
  // biome-ignore lint/suspicious/noExplicitAny: This is fine
  inputs: Record<KwilActions[Name][number]["name"], any>;
} };
type KwilCallActionRequestParams = AllKwilCallAction[ActionName];
type AllKwilExecuteAction = { [Name in ActionName]: AllKwilCallAction[Name] & {
  description: string;
} };
type KwilExecuteActionRequestParams = AllKwilExecuteAction[ActionName];
/**
* A client for interacting with kwil with type-safe abstractions for `call` and `execute`.
* Has utility methods for creating actions and setting a signer.
*/
declare class KwilActionClient {
  #private;
  signer?: KwilSigner;
  readonly client: NodeKwil | WebKwil;
  constructor(client: NodeKwil | WebKwil);
  /**
  * Calls an action on the kwil nodes. This similar to `GET` like request.
  */
  call<T = unknown>(params: KwilCallActionRequestParams, signer?: KwilSigner | undefined): Promise<T>;
  /**
  * Executes an action on the kwil nodes. This similar to `POST` like request.
  */
  execute(params: KwilExecuteActionRequestParams, signer?: KwilSigner | undefined, synchronous?: boolean): Promise<string | undefined>;
  setSigner(signer: KwilSigner | undefined): void;
}

//#endregion
//#region ../@core/src/store/index.d.ts
/**
* Create a kwil client for node.js environment
*/
interface PipeCodecArgs<T> {
  encode: (o: string) => T;
  decode: (o: T) => string;
}
declare class Store {
  #private;
  keyPrefix: string;
  readonly storage: Storage;
  readonly REMEMBER_DURATION_KEY = "storage-expiration";
  constructor(storage: Storage);
  pipeCodec<T>({
    encode,
    decode
  }: PipeCodecArgs<T>): Store;
  // biome-ignore lint/suspicious/noExplicitAny: `any` is fine here.
  get(key: string): any;
  setRememberDuration(days?: number | string): void;
  hasRememberDurationElapsed(): boolean;
  // biome-ignore lint/suspicious/noExplicitAny: `any` is fine here.
  set(key: string, value: any): void;
  reset(): void;
}

//#endregion
//#region ../@core/src/types/index.d.ts
type Wallet$2 = Wallet | JsonRpcSigner | Wallet$1;
type idOSUser = {
  id: string;
  recipient_encryption_public_key: string;
};
type idOSCredential = {
  id: string;
  user_id: string;
  issuer_auth_public_key: string;
  original_id?: string;
  public_notes: string;
  content: string;
  encryptor_public_key: string;
};
type idOSWallet = {
  id: string;
  user_id: string;
  address: string;
  wallet_type: string;
  message: string;
  public_key: string;
  signature: string;
};
type idOSUserAttribute = {
  id: string;
  attribute_key: string;
  value: string;
  user_id?: string;
};
type idOSGrant = {
  id: string;
  ag_owner_user_id: string;
  ag_grantee_wallet_identifier: string;
  data_id: string;
  locked_until: string;
  content_hash?: string;
};
type DelegatedWriteGrant = {
  owner_wallet_identifier: string;
  grantee_wallet_identifier: string;
  issuer_public_key: string;
  id: string;
  access_grant_timelock: string;
  not_usable_before: string;
  not_usable_after: string;
};

//#endregion
//#region ../@core/src/kwil-actions/credentials.d.ts
/**
* Following types are specific to the isle `postMessage` protocol.
* Do not stress much about them, they will be refactored in the future once the idOS Isle is fully integrated.
*/

type ShareableCredential = {
  id: string;
  original_credential_id: string;
  public_notes: string;
  public_notes_signature: string;
  broader_signature: string;
  content: string;
  encryptor_public_key: string;
  issuer_auth_public_key: string;
  grantee_wallet_identifier: string;
  locked_until: number;
};

//#endregion
//#region ../@core/src/kwil-actions/grants.d.ts
/**
* Shares an idOSCredential to the given `userId`.
*/
/**
* Returns the Access Grants for the given `signer` in a paginated manner.
*/
interface GetGrantsParams {
  page?: number;
  size?: number;
  user_id?: string | null;
}
interface idOSDAGSignatureParams {
  dag_owner_wallet_identifier: string;
  dag_grantee_wallet_identifier: string;
  dag_data_id: string;
  dag_locked_until: number;
  dag_content_hash: string;
}

//#endregion
//#region ../@core/src/kwil-actions/wallets.d.ts
/**
* Request a signature for a Delegated Access Grant
*/
interface AddWalletParams {
  id: string;
  address: string;
  public_key: string | null;
  message: string;
  signature: string;
}

//#endregion
//#region src/enclave/types.d.ts
type DiscoverUserEncryptionPublicKeyResponse = {
  userId: string;
  userEncryptionPublicKey: string;
};
type EnclaveOptions = {
  container: string;
  theme?: "light" | "dark";
  mode?: "new" | "existing";
  url?: string;
  throwOnUserCancelUnlock?: boolean;
};
interface EnclaveProvider {
  load(): Promise<void>;
  reconfigure(options: Omit<EnclaveOptions, "container" | "url">): Promise<void>;
  ready(userId: string, currentUserEncryptionPublicKey?: string): Promise<Uint8Array>;
  reset(): Promise<void>;
  confirm(message: string): Promise<boolean>;
  encrypt(message: Uint8Array, receiverPublicKey?: Uint8Array): Promise<{
    content: Uint8Array;
    encryptorPublicKey: Uint8Array;
  }>;
  decrypt(message: Uint8Array, senderPublicKey?: Uint8Array): Promise<Uint8Array>;
  discoverUserEncryptionPublicKey(userId: string): Promise<DiscoverUserEncryptionPublicKeyResponse>;
  filterCredentials(credentials: idOSCredential[], privateFieldFilters: {
    pick: Record<string, unknown[]>;
    omit: Record<string, unknown[]>;
  }): Promise<idOSCredential[]>;
  backupPasswordOrSecret(): Promise<void>;
}

//#endregion
//#region src/index.d.ts
type Properties<T> = { [K in keyof T as Exclude<T[K], Function> extends never ? never : K]: T[K] };
type idOSClient = idOSClientConfiguration | idOSClientIdle | idOSClientWithUserSigner | idOSClientLoggedIn;
declare class idOSClientConfiguration {
  readonly state: "configuration";
  readonly chainId?: string;
  readonly nodeUrl: string;
  readonly enclaveOptions: Omit<EnclaveOptions, "mode">;
  constructor(params: {
    chainId?: string;
    nodeUrl: string;
    enclaveOptions: Omit<EnclaveOptions, "mode">;
  });
  createClient(): Promise<idOSClientIdle>;
}
declare class idOSClientIdle {
  readonly state: "idle";
  readonly store: Store;
  readonly kwilClient: KwilActionClient;
  readonly enclaveProvider: EnclaveProvider;
  constructor(store: Store, kwilClient: KwilActionClient, enclaveProvider: EnclaveProvider);
  static fromConfig(params: idOSClientConfiguration): Promise<idOSClientIdle>;
  addressHasProfile(address: string): Promise<boolean>;
  withUserSigner(signer: Wallet$2): Promise<idOSClientWithUserSigner>;
  logOut(): Promise<idOSClientIdle>;
}
declare class idOSClientWithUserSigner implements Omit<Properties<idOSClientIdle>, "state"> {
  readonly state: "with-user-signer";
  readonly store: Store;
  readonly kwilClient: KwilActionClient;
  readonly enclaveProvider: EnclaveProvider;
  readonly signer: Wallet$2;
  readonly kwilSigner: KwilSigner;
  readonly walletIdentifier: string;
  constructor(idOSClientIdle: idOSClientIdle, signer: Wallet$2, kwilSigner: KwilSigner, walletIdentifier: string);
  logOut(): Promise<idOSClientIdle>;
  hasProfile(): Promise<boolean>;
  getUserEncryptionPublicKey(userId: string): Promise<string>;
  logIn(): Promise<idOSClientLoggedIn>;
}
declare class idOSClientLoggedIn implements Omit<Properties<idOSClientWithUserSigner>, "state"> {
  readonly state: "logged-in";
  readonly store: Store;
  readonly kwilClient: KwilActionClient;
  readonly enclaveProvider: EnclaveProvider;
  readonly signer: Wallet$2;
  readonly kwilSigner: KwilSigner;
  readonly walletIdentifier: string;
  readonly user: idOSUser;
  constructor(idOSClientWithUserSigner: idOSClientWithUserSigner, user: idOSUser);
  logOut(): Promise<idOSClientIdle>;
  requestDWGMessage(params: DelegatedWriteGrant): Promise<string>;
  removeCredential(id: string): Promise<{
    id: string;
  }>;
  getCredentialById(id: string): Promise<idOSCredential | undefined>;
  shareCredential(credential: ShareableCredential): Promise<ShareableCredential>;
  getAllCredentials(): Promise<idOSCredential[]>;
  getAccessGrantsOwned(): Promise<idOSGrant[]>;
  getCredentialOwned(id: string): Promise<idOSCredential | undefined>;
  getAttributes(): Promise<idOSUserAttribute[]>;
  createAttribute(attribute: idOSUserAttribute): Promise<idOSUserAttribute>;
  getCredentialContentSha256Hash(id: string): Promise<string>;
  createCredentialCopy(id: string, consumerRecipientEncryptionPublicKey: string, consumerAddress: string, lockedUntil: number): Promise<{
    id: string;
  }>;
  requestDAGMessage(params: idOSDAGSignatureParams): Promise<string>;
  getGrants(params: GetGrantsParams): Promise<{
    grants: idOSGrant[];
    totalCount: number;
  }>;
  addWallets(params: AddWalletParams[]): Promise<AddWalletParams[]>;
  getGrantsCount(): Promise<number>;
  getSharedCredential(id: string): Promise<idOSCredential | undefined>;
  revokeAccessGrant(grantId: string): Promise<{
    id: string;
  }>;
  addWallet(params: AddWalletParams): Promise<AddWalletParams>;
  getWallets(): Promise<idOSWallet[]>;
  removeWallet(id: string): Promise<{
    id: string;
  }>;
  removeWallets(ids: string[]): Promise<string[]>;
  filterCredentials(requirements: {
    acceptedIssuers: {
      authPublicKey: string;
    }[];
    publicNotesFieldFilters?: {
      pick: Record<string, unknown[]>;
      omit: Record<string, unknown[]>;
    };
    privateFieldFilters?: {
      pick: Record<string, unknown[]>;
      omit: Record<string, unknown[]>;
    };
  }): Promise<idOSCredential[]>;
  requestAccessGrant(credentialId: string, {
    consumerEncryptionPublicKey,
    consumerAuthPublicKey
  }: {
    consumerEncryptionPublicKey: string;
    consumerAuthPublicKey: string;
  }): Promise<idOSCredential>;
}
declare function createIDOSClient(params: {
  nodeUrl: string;
  enclaveOptions: Omit<EnclaveOptions, "mode">;
}): idOSClientConfiguration;

//#endregion
export { DelegatedWriteGrant, EnclaveOptions, EnclaveProvider, createIDOSClient, idOSClient, idOSClientConfiguration, idOSClientIdle, idOSClientLoggedIn, idOSClientWithUserSigner, idOSCredential, idOSGrant, idOSUser, idOSUserAttribute, idOSWallet };
//# sourceMappingURL=index.d.ts.map