import { createRequire } from "node:module";
import nacl from "tweetnacl";
import invariant from "tiny-invariant";
import { Ed25519Signature2020 } from "@digitalbazaar/ed25519-signature-2020";
import { Ed25519VerificationKey2020 } from "@digitalbazaar/ed25519-verification-key-2020";
import * as vc from "@digitalbazaar/vc";
import * as base85 from "base85";
import { JsonLdDocumentLoader } from "jsonld-document-loader";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc$1) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key$1; i < n; i++) {
		key$1 = keys[i];
		if (!__hasOwnProp.call(to, key$1) && key$1 !== except) __defProp(to, key$1, {
			get: ((k) => from[k]).bind(null, key$1),
			enumerable: !(desc$1 = __getOwnPropDesc(from, key$1)) || desc$1.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+hex@1.0.1/node_modules/@stablelib/hex/lib/hex.js
var require_hex = __commonJS({ "../../node_modules/.pnpm/@stablelib+hex@1.0.1/node_modules/@stablelib/hex/lib/hex.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Package hex implements hex encoder and decoder.
	*/
	function encodeNibble(b) {
		var result = b + 48;
		result += 9 - b >>> 8 & 7;
		return String.fromCharCode(result);
	}
	function encodeNibbleLower(b) {
		var result = b + 48;
		result += 9 - b >>> 8 & 39;
		return String.fromCharCode(result);
	}
	var INVALID_HEX_NIBBLE = 256;
	function decodeNibble(c) {
		var result = INVALID_HEX_NIBBLE;
		result += (47 - c & c - 58) >> 8 & -INVALID_HEX_NIBBLE + c - 48;
		result += (64 - c & c - 71) >> 8 & -INVALID_HEX_NIBBLE + c - 65 + 10;
		result += (96 - c & c - 103) >> 8 & -INVALID_HEX_NIBBLE + c - 97 + 10;
		return result;
	}
	/**
	* Returns string with hex-encoded data.
	*/
	function encode$3(data, lowerCase) {
		if (lowerCase === void 0) lowerCase = false;
		var enc = lowerCase ? encodeNibbleLower : encodeNibble;
		var s$1 = "";
		for (var i = 0; i < data.length; i++) {
			s$1 += enc(data[i] >>> 4);
			s$1 += enc(data[i] & 15);
		}
		return s$1;
	}
	exports.encode = encode$3;
	/**
	* Returns Uint8Array with data decoded from hex string.
	*
	* Throws error if hex string length is not divisible by 2 or has non-hex
	* characters.
	*/
	function decode$2(hex) {
		if (hex.length === 0) return new Uint8Array(0);
		if (hex.length % 2 !== 0) throw new Error("hex: input string must be divisible by two");
		var result = new Uint8Array(hex.length / 2);
		var haveBad = 0;
		for (var i = 0; i < hex.length; i += 2) {
			var v0 = decodeNibble(hex.charCodeAt(i));
			var v1$1 = decodeNibble(hex.charCodeAt(i + 1));
			result[i / 2] = v0 << 4 | v1$1;
			haveBad |= v0 & INVALID_HEX_NIBBLE;
			haveBad |= v1$1 & INVALID_HEX_NIBBLE;
		}
		if (haveBad !== 0) throw new Error("hex: incorrect characters for decoding");
		return result;
	}
	exports.decode = decode$2;
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+int@1.0.1/node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({ "../../node_modules/.pnpm/@stablelib+int@1.0.1/node_modules/@stablelib/int/lib/int.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Package int provides helper functions for integerss.
	*/
	function imulShim(a, b) {
		var ah = a >>> 16 & 65535, al = a & 65535;
		var bh = b >>> 16 & 65535, bl = b & 65535;
		return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
	}
	/** 32-bit integer multiplication.  */
	exports.mul = Math.imul || imulShim;
	/** 32-bit integer addition.  */
	function add(a, b) {
		return a + b | 0;
	}
	exports.add = add;
	/**  32-bit integer subtraction.  */
	function sub(a, b) {
		return a - b | 0;
	}
	exports.sub = sub;
	/** 32-bit integer left rotation */
	function rotl(x, n) {
		return x << n | x >>> 32 - n;
	}
	exports.rotl = rotl;
	/** 32-bit integer left rotation */
	function rotr(x, n) {
		return x << 32 - n | x >>> n;
	}
	exports.rotr = rotr;
	function isIntegerShim(n) {
		return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
	}
	/**
	* Returns true if the argument is an integer number.
	*
	* In ES2015, Number.isInteger.
	*/
	exports.isInteger = Number.isInteger || isIntegerShim;
	/**
	*  Math.pow(2, 53) - 1
	*
	*  In ES2015 Number.MAX_SAFE_INTEGER.
	*/
	exports.MAX_SAFE_INTEGER = 9007199254740991;
	/**
	* Returns true if the argument is a safe integer number
	* (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
	*
	* In ES2015, Number.isSafeInteger.
	*/
	exports.isSafeInteger = function(n) {
		return exports.isInteger(n) && n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+binary@1.0.1/node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({ "../../node_modules/.pnpm/@stablelib+binary@1.0.1/node_modules/@stablelib/binary/lib/binary.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Package binary provides functions for encoding and decoding numbers in byte arrays.
	*/
	var int_1 = require_int();
	/**
	* Reads 2 bytes from array starting at offset as big-endian
	* signed 16-bit integer and returns it.
	*/
	function readInt16BE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
	}
	exports.readInt16BE = readInt16BE;
	/**
	* Reads 2 bytes from array starting at offset as big-endian
	* unsigned 16-bit integer and returns it.
	*/
	function readUint16BE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
	}
	exports.readUint16BE = readUint16BE;
	/**
	* Reads 2 bytes from array starting at offset as little-endian
	* signed 16-bit integer and returns it.
	*/
	function readInt16LE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
	}
	exports.readInt16LE = readInt16LE;
	/**
	* Reads 2 bytes from array starting at offset as little-endian
	* unsigned 16-bit integer and returns it.
	*/
	function readUint16LE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset + 1] << 8 | array[offset]) >>> 0;
	}
	exports.readUint16LE = readUint16LE;
	/**
	* Writes 2-byte big-endian representation of 16-bit unsigned
	* value to byte array starting at offset.
	*
	* If byte array is not given, creates a new 2-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint16BE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(2);
		if (offset === void 0) offset = 0;
		out[offset + 0] = value >>> 8;
		out[offset + 1] = value >>> 0;
		return out;
	}
	exports.writeUint16BE = writeUint16BE;
	exports.writeInt16BE = writeUint16BE;
	/**
	* Writes 2-byte little-endian representation of 16-bit unsigned
	* value to array starting at offset.
	*
	* If byte array is not given, creates a new 2-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint16LE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(2);
		if (offset === void 0) offset = 0;
		out[offset + 0] = value >>> 0;
		out[offset + 1] = value >>> 8;
		return out;
	}
	exports.writeUint16LE = writeUint16LE;
	exports.writeInt16LE = writeUint16LE;
	/**
	* Reads 4 bytes from array starting at offset as big-endian
	* signed 32-bit integer and returns it.
	*/
	function readInt32BE(array, offset) {
		if (offset === void 0) offset = 0;
		return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
	}
	exports.readInt32BE = readInt32BE;
	/**
	* Reads 4 bytes from array starting at offset as big-endian
	* unsigned 32-bit integer and returns it.
	*/
	function readUint32BE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
	}
	exports.readUint32BE = readUint32BE;
	/**
	* Reads 4 bytes from array starting at offset as little-endian
	* signed 32-bit integer and returns it.
	*/
	function readInt32LE(array, offset) {
		if (offset === void 0) offset = 0;
		return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
	}
	exports.readInt32LE = readInt32LE;
	/**
	* Reads 4 bytes from array starting at offset as little-endian
	* unsigned 32-bit integer and returns it.
	*/
	function readUint32LE(array, offset) {
		if (offset === void 0) offset = 0;
		return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
	}
	exports.readUint32LE = readUint32LE;
	/**
	* Writes 4-byte big-endian representation of 32-bit unsigned
	* value to byte array starting at offset.
	*
	* If byte array is not given, creates a new 4-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint32BE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(4);
		if (offset === void 0) offset = 0;
		out[offset + 0] = value >>> 24;
		out[offset + 1] = value >>> 16;
		out[offset + 2] = value >>> 8;
		out[offset + 3] = value >>> 0;
		return out;
	}
	exports.writeUint32BE = writeUint32BE;
	exports.writeInt32BE = writeUint32BE;
	/**
	* Writes 4-byte little-endian representation of 32-bit unsigned
	* value to array starting at offset.
	*
	* If byte array is not given, creates a new 4-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint32LE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(4);
		if (offset === void 0) offset = 0;
		out[offset + 0] = value >>> 0;
		out[offset + 1] = value >>> 8;
		out[offset + 2] = value >>> 16;
		out[offset + 3] = value >>> 24;
		return out;
	}
	exports.writeUint32LE = writeUint32LE;
	exports.writeInt32LE = writeUint32LE;
	/**
	* Reads 8 bytes from array starting at offset as big-endian
	* signed 64-bit integer and returns it.
	*
	* IMPORTANT: due to JavaScript limitation, supports exact
	* numbers in range -9007199254740991 to 9007199254740991.
	* If the number stored in the byte array is outside this range,
	* the result is not exact.
	*/
	function readInt64BE(array, offset) {
		if (offset === void 0) offset = 0;
		var hi = readInt32BE(array, offset);
		var lo = readInt32BE(array, offset + 4);
		return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
	}
	exports.readInt64BE = readInt64BE;
	/**
	* Reads 8 bytes from array starting at offset as big-endian
	* unsigned 64-bit integer and returns it.
	*
	* IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
	*/
	function readUint64BE(array, offset) {
		if (offset === void 0) offset = 0;
		var hi = readUint32BE(array, offset);
		var lo = readUint32BE(array, offset + 4);
		return hi * 4294967296 + lo;
	}
	exports.readUint64BE = readUint64BE;
	/**
	* Reads 8 bytes from array starting at offset as little-endian
	* signed 64-bit integer and returns it.
	*
	* IMPORTANT: due to JavaScript limitation, supports exact
	* numbers in range -9007199254740991 to 9007199254740991.
	* If the number stored in the byte array is outside this range,
	* the result is not exact.
	*/
	function readInt64LE(array, offset) {
		if (offset === void 0) offset = 0;
		var lo = readInt32LE(array, offset);
		var hi = readInt32LE(array, offset + 4);
		return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
	}
	exports.readInt64LE = readInt64LE;
	/**
	* Reads 8 bytes from array starting at offset as little-endian
	* unsigned 64-bit integer and returns it.
	*
	* IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
	*/
	function readUint64LE(array, offset) {
		if (offset === void 0) offset = 0;
		var lo = readUint32LE(array, offset);
		var hi = readUint32LE(array, offset + 4);
		return hi * 4294967296 + lo;
	}
	exports.readUint64LE = readUint64LE;
	/**
	* Writes 8-byte big-endian representation of 64-bit unsigned
	* value to byte array starting at offset.
	*
	* Due to JavaScript limitation, supports values up to 2^53-1.
	*
	* If byte array is not given, creates a new 8-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint64BE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(8);
		if (offset === void 0) offset = 0;
		writeUint32BE(value / 4294967296 >>> 0, out, offset);
		writeUint32BE(value >>> 0, out, offset + 4);
		return out;
	}
	exports.writeUint64BE = writeUint64BE;
	exports.writeInt64BE = writeUint64BE;
	/**
	* Writes 8-byte little-endian representation of 64-bit unsigned
	* value to byte array starting at offset.
	*
	* Due to JavaScript limitation, supports values up to 2^53-1.
	*
	* If byte array is not given, creates a new 8-byte one.
	*
	* Returns the output byte array.
	*/
	function writeUint64LE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(8);
		if (offset === void 0) offset = 0;
		writeUint32LE(value >>> 0, out, offset);
		writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
		return out;
	}
	exports.writeUint64LE = writeUint64LE;
	exports.writeInt64LE = writeUint64LE;
	/**
	* Reads bytes from array starting at offset as big-endian
	* unsigned bitLen-bit integer and returns it.
	*
	* Supports bit lengths divisible by 8, up to 48.
	*/
	function readUintBE(bitLength, array, offset) {
		if (offset === void 0) offset = 0;
		if (bitLength % 8 !== 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
		if (bitLength / 8 > array.length - offset) throw new Error("readUintBE: array is too short for the given bitLength");
		var result = 0;
		var mul = 1;
		for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
			result += array[i] * mul;
			mul *= 256;
		}
		return result;
	}
	exports.readUintBE = readUintBE;
	/**
	* Reads bytes from array starting at offset as little-endian
	* unsigned bitLen-bit integer and returns it.
	*
	* Supports bit lengths divisible by 8, up to 48.
	*/
	function readUintLE(bitLength, array, offset) {
		if (offset === void 0) offset = 0;
		if (bitLength % 8 !== 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
		if (bitLength / 8 > array.length - offset) throw new Error("readUintLE: array is too short for the given bitLength");
		var result = 0;
		var mul = 1;
		for (var i = offset; i < offset + bitLength / 8; i++) {
			result += array[i] * mul;
			mul *= 256;
		}
		return result;
	}
	exports.readUintLE = readUintLE;
	/**
	* Writes a big-endian representation of bitLen-bit unsigned
	* value to array starting at offset.
	*
	* Supports bit lengths divisible by 8, up to 48.
	*
	* If byte array is not given, creates a new one.
	*
	* Returns the output byte array.
	*/
	function writeUintBE(bitLength, value, out, offset) {
		if (out === void 0) out = new Uint8Array(bitLength / 8);
		if (offset === void 0) offset = 0;
		if (bitLength % 8 !== 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
		if (!int_1.isSafeInteger(value)) throw new Error("writeUintBE value must be an integer");
		var div = 1;
		for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
			out[i] = value / div & 255;
			div *= 256;
		}
		return out;
	}
	exports.writeUintBE = writeUintBE;
	/**
	* Writes a little-endian representation of bitLen-bit unsigned
	* value to array starting at offset.
	*
	* Supports bit lengths divisible by 8, up to 48.
	*
	* If byte array is not given, creates a new one.
	*
	* Returns the output byte array.
	*/
	function writeUintLE(bitLength, value, out, offset) {
		if (out === void 0) out = new Uint8Array(bitLength / 8);
		if (offset === void 0) offset = 0;
		if (bitLength % 8 !== 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
		if (!int_1.isSafeInteger(value)) throw new Error("writeUintLE value must be an integer");
		var div = 1;
		for (var i = offset; i < offset + bitLength / 8; i++) {
			out[i] = value / div & 255;
			div *= 256;
		}
		return out;
	}
	exports.writeUintLE = writeUintLE;
	/**
	* Reads 4 bytes from array starting at offset as big-endian
	* 32-bit floating-point number and returns it.
	*/
	function readFloat32BE(array, offset) {
		if (offset === void 0) offset = 0;
		var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
		return view.getFloat32(offset);
	}
	exports.readFloat32BE = readFloat32BE;
	/**
	* Reads 4 bytes from array starting at offset as little-endian
	* 32-bit floating-point number and returns it.
	*/
	function readFloat32LE(array, offset) {
		if (offset === void 0) offset = 0;
		var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
		return view.getFloat32(offset, true);
	}
	exports.readFloat32LE = readFloat32LE;
	/**
	* Reads 8 bytes from array starting at offset as big-endian
	* 64-bit floating-point number ("double") and returns it.
	*/
	function readFloat64BE(array, offset) {
		if (offset === void 0) offset = 0;
		var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
		return view.getFloat64(offset);
	}
	exports.readFloat64BE = readFloat64BE;
	/**
	* Reads 8 bytes from array starting at offset as little-endian
	* 64-bit floating-point number ("double") and returns it.
	*/
	function readFloat64LE(array, offset) {
		if (offset === void 0) offset = 0;
		var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
		return view.getFloat64(offset, true);
	}
	exports.readFloat64LE = readFloat64LE;
	/**
	* Writes 4-byte big-endian floating-point representation of value
	* to byte array starting at offset.
	*
	* If byte array is not given, creates a new 4-byte one.
	*
	* Returns the output byte array.
	*/
	function writeFloat32BE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(4);
		if (offset === void 0) offset = 0;
		var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
		view.setFloat32(offset, value);
		return out;
	}
	exports.writeFloat32BE = writeFloat32BE;
	/**
	* Writes 4-byte little-endian floating-point representation of value
	* to byte array starting at offset.
	*
	* If byte array is not given, creates a new 4-byte one.
	*
	* Returns the output byte array.
	*/
	function writeFloat32LE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(4);
		if (offset === void 0) offset = 0;
		var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
		view.setFloat32(offset, value, true);
		return out;
	}
	exports.writeFloat32LE = writeFloat32LE;
	/**
	* Writes 8-byte big-endian floating-point representation of value
	* to byte array starting at offset.
	*
	* If byte array is not given, creates a new 8-byte one.
	*
	* Returns the output byte array.
	*/
	function writeFloat64BE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(8);
		if (offset === void 0) offset = 0;
		var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
		view.setFloat64(offset, value);
		return out;
	}
	exports.writeFloat64BE = writeFloat64BE;
	/**
	* Writes 8-byte little-endian floating-point representation of value
	* to byte array starting at offset.
	*
	* If byte array is not given, creates a new 8-byte one.
	*
	* Returns the output byte array.
	*/
	function writeFloat64LE(value, out, offset) {
		if (out === void 0) out = new Uint8Array(8);
		if (offset === void 0) offset = 0;
		var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
		view.setFloat64(offset, value, true);
		return out;
	}
	exports.writeFloat64LE = writeFloat64LE;
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({ "../../node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Sets all values in the given array to zero and returns it.
	*
	* The fact that it sets bytes to zero can be relied on.
	*
	* There is no guarantee that this function makes data disappear from memory,
	* as runtime implementation can, for example, have copying garbage collector
	* that will make copies of sensitive data before we wipe it. Or that an
	* operating system will write our data to swap or sleep image. Another thing
	* is that an optimizing compiler can remove calls to this function or make it
	* no-op. There's nothing we can do with it, so we just do our best and hope
	* that everything will be okay and good will triumph over evil.
	*/
	function wipe(array) {
		for (var i = 0; i < array.length; i++) array[i] = 0;
		return array;
	}
	exports.wipe = wipe;
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+sha256@1.0.1/node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({ "../../node_modules/.pnpm/@stablelib+sha256@1.0.1/node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var binary_1 = require_binary();
	var wipe_1 = require_wipe();
	exports.DIGEST_LENGTH = 32;
	exports.BLOCK_SIZE = 64;
	/**
	* SHA2-256 cryptographic hash algorithm.
	*/
	var SHA256 = function() {
		function SHA256$1() {
			/** Length of hash output */
			this.digestLength = exports.DIGEST_LENGTH;
			/** Block size */
			this.blockSize = exports.BLOCK_SIZE;
			this._state = new Int32Array(8);
			this._temp = new Int32Array(64);
			this._buffer = new Uint8Array(128);
			this._bufferLength = 0;
			this._bytesHashed = 0;
			this._finished = false;
			this.reset();
		}
		SHA256$1.prototype._initState = function() {
			this._state[0] = 1779033703;
			this._state[1] = 3144134277;
			this._state[2] = 1013904242;
			this._state[3] = 2773480762;
			this._state[4] = 1359893119;
			this._state[5] = 2600822924;
			this._state[6] = 528734635;
			this._state[7] = 1541459225;
		};
		/**
		* Resets hash state making it possible
		* to re-use this instance to hash other data.
		*/
		SHA256$1.prototype.reset = function() {
			this._initState();
			this._bufferLength = 0;
			this._bytesHashed = 0;
			this._finished = false;
			return this;
		};
		/**
		* Cleans internal buffers and resets hash state.
		*/
		SHA256$1.prototype.clean = function() {
			wipe_1.wipe(this._buffer);
			wipe_1.wipe(this._temp);
			this.reset();
		};
		/**
		* Updates hash state with the given data.
		*
		* Throws error when trying to update already finalized hash:
		* instance must be reset to update it again.
		*/
		SHA256$1.prototype.update = function(data, dataLength) {
			if (dataLength === void 0) dataLength = data.length;
			if (this._finished) throw new Error("SHA256: can't update because hash was finished.");
			var dataPos = 0;
			this._bytesHashed += dataLength;
			if (this._bufferLength > 0) {
				while (this._bufferLength < this.blockSize && dataLength > 0) {
					this._buffer[this._bufferLength++] = data[dataPos++];
					dataLength--;
				}
				if (this._bufferLength === this.blockSize) {
					hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
					this._bufferLength = 0;
				}
			}
			if (dataLength >= this.blockSize) {
				dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
				dataLength %= this.blockSize;
			}
			while (dataLength > 0) {
				this._buffer[this._bufferLength++] = data[dataPos++];
				dataLength--;
			}
			return this;
		};
		/**
		* Finalizes hash state and puts hash into out.
		* If hash was already finalized, puts the same value.
		*/
		SHA256$1.prototype.finish = function(out) {
			if (!this._finished) {
				var bytesHashed = this._bytesHashed;
				var left = this._bufferLength;
				var bitLenHi = bytesHashed / 536870912 | 0;
				var bitLenLo = bytesHashed << 3;
				var padLength = bytesHashed % 64 < 56 ? 64 : 128;
				this._buffer[left] = 128;
				for (var i = left + 1; i < padLength - 8; i++) this._buffer[i] = 0;
				binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
				binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
				hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
				this._finished = true;
			}
			for (var i = 0; i < this.digestLength / 4; i++) binary_1.writeUint32BE(this._state[i], out, i * 4);
			return this;
		};
		/**
		* Returns the final hash digest.
		*/
		SHA256$1.prototype.digest = function() {
			var out = new Uint8Array(this.digestLength);
			this.finish(out);
			return out;
		};
		/**
		* Function useful for HMAC/PBKDF2 optimization.
		* Returns hash state to be used with restoreState().
		* Only chain value is saved, not buffers or other
		* state variables.
		*/
		SHA256$1.prototype.saveState = function() {
			if (this._finished) throw new Error("SHA256: cannot save finished state");
			return {
				state: new Int32Array(this._state),
				buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
				bufferLength: this._bufferLength,
				bytesHashed: this._bytesHashed
			};
		};
		/**
		* Function useful for HMAC/PBKDF2 optimization.
		* Restores state saved by saveState() and sets bytesHashed
		* to the given value.
		*/
		SHA256$1.prototype.restoreState = function(savedState) {
			this._state.set(savedState.state);
			this._bufferLength = savedState.bufferLength;
			if (savedState.buffer) this._buffer.set(savedState.buffer);
			this._bytesHashed = savedState.bytesHashed;
			this._finished = false;
			return this;
		};
		/**
		* Cleans state returned by saveState().
		*/
		SHA256$1.prototype.cleanSavedState = function(savedState) {
			wipe_1.wipe(savedState.state);
			if (savedState.buffer) wipe_1.wipe(savedState.buffer);
			savedState.bufferLength = 0;
			savedState.bytesHashed = 0;
		};
		return SHA256$1;
	}();
	exports.SHA256 = SHA256;
	var K = new Int32Array([
		1116352408,
		1899447441,
		3049323471,
		3921009573,
		961987163,
		1508970993,
		2453635748,
		2870763221,
		3624381080,
		310598401,
		607225278,
		1426881987,
		1925078388,
		2162078206,
		2614888103,
		3248222580,
		3835390401,
		4022224774,
		264347078,
		604807628,
		770255983,
		1249150122,
		1555081692,
		1996064986,
		2554220882,
		2821834349,
		2952996808,
		3210313671,
		3336571891,
		3584528711,
		113926993,
		338241895,
		666307205,
		773529912,
		1294757372,
		1396182291,
		1695183700,
		1986661051,
		2177026350,
		2456956037,
		2730485921,
		2820302411,
		3259730800,
		3345764771,
		3516065817,
		3600352804,
		4094571909,
		275423344,
		430227734,
		506948616,
		659060556,
		883997877,
		958139571,
		1322822218,
		1537002063,
		1747873779,
		1955562222,
		2024104815,
		2227730452,
		2361852424,
		2428436474,
		2756734187,
		3204031479,
		3329325298
	]);
	function hashBlocks(w$1, v, p, pos, len) {
		while (len >= 64) {
			var a = v[0];
			var b = v[1];
			var c = v[2];
			var d$1 = v[3];
			var e = v[4];
			var f = v[5];
			var g = v[6];
			var h$1 = v[7];
			for (var i = 0; i < 16; i++) {
				var j = pos + i * 4;
				w$1[i] = binary_1.readUint32BE(p, j);
			}
			for (var i = 16; i < 64; i++) {
				var u = w$1[i - 2];
				var t1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
				u = w$1[i - 15];
				var t2 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
				w$1[i] = (t1 + w$1[i - 7] | 0) + (t2 + w$1[i - 16] | 0);
			}
			for (var i = 0; i < 64; i++) {
				var t1 = (((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) + (e & f ^ ~e & g) | 0) + (h$1 + (K[i] + w$1[i] | 0) | 0) | 0;
				var t2 = ((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) + (a & b ^ a & c ^ b & c) | 0;
				h$1 = g;
				g = f;
				f = e;
				e = d$1 + t1 | 0;
				d$1 = c;
				c = b;
				b = a;
				a = t1 + t2 | 0;
			}
			v[0] += a;
			v[1] += b;
			v[2] += c;
			v[3] += d$1;
			v[4] += e;
			v[5] += f;
			v[6] += g;
			v[7] += h$1;
			pos += 64;
			len -= 64;
		}
		return pos;
	}
	function hash(data) {
		var h$1 = new SHA256();
		h$1.update(data);
		var digest = h$1.digest();
		h$1.clean();
		return digest;
	}
	exports.hash = hash;
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+utf8@1.0.2/node_modules/@stablelib/utf8/lib/utf8.js
var require_utf8 = __commonJS({ "../../node_modules/.pnpm/@stablelib+utf8@1.0.2/node_modules/@stablelib/utf8/lib/utf8.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decode = exports.encodedLength = exports.encode = void 0;
	/**
	* Package utf8 implements UTF-8 encoding and decoding.
	*/
	const INVALID_UTF16 = "utf8: invalid string";
	const INVALID_UTF8 = "utf8: invalid source encoding";
	/**
	* Encodes the given string into UTF-8 byte array.
	* Throws if the source string has invalid UTF-16 encoding.
	*/
	function encode$2(s$1) {
		const arr = new Uint8Array(encodedLength(s$1));
		let pos = 0;
		for (let i = 0; i < s$1.length; i++) {
			let c = s$1.charCodeAt(i);
			if (c >= 55296 && c <= 56319) c = (c - 55296 << 10) + (s$1.charCodeAt(++i) - 56320) + 65536;
			if (c < 128) arr[pos++] = c;
			else if (c < 2048) {
				arr[pos++] = 192 | c >> 6;
				arr[pos++] = 128 | c & 63;
			} else if (c < 65536) {
				arr[pos++] = 224 | c >> 12;
				arr[pos++] = 128 | c >> 6 & 63;
				arr[pos++] = 128 | c & 63;
			} else {
				arr[pos++] = 240 | c >> 18;
				arr[pos++] = 128 | c >> 12 & 63;
				arr[pos++] = 128 | c >> 6 & 63;
				arr[pos++] = 128 | c & 63;
			}
		}
		return arr;
	}
	exports.encode = encode$2;
	/**
	* Returns the number of bytes required to encode the given string into UTF-8.
	* Throws if the source string has invalid UTF-16 encoding.
	*/
	function encodedLength(s$1) {
		let result = 0;
		for (let i = 0; i < s$1.length; i++) {
			let c = s$1.charCodeAt(i);
			if (c >= 55296 && c <= 56319) {
				if (i === s$1.length - 1) throw new Error(INVALID_UTF16);
				i++;
				const c2 = s$1.charCodeAt(i);
				if (c2 < 56320 || c2 > 57343) throw new Error(INVALID_UTF16);
				c = (c - 55296 << 10) + (c2 - 56320) + 65536;
			}
			if (c < 128) result += 1;
			else if (c < 2048) result += 2;
			else if (c < 65536) result += 3;
			else result += 4;
		}
		return result;
	}
	exports.encodedLength = encodedLength;
	/**
	* Decodes the given byte array from UTF-8 into a string.
	* Throws if encoding is invalid.
	*/
	function decode$1(arr) {
		const chars = [];
		for (let i = 0; i < arr.length; i++) {
			let b = arr[i];
			if (b & 128) {
				let min$1;
				if (b < 224) {
					if (i >= arr.length) throw new Error(INVALID_UTF8);
					const n1 = arr[++i];
					if ((n1 & 192) !== 128) throw new Error(INVALID_UTF8);
					b = (b & 31) << 6 | n1 & 63;
					min$1 = 128;
				} else if (b < 240) {
					if (i >= arr.length - 1) throw new Error(INVALID_UTF8);
					const n1 = arr[++i];
					const n2 = arr[++i];
					if ((n1 & 192) !== 128 || (n2 & 192) !== 128) throw new Error(INVALID_UTF8);
					b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
					min$1 = 2048;
				} else if (b < 248) {
					if (i >= arr.length - 2) throw new Error(INVALID_UTF8);
					const n1 = arr[++i];
					const n2 = arr[++i];
					const n3 = arr[++i];
					if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) throw new Error(INVALID_UTF8);
					b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
					min$1 = 65536;
				} else throw new Error(INVALID_UTF8);
				if (b < min$1 || b >= 55296 && b <= 57343) throw new Error(INVALID_UTF8);
				if (b >= 65536) {
					if (b > 1114111) throw new Error(INVALID_UTF8);
					b -= 65536;
					chars.push(String.fromCharCode(55296 | b >> 10));
					b = 56320 | b & 1023;
				}
			}
			chars.push(String.fromCharCode(b));
		}
		return chars.join("");
	}
	exports.decode = decode$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/base-x@5.0.0/node_modules/base-x/src/esm/index.js
function base(ALPHABET$1) {
	if (ALPHABET$1.length >= 255) throw new TypeError("Alphabet too long");
	const BASE_MAP = new Uint8Array(256);
	for (let j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
	for (let i = 0; i < ALPHABET$1.length; i++) {
		const x = ALPHABET$1.charAt(i);
		const xc = x.charCodeAt(0);
		if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
		BASE_MAP[xc] = i;
	}
	const BASE = ALPHABET$1.length;
	const LEADER = ALPHABET$1.charAt(0);
	const FACTOR = Math.log(BASE) / Math.log(256);
	const iFACTOR = Math.log(256) / Math.log(BASE);
	function encode$4(source) {
		if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
		else if (Array.isArray(source)) source = Uint8Array.from(source);
		if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
		if (source.length === 0) return "";
		let zeroes = 0;
		let length = 0;
		let pbegin = 0;
		const pend = source.length;
		while (pbegin !== pend && source[pbegin] === 0) {
			pbegin++;
			zeroes++;
		}
		const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
		const b58 = new Uint8Array(size);
		while (pbegin !== pend) {
			let carry = source[pbegin];
			let i = 0;
			for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
				carry += 256 * b58[it1] >>> 0;
				b58[it1] = carry % BASE >>> 0;
				carry = carry / BASE >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i;
			pbegin++;
		}
		let it2 = size - length;
		while (it2 !== size && b58[it2] === 0) it2++;
		let str = LEADER.repeat(zeroes);
		for (; it2 < size; ++it2) str += ALPHABET$1.charAt(b58[it2]);
		return str;
	}
	function decodeUnsafe(source) {
		if (typeof source !== "string") throw new TypeError("Expected String");
		if (source.length === 0) return new Uint8Array();
		let psz = 0;
		let zeroes = 0;
		let length = 0;
		while (source[psz] === LEADER) {
			zeroes++;
			psz++;
		}
		const size = (source.length - psz) * FACTOR + 1 >>> 0;
		const b256 = new Uint8Array(size);
		while (source[psz]) {
			let carry = BASE_MAP[source.charCodeAt(psz)];
			if (carry === 255) return;
			let i = 0;
			for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
				carry += BASE * b256[it3] >>> 0;
				b256[it3] = carry % 256 >>> 0;
				carry = carry / 256 >>> 0;
			}
			if (carry !== 0) throw new Error("Non-zero carry");
			length = i;
			psz++;
		}
		let it4 = size - length;
		while (it4 !== size && b256[it4] === 0) it4++;
		const vch = new Uint8Array(zeroes + (size - it4));
		let j = zeroes;
		while (it4 !== size) vch[j++] = b256[it4++];
		return vch;
	}
	function decode$3(string) {
		const buffer = decodeUnsafe(string);
		if (buffer) return buffer;
		throw new Error("Non-base" + BASE + " character");
	}
	return {
		encode: encode$4,
		decodeUnsafe,
		decode: decode$3
	};
}
var esm_default$1 = base;

//#endregion
//#region ../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default = esm_default$1(ALPHABET);

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+base64@1.0.1/node_modules/@stablelib/base64/lib/base64.js
var require_base64$1 = __commonJS({ "../../node_modules/.pnpm/@stablelib+base64@1.0.1/node_modules/@stablelib/base64/lib/base64.js"(exports) {
	var __extends$1 = void 0 && (void 0).__extends || function() {
		var extendStatics = function(d$1, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$1) {
				d$2.__proto__ = b$1;
			} || function(d$2, b$1) {
				for (var p in b$1) if (b$1.hasOwnProperty(p)) d$2[p] = b$1[p];
			};
			return extendStatics(d$1, b);
		};
		return function(d$1, b) {
			extendStatics(d$1, b);
			function __() {
				this.constructor = d$1;
			}
			d$1.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		};
	}();
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Package base64 implements Base64 encoding and decoding.
	*/
	var INVALID_BYTE = 256;
	/**
	* Implements standard Base64 encoding.
	*
	* Operates in constant time.
	*/
	var Coder = function() {
		function Coder$1(_paddingCharacter) {
			if (_paddingCharacter === void 0) _paddingCharacter = "=";
			this._paddingCharacter = _paddingCharacter;
		}
		Coder$1.prototype.encodedLength = function(length) {
			if (!this._paddingCharacter) return (length * 8 + 5) / 6 | 0;
			return (length + 2) / 3 * 4 | 0;
		};
		Coder$1.prototype.encode = function(data) {
			var out = "";
			var i = 0;
			for (; i < data.length - 2; i += 3) {
				var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
				out += this._encodeByte(c >>> 3 * 6 & 63);
				out += this._encodeByte(c >>> 2 * 6 & 63);
				out += this._encodeByte(c >>> 1 * 6 & 63);
				out += this._encodeByte(c >>> 0 & 63);
			}
			var left = data.length - i;
			if (left > 0) {
				var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
				out += this._encodeByte(c >>> 3 * 6 & 63);
				out += this._encodeByte(c >>> 2 * 6 & 63);
				if (left === 2) out += this._encodeByte(c >>> 1 * 6 & 63);
				else out += this._paddingCharacter || "";
				out += this._paddingCharacter || "";
			}
			return out;
		};
		Coder$1.prototype.maxDecodedLength = function(length) {
			if (!this._paddingCharacter) return (length * 6 + 7) / 8 | 0;
			return length / 4 * 3 | 0;
		};
		Coder$1.prototype.decodedLength = function(s$1) {
			return this.maxDecodedLength(s$1.length - this._getPaddingLength(s$1));
		};
		Coder$1.prototype.decode = function(s$1) {
			if (s$1.length === 0) return new Uint8Array(0);
			var paddingLength = this._getPaddingLength(s$1);
			var length = s$1.length - paddingLength;
			var out = new Uint8Array(this.maxDecodedLength(length));
			var op = 0;
			var i = 0;
			var haveBad = 0;
			var v0 = 0, v1$1 = 0, v2 = 0, v3$1 = 0;
			for (; i < length - 4; i += 4) {
				v0 = this._decodeChar(s$1.charCodeAt(i + 0));
				v1$1 = this._decodeChar(s$1.charCodeAt(i + 1));
				v2 = this._decodeChar(s$1.charCodeAt(i + 2));
				v3$1 = this._decodeChar(s$1.charCodeAt(i + 3));
				out[op++] = v0 << 2 | v1$1 >>> 4;
				out[op++] = v1$1 << 4 | v2 >>> 2;
				out[op++] = v2 << 6 | v3$1;
				haveBad |= v0 & INVALID_BYTE;
				haveBad |= v1$1 & INVALID_BYTE;
				haveBad |= v2 & INVALID_BYTE;
				haveBad |= v3$1 & INVALID_BYTE;
			}
			if (i < length - 1) {
				v0 = this._decodeChar(s$1.charCodeAt(i));
				v1$1 = this._decodeChar(s$1.charCodeAt(i + 1));
				out[op++] = v0 << 2 | v1$1 >>> 4;
				haveBad |= v0 & INVALID_BYTE;
				haveBad |= v1$1 & INVALID_BYTE;
			}
			if (i < length - 2) {
				v2 = this._decodeChar(s$1.charCodeAt(i + 2));
				out[op++] = v1$1 << 4 | v2 >>> 2;
				haveBad |= v2 & INVALID_BYTE;
			}
			if (i < length - 3) {
				v3$1 = this._decodeChar(s$1.charCodeAt(i + 3));
				out[op++] = v2 << 6 | v3$1;
				haveBad |= v3$1 & INVALID_BYTE;
			}
			if (haveBad !== 0) throw new Error("Base64Coder: incorrect characters for decoding");
			return out;
		};
		Coder$1.prototype._encodeByte = function(b) {
			var result = b;
			result += 65;
			result += 25 - b >>> 8 & 6;
			result += 51 - b >>> 8 & -75;
			result += 61 - b >>> 8 & -15;
			result += 62 - b >>> 8 & 3;
			return String.fromCharCode(result);
		};
		Coder$1.prototype._decodeChar = function(c) {
			var result = INVALID_BYTE;
			result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
			result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
			result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
			result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
			result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
			return result;
		};
		Coder$1.prototype._getPaddingLength = function(s$1) {
			var paddingLength = 0;
			if (this._paddingCharacter) {
				for (var i = s$1.length - 1; i >= 0; i--) {
					if (s$1[i] !== this._paddingCharacter) break;
					paddingLength++;
				}
				if (s$1.length < 4 || paddingLength > 2) throw new Error("Base64Coder: incorrect padding");
			}
			return paddingLength;
		};
		return Coder$1;
	}();
	exports.Coder = Coder;
	var stdCoder = new Coder();
	function encode$1(data) {
		return stdCoder.encode(data);
	}
	exports.encode = encode$1;
	function decode(s$1) {
		return stdCoder.decode(s$1);
	}
	exports.decode = decode;
	/**
	* Implements URL-safe Base64 encoding.
	* (Same as Base64, but '+' is replaced with '-', and '/' with '_').
	*
	* Operates in constant time.
	*/
	var URLSafeCoder = function(_super) {
		__extends$1(URLSafeCoder$1, _super);
		function URLSafeCoder$1() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		URLSafeCoder$1.prototype._encodeByte = function(b) {
			var result = b;
			result += 65;
			result += 25 - b >>> 8 & 6;
			result += 51 - b >>> 8 & -75;
			result += 61 - b >>> 8 & -13;
			result += 62 - b >>> 8 & 49;
			return String.fromCharCode(result);
		};
		URLSafeCoder$1.prototype._decodeChar = function(c) {
			var result = INVALID_BYTE;
			result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
			result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
			result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
			result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
			result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
			return result;
		};
		return URLSafeCoder$1;
	}(Coder);
	exports.URLSafeCoder = URLSafeCoder;
	var urlSafeCoder = new URLSafeCoder();
	function encodeURLSafe(data) {
		return urlSafeCoder.encode(data);
	}
	exports.encodeURLSafe = encodeURLSafe;
	function decodeURLSafe(s$1) {
		return urlSafeCoder.decode(s$1);
	}
	exports.decodeURLSafe = decodeURLSafe;
	exports.encodedLength = function(length) {
		return stdCoder.encodedLength(length);
	};
	exports.maxDecodedLength = function(length) {
		return stdCoder.maxDecodedLength(length);
	};
	exports.decodedLength = function(s$1) {
		return stdCoder.decodedLength(s$1);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/@stablelib+bytes@1.0.1/node_modules/@stablelib/bytes/lib/bytes.js
var require_bytes$1 = __commonJS({ "../../node_modules/.pnpm/@stablelib+bytes@1.0.1/node_modules/@stablelib/bytes/lib/bytes.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function concat() {
		var totalLength = 0;
		for (var i = 0; i < arguments.length; i++) totalLength += arguments[i].length;
		var result = new Uint8Array(totalLength);
		var offset = 0;
		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			result.set(arg, offset);
			offset += arg.length;
		}
		return result;
	}
	exports.concat = concat;
} });

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/types.js
var integers = [
	"u8",
	"u16",
	"u32",
	"u64",
	"u128",
	"i8",
	"i16",
	"i32",
	"i64",
	"i128",
	"f32",
	"f64"
];

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/buffer.js
var EncodeBuffer = function() {
	function EncodeBuffer$1() {
		this.offset = 0;
		this.buffer_size = 256;
		this.buffer = new ArrayBuffer(this.buffer_size);
		this.view = new DataView(this.buffer);
	}
	EncodeBuffer$1.prototype.resize_if_necessary = function(needed_space) {
		if (this.buffer_size - this.offset < needed_space) {
			this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
			var new_buffer = new ArrayBuffer(this.buffer_size);
			new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
			this.buffer = new_buffer;
			this.view = new DataView(new_buffer);
		}
	};
	EncodeBuffer$1.prototype.get_used_buffer = function() {
		return new Uint8Array(this.buffer).slice(0, this.offset);
	};
	EncodeBuffer$1.prototype.store_value = function(value, type) {
		var bSize = type.substring(1);
		var size = parseInt(bSize) / 8;
		this.resize_if_necessary(size);
		var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
		this.view[toCall](this.offset, value, true);
		this.offset += size;
	};
	EncodeBuffer$1.prototype.store_bytes = function(from) {
		this.resize_if_necessary(from.length);
		new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
		this.offset += from.length;
	};
	return EncodeBuffer$1;
}();
var DecodeBuffer = function() {
	function DecodeBuffer$1(buf) {
		this.offset = 0;
		this.buffer_size = buf.length;
		this.buffer = new ArrayBuffer(buf.length);
		new Uint8Array(this.buffer).set(buf);
		this.view = new DataView(this.buffer);
	}
	DecodeBuffer$1.prototype.assert_enough_buffer = function(size) {
		if (this.offset + size > this.buffer.byteLength) throw new Error("Error in schema, the buffer is smaller than expected");
	};
	DecodeBuffer$1.prototype.consume_value = function(type) {
		var bSize = type.substring(1);
		var size = parseInt(bSize) / 8;
		this.assert_enough_buffer(size);
		var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
		var ret = this.view[toCall](this.offset, true);
		this.offset += size;
		return ret;
	};
	DecodeBuffer$1.prototype.consume_bytes = function(size) {
		this.assert_enough_buffer(size);
		var ret = this.buffer.slice(this.offset, this.offset + size);
		this.offset += size;
		return ret;
	};
	return DecodeBuffer$1;
}();

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/utils.js
var __extends = void 0 && (void 0).__extends || function() {
	var extendStatics = function(d$1, b) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$2, b$1) {
			d$2.__proto__ = b$1;
		} || function(d$2, b$1) {
			for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$2[p] = b$1[p];
		};
		return extendStatics(d$1, b);
	};
	return function(d$1, b) {
		if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		extendStatics(d$1, b);
		function __() {
			this.constructor = d$1;
		}
		d$1.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
}();
function isArrayLike(value) {
	return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
}
function expect_type(value, type, fieldPath) {
	if (typeof value !== type) throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_bigint(value, fieldPath) {
	var basicType = [
		"number",
		"string",
		"bigint",
		"boolean"
	].includes(typeof value);
	var strObject = typeof value === "object" && value !== null && "toString" in value;
	if (!basicType && !strObject) throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_same_size(length, expected, fieldPath) {
	if (length !== expected) throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
}
function expect_enum(value, fieldPath) {
	if (typeof value !== "object" || value === null) throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
var VALID_STRING_TYPES = integers.concat(["bool", "string"]);
var VALID_OBJECT_KEYS = [
	"option",
	"enum",
	"array",
	"set",
	"map",
	"struct"
];
var ErrorSchema = function(_super) {
	__extends(ErrorSchema$1, _super);
	function ErrorSchema$1(schema, expected) {
		var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
		return _super.call(this, message) || this;
	}
	return ErrorSchema$1;
}(Error);
function validate_schema(schema) {
	if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) return;
	if (schema && typeof schema === "object") {
		var keys = Object.keys(schema);
		if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
			var key$1 = keys[0];
			if (key$1 === "option") return validate_schema(schema[key$1]);
			if (key$1 === "enum") return validate_enum_schema(schema[key$1]);
			if (key$1 === "array") return validate_array_schema(schema[key$1]);
			if (key$1 === "set") return validate_schema(schema[key$1]);
			if (key$1 === "map") return validate_map_schema(schema[key$1]);
			if (key$1 === "struct") return validate_struct_schema(schema[key$1]);
		}
	}
	throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
}
function validate_enum_schema(schema) {
	if (!Array.isArray(schema)) throw new ErrorSchema(schema, "Array");
	for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
		var sch = schema_1[_i];
		if (typeof sch !== "object" || !("struct" in sch)) throw new Error("Missing \"struct\" key in enum schema");
		if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) throw new Error("The \"struct\" in each enum must have a single key");
		validate_schema({ struct: sch.struct });
	}
}
function validate_array_schema(schema) {
	if (typeof schema !== "object") throw new ErrorSchema(schema, "{ type, len? }");
	if (schema.len && typeof schema.len !== "number") throw new Error("Invalid schema: ".concat(schema));
	if ("type" in schema) return validate_schema(schema.type);
	throw new ErrorSchema(schema, "{ type, len? }");
}
function validate_map_schema(schema) {
	if (typeof schema === "object" && "key" in schema && "value" in schema) {
		validate_schema(schema.key);
		validate_schema(schema.value);
	} else throw new ErrorSchema(schema, "{ key, value }");
}
function validate_struct_schema(schema) {
	if (typeof schema !== "object") throw new ErrorSchema(schema, "object");
	for (var key$1 in schema) validate_schema(schema[key$1]);
}

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/serialize.js
var BorshSerializer = function() {
	function BorshSerializer$1(checkTypes) {
		this.encoded = new EncodeBuffer();
		this.fieldPath = ["value"];
		this.checkTypes = checkTypes;
	}
	BorshSerializer$1.prototype.encode = function(value, schema) {
		this.encode_value(value, schema);
		return this.encoded.get_used_buffer();
	};
	BorshSerializer$1.prototype.encode_value = function(value, schema) {
		if (typeof schema === "string") {
			if (integers.includes(schema)) return this.encode_integer(value, schema);
			if (schema === "string") return this.encode_string(value);
			if (schema === "bool") return this.encode_boolean(value);
		}
		if (typeof schema === "object") {
			if ("option" in schema) return this.encode_option(value, schema);
			if ("enum" in schema) return this.encode_enum(value, schema);
			if ("array" in schema) return this.encode_array(value, schema);
			if ("set" in schema) return this.encode_set(value, schema);
			if ("map" in schema) return this.encode_map(value, schema);
			if ("struct" in schema) return this.encode_struct(value, schema);
		}
	};
	BorshSerializer$1.prototype.encode_integer = function(value, schema) {
		var size = parseInt(schema.substring(1));
		if (size <= 32 || schema == "f64") {
			this.checkTypes && expect_type(value, "number", this.fieldPath);
			this.encoded.store_value(value, schema);
		} else {
			this.checkTypes && expect_bigint(value, this.fieldPath);
			this.encode_bigint(BigInt(value), size);
		}
	};
	BorshSerializer$1.prototype.encode_bigint = function(value, size) {
		var buffer_len = size / 8;
		var buffer = new Uint8Array(buffer_len);
		for (var i = 0; i < buffer_len; i++) {
			buffer[i] = Number(value & BigInt(255));
			value = value >> BigInt(8);
		}
		this.encoded.store_bytes(new Uint8Array(buffer));
	};
	BorshSerializer$1.prototype.encode_string = function(value) {
		this.checkTypes && expect_type(value, "string", this.fieldPath);
		var _value = value;
		this.encoded.store_value(_value.length, "u32");
		for (var i = 0; i < _value.length; i++) this.encoded.store_value(_value.charCodeAt(i), "u8");
	};
	BorshSerializer$1.prototype.encode_boolean = function(value) {
		this.checkTypes && expect_type(value, "boolean", this.fieldPath);
		this.encoded.store_value(value ? 1 : 0, "u8");
	};
	BorshSerializer$1.prototype.encode_option = function(value, schema) {
		if (value === null || value === void 0) this.encoded.store_value(0, "u8");
		else {
			this.encoded.store_value(1, "u8");
			this.encode_value(value, schema.option);
		}
	};
	BorshSerializer$1.prototype.encode_enum = function(value, schema) {
		this.checkTypes && expect_enum(value, this.fieldPath);
		var valueKey = Object.keys(value)[0];
		for (var i = 0; i < schema["enum"].length; i++) {
			var valueSchema = schema["enum"][i];
			if (valueKey === Object.keys(valueSchema.struct)[0]) {
				this.encoded.store_value(i, "u8");
				return this.encode_struct(value, valueSchema);
			}
		}
		throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
	};
	BorshSerializer$1.prototype.encode_array = function(value, schema) {
		if (isArrayLike(value)) return this.encode_arraylike(value, schema);
		if (value instanceof ArrayBuffer) return this.encode_buffer(value, schema);
		throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
	};
	BorshSerializer$1.prototype.encode_arraylike = function(value, schema) {
		if (schema.array.len) expect_same_size(value.length, schema.array.len, this.fieldPath);
		else this.encoded.store_value(value.length, "u32");
		for (var i = 0; i < value.length; i++) this.encode_value(value[i], schema.array.type);
	};
	BorshSerializer$1.prototype.encode_buffer = function(value, schema) {
		if (schema.array.len) expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
		else this.encoded.store_value(value.byteLength, "u32");
		this.encoded.store_bytes(new Uint8Array(value));
	};
	BorshSerializer$1.prototype.encode_set = function(value, schema) {
		this.checkTypes && expect_type(value, "object", this.fieldPath);
		var isSet = value instanceof Set;
		var values = isSet ? Array.from(value.values()) : Object.values(value);
		this.encoded.store_value(values.length, "u32");
		for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
			var value_1 = values_1[_i];
			this.encode_value(value_1, schema.set);
		}
	};
	BorshSerializer$1.prototype.encode_map = function(value, schema) {
		this.checkTypes && expect_type(value, "object", this.fieldPath);
		var isMap = value instanceof Map;
		var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
		this.encoded.store_value(keys.length, "u32");
		for (var _i = 0, keys_1$1 = keys; _i < keys_1$1.length; _i++) {
			var key$1 = keys_1$1[_i];
			this.encode_value(key$1, schema.map.key);
			this.encode_value(isMap ? value.get(key$1) : value[key$1], schema.map.value);
		}
	};
	BorshSerializer$1.prototype.encode_struct = function(value, schema) {
		this.checkTypes && expect_type(value, "object", this.fieldPath);
		for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
			var key$1 = _a[_i];
			this.fieldPath.push(key$1);
			this.encode_value(value[key$1], schema.struct[key$1]);
			this.fieldPath.pop();
		}
	};
	return BorshSerializer$1;
}();

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/deserialize.js
var BorshDeserializer = function() {
	function BorshDeserializer$1(bufferArray) {
		this.buffer = new DecodeBuffer(bufferArray);
	}
	BorshDeserializer$1.prototype.decode = function(schema) {
		return this.decode_value(schema);
	};
	BorshDeserializer$1.prototype.decode_value = function(schema) {
		if (typeof schema === "string") {
			if (integers.includes(schema)) return this.decode_integer(schema);
			if (schema === "string") return this.decode_string();
			if (schema === "bool") return this.decode_boolean();
		}
		if (typeof schema === "object") {
			if ("option" in schema) return this.decode_option(schema);
			if ("enum" in schema) return this.decode_enum(schema);
			if ("array" in schema) return this.decode_array(schema);
			if ("set" in schema) return this.decode_set(schema);
			if ("map" in schema) return this.decode_map(schema);
			if ("struct" in schema) return this.decode_struct(schema);
		}
		throw new Error("Unsupported type: ".concat(schema));
	};
	BorshDeserializer$1.prototype.decode_integer = function(schema) {
		var size = parseInt(schema.substring(1));
		if (size <= 32 || schema == "f64") return this.buffer.consume_value(schema);
		return this.decode_bigint(size, schema.startsWith("i"));
	};
	BorshDeserializer$1.prototype.decode_bigint = function(size, signed) {
		if (signed === void 0) signed = false;
		var buffer_len = size / 8;
		var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
		var bits = buffer.reduceRight(function(r, x) {
			return r + x.toString(16).padStart(2, "0");
		}, "");
		if (signed && buffer[buffer_len - 1]) return BigInt.asIntN(size, BigInt("0x".concat(bits)));
		return BigInt("0x".concat(bits));
	};
	BorshDeserializer$1.prototype.decode_string = function() {
		var len = this.decode_integer("u32");
		var buffer = new Uint8Array(this.buffer.consume_bytes(len));
		return String.fromCharCode.apply(null, buffer);
	};
	BorshDeserializer$1.prototype.decode_boolean = function() {
		return this.buffer.consume_value("u8") > 0;
	};
	BorshDeserializer$1.prototype.decode_option = function(schema) {
		var option = this.buffer.consume_value("u8");
		if (option === 1) return this.decode_value(schema.option);
		if (option !== 0) throw new Error("Invalid option ".concat(option));
		return null;
	};
	BorshDeserializer$1.prototype.decode_enum = function(schema) {
		var _a;
		var valueIndex = this.buffer.consume_value("u8");
		if (valueIndex > schema["enum"].length) throw new Error("Enum option ".concat(valueIndex, " is not available"));
		var struct = schema["enum"][valueIndex].struct;
		var key$1 = Object.keys(struct)[0];
		return _a = {}, _a[key$1] = this.decode_value(struct[key$1]), _a;
	};
	BorshDeserializer$1.prototype.decode_array = function(schema) {
		var result = [];
		var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
		for (var i = 0; i < len; ++i) result.push(this.decode_value(schema.array.type));
		return result;
	};
	BorshDeserializer$1.prototype.decode_set = function(schema) {
		var len = this.decode_integer("u32");
		var result = new Set();
		for (var i = 0; i < len; ++i) result.add(this.decode_value(schema.set));
		return result;
	};
	BorshDeserializer$1.prototype.decode_map = function(schema) {
		var len = this.decode_integer("u32");
		var result = new Map();
		for (var i = 0; i < len; ++i) {
			var key$1 = this.decode_value(schema.map.key);
			var value = this.decode_value(schema.map.value);
			result.set(key$1, value);
		}
		return result;
	};
	BorshDeserializer$1.prototype.decode_struct = function(schema) {
		var result = {};
		for (var key$1 in schema.struct) result[key$1] = this.decode_value(schema.struct[key$1]);
		return result;
	};
	return BorshDeserializer$1;
}();

//#endregion
//#region ../../node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/esm/index.js
function serialize(schema, value, validate$1) {
	if (validate$1 === void 0) validate$1 = true;
	if (validate$1) validate_schema(schema);
	var serializer = new BorshSerializer(validate$1);
	return serializer.encode(value, schema);
}

//#endregion
//#region ../@core/src/codecs/index.ts
var import_hex = __toESM(require_hex(), 1);
var import_sha256 = __toESM(require_sha256(), 1);
var import_utf8 = __toESM(require_utf8(), 1);
var import_base64 = __toESM(require_base64$1(), 1);
var import_binary = __toESM(require_binary(), 1);
var import_bytes = __toESM(require_bytes$1(), 1);
var import_hex$1 = __toESM(require_hex(), 1);
var import_utf8$1 = __toESM(require_utf8(), 1);
function hexEncodeSha256Hash(data) {
	return (0, import_hex.encode)((0, import_sha256.hash)(data), true);
}
function bs58Encode(data) {
	return esm_default.encode(data);
}
function bs58Decode(data) {
	return esm_default.decode(data);
}

//#endregion
//#region ../@core/src/cryptography/index.ts
/**
* Encrypts a message using the recipient's public key and the sender's secret key.
*/
function encryptContent(message, recipientEncryptionPublicKey, senderEncryptionSecretKey) {
	const nonce = nacl.randomBytes(nacl.box.nonceLength);
	const encrypted = nacl.box(message, nonce, recipientEncryptionPublicKey, senderEncryptionSecretKey);
	if (encrypted === null) throw Error(`Couldn't encrypt the provided message. ${JSON.stringify({
		message: (0, import_base64.encode)(message),
		nonce: (0, import_base64.encode)(nonce),
		recipientEncryptionPublicKey: (0, import_base64.encode)(recipientEncryptionPublicKey)
	}, null, 2)}`);
	const fullMessage = new Uint8Array(nonce.length + encrypted.length);
	fullMessage.set(nonce, 0);
	fullMessage.set(encrypted, nonce.length);
	return fullMessage;
}
/**
* Decrypts a message using the sender's public key and the recipient's secret key.
*/
function decryptContent(message, nonce, senderEncryptionPublicKey, recipientEncryptionSecretKey) {
	const decrypted = nacl.box.open(message, nonce, senderEncryptionPublicKey, recipientEncryptionSecretKey);
	if (decrypted === null) throw Error(`Couldn't decrypt the provided message. ${JSON.stringify({
		message: (0, import_base64.encode)(message),
		nonce: (0, import_base64.encode)(nonce),
		senderEncryptionPublicKey: (0, import_base64.encode)(senderEncryptionPublicKey),
		recipientEncryptionSecretKey: (0, import_base64.encode)(recipientEncryptionSecretKey)
	}, null, 2)}`);
	return decrypted;
}
var NoncedBox = class NoncedBox {
	keyPair;
	constructor(keyPair) {
		this.keyPair = keyPair;
	}
	static nonceFromBase64SecretKey(secret) {
		return new NoncedBox(nacl.box.keyPair.fromSecretKey((0, import_base64.decode)(secret)));
	}
	async decrypt(b64FullMessage, b64SenderPublicKey) {
		const decodedMessage = (0, import_base64.decode)(b64FullMessage);
		const senderEncryptionPublicKey = (0, import_base64.decode)(b64SenderPublicKey);
		const message = decodedMessage.slice(nacl.box.nonceLength, decodedMessage.length);
		const nonce = decodedMessage.slice(0, nacl.box.nonceLength);
		const content = decryptContent(message, nonce, senderEncryptionPublicKey, this.keyPair.secretKey);
		return (0, import_utf8$1.decode)(content);
	}
};

//#endregion
//#region ../@core/src/kwil-actions/credentials.ts
/**
* Returns the shared idOS Credential for the given `dataId`.
*/
async function getSharedCredential(kwilClient, id) {
	const [credential] = await kwilClient.call({
		name: "get_credential_shared",
		inputs: { id }
	});
	return credential;
}
/**
* Returns the idOSCredential `id` which content hash matches the given `contentHash`.
*/
async function getCredentialIdByContentHash(kwilClient, content_hash) {
	const response = await kwilClient.call({
		name: "get_sibling_credential_id",
		inputs: { content_hash }
	});
	return response[0]?.id ?? null;
}
/**
* Edits the public notes of an idOSCredential if the signer is a permissioned issuer.
* This is how a credential is edited (modified) by a permissioned issuer.
*/
async function editCredentialAsIssuer(kwilClient, params) {
	await kwilClient.execute({
		name: "edit_public_notes_as_issuer",
		description: "Edit a credential in your idOS profile",
		inputs: params
	});
	return params;
}
/**
* Creates a new credential from a delegated write grant.
*/
async function createCredentialByDelegatedWriteGrant(kwilClient, params) {
	await kwilClient.execute({
		name: "create_credentials_by_dwg",
		description: "Create a new credential in your idOS profile",
		inputs: params
	});
	return params;
}

//#endregion
//#region ../@core/src/kwil-actions/grants.ts
/**
* Creates a new Access Grant from the given Delegated Access Grant payload.
*/
async function createAccessGrantByDag(kwilClient, params) {
	await kwilClient.execute({
		name: "create_ag_by_dag_for_copy",
		description: "Create an Access Grant in idOS",
		inputs: params
	});
	return params;
}

//#endregion
//#region ../@core/src/kwil-actions/user.ts
/**
* Checks if the user has a profile in the idOS associated with its wallet address.
*/
async function hasProfile(kwilClient, address) {
	const [{ has_profile }] = await kwilClient.call({
		name: "has_profile",
		inputs: { address }
	}, void 0);
	return has_profile;
}
/**
* Creates a user profile in the idOS.
*/
async function createUser(kwilClient, params) {
	await kwilClient.execute({
		name: "add_user_as_inserter",
		description: "Create a user profile in idOS",
		inputs: params
	});
	return params;
}

//#endregion
//#region ../@core/src/kwil-actions/wallets.ts
/**
* Upserts a wallet as an `inserter`.
*/
async function upsertWalletAsInserter(kwilClient, params) {
	await kwilClient.execute({
		name: "upsert_wallet_as_inserter",
		description: "Add a wallet to idOS",
		inputs: params
	});
	return params;
}

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/base64.js
var require_base64 = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/base64.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.base64ToBytes = exports.bytesToBase64 = void 0;
	const base64abc = [
		"A",
		"B",
		"C",
		"D",
		"E",
		"F",
		"G",
		"H",
		"I",
		"J",
		"K",
		"L",
		"M",
		"N",
		"O",
		"P",
		"Q",
		"R",
		"S",
		"T",
		"U",
		"V",
		"W",
		"X",
		"Y",
		"Z",
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"g",
		"h",
		"i",
		"j",
		"k",
		"l",
		"m",
		"n",
		"o",
		"p",
		"q",
		"r",
		"s",
		"t",
		"u",
		"v",
		"w",
		"x",
		"y",
		"z",
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"+",
		"/"
	];
	const base64codes = [
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		62,
		255,
		255,
		255,
		63,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		255,
		255,
		255,
		0,
		255,
		255,
		255,
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		23,
		24,
		25,
		255,
		255,
		255,
		255,
		255,
		255,
		26,
		27,
		28,
		29,
		30,
		31,
		32,
		33,
		34,
		35,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51
	];
	function getBase64Code(charCode) {
		if (charCode >= base64codes.length) throw new Error("Unable to parse base64 string.");
		const code = base64codes[charCode];
		if (code === 255) throw new Error("Unable to parse base64 string.");
		return code;
	}
	function bytesToBase64(bytes) {
		let result = "", i, l = bytes.length;
		for (i = 2; i < l; i += 3) {
			result += base64abc[bytes[i - 2] >> 2];
			result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
			result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
			result += base64abc[bytes[i] & 63];
		}
		if (i === l + 1) {
			result += base64abc[bytes[i - 2] >> 2];
			result += base64abc[(bytes[i - 2] & 3) << 4];
			result += "==";
		}
		if (i === l) {
			result += base64abc[bytes[i - 2] >> 2];
			result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
			result += base64abc[(bytes[i - 1] & 15) << 2];
			result += "=";
		}
		return result;
	}
	exports.bytesToBase64 = bytesToBase64;
	function base64ToBytes(str) {
		if (str.length % 4 !== 0) throw new Error("Unable to parse base64 string.");
		const index = str.indexOf("=");
		if (index !== -1 && index < str.length - 2) throw new Error("Unable to parse base64 string.");
		let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n = str.length, result = new Uint8Array(3 * (n / 4)), buffer;
		for (let i = 0, j = 0; i < n; i += 4, j += 3) {
			buffer = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));
			result[j] = buffer >> 16;
			result[j + 1] = buffer >> 8 & 255;
			result[j + 2] = buffer & 255;
		}
		return result.subarray(0, result.length - missingOctets);
	}
	exports.base64ToBytes = base64ToBytes;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/bind.js"(exports, module) {
	module.exports = function bind$6(fn, thisArg) {
		return function wrap$2() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			return fn.apply(thisArg, args);
		};
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/utils.js
var require_utils = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/utils.js"(exports, module) {
	var bind$5 = require_bind();
	var toString = Object.prototype.toString;
	var kindOf = function(cache) {
		return function(thing) {
			var str = toString.call(thing);
			return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
		};
	}(Object.create(null));
	function kindOfTest(type) {
		type = type.toLowerCase();
		return function isKindOf(thing) {
			return kindOf(thing) === type;
		};
	}
	/**
	* Determine if a value is an Array
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is an Array, otherwise false
	*/
	function isArray(val) {
		return Array.isArray(val);
	}
	/**
	* Determine if a value is undefined
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if the value is undefined, otherwise false
	*/
	function isUndefined(val) {
		return typeof val === "undefined";
	}
	/**
	* Determine if a value is a Buffer
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Buffer, otherwise false
	*/
	function isBuffer$1(val) {
		return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
	}
	/**
	* Determine if a value is an ArrayBuffer
	*
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is an ArrayBuffer, otherwise false
	*/
	var isArrayBuffer = kindOfTest("ArrayBuffer");
	/**
	* Determine if a value is a view on an ArrayBuffer
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	*/
	function isArrayBufferView(val) {
		var result;
		if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
		else result = val && val.buffer && isArrayBuffer(val.buffer);
		return result;
	}
	/**
	* Determine if a value is a String
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a String, otherwise false
	*/
	function isString$1(val) {
		return typeof val === "string";
	}
	/**
	* Determine if a value is a Number
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Number, otherwise false
	*/
	function isNumber(val) {
		return typeof val === "number";
	}
	/**
	* Determine if a value is an Object
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is an Object, otherwise false
	*/
	function isObject(val) {
		return val !== null && typeof val === "object";
	}
	/**
	* Determine if a value is a plain Object
	*
	* @param {Object} val The value to test
	* @return {boolean} True if value is a plain Object, otherwise false
	*/
	function isPlainObject(val) {
		if (kindOf(val) !== "object") return false;
		var prototype$1 = Object.getPrototypeOf(val);
		return prototype$1 === null || prototype$1 === Object.prototype;
	}
	/**
	* Determine if a value is a Date
	*
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Date, otherwise false
	*/
	var isDate = kindOfTest("Date");
	/**
	* Determine if a value is a File
	*
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a File, otherwise false
	*/
	var isFile = kindOfTest("File");
	/**
	* Determine if a value is a Blob
	*
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Blob, otherwise false
	*/
	var isBlob = kindOfTest("Blob");
	/**
	* Determine if a value is a FileList
	*
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a File, otherwise false
	*/
	var isFileList = kindOfTest("FileList");
	/**
	* Determine if a value is a Function
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Function, otherwise false
	*/
	function isFunction$1(val) {
		return toString.call(val) === "[object Function]";
	}
	/**
	* Determine if a value is a Stream
	*
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a Stream, otherwise false
	*/
	function isStream(val) {
		return isObject(val) && isFunction$1(val.pipe);
	}
	/**
	* Determine if a value is a FormData
	*
	* @param {Object} thing The value to test
	* @returns {boolean} True if value is an FormData, otherwise false
	*/
	function isFormData(thing) {
		var pattern = "[object FormData]";
		return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
	}
	/**
	* Determine if a value is a URLSearchParams object
	* @function
	* @param {Object} val The value to test
	* @returns {boolean} True if value is a URLSearchParams object, otherwise false
	*/
	var isURLSearchParams = kindOfTest("URLSearchParams");
	/**
	* Trim excess whitespace off the beginning and end of a string
	*
	* @param {String} str The String to trim
	* @returns {String} The String freed of excess whitespace
	*/
	function trim(str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
	}
	/**
	* Determine if we're running in a standard browser environment
	*
	* This allows axios to run in a web worker, and react-native.
	* Both environments support XMLHttpRequest, but not fully standard globals.
	*
	* web workers:
	*  typeof window -> undefined
	*  typeof document -> undefined
	*
	* react-native:
	*  navigator.product -> 'ReactNative'
	* nativescript
	*  navigator.product -> 'NativeScript' or 'NS'
	*/
	function isStandardBrowserEnv() {
		if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) return false;
		return typeof window !== "undefined" && typeof document !== "undefined";
	}
	/**
	* Iterate over an Array or an Object invoking a function for each item.
	*
	* If `obj` is an Array callback will be called passing
	* the value, index, and complete array for each item.
	*
	* If 'obj' is an Object callback will be called passing
	* the value, key, and complete object for each property.
	*
	* @param {Object|Array} obj The object to iterate
	* @param {Function} fn The callback to invoke for each item
	*/
	function forEach(obj, fn) {
		if (obj === null || typeof obj === "undefined") return;
		if (typeof obj !== "object") obj = [obj];
		if (isArray(obj)) for (var i = 0, l = obj.length; i < l; i++) fn.call(null, obj[i], i, obj);
		else for (var key$1 in obj) if (Object.prototype.hasOwnProperty.call(obj, key$1)) fn.call(null, obj[key$1], key$1, obj);
	}
	/**
	* Accepts varargs expecting each argument to be an object, then
	* immutably merges the properties of each object and returns result.
	*
	* When multiple objects contain the same key the later object in
	* the arguments list will take precedence.
	*
	* Example:
	*
	* ```js
	* var result = merge({foo: 123}, {foo: 456});
	* console.log(result.foo); // outputs 456
	* ```
	*
	* @param {Object} obj1 Object to merge
	* @returns {Object} Result of all merge properties
	*/
	function merge() {
		var result = {};
		function assignValue(val, key$1) {
			if (isPlainObject(result[key$1]) && isPlainObject(val)) result[key$1] = merge(result[key$1], val);
			else if (isPlainObject(val)) result[key$1] = merge({}, val);
			else if (isArray(val)) result[key$1] = val.slice();
			else result[key$1] = val;
		}
		for (var i = 0, l = arguments.length; i < l; i++) forEach(arguments[i], assignValue);
		return result;
	}
	/**
	* Extends object a by mutably adding to it the properties of object b.
	*
	* @param {Object} a The object to be extended
	* @param {Object} b The object to copy properties from
	* @param {Object} thisArg The object to bind function to
	* @return {Object} The resulting value of object a
	*/
	function extend(a, b, thisArg) {
		forEach(b, function assignValue(val, key$1) {
			if (thisArg && typeof val === "function") a[key$1] = bind$5(val, thisArg);
			else a[key$1] = val;
		});
		return a;
	}
	/**
	* Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	*
	* @param {string} content with BOM
	* @return {string} content value without BOM
	*/
	function stripBOM(content) {
		if (content.charCodeAt(0) === 65279) content = content.slice(1);
		return content;
	}
	/**
	* Inherit the prototype methods from one constructor into another
	* @param {function} constructor
	* @param {function} superConstructor
	* @param {object} [props]
	* @param {object} [descriptors]
	*/
	function inherits(constructor, superConstructor, props, descriptors$1) {
		constructor.prototype = Object.create(superConstructor.prototype, descriptors$1);
		constructor.prototype.constructor = constructor;
		props && Object.assign(constructor.prototype, props);
	}
	/**
	* Resolve object with deep prototype chain to a flat object
	* @param {Object} sourceObj source object
	* @param {Object} [destObj]
	* @param {Function} [filter]
	* @returns {Object}
	*/
	function toFlatObject(sourceObj, destObj, filter) {
		var props;
		var i;
		var prop;
		var merged = {};
		destObj = destObj || {};
		do {
			props = Object.getOwnPropertyNames(sourceObj);
			i = props.length;
			while (i-- > 0) {
				prop = props[i];
				if (!merged[prop]) {
					destObj[prop] = sourceObj[prop];
					merged[prop] = true;
				}
			}
			sourceObj = Object.getPrototypeOf(sourceObj);
		} while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
		return destObj;
	}
	function endsWith(str, searchString, position) {
		str = String(str);
		if (position === void 0 || position > str.length) position = str.length;
		position -= searchString.length;
		var lastIndex = str.indexOf(searchString, position);
		return lastIndex !== -1 && lastIndex === position;
	}
	/**
	* Returns new array from array like object
	* @param {*} [thing]
	* @returns {Array}
	*/
	function toArray(thing) {
		if (!thing) return null;
		var i = thing.length;
		if (isUndefined(i)) return null;
		var arr = new Array(i);
		while (i-- > 0) arr[i] = thing[i];
		return arr;
	}
	var isTypedArray = function(TypedArray$1) {
		return function(thing) {
			return TypedArray$1 && thing instanceof TypedArray$1;
		};
	}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
	module.exports = {
		isArray,
		isArrayBuffer,
		isBuffer: isBuffer$1,
		isFormData,
		isArrayBufferView,
		isString: isString$1,
		isNumber,
		isObject,
		isPlainObject,
		isUndefined,
		isDate,
		isFile,
		isBlob,
		isFunction: isFunction$1,
		isStream,
		isURLSearchParams,
		isStandardBrowserEnv,
		forEach,
		merge,
		extend,
		trim,
		stripBOM,
		inherits,
		toFlatObject,
		kindOf,
		kindOfTest,
		endsWith,
		toArray,
		isTypedArray,
		isFileList
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
	var utils$17 = require_utils();
	function encode(val) {
		return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
	}
	/**
	* Build a URL by appending params to the end
	*
	* @param {string} url The base of the url (e.g., http://www.google.com)
	* @param {object} [params] The params to be appended
	* @returns {string} The formatted url
	*/
	module.exports = function buildURL$3(url$2, params, paramsSerializer) {
		if (!params) return url$2;
		var serializedParams;
		if (paramsSerializer) serializedParams = paramsSerializer(params);
		else if (utils$17.isURLSearchParams(params)) serializedParams = params.toString();
		else {
			var parts = [];
			utils$17.forEach(params, function serialize$1(val, key$1) {
				if (val === null || typeof val === "undefined") return;
				if (utils$17.isArray(val)) key$1 = key$1 + "[]";
				else val = [val];
				utils$17.forEach(val, function parseValue(v) {
					if (utils$17.isDate(v)) v = v.toISOString();
					else if (utils$17.isObject(v)) v = JSON.stringify(v);
					parts.push(encode(key$1) + "=" + encode(v));
				});
			});
			serializedParams = parts.join("&");
		}
		if (serializedParams) {
			var hashmarkIndex = url$2.indexOf("#");
			if (hashmarkIndex !== -1) url$2 = url$2.slice(0, hashmarkIndex);
			url$2 += (url$2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
		}
		return url$2;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
	var utils$16 = require_utils();
	function InterceptorManager$1() {
		this.handlers = [];
	}
	/**
	* Add a new interceptor to the stack
	*
	* @param {Function} fulfilled The function to handle `then` for a `Promise`
	* @param {Function} rejected The function to handle `reject` for a `Promise`
	*
	* @return {Number} An ID used to remove interceptor later
	*/
	InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
		this.handlers.push({
			fulfilled,
			rejected,
			synchronous: options ? options.synchronous : false,
			runWhen: options ? options.runWhen : null
		});
		return this.handlers.length - 1;
	};
	/**
	* Remove an interceptor from the stack
	*
	* @param {Number} id The ID that was returned by `use`
	*/
	InterceptorManager$1.prototype.eject = function eject(id) {
		if (this.handlers[id]) this.handlers[id] = null;
	};
	/**
	* Iterate over all the registered interceptors
	*
	* This method is particularly useful for skipping over any
	* interceptors that may have become `null` calling `eject`.
	*
	* @param {Function} fn The function to call for each interceptor
	*/
	InterceptorManager$1.prototype.forEach = function forEach$1(fn) {
		utils$16.forEach(this.handlers, function forEachHandler(h$1) {
			if (h$1 !== null) fn(h$1);
		});
	};
	module.exports = InterceptorManager$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
	var utils$15 = require_utils();
	module.exports = function normalizeHeaderName$1(headers, normalizedName) {
		utils$15.forEach(headers, function processHeader(value, name) {
			if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
				headers[normalizedName] = value;
				delete headers[name];
			}
		});
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/AxiosError.js"(exports, module) {
	var utils$14 = require_utils();
	/**
	* Create an Error with the specified message, config, error code, request and response.
	*
	* @param {string} message The error message.
	* @param {string} [code] The error code (for example, 'ECONNABORTED').
	* @param {Object} [config] The config.
	* @param {Object} [request] The request.
	* @param {Object} [response] The response.
	* @returns {Error} The created error.
	*/
	function AxiosError$6(message, code, config, request, response) {
		Error.call(this);
		this.message = message;
		this.name = "AxiosError";
		code && (this.code = code);
		config && (this.config = config);
		request && (this.request = request);
		response && (this.response = response);
	}
	utils$14.inherits(AxiosError$6, Error, { toJSON: function toJSON() {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: this.config,
			code: this.code,
			status: this.response && this.response.status ? this.response.status : null
		};
	} });
	var prototype = AxiosError$6.prototype;
	var descriptors = {};
	[
		"ERR_BAD_OPTION_VALUE",
		"ERR_BAD_OPTION",
		"ECONNABORTED",
		"ETIMEDOUT",
		"ERR_NETWORK",
		"ERR_FR_TOO_MANY_REDIRECTS",
		"ERR_DEPRECATED",
		"ERR_BAD_RESPONSE",
		"ERR_BAD_REQUEST",
		"ERR_CANCELED"
	].forEach(function(code) {
		descriptors[code] = { value: code };
	});
	Object.defineProperties(AxiosError$6, descriptors);
	Object.defineProperty(prototype, "isAxiosError", { value: true });
	AxiosError$6.from = function(error, code, config, request, response, customProps) {
		var axiosError = Object.create(prototype);
		utils$14.toFlatObject(error, axiosError, function filter(obj) {
			return obj !== Error.prototype;
		});
		AxiosError$6.call(axiosError, error.message, code, config, request, response);
		axiosError.name = error.name;
		customProps && Object.assign(axiosError, customProps);
		return axiosError;
	};
	module.exports = AxiosError$6;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
	module.exports = {
		silentJSONParsing: true,
		forcedJSONParsing: true,
		clarifyTimeoutError: false
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
	var utils$13 = require_utils();
	/**
	* Convert a data object to FormData
	* @param {Object} obj
	* @param {?Object} [formData]
	* @returns {Object}
	**/
	function toFormData$1(obj, formData) {
		formData = formData || new FormData();
		var stack = [];
		function convertValue(value) {
			if (value === null) return "";
			if (utils$13.isDate(value)) return value.toISOString();
			if (utils$13.isArrayBuffer(value) || utils$13.isTypedArray(value)) return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
			return value;
		}
		function build(data, parentKey) {
			if (utils$13.isPlainObject(data) || utils$13.isArray(data)) {
				if (stack.indexOf(data) !== -1) throw Error("Circular reference detected in " + parentKey);
				stack.push(data);
				utils$13.forEach(data, function each(value, key$1) {
					if (utils$13.isUndefined(value)) return;
					var fullKey = parentKey ? parentKey + "." + key$1 : key$1;
					var arr;
					if (value && !parentKey && typeof value === "object") {
						if (utils$13.endsWith(key$1, "{}")) value = JSON.stringify(value);
						else if (utils$13.endsWith(key$1, "[]") && (arr = utils$13.toArray(value))) {
							arr.forEach(function(el) {
								!utils$13.isUndefined(el) && formData.append(fullKey, convertValue(el));
							});
							return;
						}
					}
					build(value, fullKey);
				});
				stack.pop();
			} else formData.append(parentKey, convertValue(data));
		}
		build(obj);
		return formData;
	}
	module.exports = toFormData$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/settle.js"(exports, module) {
	var AxiosError$5 = require_AxiosError();
	/**
	* Resolve or reject a Promise based on response status.
	*
	* @param {Function} resolve A function that resolves the promise.
	* @param {Function} reject A function that rejects the promise.
	* @param {object} response The response.
	*/
	module.exports = function settle$2(resolve, reject, response) {
		var validateStatus = response.config.validateStatus;
		if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
		else reject(new AxiosError$5("Request failed with status code " + response.status, [AxiosError$5.ERR_BAD_REQUEST, AxiosError$5.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
	var utils$12 = require_utils();
	module.exports = utils$12.isStandardBrowserEnv() ? function standardBrowserEnv() {
		return {
			write: function write(name, value, expires, path$1, domain, secure) {
				var cookie = [];
				cookie.push(name + "=" + encodeURIComponent(value));
				if (utils$12.isNumber(expires)) cookie.push("expires=" + new Date(expires).toGMTString());
				if (utils$12.isString(path$1)) cookie.push("path=" + path$1);
				if (utils$12.isString(domain)) cookie.push("domain=" + domain);
				if (secure === true) cookie.push("secure");
				document.cookie = cookie.join("; ");
			},
			read: function read(name) {
				var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
				return match ? decodeURIComponent(match[3]) : null;
			},
			remove: function remove(name) {
				this.write(name, "", Date.now() - 864e5);
			}
		};
	}() : function nonStandardBrowserEnv() {
		return {
			write: function write() {},
			read: function read() {
				return null;
			},
			remove: function remove() {}
		};
	}();
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
	/**
	* Determines whether the specified URL is absolute
	*
	* @param {string} url The URL to test
	* @returns {boolean} True if the specified URL is absolute, otherwise false
	*/
	module.exports = function isAbsoluteURL$1(url$2) {
		return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url$2);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
	/**
	* Creates a new URL by combining the specified URLs
	*
	* @param {string} baseURL The base URL
	* @param {string} relativeURL The relative URL
	* @returns {string} The combined URL
	*/
	module.exports = function combineURLs$1(baseURL, relativeURL) {
		return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
	var isAbsoluteURL = require_isAbsoluteURL();
	var combineURLs = require_combineURLs();
	/**
	* Creates a new URL by combining the baseURL with the requestedURL,
	* only when the requestedURL is not already an absolute URL.
	* If the requestURL is absolute, this function returns the requestedURL untouched.
	*
	* @param {string} baseURL The base URL
	* @param {string} requestedURL Absolute or relative URL to combine
	* @returns {string} The combined full path
	*/
	module.exports = function buildFullPath$3(baseURL, requestedURL) {
		if (baseURL && !isAbsoluteURL(requestedURL)) return combineURLs(baseURL, requestedURL);
		return requestedURL;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
	var utils$11 = require_utils();
	var ignoreDuplicateOf = [
		"age",
		"authorization",
		"content-length",
		"content-type",
		"etag",
		"expires",
		"from",
		"host",
		"if-modified-since",
		"if-unmodified-since",
		"last-modified",
		"location",
		"max-forwards",
		"proxy-authorization",
		"referer",
		"retry-after",
		"user-agent"
	];
	/**
	* Parse headers into an object
	*
	* ```
	* Date: Wed, 27 Aug 2014 08:58:49 GMT
	* Content-Type: application/json
	* Connection: keep-alive
	* Transfer-Encoding: chunked
	* ```
	*
	* @param {String} headers Headers needing to be parsed
	* @returns {Object} Headers parsed into an object
	*/
	module.exports = function parseHeaders$1(headers) {
		var parsed = {};
		var key$1;
		var val;
		var i;
		if (!headers) return parsed;
		utils$11.forEach(headers.split("\n"), function parser(line) {
			i = line.indexOf(":");
			key$1 = utils$11.trim(line.substr(0, i)).toLowerCase();
			val = utils$11.trim(line.substr(i + 1));
			if (key$1) {
				if (parsed[key$1] && ignoreDuplicateOf.indexOf(key$1) >= 0) return;
				if (key$1 === "set-cookie") parsed[key$1] = (parsed[key$1] ? parsed[key$1] : []).concat([val]);
				else parsed[key$1] = parsed[key$1] ? parsed[key$1] + ", " + val : val;
			}
		});
		return parsed;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
	var utils$10 = require_utils();
	module.exports = utils$10.isStandardBrowserEnv() ? function standardBrowserEnv() {
		var msie = /(msie|trident)/i.test(navigator.userAgent);
		var urlParsingNode = document.createElement("a");
		var originURL;
		/**
		* Parse a URL to discover it's components
		*
		* @param {String} url The URL to be parsed
		* @returns {Object}
		*/
		function resolveURL(url$2) {
			var href = url$2;
			if (msie) {
				urlParsingNode.setAttribute("href", href);
				href = urlParsingNode.href;
			}
			urlParsingNode.setAttribute("href", href);
			return {
				href: urlParsingNode.href,
				protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
				host: urlParsingNode.host,
				search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
				hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
				hostname: urlParsingNode.hostname,
				port: urlParsingNode.port,
				pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
			};
		}
		originURL = resolveURL(window.location.href);
		/**
		* Determine if a URL shares the same origin as the current location
		*
		* @param {String} requestURL The URL to test
		* @returns {boolean} True if URL shares the same origin, otherwise false
		*/
		return function isURLSameOrigin$1(requestURL) {
			var parsed = utils$10.isString(requestURL) ? resolveURL(requestURL) : requestURL;
			return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
		};
	}() : function nonStandardBrowserEnv() {
		return function isURLSameOrigin$1() {
			return true;
		};
	}();
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
	var AxiosError$4 = require_AxiosError();
	var utils$9 = require_utils();
	/**
	* A `CanceledError` is an object that is thrown when an operation is canceled.
	*
	* @class
	* @param {string=} message The message.
	*/
	function CanceledError$4(message) {
		AxiosError$4.call(this, message == null ? "canceled" : message, AxiosError$4.ERR_CANCELED);
		this.name = "CanceledError";
	}
	utils$9.inherits(CanceledError$4, AxiosError$4, { __CANCEL__: true });
	module.exports = CanceledError$4;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
	module.exports = function parseProtocol$1(url$2) {
		var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url$2);
		return match && match[1] || "";
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
	var utils$8 = require_utils();
	var settle$1 = require_settle();
	var cookies = require_cookies();
	var buildURL$2 = require_buildURL();
	var buildFullPath$2 = require_buildFullPath();
	var parseHeaders = require_parseHeaders();
	var isURLSameOrigin = require_isURLSameOrigin();
	var transitionalDefaults$2 = require_transitional();
	var AxiosError$3 = require_AxiosError();
	var CanceledError$3 = require_CanceledError();
	var parseProtocol = require_parseProtocol();
	module.exports = function xhrAdapter(config) {
		return new Promise(function dispatchXhrRequest(resolve, reject) {
			var requestData = config.data;
			var requestHeaders = config.headers;
			var responseType = config.responseType;
			var onCanceled;
			function done() {
				if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
				if (config.signal) config.signal.removeEventListener("abort", onCanceled);
			}
			if (utils$8.isFormData(requestData) && utils$8.isStandardBrowserEnv()) delete requestHeaders["Content-Type"];
			var request = new XMLHttpRequest();
			if (config.auth) {
				var username = config.auth.username || "";
				var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
				requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
			}
			var fullPath = buildFullPath$2(config.baseURL, config.url);
			request.open(config.method.toUpperCase(), buildURL$2(fullPath, config.params, config.paramsSerializer), true);
			request.timeout = config.timeout;
			function onloadend() {
				if (!request) return;
				var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
				var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
				var response = {
					data: responseData,
					status: request.status,
					statusText: request.statusText,
					headers: responseHeaders,
					config,
					request
				};
				settle$1(function _resolve(value) {
					resolve(value);
					done();
				}, function _reject(err) {
					reject(err);
					done();
				}, response);
				request = null;
			}
			if ("onloadend" in request) request.onloadend = onloadend;
			else request.onreadystatechange = function handleLoad() {
				if (!request || request.readyState !== 4) return;
				if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
				setTimeout(onloadend);
			};
			request.onabort = function handleAbort() {
				if (!request) return;
				reject(new AxiosError$3("Request aborted", AxiosError$3.ECONNABORTED, config, request));
				request = null;
			};
			request.onerror = function handleError() {
				reject(new AxiosError$3("Network Error", AxiosError$3.ERR_NETWORK, config, request, request));
				request = null;
			};
			request.ontimeout = function handleTimeout() {
				var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
				var transitional = config.transitional || transitionalDefaults$2;
				if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
				reject(new AxiosError$3(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$3.ETIMEDOUT : AxiosError$3.ECONNABORTED, config, request));
				request = null;
			};
			if (utils$8.isStandardBrowserEnv()) {
				var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
				if (xsrfValue) requestHeaders[config.xsrfHeaderName] = xsrfValue;
			}
			if ("setRequestHeader" in request) utils$8.forEach(requestHeaders, function setRequestHeader(val, key$1) {
				if (typeof requestData === "undefined" && key$1.toLowerCase() === "content-type") delete requestHeaders[key$1];
				else request.setRequestHeader(key$1, val);
			});
			if (!utils$8.isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
			if (responseType && responseType !== "json") request.responseType = config.responseType;
			if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", config.onDownloadProgress);
			if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", config.onUploadProgress);
			if (config.cancelToken || config.signal) {
				onCanceled = function(cancel) {
					if (!request) return;
					reject(!cancel || cancel && cancel.type ? new CanceledError$3() : cancel);
					request.abort();
					request = null;
				};
				config.cancelToken && config.cancelToken.subscribe(onCanceled);
				if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
			}
			if (!requestData) requestData = null;
			var protocol = parseProtocol(fullPath);
			if (protocol && [
				"http",
				"https",
				"file"
			].indexOf(protocol) === -1) {
				reject(new AxiosError$3("Unsupported protocol " + protocol + ":", AxiosError$3.ERR_BAD_REQUEST, config));
				return;
			}
			request.send(requestData);
		});
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$1(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$1(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return void 0;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js
var require_common = __commonJS({ "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js"(exports, module) {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env$1) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy$1;
		Object.keys(env$1).forEach((key$1) => {
			createDebug[key$1] = env$1[key$1];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash$1 = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash$1 = (hash$1 << 5) - hash$1 + namespace.charCodeAt(i);
				hash$1 |= 0;
			}
			return createDebug.colors[Math.abs(hash$1) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$2(...args) {
				if (!debug$2.enabled) return;
				const self$1 = debug$2;
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self$1.diff = ms;
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				const logFn = self$1.log || createDebug.log;
				logFn.apply(self$1, args);
			}
			debug$2.namespace = namespace;
			debug$2.useColors = createDebug.useColors();
			debug$2.color = createDebug.selectColor(namespace);
			debug$2.extend = extend$1;
			debug$2.destroy = createDebug.destroy;
			Object.defineProperty(debug$2, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$2);
			return debug$2;
		}
		function extend$1(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
} });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js
var require_browser = __commonJS({ "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js"(exports, module) {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$1;
	exports.useColors = useColors$1;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$1() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$1;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$1() {
		let r;
		try {
			r = exports.storage.getItem("debug");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	const { formatters: formatters$1 } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters$1.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({ "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
	module.exports = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({ "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
	const os = __require("os");
	const tty$1 = __require("tty");
	const hasFlag = require_has_flag();
	const { env } = process;
	let forceColor;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) forceColor = 0;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) forceColor = 1;
	if ("FORCE_COLOR" in env) if (env.FORCE_COLOR === "true") forceColor = 1;
	else if (env.FORCE_COLOR === "false") forceColor = 0;
	else forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	function translateLevel(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) return 0;
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
		if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
		const min$1 = forceColor || 0;
		if (env.TERM === "dumb") return min$1;
		if (process.platform === "win32") {
			const osRelease = os.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE"
			].some((sign$1) => sign$1 in env) || env.CI_NAME === "codeship") return 1;
			return min$1;
		}
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if (env.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env) {
			const version$1 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version$1 >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
		if ("COLORTERM" in env) return 1;
		return min$1;
	}
	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty$1.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty$1.isatty(2)))
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js
var require_node = __commonJS({ "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js"(exports, module) {
	/**
	* Module dependencies.
	*/
	const tty = __require("tty");
	const util$3 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util$3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor$1 = require_supports_color();
		if (supportsColor$1 && (supportsColor$1.stderr || supportsColor$1).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key$1) => {
		return /^debug_/i.test(key$1);
	}).reduce((obj, key$1) => {
		const prop = key$1.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key$1];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return new Date().toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log(...args) {
		return process.stderr.write(util$3.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug$2) {
		debug$2.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) debug$2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$3.inspect(v, this.inspectOpts);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js
var require_src = __commonJS({ "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"(exports, module) {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node();
} });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.9_debug@4.4.0/node_modules/follow-redirects/debug.js
var require_debug = __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.9_debug@4.4.0/node_modules/follow-redirects/debug.js"(exports, module) {
	var debug$1;
	module.exports = function() {
		if (!debug$1) {
			try {
				debug$1 = require_src()("follow-redirects");
			} catch (error) {}
			if (typeof debug$1 !== "function") debug$1 = function() {};
		}
		debug$1.apply(null, arguments);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/follow-redirects@1.15.9_debug@4.4.0/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({ "../../node_modules/.pnpm/follow-redirects@1.15.9_debug@4.4.0/node_modules/follow-redirects/index.js"(exports, module) {
	var url$1 = __require("url");
	var URL = url$1.URL;
	var http$2 = __require("http");
	var https$2 = __require("https");
	var Writable = __require("stream").Writable;
	var assert = __require("assert");
	var debug = require_debug();
	// istanbul ignore next
	(function detectUnsupportedEnvironment() {
		var looksLikeNode = typeof process !== "undefined";
		var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
		var looksLikeV8 = isFunction(Error.captureStackTrace);
		if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) console.warn("The follow-redirects package should be excluded from browser builds.");
	})();
	var useNativeURL = false;
	try {
		assert(new URL(""));
	} catch (error) {
		useNativeURL = error.code === "ERR_INVALID_URL";
	}
	var preservedUrlFields = [
		"auth",
		"host",
		"hostname",
		"href",
		"path",
		"pathname",
		"port",
		"protocol",
		"query",
		"search",
		"hash"
	];
	var events = [
		"abort",
		"aborted",
		"connect",
		"error",
		"socket",
		"timeout"
	];
	var eventHandlers = Object.create(null);
	events.forEach(function(event) {
		eventHandlers[event] = function(arg1, arg2, arg3) {
			this._redirectable.emit(event, arg1, arg2, arg3);
		};
	});
	var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
	var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
	var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
	var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
	var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;
	function RedirectableRequest(options, responseCallback) {
		Writable.call(this);
		this._sanitizeOptions(options);
		this._options = options;
		this._ended = false;
		this._ending = false;
		this._redirectCount = 0;
		this._redirects = [];
		this._requestBodyLength = 0;
		this._requestBodyBuffers = [];
		if (responseCallback) this.on("response", responseCallback);
		var self$1 = this;
		this._onNativeResponse = function(response) {
			try {
				self$1._processResponse(response);
			} catch (cause) {
				self$1.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
			}
		};
		this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);
	RedirectableRequest.prototype.abort = function() {
		destroyRequest(this._currentRequest);
		this._currentRequest.abort();
		this.emit("abort");
	};
	RedirectableRequest.prototype.destroy = function(error) {
		destroyRequest(this._currentRequest, error);
		destroy.call(this, error);
		return this;
	};
	RedirectableRequest.prototype.write = function(data, encoding, callback) {
		if (this._ending) throw new WriteAfterEndError();
		if (!isString(data) && !isBuffer(data)) throw new TypeError("data should be a string, Buffer or Uint8Array");
		if (isFunction(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (data.length === 0) {
			if (callback) callback();
			return;
		}
		if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
			this._requestBodyLength += data.length;
			this._requestBodyBuffers.push({
				data,
				encoding
			});
			this._currentRequest.write(data, encoding, callback);
		} else {
			this.emit("error", new MaxBodyLengthExceededError());
			this.abort();
		}
	};
	RedirectableRequest.prototype.end = function(data, encoding, callback) {
		if (isFunction(data)) {
			callback = data;
			data = encoding = null;
		} else if (isFunction(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (!data) {
			this._ended = this._ending = true;
			this._currentRequest.end(null, null, callback);
		} else {
			var self$1 = this;
			var currentRequest = this._currentRequest;
			this.write(data, encoding, function() {
				self$1._ended = true;
				currentRequest.end(null, null, callback);
			});
			this._ending = true;
		}
	};
	RedirectableRequest.prototype.setHeader = function(name, value) {
		this._options.headers[name] = value;
		this._currentRequest.setHeader(name, value);
	};
	RedirectableRequest.prototype.removeHeader = function(name) {
		delete this._options.headers[name];
		this._currentRequest.removeHeader(name);
	};
	RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
		var self$1 = this;
		function destroyOnTimeout(socket) {
			socket.setTimeout(msecs);
			socket.removeListener("timeout", socket.destroy);
			socket.addListener("timeout", socket.destroy);
		}
		function startTimer(socket) {
			if (self$1._timeout) clearTimeout(self$1._timeout);
			self$1._timeout = setTimeout(function() {
				self$1.emit("timeout");
				clearTimer();
			}, msecs);
			destroyOnTimeout(socket);
		}
		function clearTimer() {
			if (self$1._timeout) {
				clearTimeout(self$1._timeout);
				self$1._timeout = null;
			}
			self$1.removeListener("abort", clearTimer);
			self$1.removeListener("error", clearTimer);
			self$1.removeListener("response", clearTimer);
			self$1.removeListener("close", clearTimer);
			if (callback) self$1.removeListener("timeout", callback);
			if (!self$1.socket) self$1._currentRequest.removeListener("socket", startTimer);
		}
		if (callback) this.on("timeout", callback);
		if (this.socket) startTimer(this.socket);
		else this._currentRequest.once("socket", startTimer);
		this.on("socket", destroyOnTimeout);
		this.on("abort", clearTimer);
		this.on("error", clearTimer);
		this.on("response", clearTimer);
		this.on("close", clearTimer);
		return this;
	};
	[
		"flushHeaders",
		"getHeader",
		"setNoDelay",
		"setSocketKeepAlive"
	].forEach(function(method) {
		RedirectableRequest.prototype[method] = function(a, b) {
			return this._currentRequest[method](a, b);
		};
	});
	[
		"aborted",
		"connection",
		"socket"
	].forEach(function(property) {
		Object.defineProperty(RedirectableRequest.prototype, property, { get: function() {
			return this._currentRequest[property];
		} });
	});
	RedirectableRequest.prototype._sanitizeOptions = function(options) {
		if (!options.headers) options.headers = {};
		if (options.host) {
			if (!options.hostname) options.hostname = options.host;
			delete options.host;
		}
		if (!options.pathname && options.path) {
			var searchPos = options.path.indexOf("?");
			if (searchPos < 0) options.pathname = options.path;
			else {
				options.pathname = options.path.substring(0, searchPos);
				options.search = options.path.substring(searchPos);
			}
		}
	};
	RedirectableRequest.prototype._performRequest = function() {
		var protocol = this._options.protocol;
		var nativeProtocol = this._options.nativeProtocols[protocol];
		if (!nativeProtocol) throw new TypeError("Unsupported protocol " + protocol);
		if (this._options.agents) {
			var scheme = protocol.slice(0, -1);
			this._options.agent = this._options.agents[scheme];
		}
		var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
		request._redirectable = this;
		for (var event of events) request.on(event, eventHandlers[event]);
		this._currentUrl = /^\//.test(this._options.path) ? url$1.format(this._options) : this._options.path;
		if (this._isRedirect) {
			var i = 0;
			var self$1 = this;
			var buffers = this._requestBodyBuffers;
			(function writeNext(error) {
				// istanbul ignore else
				if (request === self$1._currentRequest) {
					// istanbul ignore if
					if (error) self$1.emit("error", error);
					else if (i < buffers.length) {
						var buffer = buffers[i++];
						// istanbul ignore else
						if (!request.finished) request.write(buffer.data, buffer.encoding, writeNext);
					} else if (self$1._ended) request.end();
				}
			})();
		}
	};
	RedirectableRequest.prototype._processResponse = function(response) {
		var statusCode = response.statusCode;
		if (this._options.trackRedirects) this._redirects.push({
			url: this._currentUrl,
			headers: response.headers,
			statusCode
		});
		var location = response.headers.location;
		if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
			response.responseUrl = this._currentUrl;
			response.redirects = this._redirects;
			this.emit("response", response);
			this._requestBodyBuffers = [];
			return;
		}
		destroyRequest(this._currentRequest);
		response.destroy();
		if (++this._redirectCount > this._options.maxRedirects) throw new TooManyRedirectsError();
		var requestHeaders;
		var beforeRedirect = this._options.beforeRedirect;
		if (beforeRedirect) requestHeaders = Object.assign({ Host: response.req.getHeader("host") }, this._options.headers);
		var method = this._options.method;
		if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
			this._options.method = "GET";
			this._requestBodyBuffers = [];
			removeMatchingHeaders(/^content-/i, this._options.headers);
		}
		var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
		var currentUrlParts = parseUrl$1(this._currentUrl);
		var currentHost = currentHostHeader || currentUrlParts.host;
		var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url$1.format(Object.assign(currentUrlParts, { host: currentHost }));
		var redirectUrl = resolveUrl(location, currentUrl);
		debug("redirecting to", redirectUrl.href);
		this._isRedirect = true;
		spreadUrlObject(redirectUrl, this._options);
		if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
		if (isFunction(beforeRedirect)) {
			var responseDetails = {
				headers: response.headers,
				statusCode
			};
			var requestDetails = {
				url: currentUrl,
				method,
				headers: requestHeaders
			};
			beforeRedirect(this._options, responseDetails, requestDetails);
			this._sanitizeOptions(this._options);
		}
		this._performRequest();
	};
	function wrap$1(protocols) {
		var exports$1 = {
			maxRedirects: 21,
			maxBodyLength: 10 * 1024 * 1024
		};
		var nativeProtocols = {};
		Object.keys(protocols).forEach(function(scheme) {
			var protocol = scheme + ":";
			var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
			var wrappedProtocol = exports$1[scheme] = Object.create(nativeProtocol);
			function request(input, options, callback) {
				if (isURL(input)) input = spreadUrlObject(input);
				else if (isString(input)) input = spreadUrlObject(parseUrl$1(input));
				else {
					callback = options;
					options = validateUrl(input);
					input = { protocol };
				}
				if (isFunction(options)) {
					callback = options;
					options = null;
				}
				options = Object.assign({
					maxRedirects: exports$1.maxRedirects,
					maxBodyLength: exports$1.maxBodyLength
				}, input, options);
				options.nativeProtocols = nativeProtocols;
				if (!isString(options.host) && !isString(options.hostname)) options.hostname = "::1";
				assert.equal(options.protocol, protocol, "protocol mismatch");
				debug("options", options);
				return new RedirectableRequest(options, callback);
			}
			function get(input, options, callback) {
				var wrappedRequest = wrappedProtocol.request(input, options, callback);
				wrappedRequest.end();
				return wrappedRequest;
			}
			Object.defineProperties(wrappedProtocol, {
				request: {
					value: request,
					configurable: true,
					enumerable: true,
					writable: true
				},
				get: {
					value: get,
					configurable: true,
					enumerable: true,
					writable: true
				}
			});
		});
		return exports$1;
	}
	function noop() {}
	function parseUrl$1(input) {
		var parsed;
		// istanbul ignore else
		if (useNativeURL) parsed = new URL(input);
		else {
			parsed = validateUrl(url$1.parse(input));
			if (!isString(parsed.protocol)) throw new InvalidUrlError({ input });
		}
		return parsed;
	}
	function resolveUrl(relative, base$1) {
		// istanbul ignore next
		return useNativeURL ? new URL(relative, base$1) : parseUrl$1(url$1.resolve(base$1, relative));
	}
	function validateUrl(input) {
		if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) throw new InvalidUrlError({ input: input.href || input });
		if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) throw new InvalidUrlError({ input: input.href || input });
		return input;
	}
	function spreadUrlObject(urlObject, target) {
		var spread = target || {};
		for (var key$1 of preservedUrlFields) spread[key$1] = urlObject[key$1];
		if (spread.hostname.startsWith("[")) spread.hostname = spread.hostname.slice(1, -1);
		if (spread.port !== "") spread.port = Number(spread.port);
		spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
		return spread;
	}
	function removeMatchingHeaders(regex, headers) {
		var lastValue;
		for (var header in headers) if (regex.test(header)) {
			lastValue = headers[header];
			delete headers[header];
		}
		return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
	}
	function createErrorType(code, message, baseClass) {
		function CustomError(properties) {
			// istanbul ignore else
			if (isFunction(Error.captureStackTrace)) Error.captureStackTrace(this, this.constructor);
			Object.assign(this, properties || {});
			this.code = code;
			this.message = this.cause ? message + ": " + this.cause.message : message;
		}
		CustomError.prototype = new (baseClass || Error)();
		Object.defineProperties(CustomError.prototype, {
			constructor: {
				value: CustomError,
				enumerable: false
			},
			name: {
				value: "Error [" + code + "]",
				enumerable: false
			}
		});
		return CustomError;
	}
	function destroyRequest(request, error) {
		for (var event of events) request.removeListener(event, eventHandlers[event]);
		request.on("error", noop);
		request.destroy(error);
	}
	function isSubdomain(subdomain, domain) {
		assert(isString(subdomain) && isString(domain));
		var dot = subdomain.length - domain.length - 1;
		return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}
	function isString(value) {
		return typeof value === "string" || value instanceof String;
	}
	function isFunction(value) {
		return typeof value === "function";
	}
	function isBuffer(value) {
		return typeof value === "object" && "length" in value;
	}
	function isURL(value) {
		return URL && value instanceof URL;
	}
	module.exports = wrap$1({
		http: http$2,
		https: https$2
	});
	module.exports.wrap = wrap$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/env/data.js
var require_data = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/env/data.js"(exports, module) {
	module.exports = { "version": "0.27.2" };
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/http.js"(exports, module) {
	var utils$7 = require_utils();
	var settle = require_settle();
	var buildFullPath$1 = require_buildFullPath();
	var buildURL$1 = require_buildURL();
	var http$1 = __require("http");
	var https$1 = __require("https");
	var httpFollow = require_follow_redirects().http;
	var httpsFollow = require_follow_redirects().https;
	var url = __require("url");
	var zlib = __require("zlib");
	var VERSION$1 = require_data().version;
	var transitionalDefaults$1 = require_transitional();
	var AxiosError$2 = require_AxiosError();
	var CanceledError$2 = require_CanceledError();
	var isHttps = /https:?/;
	var supportedProtocols = [
		"http:",
		"https:",
		"file:"
	];
	/**
	*
	* @param {http.ClientRequestArgs} options
	* @param {AxiosProxyConfig} proxy
	* @param {string} location
	*/
	function setProxy(options, proxy, location) {
		options.hostname = proxy.host;
		options.host = proxy.host;
		options.port = proxy.port;
		options.path = location;
		if (proxy.auth) {
			var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
			options.headers["Proxy-Authorization"] = "Basic " + base64;
		}
		options.beforeRedirect = function beforeRedirect(redirection) {
			redirection.headers.host = redirection.host;
			setProxy(redirection, proxy, redirection.href);
		};
	}
	module.exports = function httpAdapter(config) {
		return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
			var onCanceled;
			function done() {
				if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
				if (config.signal) config.signal.removeEventListener("abort", onCanceled);
			}
			var resolve = function resolve$1(value) {
				done();
				resolvePromise(value);
			};
			var rejected = false;
			var reject = function reject$1(value) {
				done();
				rejected = true;
				rejectPromise(value);
			};
			var data = config.data;
			var headers = config.headers;
			var headerNames = {};
			Object.keys(headers).forEach(function storeLowerName(name) {
				headerNames[name.toLowerCase()] = name;
			});
			if ("user-agent" in headerNames) {
				if (!headers[headerNames["user-agent"]]) delete headers[headerNames["user-agent"]];
			} else headers["User-Agent"] = "axios/" + VERSION$1;
			if (utils$7.isFormData(data) && utils$7.isFunction(data.getHeaders)) Object.assign(headers, data.getHeaders());
			else if (data && !utils$7.isStream(data)) {
				if (Buffer.isBuffer(data)) {} else if (utils$7.isArrayBuffer(data)) data = Buffer.from(new Uint8Array(data));
				else if (utils$7.isString(data)) data = Buffer.from(data, "utf-8");
				else return reject(new AxiosError$2("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError$2.ERR_BAD_REQUEST, config));
				if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) return reject(new AxiosError$2("Request body larger than maxBodyLength limit", AxiosError$2.ERR_BAD_REQUEST, config));
				if (!headerNames["content-length"]) headers["Content-Length"] = data.length;
			}
			var auth = void 0;
			if (config.auth) {
				var username = config.auth.username || "";
				var password = config.auth.password || "";
				auth = username + ":" + password;
			}
			var fullPath = buildFullPath$1(config.baseURL, config.url);
			var parsed = url.parse(fullPath);
			var protocol = parsed.protocol || supportedProtocols[0];
			if (supportedProtocols.indexOf(protocol) === -1) return reject(new AxiosError$2("Unsupported protocol " + protocol, AxiosError$2.ERR_BAD_REQUEST, config));
			if (!auth && parsed.auth) {
				var urlAuth = parsed.auth.split(":");
				var urlUsername = urlAuth[0] || "";
				var urlPassword = urlAuth[1] || "";
				auth = urlUsername + ":" + urlPassword;
			}
			if (auth && headerNames.authorization) delete headers[headerNames.authorization];
			var isHttpsRequest = isHttps.test(protocol);
			var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
			try {
				buildURL$1(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
			} catch (err) {
				var customErr = new Error(err.message);
				customErr.config = config;
				customErr.url = config.url;
				customErr.exists = true;
				reject(customErr);
			}
			var options = {
				path: buildURL$1(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
				method: config.method.toUpperCase(),
				headers,
				agent,
				agents: {
					http: config.httpAgent,
					https: config.httpsAgent
				},
				auth
			};
			if (config.socketPath) options.socketPath = config.socketPath;
			else {
				options.hostname = parsed.hostname;
				options.port = parsed.port;
			}
			var proxy = config.proxy;
			if (!proxy && proxy !== false) {
				var proxyEnv = protocol.slice(0, -1) + "_proxy";
				var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
				if (proxyUrl) {
					var parsedProxyUrl = url.parse(proxyUrl);
					var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
					var shouldProxy = true;
					if (noProxyEnv) {
						var noProxy = noProxyEnv.split(",").map(function trim$1(s$1) {
							return s$1.trim();
						});
						shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
							if (!proxyElement) return false;
							if (proxyElement === "*") return true;
							if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) return true;
							return parsed.hostname === proxyElement;
						});
					}
					if (shouldProxy) {
						proxy = {
							host: parsedProxyUrl.hostname,
							port: parsedProxyUrl.port,
							protocol: parsedProxyUrl.protocol
						};
						if (parsedProxyUrl.auth) {
							var proxyUrlAuth = parsedProxyUrl.auth.split(":");
							proxy.auth = {
								username: proxyUrlAuth[0],
								password: proxyUrlAuth[1]
							};
						}
					}
				}
			}
			if (proxy) {
				options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
				setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
			}
			var transport;
			var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
			if (config.transport) transport = config.transport;
			else if (config.maxRedirects === 0) transport = isHttpsProxy ? https$1 : http$1;
			else {
				if (config.maxRedirects) options.maxRedirects = config.maxRedirects;
				if (config.beforeRedirect) options.beforeRedirect = config.beforeRedirect;
				transport = isHttpsProxy ? httpsFollow : httpFollow;
			}
			if (config.maxBodyLength > -1) options.maxBodyLength = config.maxBodyLength;
			if (config.insecureHTTPParser) options.insecureHTTPParser = config.insecureHTTPParser;
			var req = transport.request(options, function handleResponse(res) {
				if (req.aborted) return;
				var stream = res;
				var lastRequest = res.req || req;
				if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) switch (res.headers["content-encoding"]) {
					case "gzip":
					case "compress":
					case "deflate":
						stream = stream.pipe(zlib.createUnzip());
						delete res.headers["content-encoding"];
						break;
				}
				var response = {
					status: res.statusCode,
					statusText: res.statusMessage,
					headers: res.headers,
					config,
					request: lastRequest
				};
				if (config.responseType === "stream") {
					response.data = stream;
					settle(resolve, reject, response);
				} else {
					var responseBuffer = [];
					var totalResponseBytes = 0;
					stream.on("data", function handleStreamData(chunk) {
						responseBuffer.push(chunk);
						totalResponseBytes += chunk.length;
						if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
							rejected = true;
							stream.destroy();
							reject(new AxiosError$2("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError$2.ERR_BAD_RESPONSE, config, lastRequest));
						}
					});
					stream.on("aborted", function handlerStreamAborted() {
						if (rejected) return;
						stream.destroy();
						reject(new AxiosError$2("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError$2.ERR_BAD_RESPONSE, config, lastRequest));
					});
					stream.on("error", function handleStreamError(err) {
						if (req.aborted) return;
						reject(AxiosError$2.from(err, null, config, lastRequest));
					});
					stream.on("end", function handleStreamEnd() {
						try {
							var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
							if (config.responseType !== "arraybuffer") {
								responseData = responseData.toString(config.responseEncoding);
								if (!config.responseEncoding || config.responseEncoding === "utf8") responseData = utils$7.stripBOM(responseData);
							}
							response.data = responseData;
						} catch (err) {
							reject(AxiosError$2.from(err, null, config, response.request, response));
						}
						settle(resolve, reject, response);
					});
				}
			});
			req.on("error", function handleRequestError(err) {
				reject(AxiosError$2.from(err, null, config, req));
			});
			req.on("socket", function handleRequestSocket(socket) {
				socket.setKeepAlive(true, 1e3 * 60);
			});
			if (config.timeout) {
				var timeout = parseInt(config.timeout, 10);
				if (isNaN(timeout)) {
					reject(new AxiosError$2("error trying to parse `config.timeout` to int", AxiosError$2.ERR_BAD_OPTION_VALUE, config, req));
					return;
				}
				req.setTimeout(timeout, function handleRequestTimeout() {
					req.abort();
					var transitional = config.transitional || transitionalDefaults$1;
					reject(new AxiosError$2("timeout of " + timeout + "ms exceeded", transitional.clarifyTimeoutError ? AxiosError$2.ETIMEDOUT : AxiosError$2.ECONNABORTED, config, req));
				});
			}
			if (config.cancelToken || config.signal) {
				onCanceled = function(cancel) {
					if (req.aborted) return;
					req.abort();
					reject(!cancel || cancel && cancel.type ? new CanceledError$2() : cancel);
				};
				config.cancelToken && config.cancelToken.subscribe(onCanceled);
				if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
			}
			if (utils$7.isStream(data)) data.on("error", function handleStreamError(err) {
				reject(AxiosError$2.from(err, config, null, req));
			}).pipe(req);
			else req.end(data);
		});
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({ "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
	var Stream$2 = __require("stream").Stream;
	var util$2 = __require("util");
	module.exports = DelayedStream$1;
	function DelayedStream$1() {
		this.source = null;
		this.dataSize = 0;
		this.maxDataSize = 1024 * 1024;
		this.pauseStream = true;
		this._maxDataSizeExceeded = false;
		this._released = false;
		this._bufferedEvents = [];
	}
	util$2.inherits(DelayedStream$1, Stream$2);
	DelayedStream$1.create = function(source, options) {
		var delayedStream = new this();
		options = options || {};
		for (var option in options) delayedStream[option] = options[option];
		delayedStream.source = source;
		var realEmit = source.emit;
		source.emit = function() {
			delayedStream._handleEmit(arguments);
			return realEmit.apply(source, arguments);
		};
		source.on("error", function() {});
		if (delayedStream.pauseStream) source.pause();
		return delayedStream;
	};
	Object.defineProperty(DelayedStream$1.prototype, "readable", {
		configurable: true,
		enumerable: true,
		get: function() {
			return this.source.readable;
		}
	});
	DelayedStream$1.prototype.setEncoding = function() {
		return this.source.setEncoding.apply(this.source, arguments);
	};
	DelayedStream$1.prototype.resume = function() {
		if (!this._released) this.release();
		this.source.resume();
	};
	DelayedStream$1.prototype.pause = function() {
		this.source.pause();
	};
	DelayedStream$1.prototype.release = function() {
		this._released = true;
		this._bufferedEvents.forEach(function(args) {
			this.emit.apply(this, args);
		}.bind(this));
		this._bufferedEvents = [];
	};
	DelayedStream$1.prototype.pipe = function() {
		var r = Stream$2.prototype.pipe.apply(this, arguments);
		this.resume();
		return r;
	};
	DelayedStream$1.prototype._handleEmit = function(args) {
		if (this._released) {
			this.emit.apply(this, args);
			return;
		}
		if (args[0] === "data") {
			this.dataSize += args[1].length;
			this._checkIfMaxDataSizeExceeded();
		}
		this._bufferedEvents.push(args);
	};
	DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
		if (this._maxDataSizeExceeded) return;
		if (this.dataSize <= this.maxDataSize) return;
		this._maxDataSizeExceeded = true;
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this.emit("error", new Error(message));
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({ "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
	var util$1 = __require("util");
	var Stream$1 = __require("stream").Stream;
	var DelayedStream = require_delayed_stream();
	module.exports = CombinedStream$1;
	function CombinedStream$1() {
		this.writable = false;
		this.readable = true;
		this.dataSize = 0;
		this.maxDataSize = 2 * 1024 * 1024;
		this.pauseStreams = true;
		this._released = false;
		this._streams = [];
		this._currentStream = null;
		this._insideLoop = false;
		this._pendingNext = false;
	}
	util$1.inherits(CombinedStream$1, Stream$1);
	CombinedStream$1.create = function(options) {
		var combinedStream = new this();
		options = options || {};
		for (var option in options) combinedStream[option] = options[option];
		return combinedStream;
	};
	CombinedStream$1.isStreamLike = function(stream) {
		return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
	};
	CombinedStream$1.prototype.append = function(stream) {
		var isStreamLike = CombinedStream$1.isStreamLike(stream);
		if (isStreamLike) {
			if (!(stream instanceof DelayedStream)) {
				var newStream = DelayedStream.create(stream, {
					maxDataSize: Infinity,
					pauseStream: this.pauseStreams
				});
				stream.on("data", this._checkDataSize.bind(this));
				stream = newStream;
			}
			this._handleErrors(stream);
			if (this.pauseStreams) stream.pause();
		}
		this._streams.push(stream);
		return this;
	};
	CombinedStream$1.prototype.pipe = function(dest, options) {
		Stream$1.prototype.pipe.call(this, dest, options);
		this.resume();
		return dest;
	};
	CombinedStream$1.prototype._getNext = function() {
		this._currentStream = null;
		if (this._insideLoop) {
			this._pendingNext = true;
			return;
		}
		this._insideLoop = true;
		try {
			do {
				this._pendingNext = false;
				this._realGetNext();
			} while (this._pendingNext);
		} finally {
			this._insideLoop = false;
		}
	};
	CombinedStream$1.prototype._realGetNext = function() {
		var stream = this._streams.shift();
		if (typeof stream == "undefined") {
			this.end();
			return;
		}
		if (typeof stream !== "function") {
			this._pipeNext(stream);
			return;
		}
		var getStream = stream;
		getStream(function(stream$1) {
			var isStreamLike = CombinedStream$1.isStreamLike(stream$1);
			if (isStreamLike) {
				stream$1.on("data", this._checkDataSize.bind(this));
				this._handleErrors(stream$1);
			}
			this._pipeNext(stream$1);
		}.bind(this));
	};
	CombinedStream$1.prototype._pipeNext = function(stream) {
		this._currentStream = stream;
		var isStreamLike = CombinedStream$1.isStreamLike(stream);
		if (isStreamLike) {
			stream.on("end", this._getNext.bind(this));
			stream.pipe(this, { end: false });
			return;
		}
		var value = stream;
		this.write(value);
		this._getNext();
	};
	CombinedStream$1.prototype._handleErrors = function(stream) {
		var self$1 = this;
		stream.on("error", function(err) {
			self$1._emitError(err);
		});
	};
	CombinedStream$1.prototype.write = function(data) {
		this.emit("data", data);
	};
	CombinedStream$1.prototype.pause = function() {
		if (!this.pauseStreams) return;
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
		this.emit("pause");
	};
	CombinedStream$1.prototype.resume = function() {
		if (!this._released) {
			this._released = true;
			this.writable = true;
			this._getNext();
		}
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
		this.emit("resume");
	};
	CombinedStream$1.prototype.end = function() {
		this._reset();
		this.emit("end");
	};
	CombinedStream$1.prototype.destroy = function() {
		this._reset();
		this.emit("close");
	};
	CombinedStream$1.prototype._reset = function() {
		this.writable = false;
		this._streams = [];
		this._currentStream = null;
	};
	CombinedStream$1.prototype._checkDataSize = function() {
		this._updateDataSize();
		if (this.dataSize <= this.maxDataSize) return;
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this._emitError(new Error(message));
	};
	CombinedStream$1.prototype._updateDataSize = function() {
		this.dataSize = 0;
		var self$1 = this;
		this._streams.forEach(function(stream) {
			if (!stream.dataSize) return;
			self$1.dataSize += stream.dataSize;
		});
		if (this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize;
	};
	CombinedStream$1.prototype._emitError = function(err) {
		this._reset();
		this.emit("error", err);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module) {
	module.exports = {
		"application/1d-interleaved-parityfec": { "source": "iana" },
		"application/3gpdash-qoe-report+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/3gpp-ims+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphalforms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/a2l": { "source": "iana" },
		"application/ace+cbor": { "source": "iana" },
		"application/activemessage": { "source": "iana" },
		"application/activity+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamcontrol+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": { "source": "iana" },
		"application/andrew-inset": {
			"source": "iana",
			"extensions": ["ez"]
		},
		"application/applefile": { "source": "iana" },
		"application/applixware": {
			"source": "apache",
			"extensions": ["aw"]
		},
		"application/at+jwt": { "source": "iana" },
		"application/atf": { "source": "iana" },
		"application/atfx": { "source": "iana" },
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atom"]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomcat"]
		},
		"application/atomdeleted+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomdeleted"]
		},
		"application/atomicmail": { "source": "iana" },
		"application/atomsvc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomsvc"]
		},
		"application/atsc-dwd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dwd"]
		},
		"application/atsc-dynamic-event-message": { "source": "iana" },
		"application/atsc-held+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["held"]
		},
		"application/atsc-rdt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/atsc-rsat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsat"]
		},
		"application/atxml": { "source": "iana" },
		"application/auth-policy+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/bacnet-xdd+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/batch-smtp": { "source": "iana" },
		"application/bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/beep+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xcs"]
		},
		"application/call-completion": { "source": "iana" },
		"application/cals-1840": { "source": "iana" },
		"application/captive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cbor": { "source": "iana" },
		"application/cbor-seq": { "source": "iana" },
		"application/cccex": { "source": "iana" },
		"application/ccmp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ccxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ccxml"]
		},
		"application/cdfx+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdfx"]
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": ["cdmia"]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": ["cdmic"]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": ["cdmid"]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": ["cdmio"]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": ["cdmiq"]
		},
		"application/cdni": { "source": "iana" },
		"application/cea": { "source": "iana" },
		"application/cea-2018+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cellml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cfw": { "source": "iana" },
		"application/city+json": {
			"source": "iana",
			"compressible": true
		},
		"application/clr": { "source": "iana" },
		"application/clue+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/clue_info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cms": { "source": "iana" },
		"application/cnrp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-payload": { "source": "iana" },
		"application/commonground": { "source": "iana" },
		"application/conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cose": { "source": "iana" },
		"application/cose-key": { "source": "iana" },
		"application/cose-key-set": { "source": "iana" },
		"application/cpl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cpl"]
		},
		"application/csrattrs": { "source": "iana" },
		"application/csta+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cstadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": ["cu"]
		},
		"application/cwt": { "source": "iana" },
		"application/cybercash": { "source": "iana" },
		"application/dart": { "compressible": true },
		"application/dash+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpd"]
		},
		"application/dash-patch+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpp"]
		},
		"application/dashdelta": { "source": "iana" },
		"application/davmount+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["davmount"]
		},
		"application/dca-rft": { "source": "iana" },
		"application/dcd": { "source": "iana" },
		"application/dec-dx": { "source": "iana" },
		"application/dialog-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom": { "source": "iana" },
		"application/dicom+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dii": { "source": "iana" },
		"application/dit": { "source": "iana" },
		"application/dns": { "source": "iana" },
		"application/dns+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dns-message": { "source": "iana" },
		"application/docbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dbk"]
		},
		"application/dots+cbor": { "source": "iana" },
		"application/dskpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": ["dssc"]
		},
		"application/dssc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdssc"]
		},
		"application/dvcs": { "source": "iana" },
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es", "ecma"]
		},
		"application/edi-consent": { "source": "iana" },
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": { "source": "iana" },
		"application/elm+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/elm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.cap+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.ecall.msd": { "source": "iana" },
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.veds+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emma+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emma"]
		},
		"application/emotionml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emotionml"]
		},
		"application/encaprtp": { "source": "iana" },
		"application/epp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/epub+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["epub"]
		},
		"application/eshop": { "source": "iana" },
		"application/exi": {
			"source": "iana",
			"extensions": ["exi"]
		},
		"application/expect-ct-report+json": {
			"source": "iana",
			"compressible": true
		},
		"application/express": {
			"source": "iana",
			"extensions": ["exp"]
		},
		"application/fastinfoset": { "source": "iana" },
		"application/fastsoap": { "source": "iana" },
		"application/fdt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fdt"]
		},
		"application/fhir+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fhir+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fido.trusted-apps+json": { "compressible": true },
		"application/fits": { "source": "iana" },
		"application/flexfec": { "source": "iana" },
		"application/font-sfnt": { "source": "iana" },
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": ["pfr"]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false
		},
		"application/framework-attributes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["geojson"]
		},
		"application/geo+json-seq": { "source": "iana" },
		"application/geopackage+sqlite3": { "source": "iana" },
		"application/geoxacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/gltf-buffer": { "source": "iana" },
		"application/gml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gml"]
		},
		"application/gpx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["gpx"]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": ["gxf"]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gz"]
		},
		"application/h224": { "source": "iana" },
		"application/held+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/hjson": { "extensions": ["hjson"] },
		"application/http": { "source": "iana" },
		"application/hyperstudio": {
			"source": "iana",
			"extensions": ["stk"]
		},
		"application/ibe-key-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pp-data": { "source": "iana" },
		"application/iges": { "source": "iana" },
		"application/im-iscomposing+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/index": { "source": "iana" },
		"application/index.cmd": { "source": "iana" },
		"application/index.obj": { "source": "iana" },
		"application/index.response": { "source": "iana" },
		"application/index.vnd": { "source": "iana" },
		"application/inkml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ink", "inkml"]
		},
		"application/iotp": { "source": "iana" },
		"application/ipfix": {
			"source": "iana",
			"extensions": ["ipfix"]
		},
		"application/ipp": { "source": "iana" },
		"application/isup": { "source": "iana" },
		"application/its+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["its"]
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": ["ser"]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["class"]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["js", "mjs"]
		},
		"application/jf2feed+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jose": { "source": "iana" },
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jscalendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["json", "map"]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": { "source": "iana" },
		"application/json5": { "extensions": ["json5"] },
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": ["jsonml"]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": { "source": "iana" },
		"application/kpml-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/kpml-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["jsonld"]
		},
		"application/lgr+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lgr"]
		},
		"application/link-format": { "source": "iana" },
		"application/load-control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lost+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lostxml"]
		},
		"application/lostsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lpf+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/lxf": { "source": "iana" },
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": ["hqx"]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": ["cpt"]
		},
		"application/macwriteii": { "source": "iana" },
		"application/mads+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mads"]
		},
		"application/manifest+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["webmanifest"]
		},
		"application/marc": {
			"source": "iana",
			"extensions": ["mrc"]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mrcx"]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mathml"]
		},
		"application/mathml-content+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mathml-presentation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-deregister+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-envelope+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-protection-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-reception-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-schedule+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbox": {
			"source": "iana",
			"extensions": ["mbox"]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpf"]
		},
		"application/media_control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mscml"]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["metalink"]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["meta4"]
		},
		"application/mets+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mets"]
		},
		"application/mf4": { "source": "iana" },
		"application/mikey": { "source": "iana" },
		"application/mipc": { "source": "iana" },
		"application/missing-blocks+cbor-seq": { "source": "iana" },
		"application/mmt-aei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["maei"]
		},
		"application/mmt-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musd"]
		},
		"application/mods+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mods"]
		},
		"application/moss-keys": { "source": "iana" },
		"application/moss-signature": { "source": "iana" },
		"application/mosskey-data": { "source": "iana" },
		"application/mosskey-request": { "source": "iana" },
		"application/mp21": {
			"source": "iana",
			"extensions": ["m21", "mp21"]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": ["mp4s", "m4p"]
		},
		"application/mpeg4-generic": { "source": "iana" },
		"application/mpeg4-iod": { "source": "iana" },
		"application/mpeg4-iod-xmt": { "source": "iana" },
		"application/mrb-consumer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mrb-publish+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/msc-ivr+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msc-mixer+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": ["doc", "dot"]
		},
		"application/mud+json": {
			"source": "iana",
			"compressible": true
		},
		"application/multipart-core": { "source": "iana" },
		"application/mxf": {
			"source": "iana",
			"extensions": ["mxf"]
		},
		"application/n-quads": {
			"source": "iana",
			"extensions": ["nq"]
		},
		"application/n-triples": {
			"source": "iana",
			"extensions": ["nt"]
		},
		"application/nasdata": { "source": "iana" },
		"application/news-checkgroups": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-groupinfo": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-transmission": { "source": "iana" },
		"application/nlsml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/node": {
			"source": "iana",
			"extensions": ["cjs"]
		},
		"application/nss": { "source": "iana" },
		"application/oauth-authz-req+jwt": { "source": "iana" },
		"application/oblivious-dns-message": { "source": "iana" },
		"application/ocsp-request": { "source": "iana" },
		"application/ocsp-response": { "source": "iana" },
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": ["oda"]
		},
		"application/odm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/odx": { "source": "iana" },
		"application/oebps-package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["opf"]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogx"]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["omdoc"]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/opc-nodeset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/oscore": { "source": "iana" },
		"application/oxps": {
			"source": "iana",
			"extensions": ["oxps"]
		},
		"application/p21": { "source": "iana" },
		"application/p21+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/p2p-overlay+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["relo"]
		},
		"application/parityfec": { "source": "iana" },
		"application/passport": { "source": "iana" },
		"application/patch-ops-error+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xer"]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pdf"]
		},
		"application/pdx": { "source": "iana" },
		"application/pem-certificate-chain": { "source": "iana" },
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pgp"]
		},
		"application/pgp-keys": {
			"source": "iana",
			"extensions": ["asc"]
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": ["asc", "sig"]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": ["prf"]
		},
		"application/pidf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pidf-diff+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": ["p10"]
		},
		"application/pkcs12": { "source": "iana" },
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": ["p7m", "p7c"]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": ["p7s"]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": ["p8"]
		},
		"application/pkcs8-encrypted": { "source": "iana" },
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": ["ac"]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": ["cer"]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": ["crl"]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": ["pkipath"]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": ["pki"]
		},
		"application/pls+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pls"]
		},
		"application/poc-settings+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/provenance+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["provx"]
		},
		"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
		"application/prs.cww": {
			"source": "iana",
			"extensions": ["cww"]
		},
		"application/prs.cyn": {
			"source": "iana",
			"charset": "7-BIT"
		},
		"application/prs.hpub+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/prs.nprend": { "source": "iana" },
		"application/prs.plucker": { "source": "iana" },
		"application/prs.rdf-xml-crypt": { "source": "iana" },
		"application/prs.xsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/pskc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pskcxml"]
		},
		"application/pvd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/qsig": { "source": "iana" },
		"application/raml+yaml": {
			"compressible": true,
			"extensions": ["raml"]
		},
		"application/raptorfec": { "source": "iana" },
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rdf", "owl"]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rif"]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": ["rnc"]
		},
		"application/remote-printing": { "source": "iana" },
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rl"]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rld"]
		},
		"application/rfc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/riscos": { "source": "iana" },
		"application/rlmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/rls-services+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rs"]
		},
		"application/route-apd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rapd"]
		},
		"application/route-s-tsid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sls"]
		},
		"application/route-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rusd"]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": ["gbr"]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": ["mft"]
		},
		"application/rpki-publication": { "source": "iana" },
		"application/rpki-roa": {
			"source": "iana",
			"extensions": ["roa"]
		},
		"application/rpki-updown": { "source": "iana" },
		"application/rsd+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rsd"]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rss"]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"application/rtploopback": { "source": "iana" },
		"application/rtx": { "source": "iana" },
		"application/samlassertion+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/samlmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif-external-properties+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sbe": { "source": "iana" },
		"application/sbml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sbml"]
		},
		"application/scaip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": ["scq"]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": ["scs"]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": ["spq"]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": ["spp"]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": ["sdp"]
		},
		"application/secevent+jwt": { "source": "iana" },
		"application/senml+cbor": { "source": "iana" },
		"application/senml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["senmlx"]
		},
		"application/senml-etch+cbor": { "source": "iana" },
		"application/senml-etch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml-exi": { "source": "iana" },
		"application/sensml+cbor": { "source": "iana" },
		"application/sensml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sensml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sensmlx"]
		},
		"application/sensml-exi": { "source": "iana" },
		"application/sep+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sep-exi": { "source": "iana" },
		"application/session-info": { "source": "iana" },
		"application/set-payment": { "source": "iana" },
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": ["setpay"]
		},
		"application/set-registration": { "source": "iana" },
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": ["setreg"]
		},
		"application/sgml": { "source": "iana" },
		"application/sgml-open-catalog": { "source": "iana" },
		"application/shf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["shf"]
		},
		"application/sieve": {
			"source": "iana",
			"extensions": ["siv", "sieve"]
		},
		"application/simple-filter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/simple-message-summary": { "source": "iana" },
		"application/simplesymbolcontainer": { "source": "iana" },
		"application/sipc": { "source": "iana" },
		"application/slate": { "source": "iana" },
		"application/smil": { "source": "iana" },
		"application/smil+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["smi", "smil"]
		},
		"application/smpte336m": { "source": "iana" },
		"application/soap+fastinfoset": { "source": "iana" },
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": ["rq"]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["srx"]
		},
		"application/spdx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/spirits-event+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sql": { "source": "iana" },
		"application/srgs": {
			"source": "iana",
			"extensions": ["gram"]
		},
		"application/srgs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["grxml"]
		},
		"application/sru+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sru"]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ssdl"]
		},
		"application/ssml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ssml"]
		},
		"application/stix+json": {
			"source": "iana",
			"compressible": true
		},
		"application/swid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["swidtag"]
		},
		"application/tamp-apex-update": { "source": "iana" },
		"application/tamp-apex-update-confirm": { "source": "iana" },
		"application/tamp-community-update": { "source": "iana" },
		"application/tamp-community-update-confirm": { "source": "iana" },
		"application/tamp-error": { "source": "iana" },
		"application/tamp-sequence-adjust": { "source": "iana" },
		"application/tamp-sequence-adjust-confirm": { "source": "iana" },
		"application/tamp-status-query": { "source": "iana" },
		"application/tamp-status-response": { "source": "iana" },
		"application/tamp-update": { "source": "iana" },
		"application/tamp-update-confirm": { "source": "iana" },
		"application/tar": { "compressible": true },
		"application/taxii+json": {
			"source": "iana",
			"compressible": true
		},
		"application/td+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tei", "teicorpus"]
		},
		"application/tetra_isi": { "source": "iana" },
		"application/thraud+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tfi"]
		},
		"application/timestamp-query": { "source": "iana" },
		"application/timestamp-reply": { "source": "iana" },
		"application/timestamped-data": {
			"source": "iana",
			"extensions": ["tsd"]
		},
		"application/tlsrpt+gzip": { "source": "iana" },
		"application/tlsrpt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tnauthlist": { "source": "iana" },
		"application/token-introspection+jwt": { "source": "iana" },
		"application/toml": {
			"compressible": true,
			"extensions": ["toml"]
		},
		"application/trickle-ice-sdpfrag": { "source": "iana" },
		"application/trig": {
			"source": "iana",
			"extensions": ["trig"]
		},
		"application/ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttml"]
		},
		"application/tve-trigger": { "source": "iana" },
		"application/tzif": { "source": "iana" },
		"application/tzif-leap": { "source": "iana" },
		"application/ubjson": {
			"compressible": false,
			"extensions": ["ubj"]
		},
		"application/ulpfec": { "source": "iana" },
		"application/urc-grpsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/urc-ressheet+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsheet"]
		},
		"application/urc-targetdesc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["td"]
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vemmi": { "source": "iana" },
		"application/vividence.scriptfile": { "source": "apache" },
		"application/vnd.1000minds.decision-model+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["1km"]
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
		"application/vnd.3gpp.5gnas": { "source": "iana" },
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gmop+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gtpc": { "source": "iana" },
		"application/vnd.3gpp.interworking-data": { "source": "iana" },
		"application/vnd.3gpp.lpp": { "source": "iana" },
		"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
		"application/vnd.3gpp.mcdata-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ngap": { "source": "iana" },
		"application/vnd.3gpp.pfcp": { "source": "iana" },
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": ["plb"]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": ["psb"]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": ["pvb"]
		},
		"application/vnd.3gpp.s1ap": { "source": "iana" },
		"application/vnd.3gpp.sms": { "source": "iana" },
		"application/vnd.3gpp.sms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.sms": { "source": "iana" },
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": ["tcap"]
		},
		"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": ["pwn"]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": ["aso"]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": ["imp"]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": ["acu"]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": ["atc", "acutc"]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["air"]
		},
		"application/vnd.adobe.flash.movie": { "source": "iana" },
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": ["fcdt"]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": ["fxp", "fxpl"]
		},
		"application/vnd.adobe.partial-upload": { "source": "iana" },
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdp"]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": ["xfdf"]
		},
		"application/vnd.aether.imp": { "source": "iana" },
		"application/vnd.afpc.afplinedata": { "source": "iana" },
		"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
		"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
		"application/vnd.afpc.foca-charset": { "source": "iana" },
		"application/vnd.afpc.foca-codedfont": { "source": "iana" },
		"application/vnd.afpc.foca-codepage": { "source": "iana" },
		"application/vnd.afpc.modca": { "source": "iana" },
		"application/vnd.afpc.modca-cmtable": { "source": "iana" },
		"application/vnd.afpc.modca-formdef": { "source": "iana" },
		"application/vnd.afpc.modca-mediummap": { "source": "iana" },
		"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
		"application/vnd.afpc.modca-overlay": { "source": "iana" },
		"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
		"application/vnd.age": {
			"source": "iana",
			"extensions": ["age"]
		},
		"application/vnd.ah-barcode": { "source": "iana" },
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": ["ahead"]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": ["azf"]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": ["azs"]
		},
		"application/vnd.amadeus+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": ["azw"]
		},
		"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": ["acc"]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": ["ami"]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.android.ota": { "source": "iana" },
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": ["apk"]
		},
		"application/vnd.anki": { "source": "iana" },
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": ["cii"]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": ["fti"]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": ["atx"]
		},
		"application/vnd.apache.arrow.file": { "source": "iana" },
		"application/vnd.apache.arrow.stream": { "source": "iana" },
		"application/vnd.apache.thrift.binary": { "source": "iana" },
		"application/vnd.apache.thrift.compact": { "source": "iana" },
		"application/vnd.apache.thrift.json": { "source": "iana" },
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.aplextor.warrp+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apothekende.reservation+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpkg"]
		},
		"application/vnd.apple.keynote": {
			"source": "iana",
			"extensions": ["key"]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": ["m3u8"]
		},
		"application/vnd.apple.numbers": {
			"source": "iana",
			"extensions": ["numbers"]
		},
		"application/vnd.apple.pages": {
			"source": "iana",
			"extensions": ["pages"]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": ["pkpass"]
		},
		"application/vnd.arastra.swi": { "source": "iana" },
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": ["swi"]
		},
		"application/vnd.artisan+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.artsquare": { "source": "iana" },
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": ["iota"]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": ["aep"]
		},
		"application/vnd.autopackage": { "source": "iana" },
		"application/vnd.avalon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.avistar+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmml"]
		},
		"application/vnd.balsamiq.bmpr": { "source": "iana" },
		"application/vnd.banana-accounting": { "source": "iana" },
		"application/vnd.bbf.usp.error": { "source": "iana" },
		"application/vnd.bbf.usp.msg": { "source": "iana" },
		"application/vnd.bbf.usp.msg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bint.med-content": { "source": "iana" },
		"application/vnd.biopax.rdf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": ["mpm"]
		},
		"application/vnd.bluetooth.ep.oob": { "source": "iana" },
		"application/vnd.bluetooth.le.oob": { "source": "iana" },
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": ["bmi"]
		},
		"application/vnd.bpf": { "source": "iana" },
		"application/vnd.bpf3": { "source": "iana" },
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": ["rep"]
		},
		"application/vnd.byu.uapi+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cab-jscript": { "source": "iana" },
		"application/vnd.canon-cpdl": { "source": "iana" },
		"application/vnd.canon-lips": { "source": "iana" },
		"application/vnd.capasystems-pg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
		"application/vnd.century-systems.tcp_stream": { "source": "iana" },
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdxml"]
		},
		"application/vnd.chess-pgn": { "source": "iana" },
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": ["mmd"]
		},
		"application/vnd.ciedi": { "source": "iana" },
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": ["cdy"]
		},
		"application/vnd.cirpack.isdn-ext": { "source": "iana" },
		"application/vnd.citationstyles.style+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csl"]
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": ["cla"]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": ["rp9"]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": ["c11amc"]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": ["c11amz"]
		},
		"application/vnd.coffeescript": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.comicbook-rar": { "source": "iana" },
		"application/vnd.commerce-battelle": { "source": "iana" },
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": ["csp"]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": ["cdbcmsg"]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": ["cmc"]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": ["clkx"]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": ["clkk"]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": ["clkp"]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": ["clkt"]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": ["clkw"]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wbs"]
		},
		"application/vnd.cryptii.pipe+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.crypto-shade-file": { "source": "iana" },
		"application/vnd.cryptomator.encrypted": { "source": "iana" },
		"application/vnd.cryptomator.vault": { "source": "iana" },
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": ["pml"]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cups-pdf": { "source": "iana" },
		"application/vnd.cups-postscript": { "source": "iana" },
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": ["ppd"]
		},
		"application/vnd.cups-raster": { "source": "iana" },
		"application/vnd.cups-raw": { "source": "iana" },
		"application/vnd.curl": { "source": "iana" },
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": ["car"]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": ["pcurl"]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cybank": { "source": "iana" },
		"application/vnd.cyclonedx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cyclonedx+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.d3m-dataset": { "source": "iana" },
		"application/vnd.d3m-problem": { "source": "iana" },
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dart"]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": ["rdz"]
		},
		"application/vnd.datapackage+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dataresource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dbf": {
			"source": "iana",
			"extensions": ["dbf"]
		},
		"application/vnd.debian.binary-package": { "source": "iana" },
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uvt", "uvvt"]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": ["uvx", "uvvx"]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": ["uvz", "uvvz"]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": ["fe_launch"]
		},
		"application/vnd.desmume.movie": { "source": "iana" },
		"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
		"application/vnd.dm.delegation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": ["dna"]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": ["mlp"]
		},
		"application/vnd.dolby.mobile.1": { "source": "iana" },
		"application/vnd.dolby.mobile.2": { "source": "iana" },
		"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": ["dpg"]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": ["dfac"]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": ["kpxx"]
		},
		"application/vnd.dtg.local": { "source": "iana" },
		"application/vnd.dtg.local.flash": { "source": "iana" },
		"application/vnd.dtg.local.html": { "source": "iana" },
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": ["ait"]
		},
		"application/vnd.dvb.dvbisl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.dvbj": { "source": "iana" },
		"application/vnd.dvb.esgcontainer": { "source": "iana" },
		"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
		"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
		"application/vnd.dvb.ipdcroaming": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.pfr": { "source": "iana" },
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": ["svc"]
		},
		"application/vnd.dxr": { "source": "iana" },
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": ["geo"]
		},
		"application/vnd.dzr": { "source": "iana" },
		"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
		"application/vnd.ecdis-update": { "source": "iana" },
		"application/vnd.ecip.rlp": { "source": "iana" },
		"application/vnd.eclipse.ditto+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": ["mag"]
		},
		"application/vnd.ecowin.filerequest": { "source": "iana" },
		"application/vnd.ecowin.fileupdate": { "source": "iana" },
		"application/vnd.ecowin.series": { "source": "iana" },
		"application/vnd.ecowin.seriesrequest": { "source": "iana" },
		"application/vnd.ecowin.seriesupdate": { "source": "iana" },
		"application/vnd.efi.img": { "source": "iana" },
		"application/vnd.efi.iso": { "source": "iana" },
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": ["nml"]
		},
		"application/vnd.enphase.envoy": { "source": "iana" },
		"application/vnd.eprints.data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": ["esf"]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": ["msf"]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": ["qam"]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": ["slt"]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": ["ssf"]
		},
		"application/vnd.ericsson.quickcall": { "source": "iana" },
		"application/vnd.espass-espass+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es3", "et3"]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mheg5": { "source": "iana" },
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.timestamp-token": { "source": "iana" },
		"application/vnd.etsi.tsl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.tsl.der": { "source": "iana" },
		"application/vnd.eu.kasparian.car+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.eudora.data": { "source": "iana" },
		"application/vnd.evolv.ecig.profile": { "source": "iana" },
		"application/vnd.evolv.ecig.settings": { "source": "iana" },
		"application/vnd.evolv.ecig.theme": { "source": "iana" },
		"application/vnd.exstream-empower+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.exstream-package": { "source": "iana" },
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": ["ez2"]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": ["ez3"]
		},
		"application/vnd.f-secure.mobile": { "source": "iana" },
		"application/vnd.familysearch.gedcom+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.fastcopy-disk-image": { "source": "iana" },
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": ["fdf"]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": ["mseed"]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": ["seed", "dataless"]
		},
		"application/vnd.ffsns": { "source": "iana" },
		"application/vnd.ficlab.flb+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.filmit.zfc": { "source": "iana" },
		"application/vnd.fints": { "source": "iana" },
		"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": ["gph"]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": ["ftc"]
		},
		"application/vnd.font-fontforge-sfd": { "source": "iana" },
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": ["fnc"]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": ["ltf"]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": ["fsc"]
		},
		"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
		"application/vnd.fujifilm.fb.jfi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": ["oas"]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": ["oa2"]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": ["oa3"]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": ["fg5"]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": ["bh2"]
		},
		"application/vnd.fujixerox.art-ex": { "source": "iana" },
		"application/vnd.fujixerox.art4": { "source": "iana" },
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": ["ddd"]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": ["xdw"]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": ["xbd"]
		},
		"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
		"application/vnd.fujixerox.hbpl": { "source": "iana" },
		"application/vnd.fut-misnet": { "source": "iana" },
		"application/vnd.futoin+cbor": { "source": "iana" },
		"application/vnd.futoin+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": ["fzs"]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": ["txd"]
		},
		"application/vnd.gentics.grd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": ["ggb"]
		},
		"application/vnd.geogebra.slides": { "source": "iana" },
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": ["ggt"]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": ["gex", "gre"]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": ["gxt"]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": ["g2w"]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": ["g3w"]
		},
		"application/vnd.gerber": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": ["gmx"]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": ["gdoc"]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": ["gslides"]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": ["gsheet"]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["kml"]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": ["kmz"]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": ["gqf", "gqs"]
		},
		"application/vnd.gridmp": { "source": "iana" },
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": ["gac"]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": ["ghf"]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": ["gim"]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": ["grv"]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": ["gtm"]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": ["tpl"]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": ["vcg"]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["hal"]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zmm"]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": ["hbci"]
		},
		"application/vnd.hc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hcl-bireports": { "source": "iana" },
		"application/vnd.hdt": { "source": "iana" },
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": ["les"]
		},
		"application/vnd.hl7cda+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hl7v2+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": ["hpgl"]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": ["hpid"]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": ["hps"]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": ["jlt"]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": ["pcl"]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": ["pclxl"]
		},
		"application/vnd.httphone": { "source": "iana" },
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": ["sfd-hdstx"]
		},
		"application/vnd.hyper+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyper-item+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": { "source": "iana" },
		"application/vnd.ibm.afplinedata": { "source": "iana" },
		"application/vnd.ibm.electronic-media": { "source": "iana" },
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": ["mpy"]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": ["irm"]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": ["sc"]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": ["icc", "icm"]
		},
		"application/vnd.ieee.1905": { "source": "iana" },
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": ["igl"]
		},
		"application/vnd.imagemeter.folder+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.imagemeter.image+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": ["ivp"]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": ["ivu"]
		},
		"application/vnd.ims.imsccv1p1": { "source": "iana" },
		"application/vnd.ims.imsccv1p2": { "source": "iana" },
		"application/vnd.ims.imsccv1p3": { "source": "iana" },
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informix-visionary": { "source": "iana" },
		"application/vnd.infotech.project": { "source": "iana" },
		"application/vnd.infotech.project+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.innopath.wamp.notification": { "source": "iana" },
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": ["igm"]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": ["xpw", "xpx"]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": ["i2g"]
		},
		"application/vnd.intertrust.digibox": { "source": "iana" },
		"application/vnd.intertrust.nncp": { "source": "iana" },
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": ["qbo"]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": ["qfx"]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": ["rcprofile"]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["irp"]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": ["xpr"]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": ["fcs"]
		},
		"application/vnd.iso11783-10+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": ["jam"]
		},
		"application/vnd.japannet-directory-service": { "source": "iana" },
		"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-payment-wakeup": { "source": "iana" },
		"application/vnd.japannet-registration": { "source": "iana" },
		"application/vnd.japannet-registration-wakeup": { "source": "iana" },
		"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-verification": { "source": "iana" },
		"application/vnd.japannet-verification-wakeup": { "source": "iana" },
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": ["rms"]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": ["jisp"]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": ["joda"]
		},
		"application/vnd.jsk.isdn-ngn": { "source": "iana" },
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": ["ktz", "ktr"]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": ["karbon"]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": ["chrt"]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": ["kfo"]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": ["flw"]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": ["kon"]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": ["kpr", "kpt"]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": ["ksp"]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": ["kwd", "kwt"]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": ["htke"]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": ["kia"]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": ["kne", "knp"]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": ["sse"]
		},
		"application/vnd.las": { "source": "iana" },
		"application/vnd.las.las+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lasxml"]
		},
		"application/vnd.laszip": { "source": "iana" },
		"application/vnd.leap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": ["lbd"]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lbe"]
		},
		"application/vnd.logipipe.circuit+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.loom": { "source": "iana" },
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": ["123"]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": ["apr"]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": ["pre"]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": ["nsf"]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": ["org"]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": ["scm"]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": ["lwp"]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": ["portpkg"]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana",
			"extensions": ["mvt"]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.mdcf": { "source": "iana" },
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxar.archive.3tz+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.maxmind.maxmind-db": { "source": "iana" },
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": ["mcd"]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": ["mc1"]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": ["cdkey"]
		},
		"application/vnd.meridian-slingshot": { "source": "iana" },
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": ["mwf"]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": ["mfm"]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": ["flo"]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": ["igx"]
		},
		"application/vnd.microsoft.portable-executable": { "source": "iana" },
		"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": ["mif"]
		},
		"application/vnd.minisoft-hp3000-save": { "source": "iana" },
		"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": ["daf"]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": ["dis"]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": ["mbk"]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": ["mqy"]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": ["msl"]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": ["plc"]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": ["txf"]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": ["mpn"]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": ["mpc"]
		},
		"application/vnd.motorola.flexsuite": { "source": "iana" },
		"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
		"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
		"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
		"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
		"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
		"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
		"application/vnd.motorola.iprm": { "source": "iana" },
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xul"]
		},
		"application/vnd.ms-3mfdocument": { "source": "iana" },
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": ["cil"]
		},
		"application/vnd.ms-asf": { "source": "iana" },
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": ["cab"]
		},
		"application/vnd.ms-color.iccprofile": { "source": "apache" },
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlam"]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsb"]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsm"]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["xltm"]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eot"]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": ["chm"]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": ["ims"]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": ["lrm"]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": ["thmx"]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-outlook": {
			"compressible": false,
			"extensions": ["msg"]
		},
		"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": ["cat"]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": ["stl"]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppam"]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": ["pptm"]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": ["sldm"]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppsm"]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["potm"]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": ["mpp", "mpt"]
		},
		"application/vnd.ms-tnef": { "source": "iana" },
		"application/vnd.ms-windows.devicepairing": { "source": "iana" },
		"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
		"application/vnd.ms-windows.printerpairing": { "source": "iana" },
		"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": ["docm"]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["dotm"]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": ["wpl"]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xps"]
		},
		"application/vnd.msa-disk-image": { "source": "iana" },
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": ["mseq"]
		},
		"application/vnd.msign": { "source": "iana" },
		"application/vnd.multiad.creator": { "source": "iana" },
		"application/vnd.multiad.creator.cif": { "source": "iana" },
		"application/vnd.music-niff": { "source": "iana" },
		"application/vnd.musician": {
			"source": "iana",
			"extensions": ["mus"]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": ["msty"]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": ["taglet"]
		},
		"application/vnd.nacamar.ybrid+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ncd.control": { "source": "iana" },
		"application/vnd.ncd.reference": { "source": "iana" },
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nebumind.line": { "source": "iana" },
		"application/vnd.nervana": { "source": "iana" },
		"application/vnd.netfpx": { "source": "iana" },
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": ["nlu"]
		},
		"application/vnd.nimn": { "source": "iana" },
		"application/vnd.nintendo.nitro.rom": { "source": "iana" },
		"application/vnd.nintendo.snes.rom": { "source": "iana" },
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": ["ntf", "nitf"]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": ["nnd"]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": ["nns"]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": ["nnw"]
		},
		"application/vnd.nokia.catalogs": { "source": "iana" },
		"application/vnd.nokia.conml+wbxml": { "source": "iana" },
		"application/vnd.nokia.conml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
		"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
		"application/vnd.nokia.landmark+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ac"]
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": ["ngdat"]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": ["n-gage"]
		},
		"application/vnd.nokia.ncd": { "source": "iana" },
		"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
		"application/vnd.nokia.pcd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": ["rpst"]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": ["rpss"]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": ["edm"]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": ["edx"]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": ["ext"]
		},
		"application/vnd.ntt-local.content-share": { "source": "iana" },
		"application/vnd.ntt-local.file-transfer": { "source": "iana" },
		"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": ["odc"]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": ["otc"]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": ["odb"]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": ["odf"]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": ["odft"]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odg"]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": ["otg"]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": ["odi"]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": ["oti"]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odp"]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": ["otp"]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ods"]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": ["ots"]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odt"]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": ["odm"]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": ["ott"]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": ["oth"]
		},
		"application/vnd.obn": { "source": "iana" },
		"application/vnd.ocf+cbor": { "source": "iana" },
		"application/vnd.oci.image.manifest.v1+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.pae.gem": { "source": "iana" },
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": ["xo"]
		},
		"application/vnd.oma-scws-config": { "source": "iana" },
		"application/vnd.oma-scws-http-request": { "source": "iana" },
		"application/vnd.oma-scws-http-response": { "source": "iana" },
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.ltkm": { "source": "iana" },
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
		"application/vnd.oma.bcast.sgboot": { "source": "iana" },
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sgdu": { "source": "iana" },
		"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.stkm": { "source": "iana" },
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.dcd": { "source": "iana" },
		"application/vnd.oma.dcdc": { "source": "iana" },
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dd2"]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
		"application/vnd.oma.pal+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.push": { "source": "iana" },
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.omads-email+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-file+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omaloc-supl-init": { "source": "iana" },
		"application/vnd.onepager": { "source": "iana" },
		"application/vnd.onepagertamp": { "source": "iana" },
		"application/vnd.onepagertamx": { "source": "iana" },
		"application/vnd.onepagertat": { "source": "iana" },
		"application/vnd.onepagertatp": { "source": "iana" },
		"application/vnd.onepagertatx": { "source": "iana" },
		"application/vnd.openblox.game+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["obgx"]
		},
		"application/vnd.openblox.game-binary": { "source": "iana" },
		"application/vnd.openeye.oeb": { "source": "iana" },
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": ["oxt"]
		},
		"application/vnd.openstreetmap.data+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osm"]
		},
		"application/vnd.opentimestamps.ots": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pptx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": ["sldx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": ["ppsx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "iana",
			"extensions": ["potx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xlsx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "iana",
			"extensions": ["xltx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": ["docx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "iana",
			"extensions": ["dotx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": { "source": "iana" },
		"application/vnd.osa.netdeploy": { "source": "iana" },
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": ["mgp"]
		},
		"application/vnd.osgi.bundle": { "source": "iana" },
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": ["dp"]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": ["esa"]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oxli.countgraph": { "source": "iana" },
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": { "source": "iana" },
		"application/vnd.paos.xml": { "source": "iana" },
		"application/vnd.patentdive": { "source": "iana" },
		"application/vnd.patientecommsdoc": { "source": "iana" },
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": ["paw"]
		},
		"application/vnd.pcos": { "source": "iana" },
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": ["str"]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": ["ei6"]
		},
		"application/vnd.piaccess.application-licence": { "source": "iana" },
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": ["efif"]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": ["wg"]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": ["plf"]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": ["pbd"]
		},
		"application/vnd.powerbuilder6-s": { "source": "iana" },
		"application/vnd.powerbuilder7": { "source": "iana" },
		"application/vnd.powerbuilder7-s": { "source": "iana" },
		"application/vnd.powerbuilder75": { "source": "iana" },
		"application/vnd.powerbuilder75-s": { "source": "iana" },
		"application/vnd.preminet": { "source": "iana" },
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": ["box"]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": ["mgz"]
		},
		"application/vnd.psfs": { "source": "iana" },
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": ["qps"]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": ["ptid"]
		},
		"application/vnd.pwg-multiplexed": { "source": "iana" },
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
		"application/vnd.quarantainenet": { "source": "iana" },
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": { "source": "iana" },
		"application/vnd.radisys.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rainstor.data": { "source": "iana" },
		"application/vnd.rapid": { "source": "iana" },
		"application/vnd.rar": {
			"source": "iana",
			"extensions": ["rar"]
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": ["bed"]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": ["mxl"]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musicxml"]
		},
		"application/vnd.renlearn.rlprint": { "source": "iana" },
		"application/vnd.resilient.logic": { "source": "iana" },
		"application/vnd.restful+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": ["cryptonote"]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": ["cod"]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": ["rm"]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": ["rmvb"]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["link66"]
		},
		"application/vnd.rs-274x": { "source": "iana" },
		"application/vnd.ruckus.download": { "source": "iana" },
		"application/vnd.s3sms": { "source": "iana" },
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": ["st"]
		},
		"application/vnd.sar": { "source": "iana" },
		"application/vnd.sbm.cid": { "source": "iana" },
		"application/vnd.sbm.mid2": { "source": "iana" },
		"application/vnd.scribus": { "source": "iana" },
		"application/vnd.sealed.3df": { "source": "iana" },
		"application/vnd.sealed.csf": { "source": "iana" },
		"application/vnd.sealed.doc": { "source": "iana" },
		"application/vnd.sealed.eml": { "source": "iana" },
		"application/vnd.sealed.mht": { "source": "iana" },
		"application/vnd.sealed.net": { "source": "iana" },
		"application/vnd.sealed.ppt": { "source": "iana" },
		"application/vnd.sealed.tiff": { "source": "iana" },
		"application/vnd.sealed.xls": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": ["see"]
		},
		"application/vnd.seis+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": ["sema"]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": ["semd"]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": ["semf"]
		},
		"application/vnd.shade-save-file": { "source": "iana" },
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": ["ifm"]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": ["itp"]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": ["iif"]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": ["ipk"]
		},
		"application/vnd.shootproof+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shopkick+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shp": { "source": "iana" },
		"application/vnd.shx": { "source": "iana" },
		"application/vnd.sigrok.session": { "source": "iana" },
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": ["twd", "twds"]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": ["mmf"]
		},
		"application/vnd.smart.notebook": { "source": "iana" },
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": ["teacher"]
		},
		"application/vnd.snesdev-page-table": { "source": "iana" },
		"application/vnd.software602.filler.form+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fo"]
		},
		"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sdkm", "sdkd"]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": ["dxp"]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": ["sfs"]
		},
		"application/vnd.sqlite3": { "source": "iana" },
		"application/vnd.sss-cod": { "source": "iana" },
		"application/vnd.sss-dtf": { "source": "iana" },
		"application/vnd.sss-ntf": { "source": "iana" },
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": ["sdc"]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": ["sda"]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": ["sdd"]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": ["smf"]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": ["sdw", "vor"]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": ["sgl"]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": ["smzip"]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": ["sm"]
		},
		"application/vnd.street-stream": { "source": "iana" },
		"application/vnd.sun.wadl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wadl"]
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": ["sxc"]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": ["stc"]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": ["sxd"]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": ["std"]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": ["sxi"]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": ["sti"]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": ["sxm"]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": ["sxw"]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": ["sxg"]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": ["stw"]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": ["sus", "susp"]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": ["svd"]
		},
		"application/vnd.swiftview-ics": { "source": "iana" },
		"application/vnd.sycle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.syft+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": ["sis", "sisx"]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xsm"]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["bdm"]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xdm"]
		},
		"application/vnd.syncml.dm.notification": { "source": "iana" },
		"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["ddf"]
		},
		"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.syncml.ds.notification": { "source": "iana" },
		"application/vnd.tableschema+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": ["tao"]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.think-cell.ppttc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tml": { "source": "iana" },
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": ["tmo"]
		},
		"application/vnd.tri.onesource": { "source": "iana" },
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": ["tpt"]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": ["mxs"]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": ["tra"]
		},
		"application/vnd.truedoc": { "source": "iana" },
		"application/vnd.ubisoft.webplayer": { "source": "iana" },
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": ["ufd", "ufdl"]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": ["utz"]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": ["umj"]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": ["unityweb"]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uoml"]
		},
		"application/vnd.uplanet.alert": { "source": "iana" },
		"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
		"application/vnd.uplanet.cacheop": { "source": "iana" },
		"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
		"application/vnd.uplanet.channel": { "source": "iana" },
		"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
		"application/vnd.uplanet.list": { "source": "iana" },
		"application/vnd.uplanet.list-wbxml": { "source": "iana" },
		"application/vnd.uplanet.listcmd": { "source": "iana" },
		"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
		"application/vnd.uplanet.signal": { "source": "iana" },
		"application/vnd.uri-map": { "source": "iana" },
		"application/vnd.valve.source.material": { "source": "iana" },
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": ["vcx"]
		},
		"application/vnd.vd-study": { "source": "iana" },
		"application/vnd.vectorworks": { "source": "iana" },
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": { "source": "iana" },
		"application/vnd.veritone.aion+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.veryant.thin": { "source": "iana" },
		"application/vnd.ves.encrypted": { "source": "iana" },
		"application/vnd.vidsoft.vidconference": { "source": "iana" },
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": ["vis"]
		},
		"application/vnd.vividence.scriptfile": { "source": "iana" },
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": ["vsf"]
		},
		"application/vnd.wap.sic": { "source": "iana" },
		"application/vnd.wap.slc": { "source": "iana" },
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["wbxml"]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": ["wmlc"]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": ["wmlsc"]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": ["wtb"]
		},
		"application/vnd.wfa.dpp": { "source": "iana" },
		"application/vnd.wfa.p2p": { "source": "iana" },
		"application/vnd.wfa.wsc": { "source": "iana" },
		"application/vnd.windows.devicepairing": { "source": "iana" },
		"application/vnd.wmc": { "source": "iana" },
		"application/vnd.wmf.bootstrap": { "source": "iana" },
		"application/vnd.wolfram.mathematica": { "source": "iana" },
		"application/vnd.wolfram.mathematica.package": { "source": "iana" },
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": ["nbp"]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": ["wpd"]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": ["wqd"]
		},
		"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": ["stf"]
		},
		"application/vnd.wv.csp+wbxml": { "source": "iana" },
		"application/vnd.wv.csp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": ["xar"]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": ["xfdl"]
		},
		"application/vnd.xfdl.webform": { "source": "iana" },
		"application/vnd.xmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xmpie.cpkg": { "source": "iana" },
		"application/vnd.xmpie.dpkg": { "source": "iana" },
		"application/vnd.xmpie.plan": { "source": "iana" },
		"application/vnd.xmpie.ppkg": { "source": "iana" },
		"application/vnd.xmpie.xlim": { "source": "iana" },
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": ["hvd"]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": ["hvs"]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": ["hvp"]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": ["osf"]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osfpvg"]
		},
		"application/vnd.yamaha.remote-setup": { "source": "iana" },
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": ["saf"]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": ["spf"]
		},
		"application/vnd.yamaha.through-ngn": { "source": "iana" },
		"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
		"application/vnd.yaoweme": { "source": "iana" },
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": ["cmp"]
		},
		"application/vnd.youtube.yt": { "source": "iana" },
		"application/vnd.zul": {
			"source": "iana",
			"extensions": ["zir", "zirz"]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zaz"]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vxml"]
		},
		"application/voucher-cms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vq-rtcpxr": { "source": "iana" },
		"application/wasm": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wasm"]
		},
		"application/watcherinfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wif"]
		},
		"application/webpush-options+json": {
			"source": "iana",
			"compressible": true
		},
		"application/whoispp-query": { "source": "iana" },
		"application/whoispp-response": { "source": "iana" },
		"application/widget": {
			"source": "iana",
			"extensions": ["wgt"]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": ["hlp"]
		},
		"application/wita": { "source": "iana" },
		"application/wordperfect5.1": { "source": "iana" },
		"application/wsdl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wsdl"]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wspolicy"]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["7z"]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": ["abw"]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": ["ace"]
		},
		"application/x-amf": { "source": "apache" },
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": ["dmg"]
		},
		"application/x-arj": {
			"compressible": false,
			"extensions": ["arj"]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": ["aam"]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": ["aas"]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": ["bcpio"]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": ["torrent"]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": ["blb", "blorb"]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz"]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz2", "boz"]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": ["vcd"]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": ["cfs"]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": ["chat"]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": ["pgn"]
		},
		"application/x-chrome-extension": { "extensions": ["crx"] },
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": ["cco"]
		},
		"application/x-compress": { "source": "apache" },
		"application/x-conference": {
			"source": "apache",
			"extensions": ["nsc"]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": ["cpio"]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": ["csh"]
		},
		"application/x-deb": { "compressible": false },
		"application/x-debian-package": {
			"source": "apache",
			"extensions": ["deb", "udeb"]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": ["dgc"]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": ["wad"]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ncx"]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dtb"]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["res"]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": ["dvi"]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": ["evy"]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": ["eva"]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": ["bdf"]
		},
		"application/x-font-dos": { "source": "apache" },
		"application/x-font-framemaker": { "source": "apache" },
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": ["gsf"]
		},
		"application/x-font-libgrx": { "source": "apache" },
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": ["psf"]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": ["pcf"]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": ["snf"]
		},
		"application/x-font-speedo": { "source": "apache" },
		"application/x-font-sunos-news": { "source": "apache" },
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": { "source": "apache" },
		"application/x-freearc": {
			"source": "apache",
			"extensions": ["arc"]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": ["spl"]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": ["gca"]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": ["ulx"]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": ["gnumeric"]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": ["gramps"]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": ["gtar"]
		},
		"application/x-gzip": { "source": "apache" },
		"application/x-hdf": {
			"source": "apache",
			"extensions": ["hdf"]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": ["php"]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": ["install"]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": ["iso"]
		},
		"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
		"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
		"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": ["jardiff"]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": ["jnlp"]
		},
		"application/x-javascript": { "compressible": true },
		"application/x-keepass2": { "extensions": ["kdbx"] },
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": ["latex"]
		},
		"application/x-lua-bytecode": { "extensions": ["luac"] },
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": ["lzh", "lha"]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": ["run"]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": ["mie"]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": ["prc", "mobi"]
		},
		"application/x-mpegurl": { "compressible": false },
		"application/x-ms-application": {
			"source": "apache",
			"extensions": ["application"]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": ["lnk"]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": ["wmd"]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": ["wmz"]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": ["xbap"]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": ["mdb"]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": ["obd"]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": ["crd"]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": ["clp"]
		},
		"application/x-msdos-program": { "extensions": ["exe"] },
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": ["mny"]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": ["pub"]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": ["scd"]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": ["trm"]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": ["wri"]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": ["nc", "cdf"]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": ["pac"]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": ["nzb"]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": ["pl", "pm"]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": ["prc", "pdb"]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": ["p12", "pfx"]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": ["p7b", "spc"]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": ["p7r"]
		},
		"application/x-pki-message": { "source": "iana" },
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["rar"]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": ["rpm"]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": ["ris"]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": ["sea"]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": ["sh"]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": ["shar"]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": ["swf"]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": ["xap"]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": ["sql"]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": ["sit"]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": ["sitx"]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": ["srt"]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": ["sv4cpio"]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": ["sv4crc"]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": ["t3"]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": ["gam"]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": ["tar"]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": ["tcl", "tk"]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": ["tex"]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": ["tfm"]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": ["texinfo", "texi"]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": ["obj"]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": ["ustar"]
		},
		"application/x-virtualbox-hdd": {
			"compressible": true,
			"extensions": ["hdd"]
		},
		"application/x-virtualbox-ova": {
			"compressible": true,
			"extensions": ["ova"]
		},
		"application/x-virtualbox-ovf": {
			"compressible": true,
			"extensions": ["ovf"]
		},
		"application/x-virtualbox-vbox": {
			"compressible": true,
			"extensions": ["vbox"]
		},
		"application/x-virtualbox-vbox-extpack": {
			"compressible": false,
			"extensions": ["vbox-extpack"]
		},
		"application/x-virtualbox-vdi": {
			"compressible": true,
			"extensions": ["vdi"]
		},
		"application/x-virtualbox-vhd": {
			"compressible": true,
			"extensions": ["vhd"]
		},
		"application/x-virtualbox-vmdk": {
			"compressible": true,
			"extensions": ["vmdk"]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": ["src"]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": ["webapp"]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "iana",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-x509-ca-ra-cert": { "source": "iana" },
		"application/x-x509-next-ca-cert": { "source": "iana" },
		"application/x-xfig": {
			"source": "apache",
			"extensions": ["fig"]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": ["xpi"]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": ["xz"]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": { "source": "iana" },
		"application/xacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xaml+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xaml"]
		},
		"application/xcap-att+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xav"]
		},
		"application/xcap-caps+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xca"]
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdf"]
		},
		"application/xcap-el+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xel"]
		},
		"application/xcap-error+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcap-ns+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xns"]
		},
		"application/xcon-conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xenc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xenc"]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xhtml", "xht"]
		},
		"application/xhtml-voice+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/xliff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dtd"]
		},
		"application/xml-external-parsed-entity": { "source": "iana" },
		"application/xml-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xmpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xop"]
		},
		"application/xproc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xpl"]
		},
		"application/xslt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xsl", "xslt"]
		},
		"application/xspf+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xspf"]
		},
		"application/xv+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": ["yang"]
		},
		"application/yang-data+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yin+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["yin"]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["zip"]
		},
		"application/zlib": { "source": "iana" },
		"application/zstd": { "source": "iana" },
		"audio/1d-interleaved-parityfec": { "source": "iana" },
		"audio/32kadpcm": { "source": "iana" },
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": ["3gpp"]
		},
		"audio/3gpp2": { "source": "iana" },
		"audio/aac": { "source": "iana" },
		"audio/ac3": { "source": "iana" },
		"audio/adpcm": {
			"source": "apache",
			"extensions": ["adp"]
		},
		"audio/amr": {
			"source": "iana",
			"extensions": ["amr"]
		},
		"audio/amr-wb": { "source": "iana" },
		"audio/amr-wb+": { "source": "iana" },
		"audio/aptx": { "source": "iana" },
		"audio/asc": { "source": "iana" },
		"audio/atrac-advanced-lossless": { "source": "iana" },
		"audio/atrac-x": { "source": "iana" },
		"audio/atrac3": { "source": "iana" },
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": ["au", "snd"]
		},
		"audio/bv16": { "source": "iana" },
		"audio/bv32": { "source": "iana" },
		"audio/clearmode": { "source": "iana" },
		"audio/cn": { "source": "iana" },
		"audio/dat12": { "source": "iana" },
		"audio/dls": { "source": "iana" },
		"audio/dsr-es201108": { "source": "iana" },
		"audio/dsr-es202050": { "source": "iana" },
		"audio/dsr-es202211": { "source": "iana" },
		"audio/dsr-es202212": { "source": "iana" },
		"audio/dv": { "source": "iana" },
		"audio/dvi4": { "source": "iana" },
		"audio/eac3": { "source": "iana" },
		"audio/encaprtp": { "source": "iana" },
		"audio/evrc": { "source": "iana" },
		"audio/evrc-qcp": { "source": "iana" },
		"audio/evrc0": { "source": "iana" },
		"audio/evrc1": { "source": "iana" },
		"audio/evrcb": { "source": "iana" },
		"audio/evrcb0": { "source": "iana" },
		"audio/evrcb1": { "source": "iana" },
		"audio/evrcnw": { "source": "iana" },
		"audio/evrcnw0": { "source": "iana" },
		"audio/evrcnw1": { "source": "iana" },
		"audio/evrcwb": { "source": "iana" },
		"audio/evrcwb0": { "source": "iana" },
		"audio/evrcwb1": { "source": "iana" },
		"audio/evs": { "source": "iana" },
		"audio/flexfec": { "source": "iana" },
		"audio/fwdred": { "source": "iana" },
		"audio/g711-0": { "source": "iana" },
		"audio/g719": { "source": "iana" },
		"audio/g722": { "source": "iana" },
		"audio/g7221": { "source": "iana" },
		"audio/g723": { "source": "iana" },
		"audio/g726-16": { "source": "iana" },
		"audio/g726-24": { "source": "iana" },
		"audio/g726-32": { "source": "iana" },
		"audio/g726-40": { "source": "iana" },
		"audio/g728": { "source": "iana" },
		"audio/g729": { "source": "iana" },
		"audio/g7291": { "source": "iana" },
		"audio/g729d": { "source": "iana" },
		"audio/g729e": { "source": "iana" },
		"audio/gsm": { "source": "iana" },
		"audio/gsm-efr": { "source": "iana" },
		"audio/gsm-hr-08": { "source": "iana" },
		"audio/ilbc": { "source": "iana" },
		"audio/ip-mr_v2.5": { "source": "iana" },
		"audio/isac": { "source": "apache" },
		"audio/l16": { "source": "iana" },
		"audio/l20": { "source": "iana" },
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": { "source": "iana" },
		"audio/lpc": { "source": "iana" },
		"audio/melp": { "source": "iana" },
		"audio/melp1200": { "source": "iana" },
		"audio/melp2400": { "source": "iana" },
		"audio/melp600": { "source": "iana" },
		"audio/mhas": { "source": "iana" },
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana",
			"extensions": ["mxmf"]
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": ["mp3"]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": ["m4a", "mp4a"]
		},
		"audio/mp4a-latm": { "source": "iana" },
		"audio/mpa": { "source": "iana" },
		"audio/mpa-robust": { "source": "iana" },
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": { "source": "iana" },
		"audio/musepack": { "source": "apache" },
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx",
				"opus"
			]
		},
		"audio/opus": { "source": "iana" },
		"audio/parityfec": { "source": "iana" },
		"audio/pcma": { "source": "iana" },
		"audio/pcma-wb": { "source": "iana" },
		"audio/pcmu": { "source": "iana" },
		"audio/pcmu-wb": { "source": "iana" },
		"audio/prs.sid": { "source": "iana" },
		"audio/qcelp": { "source": "iana" },
		"audio/raptorfec": { "source": "iana" },
		"audio/red": { "source": "iana" },
		"audio/rtp-enc-aescm128": { "source": "iana" },
		"audio/rtp-midi": { "source": "iana" },
		"audio/rtploopback": { "source": "iana" },
		"audio/rtx": { "source": "iana" },
		"audio/s3m": {
			"source": "apache",
			"extensions": ["s3m"]
		},
		"audio/scip": { "source": "iana" },
		"audio/silk": {
			"source": "apache",
			"extensions": ["sil"]
		},
		"audio/smv": { "source": "iana" },
		"audio/smv-qcp": { "source": "iana" },
		"audio/smv0": { "source": "iana" },
		"audio/sofa": { "source": "iana" },
		"audio/sp-midi": { "source": "iana" },
		"audio/speex": { "source": "iana" },
		"audio/t140c": { "source": "iana" },
		"audio/t38": { "source": "iana" },
		"audio/telephone-event": { "source": "iana" },
		"audio/tetra_acelp": { "source": "iana" },
		"audio/tetra_acelp_bb": { "source": "iana" },
		"audio/tone": { "source": "iana" },
		"audio/tsvcis": { "source": "iana" },
		"audio/uemclip": { "source": "iana" },
		"audio/ulpfec": { "source": "iana" },
		"audio/usac": { "source": "iana" },
		"audio/vdvi": { "source": "iana" },
		"audio/vmr-wb": { "source": "iana" },
		"audio/vnd.3gpp.iufp": { "source": "iana" },
		"audio/vnd.4sb": { "source": "iana" },
		"audio/vnd.audiokoz": { "source": "iana" },
		"audio/vnd.celp": { "source": "iana" },
		"audio/vnd.cisco.nse": { "source": "iana" },
		"audio/vnd.cmles.radio-events": { "source": "iana" },
		"audio/vnd.cns.anp1": { "source": "iana" },
		"audio/vnd.cns.inf1": { "source": "iana" },
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": ["uva", "uvva"]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": ["eol"]
		},
		"audio/vnd.dlna.adts": { "source": "iana" },
		"audio/vnd.dolby.heaac.1": { "source": "iana" },
		"audio/vnd.dolby.heaac.2": { "source": "iana" },
		"audio/vnd.dolby.mlp": { "source": "iana" },
		"audio/vnd.dolby.mps": { "source": "iana" },
		"audio/vnd.dolby.pl2": { "source": "iana" },
		"audio/vnd.dolby.pl2x": { "source": "iana" },
		"audio/vnd.dolby.pl2z": { "source": "iana" },
		"audio/vnd.dolby.pulse.1": { "source": "iana" },
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": ["dra"]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": ["dts"]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": ["dtshd"]
		},
		"audio/vnd.dts.uhd": { "source": "iana" },
		"audio/vnd.dvb.file": { "source": "iana" },
		"audio/vnd.everad.plj": { "source": "iana" },
		"audio/vnd.hns.audio": { "source": "iana" },
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": ["lvp"]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": ["pya"]
		},
		"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
		"audio/vnd.nortel.vbk": { "source": "iana" },
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": ["ecelp4800"]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": ["ecelp7470"]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": ["ecelp9600"]
		},
		"audio/vnd.octel.sbc": { "source": "iana" },
		"audio/vnd.presonus.multitrack": { "source": "iana" },
		"audio/vnd.qcelp": { "source": "iana" },
		"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": ["rip"]
		},
		"audio/vnd.rn-realaudio": { "compressible": false },
		"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
		"audio/vnd.vmx.cvsd": { "source": "iana" },
		"audio/vnd.wave": { "compressible": false },
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": { "source": "iana" },
		"audio/wav": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["weba"]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": ["aac"]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": ["caf"]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": ["flac"]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": ["m4a"]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": ["mka"]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": ["m3u"]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": ["wax"]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": ["wma"]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": ["ram", "ra"]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": ["rmp"]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": ["ra"]
		},
		"audio/x-tta": { "source": "apache" },
		"audio/x-wav": {
			"source": "apache",
			"extensions": ["wav"]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": ["xm"]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": ["cdx"]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": ["cif"]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": ["cmdf"]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": ["cml"]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": ["csml"]
		},
		"chemical/x-pdb": { "source": "apache" },
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": ["xyz"]
		},
		"font/collection": {
			"source": "iana",
			"extensions": ["ttc"]
		},
		"font/otf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["otf"]
		},
		"font/sfnt": { "source": "iana" },
		"font/ttf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttf"]
		},
		"font/woff": {
			"source": "iana",
			"extensions": ["woff"]
		},
		"font/woff2": {
			"source": "iana",
			"extensions": ["woff2"]
		},
		"image/aces": {
			"source": "iana",
			"extensions": ["exr"]
		},
		"image/apng": {
			"compressible": false,
			"extensions": ["apng"]
		},
		"image/avci": {
			"source": "iana",
			"extensions": ["avci"]
		},
		"image/avcs": {
			"source": "iana",
			"extensions": ["avcs"]
		},
		"image/avif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["avif"]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": ["cgm"]
		},
		"image/dicom-rle": {
			"source": "iana",
			"extensions": ["drle"]
		},
		"image/emf": {
			"source": "iana",
			"extensions": ["emf"]
		},
		"image/fits": {
			"source": "iana",
			"extensions": ["fits"]
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": ["g3"]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gif"]
		},
		"image/heic": {
			"source": "iana",
			"extensions": ["heic"]
		},
		"image/heic-sequence": {
			"source": "iana",
			"extensions": ["heics"]
		},
		"image/heif": {
			"source": "iana",
			"extensions": ["heif"]
		},
		"image/heif-sequence": {
			"source": "iana",
			"extensions": ["heifs"]
		},
		"image/hej2k": {
			"source": "iana",
			"extensions": ["hej2"]
		},
		"image/hsj2": {
			"source": "iana",
			"extensions": ["hsj2"]
		},
		"image/ief": {
			"source": "iana",
			"extensions": ["ief"]
		},
		"image/jls": {
			"source": "iana",
			"extensions": ["jls"]
		},
		"image/jp2": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jp2", "jpg2"]
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jph": {
			"source": "iana",
			"extensions": ["jph"]
		},
		"image/jphc": {
			"source": "iana",
			"extensions": ["jhc"]
		},
		"image/jpm": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpm"]
		},
		"image/jpx": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpx", "jpf"]
		},
		"image/jxr": {
			"source": "iana",
			"extensions": ["jxr"]
		},
		"image/jxra": {
			"source": "iana",
			"extensions": ["jxra"]
		},
		"image/jxrs": {
			"source": "iana",
			"extensions": ["jxrs"]
		},
		"image/jxs": {
			"source": "iana",
			"extensions": ["jxs"]
		},
		"image/jxsc": {
			"source": "iana",
			"extensions": ["jxsc"]
		},
		"image/jxsi": {
			"source": "iana",
			"extensions": ["jxsi"]
		},
		"image/jxss": {
			"source": "iana",
			"extensions": ["jxss"]
		},
		"image/ktx": {
			"source": "iana",
			"extensions": ["ktx"]
		},
		"image/ktx2": {
			"source": "iana",
			"extensions": ["ktx2"]
		},
		"image/naplps": { "source": "iana" },
		"image/pjpeg": { "compressible": false },
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": ["png"]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": ["btif"]
		},
		"image/prs.pti": {
			"source": "iana",
			"extensions": ["pti"]
		},
		"image/pwg-raster": { "source": "iana" },
		"image/sgi": {
			"source": "apache",
			"extensions": ["sgi"]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["svg", "svgz"]
		},
		"image/t38": {
			"source": "iana",
			"extensions": ["t38"]
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": ["tif", "tiff"]
		},
		"image/tiff-fx": {
			"source": "iana",
			"extensions": ["tfx"]
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": ["psd"]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana",
			"extensions": ["azv"]
		},
		"image/vnd.cns.inf2": { "source": "iana" },
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": ["djvu", "djv"]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": ["dwg"]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": ["dxf"]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": ["fbs"]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": ["fpx"]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": ["fst"]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": ["mmr"]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": ["rlc"]
		},
		"image/vnd.globalgraphics.pgb": { "source": "iana" },
		"image/vnd.microsoft.icon": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/vnd.mix": { "source": "iana" },
		"image/vnd.mozilla.apng": { "source": "iana" },
		"image/vnd.ms-dds": {
			"compressible": true,
			"extensions": ["dds"]
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": ["mdi"]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": ["wdp"]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": ["npx"]
		},
		"image/vnd.pco.b16": {
			"source": "iana",
			"extensions": ["b16"]
		},
		"image/vnd.radiance": { "source": "iana" },
		"image/vnd.sealed.png": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
		"image/vnd.svf": { "source": "iana" },
		"image/vnd.tencent.tap": {
			"source": "iana",
			"extensions": ["tap"]
		},
		"image/vnd.valve.source.texture": {
			"source": "iana",
			"extensions": ["vtf"]
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": ["wbmp"]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": ["xif"]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana",
			"extensions": ["pcx"]
		},
		"image/webp": {
			"source": "apache",
			"extensions": ["webp"]
		},
		"image/wmf": {
			"source": "iana",
			"extensions": ["wmf"]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": ["3ds"]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": ["ras"]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": ["cmx"]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": ["jng"]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": ["sid"]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": ["pcx"]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": ["pic", "pct"]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": ["pnm"]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": ["pbm"]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": ["pgm"]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": ["ppm"]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": ["rgb"]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": ["tga"]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": ["xbm"]
		},
		"image/x-xcf": { "compressible": false },
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": ["xpm"]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": ["xwd"]
		},
		"message/cpim": { "source": "iana" },
		"message/delivery-status": { "source": "iana" },
		"message/disposition-notification": {
			"source": "iana",
			"extensions": ["disposition-notification"]
		},
		"message/external-body": { "source": "iana" },
		"message/feedback-report": { "source": "iana" },
		"message/global": {
			"source": "iana",
			"extensions": ["u8msg"]
		},
		"message/global-delivery-status": {
			"source": "iana",
			"extensions": ["u8dsn"]
		},
		"message/global-disposition-notification": {
			"source": "iana",
			"extensions": ["u8mdn"]
		},
		"message/global-headers": {
			"source": "iana",
			"extensions": ["u8hdr"]
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": { "source": "iana" },
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eml", "mime"]
		},
		"message/s-http": { "source": "iana" },
		"message/sip": { "source": "iana" },
		"message/sipfrag": { "source": "iana" },
		"message/tracking-status": { "source": "iana" },
		"message/vnd.si.simp": { "source": "iana" },
		"message/vnd.wfa.wsc": {
			"source": "iana",
			"extensions": ["wsc"]
		},
		"model/3mf": {
			"source": "iana",
			"extensions": ["3mf"]
		},
		"model/e57": { "source": "iana" },
		"model/gltf+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gltf"]
		},
		"model/gltf-binary": {
			"source": "iana",
			"compressible": true,
			"extensions": ["glb"]
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": ["igs", "iges"]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/mtl": {
			"source": "iana",
			"extensions": ["mtl"]
		},
		"model/obj": {
			"source": "iana",
			"extensions": ["obj"]
		},
		"model/step": { "source": "iana" },
		"model/step+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["stpx"]
		},
		"model/step+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpz"]
		},
		"model/step-xml+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpxz"]
		},
		"model/stl": {
			"source": "iana",
			"extensions": ["stl"]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dae"]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": ["dwf"]
		},
		"model/vnd.flatland.3dml": { "source": "iana" },
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": ["gdl"]
		},
		"model/vnd.gs-gdl": { "source": "apache" },
		"model/vnd.gs.gdl": { "source": "iana" },
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": ["gtw"]
		},
		"model/vnd.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": ["mts"]
		},
		"model/vnd.opengex": {
			"source": "iana",
			"extensions": ["ogex"]
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana",
			"extensions": ["x_b"]
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana",
			"extensions": ["x_t"]
		},
		"model/vnd.pytha.pyox": { "source": "iana" },
		"model/vnd.rosette.annotated-data-model": { "source": "iana" },
		"model/vnd.sap.vds": {
			"source": "iana",
			"extensions": ["vds"]
		},
		"model/vnd.usdz+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["usdz"]
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana",
			"extensions": ["bsp"]
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": ["vtu"]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": ["wrl", "vrml"]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3db", "x3dbz"]
		},
		"model/x3d+fastinfoset": {
			"source": "iana",
			"extensions": ["x3db"]
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3dv", "x3dvz"]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["x3d", "x3dz"]
		},
		"model/x3d-vrml": {
			"source": "iana",
			"extensions": ["x3dv"]
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": { "source": "iana" },
		"multipart/byteranges": { "source": "iana" },
		"multipart/digest": { "source": "iana" },
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": { "source": "iana" },
		"multipart/mixed": { "source": "iana" },
		"multipart/multilingual": { "source": "iana" },
		"multipart/parallel": { "source": "iana" },
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": { "source": "iana" },
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/vnd.bint.med-plus": { "source": "iana" },
		"multipart/voice-message": { "source": "iana" },
		"multipart/x-mixed-replace": { "source": "iana" },
		"text/1d-interleaved-parityfec": { "source": "iana" },
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": ["appcache", "manifest"]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": ["ics", "ifb"]
		},
		"text/calender": { "compressible": true },
		"text/cmd": { "compressible": true },
		"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
		"text/cql": { "source": "iana" },
		"text/cql-expression": { "source": "iana" },
		"text/cql-identifier": { "source": "iana" },
		"text/css": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["css"]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csv"]
		},
		"text/csv-schema": { "source": "iana" },
		"text/directory": { "source": "iana" },
		"text/dns": { "source": "iana" },
		"text/ecmascript": { "source": "iana" },
		"text/encaprtp": { "source": "iana" },
		"text/enriched": { "source": "iana" },
		"text/fhirpath": { "source": "iana" },
		"text/flexfec": { "source": "iana" },
		"text/fwdred": { "source": "iana" },
		"text/gff3": { "source": "iana" },
		"text/grammar-ref-list": { "source": "iana" },
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": { "extensions": ["jade"] },
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": { "source": "iana" },
		"text/jsx": {
			"compressible": true,
			"extensions": ["jsx"]
		},
		"text/less": {
			"compressible": true,
			"extensions": ["less"]
		},
		"text/markdown": {
			"source": "iana",
			"compressible": true,
			"extensions": ["markdown", "md"]
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": ["mml"]
		},
		"text/mdx": {
			"compressible": true,
			"extensions": ["mdx"]
		},
		"text/mizar": { "source": "iana" },
		"text/n3": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["n3"]
		},
		"text/parameters": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/parityfec": { "source": "iana" },
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/prs.fallenstein.rst": { "source": "iana" },
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": ["dsc"]
		},
		"text/prs.prop.logic": { "source": "iana" },
		"text/raptorfec": { "source": "iana" },
		"text/red": { "source": "iana" },
		"text/rfc822-headers": { "source": "iana" },
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtx"]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"text/rtp-enc-aescm128": { "source": "iana" },
		"text/rtploopback": { "source": "iana" },
		"text/rtx": { "source": "iana" },
		"text/sgml": {
			"source": "iana",
			"extensions": ["sgml", "sgm"]
		},
		"text/shaclc": { "source": "iana" },
		"text/shex": {
			"source": "iana",
			"extensions": ["shex"]
		},
		"text/slim": { "extensions": ["slim", "slm"] },
		"text/spdx": {
			"source": "iana",
			"extensions": ["spdx"]
		},
		"text/strings": { "source": "iana" },
		"text/stylus": { "extensions": ["stylus", "styl"] },
		"text/t140": { "source": "iana" },
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tsv"]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["ttl"]
		},
		"text/ulpfec": { "source": "iana" },
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vcard"]
		},
		"text/vnd.a": { "source": "iana" },
		"text/vnd.abc": { "source": "iana" },
		"text/vnd.ascii-art": { "source": "iana" },
		"text/vnd.curl": {
			"source": "iana",
			"extensions": ["curl"]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": ["dcurl"]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": ["mcurl"]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": ["scurl"]
		},
		"text/vnd.debian.copyright": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.dmclientscript": { "source": "iana" },
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.familysearch.gedcom": {
			"source": "iana",
			"extensions": ["ged"]
		},
		"text/vnd.ficlab.flt": { "source": "iana" },
		"text/vnd.fly": {
			"source": "iana",
			"extensions": ["fly"]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": ["flx"]
		},
		"text/vnd.gml": { "source": "iana" },
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": ["gv"]
		},
		"text/vnd.hans": { "source": "iana" },
		"text/vnd.hgl": { "source": "iana" },
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": ["3dml"]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": ["spot"]
		},
		"text/vnd.iptc.newsml": { "source": "iana" },
		"text/vnd.iptc.nitf": { "source": "iana" },
		"text/vnd.latex-z": { "source": "iana" },
		"text/vnd.motorola.reflex": { "source": "iana" },
		"text/vnd.ms-mediapackage": { "source": "iana" },
		"text/vnd.net2phone.commcenter.command": { "source": "iana" },
		"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
		"text/vnd.senx.warpscript": { "source": "iana" },
		"text/vnd.si.uricatalogue": { "source": "iana" },
		"text/vnd.sosi": { "source": "iana" },
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["jad"]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.wap.si": { "source": "iana" },
		"text/vnd.wap.sl": { "source": "iana" },
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": ["wml"]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": ["wmls"]
		},
		"text/vtt": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["vtt"]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": ["s", "asm"]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": ["htc"]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": { "compressible": true },
		"text/x-handlebars-template": { "extensions": ["hbs"] },
		"text/x-java-source": {
			"source": "apache",
			"extensions": ["java"]
		},
		"text/x-jquery-tmpl": { "compressible": true },
		"text/x-lua": { "extensions": ["lua"] },
		"text/x-markdown": {
			"compressible": true,
			"extensions": ["mkd"]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": ["nfo"]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": ["opml"]
		},
		"text/x-org": {
			"compressible": true,
			"extensions": ["org"]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": ["p", "pas"]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": ["pde"]
		},
		"text/x-sass": { "extensions": ["sass"] },
		"text/x-scss": { "extensions": ["scss"] },
		"text/x-setext": {
			"source": "apache",
			"extensions": ["etx"]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": ["sfv"]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": ["ymp"]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": ["uu"]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": ["vcs"]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": ["vcf"]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xml"]
		},
		"text/xml-external-parsed-entity": { "source": "iana" },
		"text/yaml": {
			"compressible": true,
			"extensions": ["yaml", "yml"]
		},
		"video/1d-interleaved-parityfec": { "source": "iana" },
		"video/3gpp": {
			"source": "iana",
			"extensions": ["3gp", "3gpp"]
		},
		"video/3gpp-tt": { "source": "iana" },
		"video/3gpp2": {
			"source": "iana",
			"extensions": ["3g2"]
		},
		"video/av1": { "source": "iana" },
		"video/bmpeg": { "source": "iana" },
		"video/bt656": { "source": "iana" },
		"video/celb": { "source": "iana" },
		"video/dv": { "source": "iana" },
		"video/encaprtp": { "source": "iana" },
		"video/ffv1": { "source": "iana" },
		"video/flexfec": { "source": "iana" },
		"video/h261": {
			"source": "iana",
			"extensions": ["h261"]
		},
		"video/h263": {
			"source": "iana",
			"extensions": ["h263"]
		},
		"video/h263-1998": { "source": "iana" },
		"video/h263-2000": { "source": "iana" },
		"video/h264": {
			"source": "iana",
			"extensions": ["h264"]
		},
		"video/h264-rcdo": { "source": "iana" },
		"video/h264-svc": { "source": "iana" },
		"video/h265": { "source": "iana" },
		"video/iso.segment": {
			"source": "iana",
			"extensions": ["m4s"]
		},
		"video/jpeg": {
			"source": "iana",
			"extensions": ["jpgv"]
		},
		"video/jpeg2000": { "source": "iana" },
		"video/jpm": {
			"source": "apache",
			"extensions": ["jpm", "jpgm"]
		},
		"video/jxsv": { "source": "iana" },
		"video/mj2": {
			"source": "iana",
			"extensions": ["mj2", "mjp2"]
		},
		"video/mp1s": { "source": "iana" },
		"video/mp2p": { "source": "iana" },
		"video/mp2t": {
			"source": "iana",
			"extensions": ["ts"]
		},
		"video/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": { "source": "iana" },
		"video/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": { "source": "iana" },
		"video/mpv": { "source": "iana" },
		"video/nv": { "source": "iana" },
		"video/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogv"]
		},
		"video/parityfec": { "source": "iana" },
		"video/pointer": { "source": "iana" },
		"video/quicktime": {
			"source": "iana",
			"compressible": false,
			"extensions": ["qt", "mov"]
		},
		"video/raptorfec": { "source": "iana" },
		"video/raw": { "source": "iana" },
		"video/rtp-enc-aescm128": { "source": "iana" },
		"video/rtploopback": { "source": "iana" },
		"video/rtx": { "source": "iana" },
		"video/scip": { "source": "iana" },
		"video/smpte291": { "source": "iana" },
		"video/smpte292m": { "source": "iana" },
		"video/ulpfec": { "source": "iana" },
		"video/vc1": { "source": "iana" },
		"video/vc2": { "source": "iana" },
		"video/vnd.cctv": { "source": "iana" },
		"video/vnd.dece.hd": {
			"source": "iana",
			"extensions": ["uvh", "uvvh"]
		},
		"video/vnd.dece.mobile": {
			"source": "iana",
			"extensions": ["uvm", "uvvm"]
		},
		"video/vnd.dece.mp4": { "source": "iana" },
		"video/vnd.dece.pd": {
			"source": "iana",
			"extensions": ["uvp", "uvvp"]
		},
		"video/vnd.dece.sd": {
			"source": "iana",
			"extensions": ["uvs", "uvvs"]
		},
		"video/vnd.dece.video": {
			"source": "iana",
			"extensions": ["uvv", "uvvv"]
		},
		"video/vnd.directv.mpeg": { "source": "iana" },
		"video/vnd.directv.mpeg-tts": { "source": "iana" },
		"video/vnd.dlna.mpeg-tts": { "source": "iana" },
		"video/vnd.dvb.file": {
			"source": "iana",
			"extensions": ["dvb"]
		},
		"video/vnd.fvt": {
			"source": "iana",
			"extensions": ["fvt"]
		},
		"video/vnd.hns.video": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.ttsavc": { "source": "iana" },
		"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
		"video/vnd.motorola.video": { "source": "iana" },
		"video/vnd.motorola.videop": { "source": "iana" },
		"video/vnd.mpegurl": {
			"source": "iana",
			"extensions": ["mxu", "m4u"]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "iana",
			"extensions": ["pyv"]
		},
		"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
		"video/vnd.nokia.mp4vr": { "source": "iana" },
		"video/vnd.nokia.videovoip": { "source": "iana" },
		"video/vnd.objectvideo": { "source": "iana" },
		"video/vnd.radgamettools.bink": { "source": "iana" },
		"video/vnd.radgamettools.smacker": { "source": "iana" },
		"video/vnd.sealed.mpeg1": { "source": "iana" },
		"video/vnd.sealed.mpeg4": { "source": "iana" },
		"video/vnd.sealed.swf": { "source": "iana" },
		"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
		"video/vnd.uvvu.mp4": {
			"source": "iana",
			"extensions": ["uvu", "uvvu"]
		},
		"video/vnd.vivo": {
			"source": "iana",
			"extensions": ["viv"]
		},
		"video/vnd.youtube.yt": { "source": "iana" },
		"video/vp8": { "source": "iana" },
		"video/vp9": { "source": "iana" },
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["webm"]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": ["f4v"]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": ["fli"]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["flv"]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": ["m4v"]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": ["mng"]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": ["asf", "asx"]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": ["vob"]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": ["wm"]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["wmv"]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": ["wmx"]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": ["wvx"]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": ["avi"]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": ["movie"]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": ["smv"]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": ["ice"]
		},
		"x-shader/x-fragment": { "compressible": true },
		"x-shader/x-vertex": { "compressible": true }
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module) {
	/*!
	* mime-db
	* Copyright(c) 2014 Jonathan Ong
	* Copyright(c) 2015-2022 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module exports.
	*/
	module.exports = require_db();
} });

//#endregion
//#region ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({ "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
	/**
	* Module dependencies.
	* @private
	*/
	var db = require_mime_db();
	var extname = __require("path").extname;
	/**
	* Module variables.
	* @private
	*/
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	/**
	* Module exports.
	* @public
	*/
	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	/**
	* Get the default charset for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function charset(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var mime$1 = match && db[match[1].toLowerCase()];
		if (mime$1 && mime$1.charset) return mime$1.charset;
		if (match && TEXT_TYPE_REGEXP.test(match[1])) return "UTF-8";
		return false;
	}
	/**
	* Create a full Content-Type header given a MIME type or extension.
	*
	* @param {string} str
	* @return {boolean|string}
	*/
	function contentType(str) {
		if (!str || typeof str !== "string") return false;
		var mime$1 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime$1) return false;
		if (mime$1.indexOf("charset") === -1) {
			var charset$1 = exports.charset(mime$1);
			if (charset$1) mime$1 += "; charset=" + charset$1.toLowerCase();
		}
		return mime$1;
	}
	/**
	* Get the default extension for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function extension(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var exts = match && exports.extensions[match[1].toLowerCase()];
		if (!exts || !exts.length) return false;
		return exts[0];
	}
	/**
	* Lookup the MIME type for a file path/extension.
	*
	* @param {string} path
	* @return {boolean|string}
	*/
	function lookup(path$1) {
		if (!path$1 || typeof path$1 !== "string") return false;
		var extension$1 = extname("x." + path$1).toLowerCase().substr(1);
		if (!extension$1) return false;
		return exports.types[extension$1] || false;
	}
	/**
	* Populate the extensions and types maps.
	* @private
	*/
	function populateMaps(extensions, types) {
		var preference = [
			"nginx",
			"apache",
			void 0,
			"iana"
		];
		Object.keys(db).forEach(function forEachMimeType(type) {
			var mime$1 = db[type];
			var exts = mime$1.extensions;
			if (!exts || !exts.length) return;
			extensions[type] = exts;
			for (var i = 0; i < exts.length; i++) {
				var extension$1 = exts[i];
				if (types[extension$1]) {
					var from = preference.indexOf(db[types[extension$1]].source);
					var to = preference.indexOf(mime$1.source);
					if (types[extension$1] !== "application/octet-stream" && (from > to || from === to && types[extension$1].substr(0, 12) === "application/")) continue;
				}
				types[extension$1] = type;
			}
		});
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module) {
	module.exports = defer$1;
	/**
	* Runs provided function on next iteration of the event loop
	*
	* @param {function} fn - function to run
	*/
	function defer$1(fn) {
		var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
		if (nextTick) nextTick(fn);
		else setTimeout(fn, 0);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module) {
	var defer = require_defer();
	module.exports = async$2;
	/**
	* Runs provided callback asynchronously
	* even if callback itself is not
	*
	* @param   {function} callback - callback to invoke
	* @returns {function} - augmented callback
	*/
	function async$2(callback) {
		var isAsync = false;
		defer(function() {
			isAsync = true;
		});
		return function async_callback(err, result) {
			if (isAsync) callback(err, result);
			else defer(function nextTick_callback() {
				callback(err, result);
			});
		};
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module) {
	module.exports = abort$2;
	/**
	* Aborts leftover active jobs
	*
	* @param {object} state - current state object
	*/
	function abort$2(state$1) {
		Object.keys(state$1.jobs).forEach(clean.bind(state$1));
		state$1.jobs = {};
	}
	/**
	* Cleans up leftover job by invoking abort function for the provided job id
	*
	* @this  state
	* @param {string|number} key - job id to abort
	*/
	function clean(key$1) {
		if (typeof this.jobs[key$1] == "function") this.jobs[key$1]();
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module) {
	var async$1 = require_async(), abort$1 = require_abort();
	module.exports = iterate$2;
	/**
	* Iterates over each job object
	*
	* @param {array|object} list - array or object (named list) to iterate over
	* @param {function} iterator - iterator to run
	* @param {object} state - current job status
	* @param {function} callback - invoked when all elements processed
	*/
	function iterate$2(list, iterator, state$1, callback) {
		var key$1 = state$1["keyedList"] ? state$1["keyedList"][state$1.index] : state$1.index;
		state$1.jobs[key$1] = runJob(iterator, key$1, list[key$1], function(error, output) {
			if (!(key$1 in state$1.jobs)) return;
			delete state$1.jobs[key$1];
			if (error) abort$1(state$1);
			else state$1.results[key$1] = output;
			callback(error, state$1.results);
		});
	}
	/**
	* Runs iterator over provided job element
	*
	* @param   {function} iterator - iterator to invoke
	* @param   {string|number} key - key/index of the element in the list of jobs
	* @param   {mixed} item - job description
	* @param   {function} callback - invoked after iterator is done with the job
	* @returns {function|mixed} - job abort function or something else
	*/
	function runJob(iterator, key$1, item, callback) {
		var aborter;
		if (iterator.length == 2) aborter = iterator(item, async$1(callback));
		else aborter = iterator(item, key$1, async$1(callback));
		return aborter;
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module) {
	module.exports = state;
	/**
	* Creates initial state object
	* for iteration over list
	*
	* @param   {array|object} list - list to iterate over
	* @param   {function|null} sortMethod - function to use for keys sort,
	*                                     or `null` to keep them as is
	* @returns {object} - initial state object
	*/
	function state(list, sortMethod) {
		var isNamedList = !Array.isArray(list), initState$2 = {
			index: 0,
			keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
			jobs: {},
			results: isNamedList ? {} : [],
			size: isNamedList ? Object.keys(list).length : list.length
		};
		if (sortMethod) initState$2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
			return sortMethod(list[a], list[b]);
		});
		return initState$2;
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module) {
	var abort = require_abort(), async = require_async();
	module.exports = terminator$2;
	/**
	* Terminates jobs in the attached state context
	*
	* @this  AsyncKitState#
	* @param {function} callback - final callback to invoke after termination
	*/
	function terminator$2(callback) {
		if (!Object.keys(this.jobs).length) return;
		this.index = this.size;
		abort(this);
		async(callback)(null, this.results);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module) {
	var iterate$1 = require_iterate(), initState$1 = require_state(), terminator$1 = require_terminator();
	module.exports = parallel;
	/**
	* Runs iterator over provided array elements in parallel
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function parallel(list, iterator, callback) {
		var state$1 = initState$1(list);
		while (state$1.index < (state$1["keyedList"] || list).length) {
			iterate$1(list, iterator, state$1, function(error, result) {
				if (error) {
					callback(error, result);
					return;
				}
				if (Object.keys(state$1.jobs).length === 0) {
					callback(null, state$1.results);
					return;
				}
			});
			state$1.index++;
		}
		return terminator$1.bind(state$1, callback);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module) {
	var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
	module.exports = serialOrdered$1;
	module.exports.ascending = ascending;
	module.exports.descending = descending;
	/**
	* Runs iterator over provided sorted array elements in series
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} sortMethod - custom sort function
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function serialOrdered$1(list, iterator, sortMethod, callback) {
		var state$1 = initState(list, sortMethod);
		iterate(list, iterator, state$1, function iteratorHandler(error, result) {
			if (error) {
				callback(error, result);
				return;
			}
			state$1.index++;
			if (state$1.index < (state$1["keyedList"] || list).length) {
				iterate(list, iterator, state$1, iteratorHandler);
				return;
			}
			callback(null, state$1.results);
		});
		return terminator.bind(state$1, callback);
	}
	/**
	* sort helper to sort array elements in ascending order
	*
	* @param   {mixed} a - an item to compare
	* @param   {mixed} b - an item to compare
	* @returns {number} - comparison result
	*/
	function ascending(a, b) {
		return a < b ? -1 : a > b ? 1 : 0;
	}
	/**
	* sort helper to sort array elements in descending order
	*
	* @param   {mixed} a - an item to compare
	* @param   {mixed} b - an item to compare
	* @returns {number} - comparison result
	*/
	function descending(a, b) {
		return -1 * ascending(a, b);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial$1 = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module) {
	var serialOrdered = require_serialOrdered();
	module.exports = serial;
	/**
	* Runs iterator over provided array elements in series
	*
	* @param   {array|object} list - array or object (named list) to iterate over
	* @param   {function} iterator - iterator to run
	* @param   {function} callback - invoked when all elements processed
	* @returns {function} - jobs terminator
	*/
	function serial(list, iterator, callback) {
		return serialOrdered(list, iterator, null, callback);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({ "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module) {
	module.exports = {
		parallel: require_parallel(),
		serial: require_serial$1(),
		serialOrdered: require_serialOrdered()
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({ "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module) {
	/** @type {import('.')} */
	module.exports = Object;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
	/** @type {import('.')} */
	module.exports = Error;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
	/** @type {import('./eval')} */
	module.exports = EvalError;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
	/** @type {import('./range')} */
	module.exports = RangeError;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
	/** @type {import('./type')} */
	module.exports = TypeError;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
	/** @type {import('./uri')} */
	module.exports = URIError;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module) {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module) {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max$1 = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module) {
	/** @type {import('./max')} */
	module.exports = Math.max;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module) {
	/** @type {import('./min')} */
	module.exports = Math.min;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module) {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module) {
	/** @type {import('./round')} */
	module.exports = Math.round;
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module) {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN$1(a) {
		return a !== a;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module) {
	var $isNaN = require_isNaN();
	/** @type {import('./sign')} */
	module.exports = function sign$1(number) {
		if ($isNaN(number) || number === 0) return number;
		return number < 0 ? -1 : 1;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
} });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
	/** @type {import('.')} */
	var $gOPD$1 = require_gOPD();
	if ($gOPD$1) try {
		$gOPD$1([], "length");
	} catch (e) {
		$gOPD$1 = null;
	}
	module.exports = $gOPD$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({ "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
	/** @type {import('.')} */
	var $defineProperty$2 = Object.defineProperty || false;
	if ($defineProperty$2) try {
		$defineProperty$2({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty$2 = false;
	}
	module.exports = $defineProperty$2;
} });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams$1 = __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module) {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols$2() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module) {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams$1();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
} });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
	var $Object$2 = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object$2.getPrototypeOf || null;
} });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max$1 = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty$1(a, b) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j = 0; j < b.length; j += 1) arr[j + a.length] = b[j];
		return arr;
	};
	var slicy = function slicy$1(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) arr[j] = arrLike[i];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind$6(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max$1(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty$1() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
} });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
} });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
} });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
} });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
	var bind$4 = require_function_bind();
	var $apply$1 = require_functionApply();
	var $call$2 = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind$4.call($call$2, $apply$1);
} });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
	var bind$3 = require_function_bind();
	var $TypeError$2 = require_type();
	var $call$1 = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError$2("a function is required");
		return $actualApply(bind$3, $call$1, args);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({ "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module) {
	var callBind = require_call_bind_apply_helpers();
	var gOPD = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
	var $Object$1 = Object;
	var $getPrototypeOf = $Object$1.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object$1(value));
	} : false;
} });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module) {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto$1(O) {
		return reflectGetProto(O);
	} : originalGetProto ? function getProto$1(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O);
	} : getDunderProto ? function getProto$1(O) {
		return getDunderProto(O);
	} : null;
} });

//#endregion
//#region ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({ "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind$2 = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind$2.call(call, $hasOwn);
} });

//#endregion
//#region ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({ "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module) {
	var undefined$1;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError$1 = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor = require_floor();
	var max = require_max$1();
	var min = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty$1 = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError$1();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols$1 = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols$1 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		"%AsyncFromSyncIteratorPrototype%": undefined$1,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols$1 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		"%JSON%": typeof JSON === "object" ? JSON : undefined$1,
		"%Map%": typeof Map === "undefined" ? undefined$1 : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined$1 : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols$1 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
		"%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError$1,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty$1,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor,
		"%Math.max%": max,
		"%Math.min%": min,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto) try {
		null.error;
	} catch (e) {
		var errorProto = getProto(getProto(e));
		INTRINSICS["%Error.prototype%"] = errorProto;
	}
	var doEval = function doEval$1(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval$1("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval$1("%AsyncGenerator%");
			if (gen && getProto) value = getProto(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind$1 = require_function_bind();
	var hasOwn$1 = require_hasown();
	var $concat = bind$1.call($call, Array.prototype.concat);
	var $spliceApply = bind$1.call($apply, Array.prototype.splice);
	var $replace = bind$1.call($call, String.prototype.replace);
	var $strSlice = bind$1.call($call, String.prototype.slice);
	var $exec = bind$1.call($call, RegExp.prototype.exec);
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath$1(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string, rePropName, function(match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic$1(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn$1(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic$1(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError$1("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError$1("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn$1(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
					return void 0;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc$1 = $gOPD(value, part);
					isOwn = !!desc$1;
					if (isOwn && "get" in desc$1 && !("originalValue" in desc$1.get)) value = desc$1.get;
					else value = value[part];
				} else {
					isOwn = hasOwn$1(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams = __commonJS({ "../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
	var hasSymbols = require_shams$1();
	/** @type {import('.')} */
	module.exports = function hasToStringTagShams() {
		return hasSymbols() && !!Symbol.toStringTag;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({ "../../node_modules/.pnpm/es-set-tostringtag@2.1.0/node_modules/es-set-tostringtag/index.js"(exports, module) {
	var GetIntrinsic = require_get_intrinsic();
	var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
	var hasToStringTag = require_shams()();
	var hasOwn = require_hasown();
	var $TypeError = require_type();
	var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
	/** @type {import('.')} */
	module.exports = function setToStringTag$1(object, value) {
		var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
		var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
		if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
		if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) if ($defineProperty) $defineProperty(object, toStringTag, {
			configurable: !nonConfigurable,
			enumerable: false,
			value,
			writable: false
		});
		else object[toStringTag] = value;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({ "../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/populate.js"(exports, module) {
	module.exports = function(dst, src) {
		Object.keys(src).forEach(function(prop) {
			dst[prop] = dst[prop] || src[prop];
		});
		return dst;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({ "../../node_modules/.pnpm/form-data@4.0.2/node_modules/form-data/lib/form_data.js"(exports, module) {
	var CombinedStream = require_combined_stream();
	var util = __require("util");
	var path = __require("path");
	var http = __require("http");
	var https = __require("https");
	var parseUrl = __require("url").parse;
	var fs = __require("fs");
	var Stream = __require("stream").Stream;
	var mime = require_mime_types();
	var asynckit = require_asynckit();
	var setToStringTag = require_es_set_tostringtag();
	var populate = require_populate();
	module.exports = FormData$1;
	util.inherits(FormData$1, CombinedStream);
	/**
	* Create readable "multipart/form-data" streams.
	* Can be used to submit forms
	* and file uploads to other web applications.
	*
	* @constructor
	* @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	*/
	function FormData$1(options) {
		if (!(this instanceof FormData$1)) return new FormData$1(options);
		this._overheadLength = 0;
		this._valueLength = 0;
		this._valuesToMeasure = [];
		CombinedStream.call(this);
		options = options || {};
		for (var option in options) this[option] = options[option];
	}
	FormData$1.LINE_BREAK = "\r\n";
	FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
	FormData$1.prototype.append = function(field, value, options) {
		options = options || {};
		if (typeof options == "string") options = { filename: options };
		var append = CombinedStream.prototype.append.bind(this);
		if (typeof value == "number") value = "" + value;
		if (Array.isArray(value)) {
			this._error(new Error("Arrays are not supported."));
			return;
		}
		var header = this._multiPartHeader(field, value, options);
		var footer = this._multiPartFooter();
		append(header);
		append(value);
		append(footer);
		this._trackLength(header, value, options);
	};
	FormData$1.prototype._trackLength = function(header, value, options) {
		var valueLength = 0;
		if (options.knownLength != null) valueLength += +options.knownLength;
		else if (Buffer.isBuffer(value)) valueLength = value.length;
		else if (typeof value === "string") valueLength = Buffer.byteLength(value);
		this._valueLength += valueLength;
		this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
		if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) return;
		if (!options.knownLength) this._valuesToMeasure.push(value);
	};
	FormData$1.prototype._lengthRetriever = function(value, callback) {
		if (Object.prototype.hasOwnProperty.call(value, "fd")) if (value.end != void 0 && value.end != Infinity && value.start != void 0) callback(null, value.end + 1 - (value.start ? value.start : 0));
		else fs.stat(value.path, function(err, stat) {
			var fileSize;
			if (err) {
				callback(err);
				return;
			}
			fileSize = stat.size - (value.start ? value.start : 0);
			callback(null, fileSize);
		});
		else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) callback(null, +value.headers["content-length"]);
		else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
			value.on("response", function(response) {
				value.pause();
				callback(null, +response.headers["content-length"]);
			});
			value.resume();
		} else callback("Unknown stream");
	};
	FormData$1.prototype._multiPartHeader = function(field, value, options) {
		if (typeof options.header == "string") return options.header;
		var contentDisposition = this._getContentDisposition(value, options);
		var contentType$1 = this._getContentType(value, options);
		var contents = "";
		var headers = {
			"Content-Disposition": ["form-data", "name=\"" + field + "\""].concat(contentDisposition || []),
			"Content-Type": [].concat(contentType$1 || [])
		};
		if (typeof options.header == "object") populate(headers, options.header);
		var header;
		for (var prop in headers) if (Object.prototype.hasOwnProperty.call(headers, prop)) {
			header = headers[prop];
			if (header == null) continue;
			if (!Array.isArray(header)) header = [header];
			if (header.length) contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
		}
		return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
	};
	FormData$1.prototype._getContentDisposition = function(value, options) {
		var filename, contentDisposition;
		if (typeof options.filepath === "string") filename = path.normalize(options.filepath).replace(/\\/g, "/");
		else if (options.filename || value.name || value.path) filename = path.basename(options.filename || value.name || value.path);
		else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) filename = path.basename(value.client._httpMessage.path || "");
		if (filename) contentDisposition = "filename=\"" + filename + "\"";
		return contentDisposition;
	};
	FormData$1.prototype._getContentType = function(value, options) {
		var contentType$1 = options.contentType;
		if (!contentType$1 && value.name) contentType$1 = mime.lookup(value.name);
		if (!contentType$1 && value.path) contentType$1 = mime.lookup(value.path);
		if (!contentType$1 && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) contentType$1 = value.headers["content-type"];
		if (!contentType$1 && (options.filepath || options.filename)) contentType$1 = mime.lookup(options.filepath || options.filename);
		if (!contentType$1 && typeof value == "object") contentType$1 = FormData$1.DEFAULT_CONTENT_TYPE;
		return contentType$1;
	};
	FormData$1.prototype._multiPartFooter = function() {
		return function(next) {
			var footer = FormData$1.LINE_BREAK;
			var lastPart = this._streams.length === 0;
			if (lastPart) footer += this._lastBoundary();
			next(footer);
		}.bind(this);
	};
	FormData$1.prototype._lastBoundary = function() {
		return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
	};
	FormData$1.prototype.getHeaders = function(userHeaders) {
		var header;
		var formHeaders = { "content-type": "multipart/form-data; boundary=" + this.getBoundary() };
		for (header in userHeaders) if (Object.prototype.hasOwnProperty.call(userHeaders, header)) formHeaders[header.toLowerCase()] = userHeaders[header];
		return formHeaders;
	};
	FormData$1.prototype.setBoundary = function(boundary) {
		this._boundary = boundary;
	};
	FormData$1.prototype.getBoundary = function() {
		if (!this._boundary) this._generateBoundary();
		return this._boundary;
	};
	FormData$1.prototype.getBuffer = function() {
		var dataBuffer = new Buffer.alloc(0);
		var boundary = this.getBoundary();
		for (var i = 0, len = this._streams.length; i < len; i++) if (typeof this._streams[i] !== "function") {
			if (Buffer.isBuffer(this._streams[i])) dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
			else dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
			if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
		}
		return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
	};
	FormData$1.prototype._generateBoundary = function() {
		var boundary = "--------------------------";
		for (var i = 0; i < 24; i++) boundary += Math.floor(Math.random() * 10).toString(16);
		this._boundary = boundary;
	};
	FormData$1.prototype.getLengthSync = function() {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) knownLength += this._lastBoundary().length;
		if (!this.hasKnownLength()) this._error(new Error("Cannot calculate proper length in synchronous way."));
		return knownLength;
	};
	FormData$1.prototype.hasKnownLength = function() {
		var hasKnownLength = true;
		if (this._valuesToMeasure.length) hasKnownLength = false;
		return hasKnownLength;
	};
	FormData$1.prototype.getLength = function(cb) {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) knownLength += this._lastBoundary().length;
		if (!this._valuesToMeasure.length) {
			process.nextTick(cb.bind(this, null, knownLength));
			return;
		}
		asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
			if (err) {
				cb(err);
				return;
			}
			values.forEach(function(length) {
				knownLength += length;
			});
			cb(null, knownLength);
		});
	};
	FormData$1.prototype.submit = function(params, cb) {
		var request, options, defaults$4 = { method: "post" };
		if (typeof params == "string") {
			params = parseUrl(params);
			options = populate({
				port: params.port,
				path: params.pathname,
				host: params.hostname,
				protocol: params.protocol
			}, defaults$4);
		} else {
			options = populate(params, defaults$4);
			if (!options.port) options.port = options.protocol == "https:" ? 443 : 80;
		}
		options.headers = this.getHeaders(params.headers);
		if (options.protocol == "https:") request = https.request(options);
		else request = http.request(options);
		this.getLength(function(err, length) {
			if (err && err !== "Unknown stream") {
				this._error(err);
				return;
			}
			if (length) request.setHeader("Content-Length", length);
			this.pipe(request);
			if (cb) {
				var onResponse;
				var callback = function(error, responce) {
					request.removeListener("error", callback);
					request.removeListener("response", onResponse);
					return cb.call(this, error, responce);
				};
				onResponse = callback.bind(this, null);
				request.on("error", callback);
				request.on("response", onResponse);
			}
		}.bind(this));
		return request;
	};
	FormData$1.prototype._error = function(err) {
		if (!this.error) {
			this.error = err;
			this.pause();
			this.emit("error", err);
		}
	};
	FormData$1.prototype.toString = function() {
		return "[object FormData]";
	};
	setToStringTag(FormData$1, "FormData");
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/env/FormData.js
var require_FormData = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/env/FormData.js"(exports, module) {
	module.exports = require_form_data();
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/index.js"(exports, module) {
	var utils$6 = require_utils();
	var normalizeHeaderName = require_normalizeHeaderName();
	var AxiosError$1 = require_AxiosError();
	var transitionalDefaults = require_transitional();
	var toFormData = require_toFormData();
	var DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
	function setContentTypeIfUnset(headers, value) {
		if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) headers["Content-Type"] = value;
	}
	function getDefaultAdapter() {
		var adapter;
		if (typeof XMLHttpRequest !== "undefined") adapter = require_xhr();
		else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") adapter = require_http();
		return adapter;
	}
	function stringifySafely(rawValue, parser, encoder) {
		if (utils$6.isString(rawValue)) try {
			(parser || JSON.parse)(rawValue);
			return utils$6.trim(rawValue);
		} catch (e) {
			if (e.name !== "SyntaxError") throw e;
		}
		return (encoder || JSON.stringify)(rawValue);
	}
	var defaults$3 = {
		transitional: transitionalDefaults,
		adapter: getDefaultAdapter(),
		transformRequest: [function transformRequest(data, headers) {
			normalizeHeaderName(headers, "Accept");
			normalizeHeaderName(headers, "Content-Type");
			if (utils$6.isFormData(data) || utils$6.isArrayBuffer(data) || utils$6.isBuffer(data) || utils$6.isStream(data) || utils$6.isFile(data) || utils$6.isBlob(data)) return data;
			if (utils$6.isArrayBufferView(data)) return data.buffer;
			if (utils$6.isURLSearchParams(data)) {
				setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
				return data.toString();
			}
			var isObjectPayload = utils$6.isObject(data);
			var contentType$1 = headers && headers["Content-Type"];
			var isFileList$1;
			if ((isFileList$1 = utils$6.isFileList(data)) || isObjectPayload && contentType$1 === "multipart/form-data") {
				var _FormData = this.env && this.env.FormData;
				return toFormData(isFileList$1 ? { "files[]": data } : data, _FormData && new _FormData());
			} else if (isObjectPayload || contentType$1 === "application/json") {
				setContentTypeIfUnset(headers, "application/json");
				return stringifySafely(data);
			}
			return data;
		}],
		transformResponse: [function transformResponse(data) {
			var transitional = this.transitional || defaults$3.transitional;
			var silentJSONParsing = transitional && transitional.silentJSONParsing;
			var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
			var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
			if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data) && data.length) try {
				return JSON.parse(data);
			} catch (e) {
				if (strictJSONParsing) {
					if (e.name === "SyntaxError") throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
					throw e;
				}
			}
			return data;
		}],
		timeout: 0,
		xsrfCookieName: "XSRF-TOKEN",
		xsrfHeaderName: "X-XSRF-TOKEN",
		maxContentLength: -1,
		maxBodyLength: -1,
		env: { FormData: require_FormData() },
		validateStatus: function validateStatus(status) {
			return status >= 200 && status < 300;
		},
		headers: { common: { "Accept": "application/json, text/plain, */*" } }
	};
	utils$6.forEach([
		"delete",
		"get",
		"head"
	], function forEachMethodNoData(method) {
		defaults$3.headers[method] = {};
	});
	utils$6.forEach([
		"post",
		"put",
		"patch"
	], function forEachMethodWithData(method) {
		defaults$3.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
	});
	module.exports = defaults$3;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/transformData.js"(exports, module) {
	var utils$5 = require_utils();
	var defaults$2 = require_defaults();
	/**
	* Transform the data for a request or a response
	*
	* @param {Object|String} data The data to be transformed
	* @param {Array} headers The headers for the request or response
	* @param {Array|Function} fns A single function or Array of functions
	* @returns {*} The resulting transformed data
	*/
	module.exports = function transformData$1(data, headers, fns) {
		var context = this || defaults$2;
		utils$5.forEach(fns, function transform(fn) {
			data = fn.call(context, data, headers);
		});
		return data;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
	module.exports = function isCancel$1(value) {
		return !!(value && value.__CANCEL__);
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
	var utils$4 = require_utils();
	var transformData = require_transformData();
	var isCancel = require_isCancel();
	var defaults$1 = require_defaults();
	var CanceledError$1 = require_CanceledError();
	/**
	* Throws a `CanceledError` if cancellation has been requested.
	*/
	function throwIfCancellationRequested(config) {
		if (config.cancelToken) config.cancelToken.throwIfRequested();
		if (config.signal && config.signal.aborted) throw new CanceledError$1();
	}
	/**
	* Dispatch a request to the server using the configured adapter.
	*
	* @param {object} config The config that is to be used for the request
	* @returns {Promise} The Promise to be fulfilled
	*/
	module.exports = function dispatchRequest$1(config) {
		throwIfCancellationRequested(config);
		config.headers = config.headers || {};
		config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
		config.headers = utils$4.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
		utils$4.forEach([
			"delete",
			"get",
			"head",
			"post",
			"put",
			"patch",
			"common"
		], function cleanHeaderConfig(method) {
			delete config.headers[method];
		});
		var adapter = config.adapter || defaults$1.adapter;
		return adapter(config).then(function onAdapterResolution(response) {
			throwIfCancellationRequested(config);
			response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
			return response;
		}, function onAdapterRejection(reason) {
			if (!isCancel(reason)) {
				throwIfCancellationRequested(config);
				if (reason && reason.response) reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
			}
			return Promise.reject(reason);
		});
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
	var utils$3 = require_utils();
	/**
	* Config-specific merge-function which creates a new config-object
	* by merging two configuration objects together.
	*
	* @param {Object} config1
	* @param {Object} config2
	* @returns {Object} New object resulting from merging config2 to config1
	*/
	module.exports = function mergeConfig$2(config1, config2) {
		config2 = config2 || {};
		var config = {};
		function getMergedValue(target, source) {
			if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) return utils$3.merge(target, source);
			else if (utils$3.isPlainObject(source)) return utils$3.merge({}, source);
			else if (utils$3.isArray(source)) return source.slice();
			return source;
		}
		function mergeDeepProperties(prop) {
			if (!utils$3.isUndefined(config2[prop])) return getMergedValue(config1[prop], config2[prop]);
			else if (!utils$3.isUndefined(config1[prop])) return getMergedValue(void 0, config1[prop]);
		}
		function valueFromConfig2(prop) {
			if (!utils$3.isUndefined(config2[prop])) return getMergedValue(void 0, config2[prop]);
		}
		function defaultToConfig2(prop) {
			if (!utils$3.isUndefined(config2[prop])) return getMergedValue(void 0, config2[prop]);
			else if (!utils$3.isUndefined(config1[prop])) return getMergedValue(void 0, config1[prop]);
		}
		function mergeDirectKeys(prop) {
			if (prop in config2) return getMergedValue(config1[prop], config2[prop]);
			else if (prop in config1) return getMergedValue(void 0, config1[prop]);
		}
		var mergeMap = {
			"url": valueFromConfig2,
			"method": valueFromConfig2,
			"data": valueFromConfig2,
			"baseURL": defaultToConfig2,
			"transformRequest": defaultToConfig2,
			"transformResponse": defaultToConfig2,
			"paramsSerializer": defaultToConfig2,
			"timeout": defaultToConfig2,
			"timeoutMessage": defaultToConfig2,
			"withCredentials": defaultToConfig2,
			"adapter": defaultToConfig2,
			"responseType": defaultToConfig2,
			"xsrfCookieName": defaultToConfig2,
			"xsrfHeaderName": defaultToConfig2,
			"onUploadProgress": defaultToConfig2,
			"onDownloadProgress": defaultToConfig2,
			"decompress": defaultToConfig2,
			"maxContentLength": defaultToConfig2,
			"maxBodyLength": defaultToConfig2,
			"beforeRedirect": defaultToConfig2,
			"transport": defaultToConfig2,
			"httpAgent": defaultToConfig2,
			"httpsAgent": defaultToConfig2,
			"cancelToken": defaultToConfig2,
			"socketPath": defaultToConfig2,
			"responseEncoding": defaultToConfig2,
			"validateStatus": mergeDirectKeys
		};
		utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
			var merge$1 = mergeMap[prop] || mergeDeepProperties;
			var configValue = merge$1(prop);
			utils$3.isUndefined(configValue) && merge$1 !== mergeDirectKeys || (config[prop] = configValue);
		});
		return config;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/validator.js"(exports, module) {
	var VERSION = require_data().version;
	var AxiosError = require_AxiosError();
	var validators$1 = {};
	[
		"object",
		"boolean",
		"number",
		"function",
		"string",
		"symbol"
	].forEach(function(type, i) {
		validators$1[type] = function validator$1(thing) {
			return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
		};
	});
	var deprecatedWarnings = {};
	/**
	* Transitional option validator
	* @param {function|boolean?} validator - set to false if the transitional option has been removed
	* @param {string?} version - deprecated version / removed since version
	* @param {string?} message - some message with additional info
	* @returns {function}
	*/
	validators$1.transitional = function transitional(validator$1, version$1, message) {
		function formatMessage(opt, desc$1) {
			return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc$1 + (message ? ". " + message : "");
		}
		return function(value, opt, opts) {
			if (validator$1 === false) throw new AxiosError(formatMessage(opt, " has been removed" + (version$1 ? " in " + version$1 : "")), AxiosError.ERR_DEPRECATED);
			if (version$1 && !deprecatedWarnings[opt]) {
				deprecatedWarnings[opt] = true;
				console.warn(formatMessage(opt, " has been deprecated since v" + version$1 + " and will be removed in the near future"));
			}
			return validator$1 ? validator$1(value, opt, opts) : true;
		};
	};
	/**
	* Assert object's properties type
	* @param {object} options
	* @param {object} schema
	* @param {boolean?} allowUnknown
	*/
	function assertOptions(options, schema, allowUnknown) {
		if (typeof options !== "object") throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
		var keys = Object.keys(options);
		var i = keys.length;
		while (i-- > 0) {
			var opt = keys[i];
			var validator$1 = schema[opt];
			if (validator$1) {
				var value = options[opt];
				var result = value === void 0 || validator$1(value, opt, options);
				if (result !== true) throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
				continue;
			}
			if (allowUnknown !== true) throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
		}
	}
	module.exports = {
		assertOptions,
		validators: validators$1
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/Axios.js"(exports, module) {
	var utils$2 = require_utils();
	var buildURL = require_buildURL();
	var InterceptorManager = require_InterceptorManager();
	var dispatchRequest = require_dispatchRequest();
	var mergeConfig$1 = require_mergeConfig();
	var buildFullPath = require_buildFullPath();
	var validator = require_validator();
	var validators = validator.validators;
	/**
	* Create a new instance of Axios
	*
	* @param {Object} instanceConfig The default config for the instance
	*/
	function Axios$1(instanceConfig) {
		this.defaults = instanceConfig;
		this.interceptors = {
			request: new InterceptorManager(),
			response: new InterceptorManager()
		};
	}
	/**
	* Dispatch a request
	*
	* @param {Object} config The config specific for this request (merged with this.defaults)
	*/
	Axios$1.prototype.request = function request(configOrUrl, config) {
		if (typeof configOrUrl === "string") {
			config = config || {};
			config.url = configOrUrl;
		} else config = configOrUrl || {};
		config = mergeConfig$1(this.defaults, config);
		if (config.method) config.method = config.method.toLowerCase();
		else if (this.defaults.method) config.method = this.defaults.method.toLowerCase();
		else config.method = "get";
		var transitional = config.transitional;
		if (transitional !== void 0) validator.assertOptions(transitional, {
			silentJSONParsing: validators.transitional(validators.boolean),
			forcedJSONParsing: validators.transitional(validators.boolean),
			clarifyTimeoutError: validators.transitional(validators.boolean)
		}, false);
		var requestInterceptorChain = [];
		var synchronousRequestInterceptors = true;
		this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
			if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
			synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
			requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
		});
		var responseInterceptorChain = [];
		this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
			responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
		});
		var promise;
		if (!synchronousRequestInterceptors) {
			var chain = [dispatchRequest, void 0];
			Array.prototype.unshift.apply(chain, requestInterceptorChain);
			chain = chain.concat(responseInterceptorChain);
			promise = Promise.resolve(config);
			while (chain.length) promise = promise.then(chain.shift(), chain.shift());
			return promise;
		}
		var newConfig = config;
		while (requestInterceptorChain.length) {
			var onFulfilled = requestInterceptorChain.shift();
			var onRejected = requestInterceptorChain.shift();
			try {
				newConfig = onFulfilled(newConfig);
			} catch (error) {
				onRejected(error);
				break;
			}
		}
		try {
			promise = dispatchRequest(newConfig);
		} catch (error) {
			return Promise.reject(error);
		}
		while (responseInterceptorChain.length) promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
		return promise;
	};
	Axios$1.prototype.getUri = function getUri(config) {
		config = mergeConfig$1(this.defaults, config);
		var fullPath = buildFullPath(config.baseURL, config.url);
		return buildURL(fullPath, config.params, config.paramsSerializer);
	};
	utils$2.forEach([
		"delete",
		"get",
		"head",
		"options"
	], function forEachMethodNoData(method) {
		Axios$1.prototype[method] = function(url$2, config) {
			return this.request(mergeConfig$1(config || {}, {
				method,
				url: url$2,
				data: (config || {}).data
			}));
		};
	});
	utils$2.forEach([
		"post",
		"put",
		"patch"
	], function forEachMethodWithData(method) {
		function generateHTTPMethod(isForm) {
			return function httpMethod(url$2, data, config) {
				return this.request(mergeConfig$1(config || {}, {
					method,
					headers: isForm ? { "Content-Type": "multipart/form-data" } : {},
					url: url$2,
					data
				}));
			};
		}
		Axios$1.prototype[method] = generateHTTPMethod();
		Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
	});
	module.exports = Axios$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
	var CanceledError = require_CanceledError();
	/**
	* A `CancelToken` is an object that can be used to request cancellation of an operation.
	*
	* @class
	* @param {Function} executor The executor function.
	*/
	function CancelToken(executor) {
		if (typeof executor !== "function") throw new TypeError("executor must be a function.");
		var resolvePromise;
		this.promise = new Promise(function promiseExecutor(resolve) {
			resolvePromise = resolve;
		});
		var token = this;
		this.promise.then(function(cancel) {
			if (!token._listeners) return;
			var i;
			var l = token._listeners.length;
			for (i = 0; i < l; i++) token._listeners[i](cancel);
			token._listeners = null;
		});
		this.promise.then = function(onfulfilled) {
			var _resolve;
			var promise = new Promise(function(resolve) {
				token.subscribe(resolve);
				_resolve = resolve;
			}).then(onfulfilled);
			promise.cancel = function reject() {
				token.unsubscribe(_resolve);
			};
			return promise;
		};
		executor(function cancel(message) {
			if (token.reason) return;
			token.reason = new CanceledError(message);
			resolvePromise(token.reason);
		});
	}
	/**
	* Throws a `CanceledError` if cancellation has been requested.
	*/
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
		if (this.reason) throw this.reason;
	};
	/**
	* Subscribe to the cancel signal
	*/
	CancelToken.prototype.subscribe = function subscribe(listener) {
		if (this.reason) {
			listener(this.reason);
			return;
		}
		if (this._listeners) this._listeners.push(listener);
		else this._listeners = [listener];
	};
	/**
	* Unsubscribe from the cancel signal
	*/
	CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
		if (!this._listeners) return;
		var index = this._listeners.indexOf(listener);
		if (index !== -1) this._listeners.splice(index, 1);
	};
	/**
	* Returns an object that contains a new `CancelToken` and a function that, when called,
	* cancels the `CancelToken`.
	*/
	CancelToken.source = function source() {
		var cancel;
		var token = new CancelToken(function executor(c) {
			cancel = c;
		});
		return {
			token,
			cancel
		};
	};
	module.exports = CancelToken;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/spread.js"(exports, module) {
	/**
	* Syntactic sugar for invoking a function and expanding an array for arguments.
	*
	* Common use case would be to use `Function.prototype.apply`.
	*
	*  ```js
	*  function f(x, y, z) {}
	*  var args = [1, 2, 3];
	*  f.apply(null, args);
	*  ```
	*
	* With `spread` this example can be re-written.
	*
	*  ```js
	*  spread(function(x, y, z) {})([1, 2, 3]);
	*  ```
	*
	* @param {Function} callback
	* @returns {Function}
	*/
	module.exports = function spread(callback) {
		return function wrap$2(arr) {
			return callback.apply(null, arr);
		};
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
	var utils$1 = require_utils();
	/**
	* Determines whether the payload is an error thrown by Axios
	*
	* @param {*} payload The value to test
	* @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	*/
	module.exports = function isAxiosError(payload) {
		return utils$1.isObject(payload) && payload.isAxiosError === true;
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/axios.js
var require_axios$1 = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/axios.js"(exports, module) {
	var utils = require_utils();
	var bind = require_bind();
	var Axios = require_Axios();
	var mergeConfig = require_mergeConfig();
	var defaults = require_defaults();
	/**
	* Create an instance of Axios
	*
	* @param {Object} defaultConfig The default config for the instance
	* @return {Axios} A new instance of Axios
	*/
	function createInstance(defaultConfig) {
		var context = new Axios(defaultConfig);
		var instance = bind(Axios.prototype.request, context);
		utils.extend(instance, Axios.prototype, context);
		utils.extend(instance, context);
		instance.create = function create(instanceConfig) {
			return createInstance(mergeConfig(defaultConfig, instanceConfig));
		};
		return instance;
	}
	var axios = createInstance(defaults);
	axios.Axios = Axios;
	axios.CanceledError = require_CanceledError();
	axios.CancelToken = require_CancelToken();
	axios.isCancel = require_isCancel();
	axios.VERSION = require_data().version;
	axios.toFormData = require_toFormData();
	axios.AxiosError = require_AxiosError();
	axios.Cancel = axios.CanceledError;
	axios.all = function all(promises) {
		return Promise.all(promises);
	};
	axios.spread = require_spread();
	axios.isAxiosError = require_isAxiosError();
	module.exports = axios;
	module.exports.default = axios;
} });

//#endregion
//#region ../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/index.js
var require_axios = __commonJS({ "../../node_modules/.pnpm/axios@0.27.2/node_modules/axios/index.js"(exports, module) {
	module.exports = require_axios$1();
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/api_client/api.js
var require_api = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/api_client/api.js"(exports) {
	var __importDefault$5 = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Api = void 0;
	const axios_1 = __importDefault$5(require_axios());
	var Api = class {
		constructor(opts) {
			this.config = this.mergeDefaults(opts);
		}
		mergeDefaults(opts) {
			if (!opts.kwilProvider) throw new Error("No Kwil provider URL provided in configuration");
			return {
				kwilProvider: opts.kwilProvider,
				timeout: opts.timeout || 1e4,
				logging: opts.logging || false,
				logger: opts.logger || console.log,
				cache: opts.cache || 10 * 60
			};
		}
		async get(endpoint, config) {
			try {
				return await this.request().get(endpoint, config);
			} catch (error) {
				if (error.response && error.response.status) return error.response;
				throw error;
			}
		}
		async post(endpoint, body, config) {
			try {
				return await this.request().post(endpoint, body, config);
			} catch (error) {
				if (error.response && error.response.status) return error.response;
				throw error;
			}
		}
		/**
		* Get an AxiosInstance with the base configuration setup to fire off
		* a request to the network.
		*/
		request() {
			let headers = {};
			if (this.cookie) headers.Cookie = this.cookie;
			let instance = axios_1.default.create({
				baseURL: this.config.kwilProvider,
				timeout: this.config.timeout,
				maxContentLength: 1024 * 1024 * 512,
				withCredentials: true,
				headers
			});
			if (this.config.logging) {
				instance.interceptors.request.use((request) => {
					this.config.logger(`Requesting: ${request.baseURL}${request.url}`);
					return request;
				});
				instance.interceptors.response.use((response) => {
					this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
					return response;
				});
			}
			return instance;
		}
	};
	exports.Api = Api;
} });

//#endregion
//#region ../../node_modules/.pnpm/long@5.3.0/node_modules/long/umd/index.js
var require_umd = __commonJS({ "../../node_modules/.pnpm/long@5.3.0/node_modules/long/umd/index.js"(exports, module) {
	var Long = function(exports$1) {
		"use strict";
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.default = void 0;
		/**
		* @license
		* Copyright 2009 The Closure Library Authors
		* Copyright 2020 Daniel Wirtz / The long.js Authors.
		*
		* Licensed under the Apache License, Version 2.0 (the "License");
		* you may not use this file except in compliance with the License.
		* You may obtain a copy of the License at
		*
		*     http://www.apache.org/licenses/LICENSE-2.0
		*
		* Unless required by applicable law or agreed to in writing, software
		* distributed under the License is distributed on an "AS IS" BASIS,
		* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		* See the License for the specific language governing permissions and
		* limitations under the License.
		*
		* SPDX-License-Identifier: Apache-2.0
		*/
		var wasm = null;
		try {
			wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
				0,
				97,
				115,
				109,
				1,
				0,
				0,
				0,
				1,
				13,
				2,
				96,
				0,
				1,
				127,
				96,
				4,
				127,
				127,
				127,
				127,
				1,
				127,
				3,
				7,
				6,
				0,
				1,
				1,
				1,
				1,
				1,
				6,
				6,
				1,
				127,
				1,
				65,
				0,
				11,
				7,
				50,
				6,
				3,
				109,
				117,
				108,
				0,
				1,
				5,
				100,
				105,
				118,
				95,
				115,
				0,
				2,
				5,
				100,
				105,
				118,
				95,
				117,
				0,
				3,
				5,
				114,
				101,
				109,
				95,
				115,
				0,
				4,
				5,
				114,
				101,
				109,
				95,
				117,
				0,
				5,
				8,
				103,
				101,
				116,
				95,
				104,
				105,
				103,
				104,
				0,
				0,
				10,
				191,
				1,
				6,
				4,
				0,
				35,
				0,
				11,
				36,
				1,
				1,
				126,
				32,
				0,
				173,
				32,
				1,
				173,
				66,
				32,
				134,
				132,
				32,
				2,
				173,
				32,
				3,
				173,
				66,
				32,
				134,
				132,
				126,
				34,
				4,
				66,
				32,
				135,
				167,
				36,
				0,
				32,
				4,
				167,
				11,
				36,
				1,
				1,
				126,
				32,
				0,
				173,
				32,
				1,
				173,
				66,
				32,
				134,
				132,
				32,
				2,
				173,
				32,
				3,
				173,
				66,
				32,
				134,
				132,
				127,
				34,
				4,
				66,
				32,
				135,
				167,
				36,
				0,
				32,
				4,
				167,
				11,
				36,
				1,
				1,
				126,
				32,
				0,
				173,
				32,
				1,
				173,
				66,
				32,
				134,
				132,
				32,
				2,
				173,
				32,
				3,
				173,
				66,
				32,
				134,
				132,
				128,
				34,
				4,
				66,
				32,
				135,
				167,
				36,
				0,
				32,
				4,
				167,
				11,
				36,
				1,
				1,
				126,
				32,
				0,
				173,
				32,
				1,
				173,
				66,
				32,
				134,
				132,
				32,
				2,
				173,
				32,
				3,
				173,
				66,
				32,
				134,
				132,
				129,
				34,
				4,
				66,
				32,
				135,
				167,
				36,
				0,
				32,
				4,
				167,
				11,
				36,
				1,
				1,
				126,
				32,
				0,
				173,
				32,
				1,
				173,
				66,
				32,
				134,
				132,
				32,
				2,
				173,
				32,
				3,
				173,
				66,
				32,
				134,
				132,
				130,
				34,
				4,
				66,
				32,
				135,
				167,
				36,
				0,
				32,
				4,
				167,
				11
			])), {}).exports;
		} catch {}
		/**
		* Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
		*  See the from* functions below for more convenient ways of constructing Longs.
		* @exports Long
		* @class A Long class for representing a 64 bit two's-complement integer value.
		* @param {number} low The low (signed) 32 bits of the long
		* @param {number} high The high (signed) 32 bits of the long
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @constructor
		*/
		function Long$1(low, high, unsigned) {
			/**
			* The low 32 bits as a signed value.
			* @type {number}
			*/
			this.low = low | 0;
			/**
			* The high 32 bits as a signed value.
			* @type {number}
			*/
			this.high = high | 0;
			/**
			* Whether unsigned or not.
			* @type {boolean}
			*/
			this.unsigned = !!unsigned;
		}
		/**
		* An indicator used to reliably determine if an object is a Long or not.
		* @type {boolean}
		* @const
		* @private
		*/
		Long$1.prototype.__isLong__;
		Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });
		/**
		* @function
		* @param {*} obj Object
		* @returns {boolean}
		* @inner
		*/
		function isLong(obj) {
			return (obj && obj["__isLong__"]) === true;
		}
		/**
		* @function
		* @param {*} value number
		* @returns {number}
		* @inner
		*/
		function ctz32(value) {
			var c = Math.clz32(value & -value);
			return value ? 31 - c : c;
		}
		/**
		* Tests if the specified object is a Long.
		* @function
		* @param {*} obj Object
		* @returns {boolean}
		*/
		Long$1.isLong = isLong;
		/**
		* A cache of the Long representations of small integer values.
		* @type {!Object}
		* @inner
		*/
		var INT_CACHE = {};
		/**
		* A cache of the Long representations of small unsigned integer values.
		* @type {!Object}
		* @inner
		*/
		var UINT_CACHE = {};
		/**
		* @param {number} value
		* @param {boolean=} unsigned
		* @returns {!Long}
		* @inner
		*/
		function fromInt(value, unsigned) {
			var obj, cachedObj, cache;
			if (unsigned) {
				value >>>= 0;
				if (cache = 0 <= value && value < 256) {
					cachedObj = UINT_CACHE[value];
					if (cachedObj) return cachedObj;
				}
				obj = fromBits(value, 0, true);
				if (cache) UINT_CACHE[value] = obj;
				return obj;
			} else {
				value |= 0;
				if (cache = -128 <= value && value < 128) {
					cachedObj = INT_CACHE[value];
					if (cachedObj) return cachedObj;
				}
				obj = fromBits(value, value < 0 ? -1 : 0, false);
				if (cache) INT_CACHE[value] = obj;
				return obj;
			}
		}
		/**
		* Returns a Long representing the given 32 bit integer value.
		* @function
		* @param {number} value The 32 bit integer in question
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {!Long} The corresponding Long value
		*/
		Long$1.fromInt = fromInt;
		/**
		* @param {number} value
		* @param {boolean=} unsigned
		* @returns {!Long}
		* @inner
		*/
		function fromNumber(value, unsigned) {
			if (isNaN(value)) return unsigned ? UZERO : ZERO;
			if (unsigned) {
				if (value < 0) return UZERO;
				if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
			} else {
				if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
				if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
			}
			if (value < 0) return fromNumber(-value, unsigned).neg();
			return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
		}
		/**
		* Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
		* @function
		* @param {number} value The number in question
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {!Long} The corresponding Long value
		*/
		Long$1.fromNumber = fromNumber;
		/**
		* @param {number} lowBits
		* @param {number} highBits
		* @param {boolean=} unsigned
		* @returns {!Long}
		* @inner
		*/
		function fromBits(lowBits, highBits, unsigned) {
			return new Long$1(lowBits, highBits, unsigned);
		}
		/**
		* Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
		*  assumed to use 32 bits.
		* @function
		* @param {number} lowBits The low 32 bits
		* @param {number} highBits The high 32 bits
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {!Long} The corresponding Long value
		*/
		Long$1.fromBits = fromBits;
		/**
		* @function
		* @param {number} base
		* @param {number} exponent
		* @returns {number}
		* @inner
		*/
		var pow_dbl = Math.pow;
		/**
		* @param {string} str
		* @param {(boolean|number)=} unsigned
		* @param {number=} radix
		* @returns {!Long}
		* @inner
		*/
		function fromString(str, unsigned, radix) {
			if (str.length === 0) throw Error("empty string");
			if (typeof unsigned === "number") {
				radix = unsigned;
				unsigned = false;
			} else unsigned = !!unsigned;
			if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
			radix = radix || 10;
			if (radix < 2 || 36 < radix) throw RangeError("radix");
			var p;
			if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
			else if (p === 0) return fromString(str.substring(1), unsigned, radix).neg();
			var radixToPower = fromNumber(pow_dbl(radix, 8));
			var result = ZERO;
			for (var i = 0; i < str.length; i += 8) {
				var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
				if (size < 8) {
					var power = fromNumber(pow_dbl(radix, size));
					result = result.mul(power).add(fromNumber(value));
				} else {
					result = result.mul(radixToPower);
					result = result.add(fromNumber(value));
				}
			}
			result.unsigned = unsigned;
			return result;
		}
		/**
		* Returns a Long representation of the given string, written using the specified radix.
		* @function
		* @param {string} str The textual representation of the Long
		* @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
		* @param {number=} radix The radix in which the text is written (2-36), defaults to 10
		* @returns {!Long} The corresponding Long value
		*/
		Long$1.fromString = fromString;
		/**
		* @function
		* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
		* @param {boolean=} unsigned
		* @returns {!Long}
		* @inner
		*/
		function fromValue(val, unsigned) {
			if (typeof val === "number") return fromNumber(val, unsigned);
			if (typeof val === "string") return fromString(val, unsigned);
			return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
		}
		/**
		* Converts the specified value to a Long using the appropriate from* function for its type.
		* @function
		* @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {!Long}
		*/
		Long$1.fromValue = fromValue;
		/**
		* @type {number}
		* @const
		* @inner
		*/
		var TWO_PWR_16_DBL = 65536;
		/**
		* @type {number}
		* @const
		* @inner
		*/
		var TWO_PWR_24_DBL = 1 << 24;
		/**
		* @type {number}
		* @const
		* @inner
		*/
		var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
		/**
		* @type {number}
		* @const
		* @inner
		*/
		var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
		/**
		* @type {number}
		* @const
		* @inner
		*/
		var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
		/**
		* @type {!Long}
		* @const
		* @inner
		*/
		var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
		/**
		* @type {!Long}
		* @inner
		*/
		var ZERO = fromInt(0);
		/**
		* Signed zero.
		* @type {!Long}
		*/
		Long$1.ZERO = ZERO;
		/**
		* @type {!Long}
		* @inner
		*/
		var UZERO = fromInt(0, true);
		/**
		* Unsigned zero.
		* @type {!Long}
		*/
		Long$1.UZERO = UZERO;
		/**
		* @type {!Long}
		* @inner
		*/
		var ONE = fromInt(1);
		/**
		* Signed one.
		* @type {!Long}
		*/
		Long$1.ONE = ONE;
		/**
		* @type {!Long}
		* @inner
		*/
		var UONE = fromInt(1, true);
		/**
		* Unsigned one.
		* @type {!Long}
		*/
		Long$1.UONE = UONE;
		/**
		* @type {!Long}
		* @inner
		*/
		var NEG_ONE = fromInt(-1);
		/**
		* Signed negative one.
		* @type {!Long}
		*/
		Long$1.NEG_ONE = NEG_ONE;
		/**
		* @type {!Long}
		* @inner
		*/
		var MAX_VALUE = fromBits(-1, 2147483647, false);
		/**
		* Maximum signed value.
		* @type {!Long}
		*/
		Long$1.MAX_VALUE = MAX_VALUE;
		/**
		* @type {!Long}
		* @inner
		*/
		var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
		/**
		* Maximum unsigned value.
		* @type {!Long}
		*/
		Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
		/**
		* @type {!Long}
		* @inner
		*/
		var MIN_VALUE = fromBits(0, -2147483648, false);
		/**
		* Minimum signed value.
		* @type {!Long}
		*/
		Long$1.MIN_VALUE = MIN_VALUE;
		/**
		* @alias Long.prototype
		* @inner
		*/
		var LongPrototype = Long$1.prototype;
		/**
		* Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
		* @this {!Long}
		* @returns {number}
		*/
		LongPrototype.toInt = function toInt() {
			return this.unsigned ? this.low >>> 0 : this.low;
		};
		/**
		* Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
		* @this {!Long}
		* @returns {number}
		*/
		LongPrototype.toNumber = function toNumber() {
			if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
			return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
		};
		/**
		* Converts the Long to a string written in the specified radix.
		* @this {!Long}
		* @param {number=} radix Radix (2-36), defaults to 10
		* @returns {string}
		* @override
		* @throws {RangeError} If `radix` is out of range
		*/
		LongPrototype.toString = function toString$1(radix) {
			radix = radix || 10;
			if (radix < 2 || 36 < radix) throw RangeError("radix");
			if (this.isZero()) return "0";
			if (this.isNegative()) if (this.eq(MIN_VALUE)) {
				var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
				return div.toString(radix) + rem1.toInt().toString(radix);
			} else return "-" + this.neg().toString(radix);
			var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
			var result = "";
			while (true) {
				var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
				rem = remDiv;
				if (rem.isZero()) return digits + result;
				else {
					while (digits.length < 6) digits = "0" + digits;
					result = "" + digits + result;
				}
			}
		};
		/**
		* Gets the high 32 bits as a signed integer.
		* @this {!Long}
		* @returns {number} Signed high bits
		*/
		LongPrototype.getHighBits = function getHighBits() {
			return this.high;
		};
		/**
		* Gets the high 32 bits as an unsigned integer.
		* @this {!Long}
		* @returns {number} Unsigned high bits
		*/
		LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
			return this.high >>> 0;
		};
		/**
		* Gets the low 32 bits as a signed integer.
		* @this {!Long}
		* @returns {number} Signed low bits
		*/
		LongPrototype.getLowBits = function getLowBits() {
			return this.low;
		};
		/**
		* Gets the low 32 bits as an unsigned integer.
		* @this {!Long}
		* @returns {number} Unsigned low bits
		*/
		LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
			return this.low >>> 0;
		};
		/**
		* Gets the number of bits needed to represent the absolute value of this Long.
		* @this {!Long}
		* @returns {number}
		*/
		LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
			if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
			var val = this.high != 0 ? this.high : this.low;
			for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
			return this.high != 0 ? bit + 33 : bit + 1;
		};
		/**
		* Tests if this Long can be safely represented as a JavaScript number.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isSafeInteger = function isSafeInteger() {
			var top11Bits = this.high >> 21;
			if (!top11Bits) return true;
			if (this.unsigned) return false;
			return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
		};
		/**
		* Tests if this Long's value equals zero.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isZero = function isZero() {
			return this.high === 0 && this.low === 0;
		};
		/**
		* Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
		* @returns {boolean}
		*/
		LongPrototype.eqz = LongPrototype.isZero;
		/**
		* Tests if this Long's value is negative.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isNegative = function isNegative() {
			return !this.unsigned && this.high < 0;
		};
		/**
		* Tests if this Long's value is positive or zero.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isPositive = function isPositive() {
			return this.unsigned || this.high >= 0;
		};
		/**
		* Tests if this Long's value is odd.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isOdd = function isOdd() {
			return (this.low & 1) === 1;
		};
		/**
		* Tests if this Long's value is even.
		* @this {!Long}
		* @returns {boolean}
		*/
		LongPrototype.isEven = function isEven() {
			return (this.low & 1) === 0;
		};
		/**
		* Tests if this Long's value equals the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.equals = function equals(other) {
			if (!isLong(other)) other = fromValue(other);
			if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
			return this.high === other.high && this.low === other.low;
		};
		/**
		* Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.eq = LongPrototype.equals;
		/**
		* Tests if this Long's value differs from the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.notEquals = function notEquals(other) {
			return !this.eq(other);
		};
		/**
		* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.neq = LongPrototype.notEquals;
		/**
		* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.ne = LongPrototype.notEquals;
		/**
		* Tests if this Long's value is less than the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.lessThan = function lessThan(other) {
			return this.comp(other) < 0;
		};
		/**
		* Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.lt = LongPrototype.lessThan;
		/**
		* Tests if this Long's value is less than or equal the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
			return this.comp(other) <= 0;
		};
		/**
		* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.lte = LongPrototype.lessThanOrEqual;
		/**
		* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.le = LongPrototype.lessThanOrEqual;
		/**
		* Tests if this Long's value is greater than the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.greaterThan = function greaterThan(other) {
			return this.comp(other) > 0;
		};
		/**
		* Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.gt = LongPrototype.greaterThan;
		/**
		* Tests if this Long's value is greater than or equal the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
			return this.comp(other) >= 0;
		};
		/**
		* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.gte = LongPrototype.greaterThanOrEqual;
		/**
		* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {boolean}
		*/
		LongPrototype.ge = LongPrototype.greaterThanOrEqual;
		/**
		* Compares this Long's value with the specified's.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other value
		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
		*  if the given one is greater
		*/
		LongPrototype.compare = function compare(other) {
			if (!isLong(other)) other = fromValue(other);
			if (this.eq(other)) return 0;
			var thisNeg = this.isNegative(), otherNeg = other.isNegative();
			if (thisNeg && !otherNeg) return -1;
			if (!thisNeg && otherNeg) return 1;
			if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
			return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
		};
		/**
		* Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
		* @function
		* @param {!Long|number|bigint|string} other Other value
		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
		*  if the given one is greater
		*/
		LongPrototype.comp = LongPrototype.compare;
		/**
		* Negates this Long's value.
		* @this {!Long}
		* @returns {!Long} Negated Long
		*/
		LongPrototype.negate = function negate() {
			if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
			return this.not().add(ONE);
		};
		/**
		* Negates this Long's value. This is an alias of {@link Long#negate}.
		* @function
		* @returns {!Long} Negated Long
		*/
		LongPrototype.neg = LongPrototype.negate;
		/**
		* Returns the sum of this and the specified Long.
		* @this {!Long}
		* @param {!Long|number|bigint|string} addend Addend
		* @returns {!Long} Sum
		*/
		LongPrototype.add = function add$1(addend) {
			if (!isLong(addend)) addend = fromValue(addend);
			var a48 = this.high >>> 16;
			var a32 = this.high & 65535;
			var a16 = this.low >>> 16;
			var a00 = this.low & 65535;
			var b48 = addend.high >>> 16;
			var b32 = addend.high & 65535;
			var b16 = addend.low >>> 16;
			var b00 = addend.low & 65535;
			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
			c00 += a00 + b00;
			c16 += c00 >>> 16;
			c00 &= 65535;
			c16 += a16 + b16;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c32 += a32 + b32;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c48 += a48 + b48;
			c48 &= 65535;
			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		};
		/**
		* Returns the difference of this and the specified Long.
		* @this {!Long}
		* @param {!Long|number|bigint|string} subtrahend Subtrahend
		* @returns {!Long} Difference
		*/
		LongPrototype.subtract = function subtract(subtrahend) {
			if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
			return this.add(subtrahend.neg());
		};
		/**
		* Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
		* @function
		* @param {!Long|number|bigint|string} subtrahend Subtrahend
		* @returns {!Long} Difference
		*/
		LongPrototype.sub = LongPrototype.subtract;
		/**
		* Returns the product of this and the specified Long.
		* @this {!Long}
		* @param {!Long|number|bigint|string} multiplier Multiplier
		* @returns {!Long} Product
		*/
		LongPrototype.multiply = function multiply(multiplier) {
			if (this.isZero()) return this;
			if (!isLong(multiplier)) multiplier = fromValue(multiplier);
			if (wasm) {
				var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
				return fromBits(low, wasm["get_high"](), this.unsigned);
			}
			if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
			if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
			if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
			if (this.isNegative()) if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
			else return this.neg().mul(multiplier).neg();
			else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
			if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
			var a48 = this.high >>> 16;
			var a32 = this.high & 65535;
			var a16 = this.low >>> 16;
			var a00 = this.low & 65535;
			var b48 = multiplier.high >>> 16;
			var b32 = multiplier.high & 65535;
			var b16 = multiplier.low >>> 16;
			var b00 = multiplier.low & 65535;
			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
			c00 += a00 * b00;
			c16 += c00 >>> 16;
			c00 &= 65535;
			c16 += a16 * b00;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c16 += a00 * b16;
			c32 += c16 >>> 16;
			c16 &= 65535;
			c32 += a32 * b00;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c32 += a16 * b16;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c32 += a00 * b32;
			c48 += c32 >>> 16;
			c32 &= 65535;
			c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
			c48 &= 65535;
			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		};
		/**
		* Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
		* @function
		* @param {!Long|number|bigint|string} multiplier Multiplier
		* @returns {!Long} Product
		*/
		LongPrototype.mul = LongPrototype.multiply;
		/**
		* Returns this Long divided by the specified. The result is signed if this Long is signed or
		*  unsigned if this Long is unsigned.
		* @this {!Long}
		* @param {!Long|number|bigint|string} divisor Divisor
		* @returns {!Long} Quotient
		*/
		LongPrototype.divide = function divide(divisor) {
			if (!isLong(divisor)) divisor = fromValue(divisor);
			if (divisor.isZero()) throw Error("division by zero");
			if (wasm) {
				if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) return this;
				var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
				return fromBits(low, wasm["get_high"](), this.unsigned);
			}
			if (this.isZero()) return this.unsigned ? UZERO : ZERO;
			var approx, rem, res;
			if (!this.unsigned) {
				if (this.eq(MIN_VALUE)) if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
				else if (divisor.eq(MIN_VALUE)) return ONE;
				else {
					var halfThis = this.shr(1);
					approx = halfThis.div(divisor).shl(1);
					if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE;
					else {
						rem = this.sub(divisor.mul(approx));
						res = approx.add(rem.div(divisor));
						return res;
					}
				}
				else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
				if (this.isNegative()) {
					if (divisor.isNegative()) return this.neg().div(divisor.neg());
					return this.neg().div(divisor).neg();
				} else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
				res = ZERO;
			} else {
				if (!divisor.unsigned) divisor = divisor.toUnsigned();
				if (divisor.gt(this)) return UZERO;
				if (divisor.gt(this.shru(1))) return UONE;
				res = UZERO;
			}
			rem = this;
			while (rem.gte(divisor)) {
				approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
				var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
				while (approxRem.isNegative() || approxRem.gt(rem)) {
					approx -= delta;
					approxRes = fromNumber(approx, this.unsigned);
					approxRem = approxRes.mul(divisor);
				}
				if (approxRes.isZero()) approxRes = ONE;
				res = res.add(approxRes);
				rem = rem.sub(approxRem);
			}
			return res;
		};
		/**
		* Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
		* @function
		* @param {!Long|number|bigint|string} divisor Divisor
		* @returns {!Long} Quotient
		*/
		LongPrototype.div = LongPrototype.divide;
		/**
		* Returns this Long modulo the specified.
		* @this {!Long}
		* @param {!Long|number|bigint|string} divisor Divisor
		* @returns {!Long} Remainder
		*/
		LongPrototype.modulo = function modulo(divisor) {
			if (!isLong(divisor)) divisor = fromValue(divisor);
			if (wasm) {
				var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
				return fromBits(low, wasm["get_high"](), this.unsigned);
			}
			return this.sub(this.div(divisor).mul(divisor));
		};
		/**
		* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		* @function
		* @param {!Long|number|bigint|string} divisor Divisor
		* @returns {!Long} Remainder
		*/
		LongPrototype.mod = LongPrototype.modulo;
		/**
		* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		* @function
		* @param {!Long|number|bigint|string} divisor Divisor
		* @returns {!Long} Remainder
		*/
		LongPrototype.rem = LongPrototype.modulo;
		/**
		* Returns the bitwise NOT of this Long.
		* @this {!Long}
		* @returns {!Long}
		*/
		LongPrototype.not = function not() {
			return fromBits(~this.low, ~this.high, this.unsigned);
		};
		/**
		* Returns count leading zeros of this Long.
		* @this {!Long}
		* @returns {!number}
		*/
		LongPrototype.countLeadingZeros = function countLeadingZeros() {
			return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
		};
		/**
		* Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
		* @function
		* @param {!Long}
		* @returns {!number}
		*/
		LongPrototype.clz = LongPrototype.countLeadingZeros;
		/**
		* Returns count trailing zeros of this Long.
		* @this {!Long}
		* @returns {!number}
		*/
		LongPrototype.countTrailingZeros = function countTrailingZeros() {
			return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
		};
		/**
		* Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
		* @function
		* @param {!Long}
		* @returns {!number}
		*/
		LongPrototype.ctz = LongPrototype.countTrailingZeros;
		/**
		* Returns the bitwise AND of this Long and the specified.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other Long
		* @returns {!Long}
		*/
		LongPrototype.and = function and(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
		};
		/**
		* Returns the bitwise OR of this Long and the specified.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other Long
		* @returns {!Long}
		*/
		LongPrototype.or = function or(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
		};
		/**
		* Returns the bitwise XOR of this Long and the given one.
		* @this {!Long}
		* @param {!Long|number|bigint|string} other Other Long
		* @returns {!Long}
		*/
		LongPrototype.xor = function xor(other) {
			if (!isLong(other)) other = fromValue(other);
			return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
		};
		/**
		* Returns this Long with bits shifted to the left by the given amount.
		* @this {!Long}
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shiftLeft = function shiftLeft(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
			else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
			else return fromBits(0, this.low << numBits - 32, this.unsigned);
		};
		/**
		* Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shl = LongPrototype.shiftLeft;
		/**
		* Returns this Long with bits arithmetically shifted to the right by the given amount.
		* @this {!Long}
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shiftRight = function shiftRight(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
			else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
			else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
		};
		/**
		* Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shr = LongPrototype.shiftRight;
		/**
		* Returns this Long with bits logically shifted to the right by the given amount.
		* @this {!Long}
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
			if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
			if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
			return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
		};
		/**
		* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shru = LongPrototype.shiftRightUnsigned;
		/**
		* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Shifted Long
		*/
		LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
		/**
		* Returns this Long with bits rotated to the left by the given amount.
		* @this {!Long}
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Rotated Long
		*/
		LongPrototype.rotateLeft = function rotateLeft(numBits) {
			var b;
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
			if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
			if (numBits < 32) {
				b = 32 - numBits;
				return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
			}
			numBits -= 32;
			b = 32 - numBits;
			return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
		};
		/**
		* Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Rotated Long
		*/
		LongPrototype.rotl = LongPrototype.rotateLeft;
		/**
		* Returns this Long with bits rotated to the right by the given amount.
		* @this {!Long}
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Rotated Long
		*/
		LongPrototype.rotateRight = function rotateRight(numBits) {
			var b;
			if (isLong(numBits)) numBits = numBits.toInt();
			if ((numBits &= 63) === 0) return this;
			if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
			if (numBits < 32) {
				b = 32 - numBits;
				return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
			}
			numBits -= 32;
			b = 32 - numBits;
			return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
		};
		/**
		* Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
		* @function
		* @param {number|!Long} numBits Number of bits
		* @returns {!Long} Rotated Long
		*/
		LongPrototype.rotr = LongPrototype.rotateRight;
		/**
		* Converts this Long to signed.
		* @this {!Long}
		* @returns {!Long} Signed long
		*/
		LongPrototype.toSigned = function toSigned() {
			if (!this.unsigned) return this;
			return fromBits(this.low, this.high, false);
		};
		/**
		* Converts this Long to unsigned.
		* @this {!Long}
		* @returns {!Long} Unsigned long
		*/
		LongPrototype.toUnsigned = function toUnsigned() {
			if (this.unsigned) return this;
			return fromBits(this.low, this.high, true);
		};
		/**
		* Converts this Long to its byte representation.
		* @param {boolean=} le Whether little or big endian, defaults to big endian
		* @this {!Long}
		* @returns {!Array.<number>} Byte representation
		*/
		LongPrototype.toBytes = function toBytes(le) {
			return le ? this.toBytesLE() : this.toBytesBE();
		};
		/**
		* Converts this Long to its little endian byte representation.
		* @this {!Long}
		* @returns {!Array.<number>} Little endian byte representation
		*/
		LongPrototype.toBytesLE = function toBytesLE() {
			var hi = this.high, lo = this.low;
			return [
				lo & 255,
				lo >>> 8 & 255,
				lo >>> 16 & 255,
				lo >>> 24,
				hi & 255,
				hi >>> 8 & 255,
				hi >>> 16 & 255,
				hi >>> 24
			];
		};
		/**
		* Converts this Long to its big endian byte representation.
		* @this {!Long}
		* @returns {!Array.<number>} Big endian byte representation
		*/
		LongPrototype.toBytesBE = function toBytesBE() {
			var hi = this.high, lo = this.low;
			return [
				hi >>> 24,
				hi >>> 16 & 255,
				hi >>> 8 & 255,
				hi & 255,
				lo >>> 24,
				lo >>> 16 & 255,
				lo >>> 8 & 255,
				lo & 255
			];
		};
		/**
		* Creates a Long from its byte representation.
		* @param {!Array.<number>} bytes Byte representation
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @param {boolean=} le Whether little or big endian, defaults to big endian
		* @returns {Long} The corresponding Long value
		*/
		Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
			return le ? Long$1.fromBytesLE(bytes, unsigned) : Long$1.fromBytesBE(bytes, unsigned);
		};
		/**
		* Creates a Long from its little endian byte representation.
		* @param {!Array.<number>} bytes Little endian byte representation
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {Long} The corresponding Long value
		*/
		Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
			return new Long$1(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
		};
		/**
		* Creates a Long from its big endian byte representation.
		* @param {!Array.<number>} bytes Big endian byte representation
		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		* @returns {Long} The corresponding Long value
		*/
		Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
			return new Long$1(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
		};
		if (typeof BigInt === "function") {
			/**
			* Returns a Long representing the given big integer.
			* @function
			* @param {number} value The big integer value
			* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
			* @returns {!Long} The corresponding Long value
			*/
			Long$1.fromBigInt = function fromBigInt$1(value, unsigned) {
				var lowBits = Number(BigInt.asIntN(32, value));
				var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
				return fromBits(lowBits, highBits, unsigned);
			};
			Long$1.fromValue = function fromValueWithBigInt(value, unsigned) {
				if (typeof value === "bigint") return fromBigInt(value, unsigned);
				return fromValue(value, unsigned);
			};
			/**
			* Converts the Long to its big integer representation.
			* @this {!Long}
			* @returns {bigint}
			*/
			LongPrototype.toBigInt = function toBigInt() {
				var lowBigInt = BigInt(this.low >>> 0);
				var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
				return highBigInt << BigInt(32) | lowBigInt;
			};
		}
		var _default = exports$1.default = Long$1;
		return "default" in exports$1 ? exports$1.default : exports$1;
	}({});
	if (typeof define === "function" && define.amd) define([], function() {
		return Long;
	});
	else if (typeof module === "object" && typeof exports === "object") module.exports = Long;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/objects.js
var require_objects = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/objects.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.objects = exports.NillableError = void 0;
	const NillablErrorSymbol = Symbol();
	const NILL_ERROR_MESSAGE = "value cannot be null or undefined";
	var NillableError = class extends Error {
		constructor(message = NILL_ERROR_MESSAGE) {
			super(message || NILL_ERROR_MESSAGE);
		}
		get [NillablErrorSymbol]() {
			return true;
		}
	};
	exports.NillableError = NillableError;
	exports.objects = {
		isNilError: (error) => {
			return error[NillablErrorSymbol] === true;
		},
		isNil: (value) => {
			return value === null || value === void 0;
		},
		isNotNil: (value) => {
			return !exports.objects.isNil(value);
		},
		validateFields: (values, errorMessageTemplate) => {
			for (const key$1 in values) exports.objects.requireNonNil(values[key$1], errorMessageTemplate(key$1));
			return values;
		},
		requireNonNil: (value, message) => {
			if (!exports.objects.isNil(value)) return value;
			if (typeof message === "function") throw message(value);
			throw new NillableError(message);
		},
		requireNonNilNumber: (value, message) => {
			if (typeof value === "number") return value;
			if (typeof message === "function") throw message(value);
			if (!value) throw new NillableError(message);
			throw new Error("value is not a number, it is a " + typeof value);
		},
		requireMaxLength: (value, maxLength, message) => {
			if (!value) {
				if (typeof message === "function") throw message(value);
				throw new Error(message || "value is null or undefined");
			}
			if (typeof value.toString !== "function") throw new Error("value does not have a toString() method");
			if (value.toString().length > maxLength) {
				if (typeof message === "function") throw message(value);
				throw new Error(message || `value is longer than ${maxLength} characters`);
			}
			return value;
		},
		validateOptionalFields(options, fields) {
			fields.forEach((field) => {
				if (options[field] !== void 0 && options[field] === null) throw new Error(`${String(field)} must not be null.`);
			});
		},
		validateRequiredFields(options, fields) {
			fields.forEach((field) => {
				if (options[field] === void 0 && options[field] === null) throw new Error(`${String(field)} must not be null.`);
			});
			return options;
		}
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/strings.js
var require_strings = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/strings.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.strings = void 0;
	const objects_1$8 = require_objects();
	exports.strings = {
		is: (value) => {
			return typeof value === "string";
		},
		requireNonNil: (value, message) => {
			if (exports.strings.is(value)) return value;
			if (typeof message === "function") throw message();
			throw new Error("value is not a string, it is a " + (!value ? "null or undefined" : typeof value));
		},
		requireNonNilElse: (value, defaultValue) => {
			if (!objects_1$8.objects.isNil(value)) return value;
			if (typeof defaultValue === "function") defaultValue(value);
			if (exports.strings.is(defaultValue)) return defaultValue;
			throw new Error("defaultValue is not a string, it is a " + (!value ? "null or undefined" : typeof value));
		},
		isNilOrEmpty: (value) => {
			if (objects_1$8.objects.isNil(value)) return true;
			if (exports.strings.is(value)) return value === "";
			throw new Error("value is not a string or null, it is a " + (!value ? "undefined" : typeof value));
		},
		isNilOrWhitespace: (value) => {
			return exports.strings.isNilOrEmpty(value) || value.trim().length === 0;
		}
	};
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/serial.js
var require_serial = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/serial.js"(exports) {
	var __importDefault$4 = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.bytesToBoolean = exports.booleanToBytes = exports.bytesToInt64 = exports.int64ToBytes = exports.bytesToInt32 = exports.int32ToBytes = exports.bytesToString = exports.hexToBase64 = exports.base64ToHex = exports.hexToBytes = exports.bytesToHex = exports.bytesToEthHex = exports.hexToNumber = exports.numberToHex = exports.numberToEthHex = exports.numberToBytes = exports.hexToString = exports.stringToHex = exports.stringToEthHex = exports.stringToBytes = void 0;
	const long_1$1 = __importDefault$4(require_umd());
	const strings_1$2 = require_strings();
	const objects_1$7 = require_objects();
	const base64_1$5 = require_base64();
	function stringToBytes$1(str) {
		return new TextEncoder().encode(str);
	}
	exports.stringToBytes = stringToBytes$1;
	function stringToEthHex(str) {
		let hex = "0x";
		hex += stringToHex(str);
		return hex;
	}
	exports.stringToEthHex = stringToEthHex;
	function stringToHex(str) {
		return stringToBytes$1(str).reduce((str$1, byte) => str$1 + byte.toString(16).padStart(2, "0"), "");
	}
	exports.stringToHex = stringToHex;
	function hexToString(hex) {
		strings_1$2.strings.requireNonNil(hex);
		return bytesToString(hexToBytes(hex));
	}
	exports.hexToString = hexToString;
	function numberToBytes(num) {
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		if (typeof num === "number") {
			if (num < 0 || num > 9007199254740991) throw new Error("Number out of bounds for safe integer representation");
			const high = Math.floor(num / 4294967296);
			const low = num % 4294967296;
			view.setUint32(0, high);
			view.setUint32(4, low);
		} else if (typeof num === "bigint") {
			if (num < 0n || num > 0xffffffffffffffffn) throw new Error("Number out of bounds for Uint64 representation");
			const high = Number(num >> 32n);
			const low = Number(num & 0xffffffffn);
			view.setUint32(0, high);
			view.setUint32(4, low);
		} else throw new Error("Unsupported type for conversion to bytes");
		return new Uint8Array(buffer);
	}
	exports.numberToBytes = numberToBytes;
	function numberToEthHex(num) {
		return "0x" + numberToHex(num);
	}
	exports.numberToEthHex = numberToEthHex;
	function numberToHex(num) {
		let hex = num.toString(16);
		if (hex.length % 2 !== 0) hex = "0" + hex;
		return hex;
	}
	exports.numberToHex = numberToHex;
	function hexToNumber(hex) {
		strings_1$2.strings.requireNonNil(hex);
		if (hex.length % 2 !== 0) throw new Error(`invalid hex string: ${hex}`);
		if (hex.startsWith("0x")) hex = hex.slice(2);
		return parseInt(hex, 16);
	}
	exports.hexToNumber = hexToNumber;
	function bytesToEthHex(bytes) {
		return "0x" + bytesToHex(bytes);
	}
	exports.bytesToEthHex = bytesToEthHex;
	function bytesToHex(bytes) {
		return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
	}
	exports.bytesToHex = bytesToHex;
	function hexToBytes(hex) {
		strings_1$2.strings.requireNonNil(hex);
		if (hex.length % 2 !== 0) throw new Error(`invalid hex string: ${hex}`);
		if (hex.startsWith("0x")) hex = hex.slice(2);
		const bytes = new Uint8Array(hex.length / 2);
		for (let i = 0; i < hex.length; i += 2) bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
		return bytes;
	}
	exports.hexToBytes = hexToBytes;
	function base64ToHex(base64) {
		return bytesToHex((0, base64_1$5.base64ToBytes)(base64));
	}
	exports.base64ToHex = base64ToHex;
	function hexToBase64(hex) {
		return (0, base64_1$5.bytesToBase64)(hexToBytes(hex));
	}
	exports.hexToBase64 = hexToBase64;
	function bytesToString(bytes) {
		return new TextDecoder().decode(bytes);
	}
	exports.bytesToString = bytesToString;
	function int32ToBytes(num) {
		objects_1$7.objects.requireNonNilNumber(num);
		const buffer = new ArrayBuffer(4);
		const view = new DataView(buffer);
		view.setInt32(0, num, true);
		return new Uint8Array(buffer);
	}
	exports.int32ToBytes = int32ToBytes;
	function bytesToInt32(bytes) {
		objects_1$7.objects.requireNonNil(bytes);
		const buffer = new ArrayBuffer(4);
		const view = new DataView(buffer);
		for (let i = 0; i < bytes.length; i++) view.setInt8(i, bytes[i]);
		return view.getInt32(0, true);
	}
	exports.bytesToInt32 = bytesToInt32;
	function int64ToBytes(num) {
		objects_1$7.objects.requireNonNilNumber(num);
		const longNum = long_1$1.default.fromNumber(num, true);
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		view.setInt32(0, longNum.low, true);
		view.setInt32(4, longNum.high, true);
		return new Uint8Array(buffer);
	}
	exports.int64ToBytes = int64ToBytes;
	function bytesToInt64(bytes) {
		objects_1$7.objects.requireNonNil(bytes);
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		for (let i = 0; i < bytes.length; i++) view.setInt8(i, bytes[i]);
		return view.getInt32(0, true);
	}
	exports.bytesToInt64 = bytesToInt64;
	function booleanToBytes(bool) {
		objects_1$7.objects.requireNonNil(bool);
		const buffer = new ArrayBuffer(1);
		const view = new DataView(buffer);
		view.setUint8(0, bool ? 1 : 0);
		return new Uint8Array(buffer);
	}
	exports.booleanToBytes = booleanToBytes;
	function bytesToBoolean(bytes) {
		objects_1$7.objects.requireNonNil(bytes);
		const buffer = new ArrayBuffer(1);
		const view = new DataView(buffer);
		for (let i = 0; i < bytes.length; i++) view.setUint8(i, bytes[i]);
		return view.getUint8(0) === 1;
	}
	exports.bytesToBoolean = bytesToBoolean;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/enums.js
var require_enums = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/enums.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AccessModifier = exports.AccountKeyType = exports.AccountStatus = exports.AuthErrorCodes = exports.BroadcastSyncType = exports.AuthenticationMode = exports.EnvironmentType = exports.BytesEncodingStatus = exports.SerializationType = exports.PayloadType = exports.EncodingType = exports.IndexType = exports.AttributeType = exports.VarType = void 0;
	/**
	* VarType is the type of the data in the database.
	*
	* Although Kwil supports text, int, bool, blob, uuid, uint256, decimal, and null types, kwil-js only supports text, int, bool, decimal, and null. If you need to send blob, uuid, or uint256 types, you should send them as a javascript string.
	*
	*/
	var VarType;
	(function(VarType$1) {
		VarType$1["UUID"] = "uuid";
		VarType$1["TEXT"] = "text";
		VarType$1["INT8"] = "int8";
		VarType$1["BOOL"] = "bool";
		VarType$1["NUMERIC"] = "numeric";
		VarType$1["NULL"] = "null";
		VarType$1["BYTEA"] = "bytea";
		VarType$1["UNKNOWN"] = "unknown";
	})(VarType || (exports.VarType = VarType = {}));
	var AttributeType;
	(function(AttributeType$1) {
		AttributeType$1["INVALID_TYPE"] = "";
		AttributeType$1["PRIMARY_KEY"] = "PRIMARY_KEY";
		AttributeType$1["UNIQUE"] = "UNIQUE";
		AttributeType$1["NOT_NULL"] = "NOT_NULL";
		AttributeType$1["DEFAULT"] = "DEFAULT";
		AttributeType$1["MIN"] = "MIN";
		AttributeType$1["MAX"] = "MAX";
		AttributeType$1["MIN_LENGTH"] = "MIN_LENGTH";
		AttributeType$1["MAX_LENGTH"] = "MAX_LENGTH";
	})(AttributeType || (exports.AttributeType = AttributeType = {}));
	var IndexType;
	(function(IndexType$1) {
		IndexType$1["INVALID_INDEX_TYPE"] = "";
		IndexType$1["BTREE"] = "BTREE";
		IndexType$1["UNIQUE_BTREE"] = "UNIQUE_BTREE";
	})(IndexType || (exports.IndexType = IndexType = {}));
	var EncodingType;
	(function(EncodingType$1) {
		EncodingType$1[EncodingType$1["INVALID_ENCODING_TYPE"] = 0] = "INVALID_ENCODING_TYPE";
		EncodingType$1[EncodingType$1["RLP_ENCODING"] = 1] = "RLP_ENCODING";
	})(EncodingType || (exports.EncodingType = EncodingType = {}));
	var PayloadType;
	(function(PayloadType$1) {
		PayloadType$1["INVALID_PAYLOAD_TYPE"] = "invalid";
		PayloadType$1["EXECUTE_ACTION"] = "execute";
		PayloadType$1["CALL_ACTION"] = "call_action";
		PayloadType$1["TRANSFER"] = "transfer";
		PayloadType$1["RAW_STATEMENT"] = "raw_statement";
	})(PayloadType || (exports.PayloadType = PayloadType = {}));
	var SerializationType;
	(function(SerializationType$1) {
		SerializationType$1["INVALID_SERIALIZATION_TYPE"] = "invalid";
		SerializationType$1["SIGNED_MSG_CONCAT"] = "concat";
		SerializationType$1["SIGNED_MSG_EIP712"] = "eip712";
	})(SerializationType || (exports.SerializationType = SerializationType = {}));
	var BytesEncodingStatus;
	(function(BytesEncodingStatus$1) {
		BytesEncodingStatus$1["INVALID_ENCODING_STATUS"] = "invalid";
		BytesEncodingStatus$1["BASE64_ENCODED"] = "base64_encoded";
		BytesEncodingStatus$1["HEX_ENCODED"] = "hex_encoded";
		BytesEncodingStatus$1["UINT8_ENCODED"] = "uint8_encoded";
	})(BytesEncodingStatus || (exports.BytesEncodingStatus = BytesEncodingStatus = {}));
	var EnvironmentType;
	(function(EnvironmentType$1) {
		EnvironmentType$1["BROWSER"] = "browser";
		EnvironmentType$1["NODE"] = "node";
	})(EnvironmentType || (exports.EnvironmentType = EnvironmentType = {}));
	var AuthenticationMode;
	(function(AuthenticationMode$1) {
		AuthenticationMode$1["PRIVATE"] = "private";
		AuthenticationMode$1["OPEN"] = "open";
	})(AuthenticationMode || (exports.AuthenticationMode = AuthenticationMode = {}));
	var BroadcastSyncType;
	(function(BroadcastSyncType$1) {
		BroadcastSyncType$1[BroadcastSyncType$1["SYNC"] = 0] = "SYNC";
		BroadcastSyncType$1[BroadcastSyncType$1["COMMIT"] = 1] = "COMMIT";
	})(BroadcastSyncType || (exports.BroadcastSyncType = BroadcastSyncType = {}));
	var AuthErrorCodes;
	(function(AuthErrorCodes$1) {
		AuthErrorCodes$1[AuthErrorCodes$1["PRIVATE_MODE"] = -1001] = "PRIVATE_MODE";
		AuthErrorCodes$1[AuthErrorCodes$1["KGW_MODE"] = -901] = "KGW_MODE";
	})(AuthErrorCodes || (exports.AuthErrorCodes = AuthErrorCodes = {}));
	var AccountStatus;
	(function(AccountStatus$1) {
		AccountStatus$1[AccountStatus$1["LATEST"] = 0] = "LATEST";
		AccountStatus$1[AccountStatus$1["PENDING"] = 1] = "PENDING";
	})(AccountStatus || (exports.AccountStatus = AccountStatus = {}));
	var AccountKeyType;
	(function(AccountKeyType$1) {
		AccountKeyType$1["SECP256K1"] = "secp256k1";
		AccountKeyType$1["ED25519"] = "ed25519";
	})(AccountKeyType || (exports.AccountKeyType = AccountKeyType = {}));
	var AccessModifier;
	(function(AccessModifier$1) {
		AccessModifier$1["PUBLIC"] = "PUBLIC";
		AccessModifier$1["PRIVATE"] = "PRIVATE";
		AccessModifier$1["VIEW"] = "VIEW";
	})(AccessModifier || (exports.AccessModifier = AccessModifier = {}));
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/jsonrpc.js
var require_jsonrpc = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/jsonrpc.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSONRPCMethod = void 0;
	var JSONRPCMethod;
	(function(JSONRPCMethod$1) {
		JSONRPCMethod$1["METHOD_HEALTH"] = "user.health";
		JSONRPCMethod$1["METHOD_PING"] = "user.ping";
		JSONRPCMethod$1["METHOD_CHAIN_INFO"] = "user.chain_info";
		JSONRPCMethod$1["METHOD_ACCOUNT"] = "user.account";
		JSONRPCMethod$1["METHOD_BROADCAST"] = "user.broadcast";
		JSONRPCMethod$1["METHOD_CALL"] = "user.call";
		JSONRPCMethod$1["METHOD_DATABASES"] = "user.databases";
		JSONRPCMethod$1["METHOD_PRICE"] = "user.estimate_price";
		JSONRPCMethod$1["METHOD_QUERY"] = "user.query";
		JSONRPCMethod$1["METHOD_TX_QUERY"] = "user.tx_query";
		JSONRPCMethod$1["METHOD_SCHEMA"] = "user.schema";
		JSONRPCMethod$1["METHOD_KGW_PARAM"] = "kgw.authn_param";
		JSONRPCMethod$1["METHOD_KGW_AUTHN"] = "kgw.authn";
		JSONRPCMethod$1["METHOD_KGW_LOGOUT"] = "kgw.logout";
		JSONRPCMethod$1["METHOD_CHALLENGE"] = "user.challenge";
	})(JSONRPCMethod || (exports.JSONRPCMethod = JSONRPCMethod = {}));
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/api_client/client.js
var require_client = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/api_client/client.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const base64_1$4 = require_base64();
	const api_1 = require_api();
	const serial_1$10 = require_serial();
	const enums_1$9 = require_enums();
	const jsonrpc_1 = require_jsonrpc();
	var Client = class extends api_1.Api {
		constructor(opts) {
			super(opts);
			this.jsonRpcId = 1;
			this.unconfirmedNonce = opts.unconfirmedNonce || false;
		}
		async getAuthenticateClient() {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_PARAM, {});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => r.result);
		}
		async postAuthenticateClient(authBody) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_AUTHN, authBody);
			const res = await super.post(`/rpc/v1`, body);
			if (typeof window === "undefined") return checkRes(res, (r) => {
				const cookie = res.headers["set-cookie"];
				if (!cookie) throw new Error("No cookie received from gateway. An error occurred with authentication.");
				return {
					...r.result,
					cookie: cookie[0]
				};
			});
			return checkRes(res, (r) => r.result);
		}
		async logoutClient(identifier) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_LOGOUT, { account: identifier ? (0, serial_1$10.bytesToHex)(identifier) : "" });
			const res = await super.post(`/rpc/v1`, body);
			if (typeof window === "undefined") return checkRes(res, (r) => {
				const cookie = res.headers["set-cookie"];
				if (!cookie) throw new Error("No cookie received from gateway. An error occured with logout.");
				if (cookie[0].startsWith("kgw_session=;")) this.cookie = void 0;
				else this.cookie = cookie[0];
				return {
					...r.result,
					cookie: cookie[0]
				};
			});
			return checkRes(res, (r) => r.result);
		}
		async getAccountClient(accountId) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_ACCOUNT, {
				id: accountId,
				status: this.unconfirmedNonce ? enums_1$9.AccountStatus.PENDING : enums_1$9.AccountStatus.LATEST
			});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => {
				return {
					...r.result,
					id: r.result.id
				};
			});
		}
		async listDatabasesClient(owner) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_DATABASES, { owner: owner ? (0, serial_1$10.bytesToHex)(owner) : void 0 });
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => {
				if (!r.result.databases) return [];
				return r.result.databases.map((db$1) => {
					return {
						...db$1,
						owner: (0, serial_1$10.hexToBytes)(db$1.owner)
					};
				});
			});
		}
		async estimateCostClient(tx) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PRICE, { tx: tx.txData });
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => r.result.price);
		}
		async broadcastClient(tx, broadcastSync) {
			if (!tx.isSigned()) throw new Error("Tx must be signed before broadcasting.");
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_BROADCAST, {
				tx: tx.txData,
				...broadcastSync ? { sync: broadcastSync } : {}
			});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => {
				if (r.result.result && r.result.result?.code !== 0) throw new Error(JSON.stringify(r.result) || `Transaction failed after broadcast.`);
				return { tx_hash: (0, serial_1$10.base64ToHex)(r.result.tx_hash) };
			});
		}
		async pingClient() {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PING, { message: "ping" });
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => r.result.message);
		}
		async chainInfoClient() {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHAIN_INFO, {});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => {
				return {
					chain_id: r.result.chain_id,
					height: r.result.block_height.toString(),
					hash: r.result.block_hash
				};
			});
		}
		async healthModeCheckClient() {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_HEALTH, {});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => r.result);
		}
		async challengeClient() {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHALLENGE, {});
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => r.result.challenge);
		}
		async selectQueryClient(query) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_QUERY, query);
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => this.parseQueryResponse(r.result));
		}
		async txInfoClient(tx_hash) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_TX_QUERY, { tx_hash: (0, serial_1$10.hexToBase64)(tx_hash) });
			const res = await super.post(`/rpc/v1`, body);
			return checkRes(res, (r) => {
				return {
					...r.result,
					tx: {
						...r.result.tx,
						body: {
							...r.result.tx.body,
							payload: (0, base64_1$4.base64ToBytes)(r.result.tx.body.payload),
							fee: BigInt(r.result.tx.body.fee || 0)
						},
						signature: {
							...r.result.tx.signature,
							sig: (0, base64_1$4.base64ToBytes)(r.result.tx.signature.sig)
						},
						sender: (0, serial_1$10.hexToBytes)(r.result.tx.sender || "")
					}
				};
			});
		}
		async callClient(msg) {
			const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CALL, {
				body: msg.body,
				auth_type: msg.auth_type,
				sender: msg.sender || "",
				signature: msg.signature || ""
			});
			const res = await super.post(`/rpc/v1`, body);
			const errorResponse = this.checkAuthError(res);
			if (errorResponse) return errorResponse;
			return checkRes(res, (r) => {
				return { result: this.parseQueryResponse(r.result.query_result) };
			});
		}
		buildJsonRpcRequest(method, params) {
			return {
				jsonrpc: "2.0",
				id: this.jsonRpcId++,
				method,
				params
			};
		}
		checkAuthError(res) {
			const errorCode = res.data.error?.code;
			if (errorCode === enums_1$9.AuthErrorCodes.PRIVATE_MODE || errorCode === enums_1$9.AuthErrorCodes.KGW_MODE) return {
				status: res.status,
				data: void 0,
				authCode: errorCode
			};
			return null;
		}
		parseQueryResponse(queryResponse) {
			const { column_names, values } = queryResponse;
			if (!values || values.length === 0) return [];
			const mapValueToColumn = (rowValues) => {
				const obj = {};
				for (let i = 0; i < column_names.length; i++) obj[column_names[i]] = rowValues[i];
				return obj;
			};
			return values.map(mapValueToColumn);
		}
	};
	exports.default = Client;
	function checkRes(res, selector) {
		switch (res.status) {
			case 200: break;
			case 401: throw new Error(JSON.stringify(res.data) || "Unauthorized.");
			case 404: throw new Error(JSON.stringify(res.data) || "Not found.");
			case 500: throw new Error(JSON.stringify(res.data) || "Internal server error.");
			default: throw new Error(JSON.stringify(res.data) || "An unknown error has occurred.  Please check your network connection.");
		}
		if (!res.data) throw new Error(`failed to parse response: ${res}`);
		if (res.data.error) {
			const data = res.data.error.data ? `, data: ${JSON.stringify(res.data.error.data)}` : "";
			throw new Error(`JSON RPC call error: code: ${res.data.error.code}, message: ${res.data.error.message}` + data);
		}
		if (res.data.jsonrpc !== "2.0") throw new Error(JSON.stringify(res.data) || "Invalid JSON RPC response.");
		if (!res.data.result) throw new Error(JSON.stringify(res.data) || "No result in JSON RPC response.");
		return {
			status: res.status,
			data: selector(res.data)
		};
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/types.js
var require_types = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/types.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isValueType = exports.Promisy = void 0;
	const objects_1$6 = require_objects();
	var Promisy;
	(function(Promisy$1) {
		async function resolve(promisy) {
			const fov = objects_1$6.objects.requireNonNil(promisy);
			const awaitable = typeof fov === "function" ? fov() : fov;
			return await awaitable;
		}
		Promisy$1.resolve = resolve;
		async function resolveOrReject(promisy, nilError) {
			return objects_1$6.objects.isNil(promisy) ? Promise.reject(new objects_1$6.NillableError(nilError)) : resolve(promisy);
		}
		Promisy$1.resolveOrReject = resolveOrReject;
	})(Promisy || (exports.Promisy = Promisy = {}));
	function isValueType(v) {
		if (v === null || v === void 0 || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v instanceof Uint8Array) return true;
		if (Array.isArray(v)) return v.every(isValueType);
		return false;
	}
	exports.isValueType = isValueType;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/action.js
var require_action$1 = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/action.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ActionInput = exports.transformPositionalParam = exports.transformActionInput = exports.isNamedParam = exports.isNamedParams = exports.resolveParamTypes = void 0;
	const objects_1$5 = require_objects();
	const types_1 = require_types();
	function resolveParamTypes(i, types) {
		const paramTypes = [];
		if (!types) {
			if (isNamedParam(i)) for (const [k, v] of Object.entries(i)) paramTypes.push({ v });
			else for (let j = 0; j < i.length; j++) paramTypes.push({ v: i[j] });
			return paramTypes;
		}
		if (isNamedParam(i)) if (types && !Array.isArray(types)) for (const [k, v] of Object.entries(i)) paramTypes.push({
			v,
			o: types[k]
		});
		else Object.entries(i).forEach(([k, v], idx) => {
			paramTypes.push({
				v,
				o: types[idx]
			});
		});
		else if (types && !Array.isArray(types)) {
			const typeVals = Object.values(types);
			for (let j = 0; j < i.length; j++) paramTypes.push({
				v: i[j],
				o: typeVals[j]
			});
		} else for (let j = 0; j < i.length; j++) paramTypes.push({
			v: i[j],
			o: types[j]
		});
		return paramTypes;
	}
	exports.resolveParamTypes = resolveParamTypes;
	function isNamedParams(i) {
		let isNamedParams$1 = false;
		for (const p of i) if (isNamedParam(p)) {
			isNamedParams$1 = true;
			break;
		}
		return isNamedParams$1;
	}
	exports.isNamedParams = isNamedParams;
	function isNamedParam(i) {
		return typeof i === "object" && i !== null && !Array.isArray(i);
	}
	exports.isNamedParam = isNamedParam;
	/**
	* Asserts that a key is not null or undefined.
	*
	* @param key - The key to assert.
	* @returns The key if it is not null or undefined.
	* @throws Will throw an error if the key is null or undefined.
	*/
	function assertKey(key$1) {
		return objects_1$5.objects.requireNonNil(key$1, "key cannot be nil");
	}
	function lowercaseKey(key$1) {
		return key$1.toLowerCase();
	}
	exports.transformActionInput = {
		isActionInputArray(i) {
			return Array.isArray(i) && i.length > 0 && i.every((item) => item instanceof ActionInput);
		},
		toSingleEntry(inputs) {
			if (!inputs.length) return {};
			const firstInput = inputs[0];
			if (firstInput instanceof ActionInput) return firstInput.toEntries();
			return firstInput;
		},
		toNamedParams(inputs) {
			if (!exports.transformActionInput.isActionInputArray(inputs)) throw new Error("Inputs array  must be an array of Entries or ActionInput objects");
			const np = [];
			for (const input of inputs) if (input instanceof ActionInput) np.push(input.toEntries());
			return np;
		}
	};
	exports.transformPositionalParam = {
		isPositionalParams(i) {
			return Array.isArray(i) && i.every((p) => (0, types_1.isValueType)(p));
		},
		isPositionalParam(i) {
			return (0, types_1.isValueType)(i);
		},
		toNamedParams(inputs) {
			return inputs.map((i) => {
				return exports.transformPositionalParam.toNamedParam(i);
			});
		},
		toNamedParam(i) {
			const np = {};
			i.forEach((v, idx) => {
				np[`$pstn_${idx}`] = v;
			});
			return np;
		}
	};
	/**
	* @deprecated - This class is deprecated and will be removed in the next major release.  Please pass action inputs as an array of objects.
	* `ActionInput` class is a utility class for creating action inputs.
	*/
	var ActionInput = class ActionInput {
		constructor() {
			this.map = {};
		}
		/**
		* Adds or replaces a value for a single action input.
		*
		* @param key - The action input name.
		* @param value - The value to put for the action input.
		* @returns The current `ActionInput` instance for chaining.
		*/
		put(key$1, value) {
			key$1 = lowercaseKey(key$1);
			this.map[assertKey(key$1)] = value;
			return this;
		}
		/**
		* Adds a value for a single action input if the key is not already present.
		*
		* @param key - The action input name.
		* @param value - The value to put for the action input.
		* @returns The current `ActionInput` instance for chaining.
		*/
		putIfAbsent(key$1, value) {
			key$1 = lowercaseKey(key$1);
			if (!this.containsKey(key$1)) this.map[key$1] = value;
			return this;
		}
		/**
		* Replaces a value for a single action input if the key is already present.
		*
		* @param key - The action input name.
		* @param value - The value to replace for the action input.
		* @returns The current `ActionInput` instance for chaining.
		*/
		replace(key$1, value) {
			key$1 = lowercaseKey(key$1);
			if (this.containsKey(key$1)) this.map[key$1] = value;
			return this;
		}
		/**
		* Retrieves an action input value given its key.
		*
		* @param key - The action input name.
		* @returns The value associated with the action input name.
		*/
		get(key$1) {
			key$1 = lowercaseKey(key$1);
			return this.map[assertKey(key$1)];
		}
		/**
		* Retrieves a value by its action input name, or a default value if the action input name is not present.
		*
		* @param key - The action input name.
		* @param defaultValue - The default value to return if the key is not present.
		* @returns The value associated with the key, or the default value.
		*/
		getOrDefault(key$1, defaultValue) {
			key$1 = lowercaseKey(key$1);
			return this.map[assertKey(key$1)] ?? defaultValue;
		}
		/**
		* Checks if the map contains a specific action input name.
		*
		* @param key - The action input name.
		* @returns True if the action input name is present, false otherwise.
		*/
		containsKey(key$1) {
			key$1 = lowercaseKey(key$1);
			return this.map.hasOwnProperty(assertKey(key$1));
		}
		/**
		* Removes a action input name and its associated value from the map.
		*
		* @param key - The action input name to remove.
		* @returns True if the key was present and is now removed, false otherwise.
		*/
		remove(key$1) {
			key$1 = lowercaseKey(key$1);
			return delete this.map[key$1];
		}
		/**
		* Converts the map of action inputs to an array of entries.
		*
		* @param filter - An optional filter function.
		* @returns A read-only array of entries.
		*/
		toArray(filter) {
			return Object.entries(this.map).filter(filter ?? (() => true));
		}
		/**
		* Transforms the `ActionInput` to JSON.
		*
		* @returns A read-only map of entries.
		*/
		toEntries() {
			return this.map;
		}
		/**
		* Allows `ActionInput` to be iterable.
		*
		* @returns An iterator over the array of entries.
		*/
		[Symbol.iterator]() {
			return this.toArray()[Symbol.iterator]();
		}
		/**
		* Adds or replaces values from and object of action name/key-value pairs.
		*
		* @param obj - The object from which to extract action name/key-value pairs.
		* @returns The current `ActionInput` instance for chaining.
		*/
		putFromObject(obj) {
			for (let [key$1, value] of Object.entries(objects_1$5.objects.requireNonNil(obj))) {
				key$1 = lowercaseKey(key$1);
				this.map[assertKey(key$1)] = value;
			}
			return this;
		}
		/**
		* Adds values from and object of action name/key-value pairs if the key is not already present.
		*
		* @param obj - The object from which to extract key-value pairs.
		* @returns The current `ActionInput` instance for chaining.
		*/
		putFromObjectIfAbsent(obj) {
			for (let [key$1, value] of Object.entries(objects_1$5.objects.requireNonNil(obj))) {
				key$1 = lowercaseKey(key$1);
				if (!this.containsKey(key$1)) this.map[assertKey(key$1)] = value;
			}
			return this;
		}
		/**
		* Replaces values from and object of action name/key-value pairs if the key is already present.
		*
		* @param obj - The object from which to extract key-value pairs.
		* @returns The current `ActionInput` instance for chaining.
		*/
		replaceFromObject(obj) {
			for (let [key$1, value] of Object.entries(objects_1$5.objects.requireNonNil(obj))) {
				key$1 = lowercaseKey(key$1);
				if (this.containsKey(key$1)) this.map[assertKey(key$1)] = value;
			}
			return this;
		}
		/**
		* Creates multiple `ActionInput` instances from an array of objects.
		*
		* @param objs - An array of objects from which to create `ActionInput` instances.
		* @returns An array of `ActionInput` instances.
		*/
		putFromObjects(objs) {
			const actions = [];
			for (const obj of objects_1$5.objects.requireNonNil(objs)) actions.push(ActionInput.fromObject(obj));
			return actions;
		}
		/**
		* Factory method to create a new instance of `ActionInput`.
		*
		* @returns A new `ActionInput` instance.
		*/
		static of() {
			return new ActionInput();
		}
		/**
		* Creates a new `ActionInput` instance from an iterable array of entries.
		*
		* @param entries - The iterable of set of entries. Entries should be formatted as an array of `[inputName, value]`.
		* @returns A new `ActionInput` instance.
		*/
		static from(entries) {
			const action = ActionInput.of();
			for (let [key$1, value] of entries) {
				key$1 = lowercaseKey(key$1);
				action.map[assertKey(key$1)] = value;
			}
			return action;
		}
		/**
		* Creates a new `ActionInput` instance from an object.
		*
		* @param obj - The object from which to create the `ActionInput`.
		* @returns A new `ActionInput` instance.
		*/
		static fromObject(obj) {
			const action = ActionInput.of();
			for (let [key$1, value] of Object.entries(objects_1$5.objects.requireNonNil(obj))) {
				key$1 = lowercaseKey(key$1);
				action.map[assertKey(key$1)] = value;
			}
			return action;
		}
		/**
		* Creates multiple `ActionInput` instances from an array of objects.
		*
		* @param objs - An array of objects from which to create `ActionInput` instances.
		* @returns An array of `ActionInput` instances.
		*/
		static fromObjects(objs) {
			const actions = [];
			for (const obj of objects_1$5.objects.requireNonNil(objs)) actions.push(ActionInput.fromObject(obj));
			return actions;
		}
	};
	exports.ActionInput = ActionInput;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/intern.js
var require_intern = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/intern.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrap = exports.unwrap = void 0;
	const objects_1$4 = require_objects();
	const key = Symbol("estimate");
	function unwrap(kwil) {
		objects_1$4.objects.requireNonNil(kwil);
		return objects_1$4.objects.requireNonNil(kwil[key]);
	}
	exports.unwrap = unwrap;
	function wrap(kwil, method) {
		objects_1$4.objects.requireNonNil(kwil);
		kwil[key] = method;
	}
	exports.wrap = wrap;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/signature.js
var require_signature = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/signature.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.executeSign = exports.isEthersSigner = exports.getSignatureType = exports.SignatureType = void 0;
	const serial_1$9 = require_serial();
	var SignatureType;
	(function(SignatureType$1) {
		SignatureType$1["SIGNATURE_TYPE_INVALID"] = "invalid";
		SignatureType$1["SECP256K1_PERSONAL"] = "secp256k1_ep";
		SignatureType$1["ED25519"] = "ed25519";
	})(SignatureType || (exports.SignatureType = SignatureType = {}));
	function getSignatureType(signer) {
		if (isEthersSigner(signer)) return SignatureType.SECP256K1_PERSONAL;
		return SignatureType.SIGNATURE_TYPE_INVALID;
	}
	exports.getSignatureType = getSignatureType;
	async function ethSign(message, signer) {
		return await signer.signMessage(message);
	}
	function isEthersSigner(signer) {
		if (typeof signer === "object" && signer !== null && "signMessage" in signer && typeof signer.signMessage === "function") return true;
		return false;
	}
	exports.isEthersSigner = isEthersSigner;
	async function executeSign(msg, signer, signatureType) {
		if (isEthersSigner(signer) && signatureType === SignatureType.SECP256K1_PERSONAL) {
			const hexSig = await ethSign(msg, signer);
			let sigBytes = (0, serial_1$9.hexToBytes)(hexSig);
			return sigBytes;
		}
		if (!isEthersSigner(signer) && signatureType !== SignatureType.SIGNATURE_TYPE_INVALID) if (typeof signer === "function") {
			const signature = await signer(msg);
			return signature;
		} else throw new Error("Something went wrong signing! Make sure your signer is a function that returns a Uint8Array.");
		throw new Error("Could not execute signature. Make sure you pass a signer from EtherJS or a function that returns a Uint8Array.");
	}
	exports.executeSign = executeSign;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/tx.js
var require_tx = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/tx.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Txn = exports.BaseTransaction = void 0;
	const signature_1$4 = require_signature();
	const strings_1$1 = require_strings();
	const enums_1$8 = require_enums();
	/**
	* `BaseTransaction` is the base class for a payload structure for a a request to the Kwil `broadcast` GRPC endpoint {@link https://github.com/kwilteam/proto/blob/main/kwil/tx/v1/broadcast.proto}.
	* Bytes in the transaction can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the transaction within the SDK, and base64 should be used for the final transaction to be send over GRPC.
	*
	* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the transaction. Can be either base64 encoded or Uint8Array.
	* @implements {TxnData<T>} - The transaction data interface.
	*/
	var BaseTransaction = class {
		constructor(data) {
			this.data = data || {
				signature: {
					sig: null,
					type: signature_1$4.SignatureType.SIGNATURE_TYPE_INVALID
				},
				body: {
					desc: "",
					payload: null,
					type: enums_1$8.PayloadType.INVALID_PAYLOAD_TYPE,
					fee: null,
					nonce: null,
					chain_id: ""
				},
				sender: null,
				serialization: enums_1$8.SerializationType.SIGNED_MSG_CONCAT
			};
		}
		get txData() {
			return this.data;
		}
		isSigned() {
			return !strings_1$1.strings.isNilOrEmpty(this.data.signature.sig);
		}
		get signature() {
			return this.data.signature;
		}
		get sender() {
			return this.data.sender;
		}
		get body() {
			return this.data.body;
		}
		get serialization() {
			return this.data.serialization;
		}
	};
	exports.BaseTransaction = BaseTransaction;
	var Txn;
	(function(Txn$1) {
		/**
		* Creates a new instance of the `BaseTransaction` class.
		* Bytes in the transaction can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the transaction within the SDK, and base64 should be used for the final transaction to be send over GRPC.
		*
		* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the transaction. Can be either base64 encoded or Uint8Array.
		* @param {(tx: TxnData<T>) => void} configure - A function that takes in a `TxnData` object and sets fields on it.
		* @returns {BaseTransaction<T>} - A new instance of the `BaseTransaction` class.
		*/
		function create(configure) {
			const tx = {
				signature: {
					sig: null,
					type: signature_1$4.SignatureType.SECP256K1_PERSONAL
				},
				body: {
					desc: "",
					payload: null,
					type: enums_1$8.PayloadType.INVALID_PAYLOAD_TYPE,
					fee: null,
					nonce: null,
					chain_id: ""
				},
				sender: null,
				serialization: enums_1$8.SerializationType.SIGNED_MSG_CONCAT
			};
			configure(tx);
			return new BaseTransaction(tx);
		}
		Txn$1.create = create;
		/**
		* Copies an existing instance of the `BaseTransaction` class and modifies certain fields.
		*
		* Bytes in the transaction can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the transaction within the SDK, and base64 should be used for the final transaction to be send over GRPC.
		*
		* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the transaction. Can be either base64 encoded or Uint8Array.
		* @param {BaseTransaction<PayloadBytesTypes>} source - The transaction to copy. It can be using either bytes types.
		* @param {(tx: TxnData<T>) => void} configure - A function that takes in a `TxnData` object and sets fields on it.
		* @returns {BaseTransaction<T>} - A new instance of the `BaseTransaction` class.
		*/
		function copy(source, configure) {
			return Txn$1.create((tx) => {
				tx.body = source.body;
				tx.signature = source.signature;
				tx.body = source.body;
				tx.sender = source.sender;
				tx.serialization = source.serialization;
				configure(tx);
			});
		}
		Txn$1.copy = copy;
	})(Txn || (exports.Txn = Txn = {}));
} });

//#endregion
//#region ../../node_modules/.pnpm/jssha@3.3.1/node_modules/jssha/dist/sha.js
var require_sha = __commonJS({ "../../node_modules/.pnpm/jssha@3.3.1/node_modules/jssha/dist/sha.js"(exports, module) {
	/**
	* A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
	* and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
	*
	* Copyright 2008-2023 Brian Turek, 1998-2009 Paul Johnston & Contributors
	* Distributed under the BSD License
	* See http://caligatio.github.com/jsSHA/ for more information
	*
	* Two ECMAScript polyfill functions carry the following license:
	*
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
	* the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
	*
	* THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED,
	* INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	* MERCHANTABLITY OR NON-INFRINGEMENT.
	*
	* See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.
	*/
	(function(n, r) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
	})(void 0, function() {
		"use strict";
		var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "ARRAYBUFFER not supported by this environment", t = "UINT8ARRAY not supported by this environment";
		function e(n$1, r$1, t$1, e$1) {
			var i$1, o$1, u$1, f$1 = r$1 || [0], s$2 = (t$1 = t$1 || 0) >>> 3, w$2 = -1 === e$1 ? 3 : 0;
			for (i$1 = 0; i$1 < n$1.length; i$1 += 1) o$1 = (u$1 = i$1 + s$2) >>> 2, f$1.length <= o$1 && f$1.push(0), f$1[o$1] |= n$1[i$1] << 8 * (w$2 + e$1 * (u$1 % 4));
			return {
				value: f$1,
				binLen: 8 * n$1.length + t$1
			};
		}
		function i(i$1, o$1, u$1) {
			switch (o$1) {
				case "UTF8":
				case "UTF16BE":
				case "UTF16LE": break;
				default: throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
			}
			switch (i$1) {
				case "HEX": return function(n$1, r$1, t$1) {
					return function(n$2, r$2, t$2, e$1) {
						var i$2, o$2, u$2, f$1;
						if (0 != n$2.length % 2) throw new Error("String of HEX type must be in byte increments");
						var s$2 = r$2 || [0], w$2 = (t$2 = t$2 || 0) >>> 3, a$1 = -1 === e$1 ? 3 : 0;
						for (i$2 = 0; i$2 < n$2.length; i$2 += 2) {
							if (o$2 = parseInt(n$2.substr(i$2, 2), 16), isNaN(o$2)) throw new Error("String of HEX type contains invalid characters");
							for (u$2 = (f$1 = (i$2 >>> 1) + w$2) >>> 2; s$2.length <= u$2;) s$2.push(0);
							s$2[u$2] |= o$2 << 8 * (a$1 + e$1 * (f$1 % 4));
						}
						return {
							value: s$2,
							binLen: 4 * n$2.length + t$2
						};
					}(n$1, r$1, t$1, u$1);
				};
				case "TEXT": return function(n$1, r$1, t$1) {
					return function(n$2, r$2, t$2, e$1, i$2) {
						var o$2, u$2, f$1, s$2, w$2, a$1, h$2, c$1, v$1 = 0, A$1 = t$2 || [0], E$1 = (e$1 = e$1 || 0) >>> 3;
						if ("UTF8" === r$2) for (h$2 = -1 === i$2 ? 3 : 0, f$1 = 0; f$1 < n$2.length; f$1 += 1) for (u$2 = [], 128 > (o$2 = n$2.charCodeAt(f$1)) ? u$2.push(o$2) : 2048 > o$2 ? (u$2.push(192 | o$2 >>> 6), u$2.push(128 | 63 & o$2)) : 55296 > o$2 || 57344 <= o$2 ? u$2.push(224 | o$2 >>> 12, 128 | o$2 >>> 6 & 63, 128 | 63 & o$2) : (f$1 += 1, o$2 = 65536 + ((1023 & o$2) << 10 | 1023 & n$2.charCodeAt(f$1)), u$2.push(240 | o$2 >>> 18, 128 | o$2 >>> 12 & 63, 128 | o$2 >>> 6 & 63, 128 | 63 & o$2)), s$2 = 0; s$2 < u$2.length; s$2 += 1) {
							for (w$2 = (a$1 = v$1 + E$1) >>> 2; A$1.length <= w$2;) A$1.push(0);
							A$1[w$2] |= u$2[s$2] << 8 * (h$2 + i$2 * (a$1 % 4)), v$1 += 1;
						}
						else for (h$2 = -1 === i$2 ? 2 : 0, c$1 = "UTF16LE" === r$2 && 1 !== i$2 || "UTF16LE" !== r$2 && 1 === i$2, f$1 = 0; f$1 < n$2.length; f$1 += 1) {
							for (o$2 = n$2.charCodeAt(f$1), !0 === c$1 && (o$2 = (s$2 = 255 & o$2) << 8 | o$2 >>> 8), w$2 = (a$1 = v$1 + E$1) >>> 2; A$1.length <= w$2;) A$1.push(0);
							A$1[w$2] |= o$2 << 8 * (h$2 + i$2 * (a$1 % 4)), v$1 += 2;
						}
						return {
							value: A$1,
							binLen: 8 * v$1 + e$1
						};
					}(n$1, o$1, r$1, t$1, u$1);
				};
				case "B64": return function(r$1, t$1, e$1) {
					return function(r$2, t$2, e$2, i$2) {
						var o$2, u$2, f$1, s$2, w$2, a$1, h$2 = 0, c$1 = t$2 || [0], v$1 = (e$2 = e$2 || 0) >>> 3, A$1 = -1 === i$2 ? 3 : 0, E$1 = r$2.indexOf("=");
						if (-1 === r$2.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
						if (r$2 = r$2.replace(/=/g, ""), -1 !== E$1 && E$1 < r$2.length) throw new Error("Invalid '=' found in base-64 string");
						for (o$2 = 0; o$2 < r$2.length; o$2 += 4) {
							for (s$2 = r$2.substr(o$2, 4), f$1 = 0, u$2 = 0; u$2 < s$2.length; u$2 += 1) f$1 |= n.indexOf(s$2.charAt(u$2)) << 18 - 6 * u$2;
							for (u$2 = 0; u$2 < s$2.length - 1; u$2 += 1) {
								for (w$2 = (a$1 = h$2 + v$1) >>> 2; c$1.length <= w$2;) c$1.push(0);
								c$1[w$2] |= (f$1 >>> 16 - 8 * u$2 & 255) << 8 * (A$1 + i$2 * (a$1 % 4)), h$2 += 1;
							}
						}
						return {
							value: c$1,
							binLen: 8 * h$2 + e$2
						};
					}(r$1, t$1, e$1, u$1);
				};
				case "BYTES": return function(n$1, r$1, t$1) {
					return function(n$2, r$2, t$2, e$1) {
						var i$2, o$2, u$2, f$1, s$2 = r$2 || [0], w$2 = (t$2 = t$2 || 0) >>> 3, a$1 = -1 === e$1 ? 3 : 0;
						for (o$2 = 0; o$2 < n$2.length; o$2 += 1) i$2 = n$2.charCodeAt(o$2), u$2 = (f$1 = o$2 + w$2) >>> 2, s$2.length <= u$2 && s$2.push(0), s$2[u$2] |= i$2 << 8 * (a$1 + e$1 * (f$1 % 4));
						return {
							value: s$2,
							binLen: 8 * n$2.length + t$2
						};
					}(n$1, r$1, t$1, u$1);
				};
				case "ARRAYBUFFER":
					try {
						new ArrayBuffer(0);
					} catch (n$1) {
						throw new Error(r);
					}
					return function(n$1, r$1, t$1) {
						return function(n$2, r$2, t$2, i$2) {
							return e(new Uint8Array(n$2), r$2, t$2, i$2);
						}(n$1, r$1, t$1, u$1);
					};
				case "UINT8ARRAY":
					try {
						new Uint8Array(0);
					} catch (n$1) {
						throw new Error(t);
					}
					return function(n$1, r$1, t$1) {
						return e(n$1, r$1, t$1, u$1);
					};
				default: throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
			}
		}
		function o(e$1, i$1, o$1, u$1) {
			switch (e$1) {
				case "HEX": return function(n$1) {
					return function(n$2, r$1, t$1, e$2) {
						var i$2, o$2, u$2 = "0123456789abcdef", f$1 = "", s$2 = r$1 / 8, w$2 = -1 === t$1 ? 3 : 0;
						for (i$2 = 0; i$2 < s$2; i$2 += 1) o$2 = n$2[i$2 >>> 2] >>> 8 * (w$2 + t$1 * (i$2 % 4)), f$1 += u$2.charAt(o$2 >>> 4 & 15) + u$2.charAt(15 & o$2);
						return e$2.outputUpper ? f$1.toUpperCase() : f$1;
					}(n$1, i$1, o$1, u$1);
				};
				case "B64": return function(r$1) {
					return function(r$2, t$1, e$2, i$2) {
						var o$2, u$2, f$1, s$2, w$2, a$1 = "", h$2 = t$1 / 8, c$1 = -1 === e$2 ? 3 : 0;
						for (o$2 = 0; o$2 < h$2; o$2 += 3) for (s$2 = o$2 + 1 < h$2 ? r$2[o$2 + 1 >>> 2] : 0, w$2 = o$2 + 2 < h$2 ? r$2[o$2 + 2 >>> 2] : 0, f$1 = (r$2[o$2 >>> 2] >>> 8 * (c$1 + e$2 * (o$2 % 4)) & 255) << 16 | (s$2 >>> 8 * (c$1 + e$2 * ((o$2 + 1) % 4)) & 255) << 8 | w$2 >>> 8 * (c$1 + e$2 * ((o$2 + 2) % 4)) & 255, u$2 = 0; u$2 < 4; u$2 += 1) a$1 += 8 * o$2 + 6 * u$2 <= t$1 ? n.charAt(f$1 >>> 6 * (3 - u$2) & 63) : i$2.b64Pad;
						return a$1;
					}(r$1, i$1, o$1, u$1);
				};
				case "BYTES": return function(n$1) {
					return function(n$2, r$1, t$1) {
						var e$2, i$2, o$2 = "", u$2 = r$1 / 8, f$1 = -1 === t$1 ? 3 : 0;
						for (e$2 = 0; e$2 < u$2; e$2 += 1) i$2 = n$2[e$2 >>> 2] >>> 8 * (f$1 + t$1 * (e$2 % 4)) & 255, o$2 += String.fromCharCode(i$2);
						return o$2;
					}(n$1, i$1, o$1);
				};
				case "ARRAYBUFFER":
					try {
						new ArrayBuffer(0);
					} catch (n$1) {
						throw new Error(r);
					}
					return function(n$1) {
						return function(n$2, r$1, t$1) {
							var e$2, i$2 = r$1 / 8, o$2 = new ArrayBuffer(i$2), u$2 = new Uint8Array(o$2), f$1 = -1 === t$1 ? 3 : 0;
							for (e$2 = 0; e$2 < i$2; e$2 += 1) u$2[e$2] = n$2[e$2 >>> 2] >>> 8 * (f$1 + t$1 * (e$2 % 4)) & 255;
							return o$2;
						}(n$1, i$1, o$1);
					};
				case "UINT8ARRAY":
					try {
						new Uint8Array(0);
					} catch (n$1) {
						throw new Error(t);
					}
					return function(n$1) {
						return function(n$2, r$1, t$1) {
							var e$2, i$2 = r$1 / 8, o$2 = -1 === t$1 ? 3 : 0, u$2 = new Uint8Array(i$2);
							for (e$2 = 0; e$2 < i$2; e$2 += 1) u$2[e$2] = n$2[e$2 >>> 2] >>> 8 * (o$2 + t$1 * (e$2 % 4)) & 255;
							return u$2;
						}(n$1, i$1, o$1);
					};
				default: throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
			}
		}
		var u = 4294967296, f = [
			1116352408,
			1899447441,
			3049323471,
			3921009573,
			961987163,
			1508970993,
			2453635748,
			2870763221,
			3624381080,
			310598401,
			607225278,
			1426881987,
			1925078388,
			2162078206,
			2614888103,
			3248222580,
			3835390401,
			4022224774,
			264347078,
			604807628,
			770255983,
			1249150122,
			1555081692,
			1996064986,
			2554220882,
			2821834349,
			2952996808,
			3210313671,
			3336571891,
			3584528711,
			113926993,
			338241895,
			666307205,
			773529912,
			1294757372,
			1396182291,
			1695183700,
			1986661051,
			2177026350,
			2456956037,
			2730485921,
			2820302411,
			3259730800,
			3345764771,
			3516065817,
			3600352804,
			4094571909,
			275423344,
			430227734,
			506948616,
			659060556,
			883997877,
			958139571,
			1322822218,
			1537002063,
			1747873779,
			1955562222,
			2024104815,
			2227730452,
			2361852424,
			2428436474,
			2756734187,
			3204031479,
			3329325298
		], s$1 = [
			3238371032,
			914150663,
			812702999,
			4144912697,
			4290775857,
			1750603025,
			1694076839,
			3204075428
		], w$1 = [
			1779033703,
			3144134277,
			1013904242,
			2773480762,
			1359893119,
			2600822924,
			528734635,
			1541459225
		], a = "Chosen SHA variant is not supported", h$1 = "Cannot set numRounds with MAC";
		function c(n$1, r$1) {
			var t$1, e$1, i$1 = n$1.binLen >>> 3, o$1 = r$1.binLen >>> 3, u$1 = i$1 << 3, f$1 = 4 - i$1 << 3;
			if (i$1 % 4 != 0) {
				for (t$1 = 0; t$1 < o$1; t$1 += 4) e$1 = i$1 + t$1 >>> 2, n$1.value[e$1] |= r$1.value[t$1 >>> 2] << u$1, n$1.value.push(0), n$1.value[e$1 + 1] |= r$1.value[t$1 >>> 2] >>> f$1;
				return (n$1.value.length << 2) - 4 >= o$1 + i$1 && n$1.value.pop(), {
					value: n$1.value,
					binLen: n$1.binLen + r$1.binLen
				};
			}
			return {
				value: n$1.value.concat(r$1.value),
				binLen: n$1.binLen + r$1.binLen
			};
		}
		function v(n$1) {
			var r$1 = {
				outputUpper: !1,
				b64Pad: "=",
				outputLen: -1
			}, t$1 = n$1 || {}, e$1 = "Output length must be a multiple of 8";
			if (r$1.outputUpper = t$1.outputUpper || !1, t$1.b64Pad && (r$1.b64Pad = t$1.b64Pad), t$1.outputLen) {
				if (t$1.outputLen % 8 != 0) throw new Error(e$1);
				r$1.outputLen = t$1.outputLen;
			} else if (t$1.shakeLen) {
				if (t$1.shakeLen % 8 != 0) throw new Error(e$1);
				r$1.outputLen = t$1.shakeLen;
			}
			if ("boolean" != typeof r$1.outputUpper) throw new Error("Invalid outputUpper formatting option");
			if ("string" != typeof r$1.b64Pad) throw new Error("Invalid b64Pad formatting option");
			return r$1;
		}
		function A(n$1, r$1, t$1, e$1) {
			var o$1 = n$1 + " must include a value and format";
			if (!r$1) {
				if (!e$1) throw new Error(o$1);
				return e$1;
			}
			if (void 0 === r$1.value || !r$1.format) throw new Error(o$1);
			return i(r$1.format, r$1.encoding || "UTF8", t$1)(r$1.value);
		}
		var E = function() {
			function n$1(n$2, r$1, t$1) {
				var e$1 = t$1 || {};
				if (this.t = r$1, this.i = e$1.encoding || "UTF8", this.numRounds = e$1.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
				this.o = n$2, this.u = [], this.h = 0, this.v = !1, this.A = 0, this.l = !1, this.S = [], this.H = [];
			}
			return n$1.prototype.update = function(n$2) {
				var r$1, t$1 = 0, e$1 = this.p >>> 5, i$1 = this.m(n$2, this.u, this.h), o$1 = i$1.binLen, u$1 = i$1.value, f$1 = o$1 >>> 5;
				for (r$1 = 0; r$1 < f$1; r$1 += e$1) t$1 + this.p <= o$1 && (this.U = this.R(u$1.slice(r$1, r$1 + e$1), this.U), t$1 += this.p);
				return this.A += t$1, this.u = u$1.slice(t$1 >>> 5), this.h = o$1 % this.p, this.v = !0, this;
			}, n$1.prototype.getHash = function(n$2, r$1) {
				var t$1, e$1, i$1 = this.T, u$1 = v(r$1);
				if (this.C) {
					if (-1 === u$1.outputLen) throw new Error("Output length must be specified in options");
					i$1 = u$1.outputLen;
				}
				var f$1 = o(n$2, i$1, this.F, u$1);
				if (this.l && this.K) return f$1(this.K(u$1));
				for (e$1 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), i$1), t$1 = 1; t$1 < this.numRounds; t$1 += 1) this.C && i$1 % 32 != 0 && (e$1[e$1.length - 1] &= 16777215 >>> 24 - i$1 % 32), e$1 = this.g(e$1, i$1, 0, this.B(this.o), i$1);
				return f$1(e$1);
			}, n$1.prototype.setHMACKey = function(n$2, r$1, t$1) {
				if (!this.k) throw new Error("Variant does not support HMAC");
				if (this.v) throw new Error("Cannot set MAC key after calling update");
				var e$1 = i(r$1, (t$1 || {}).encoding || "UTF8", this.F);
				this.Y(e$1(n$2));
			}, n$1.prototype.Y = function(n$2) {
				var r$1, t$1 = this.p >>> 3, e$1 = t$1 / 4 - 1;
				if (1 !== this.numRounds) throw new Error(h$1);
				if (this.l) throw new Error("MAC key already set");
				for (t$1 < n$2.binLen / 8 && (n$2.value = this.g(n$2.value, n$2.binLen, 0, this.B(this.o), this.T)); n$2.value.length <= e$1;) n$2.value.push(0);
				for (r$1 = 0; r$1 <= e$1; r$1 += 1) this.S[r$1] = 909522486 ^ n$2.value[r$1], this.H[r$1] = 1549556828 ^ n$2.value[r$1];
				this.U = this.R(this.S, this.U), this.A = this.p, this.l = !0;
			}, n$1.prototype.getHMAC = function(n$2, r$1) {
				var t$1 = v(r$1);
				return o(n$2, this.T, this.F, t$1)(this.N());
			}, n$1.prototype.N = function() {
				var n$2;
				if (!this.l) throw new Error("Cannot call getHMAC without first setting MAC key");
				var r$1 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), this.T);
				return n$2 = this.R(this.H, this.B(this.o)), n$2 = this.g(r$1, this.T, this.p, n$2, this.T);
			}, n$1;
		}(), l = function(n$1, r$1) {
			return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n$2, r$2) {
				n$2.__proto__ = r$2;
			} || function(n$2, r$2) {
				for (var t$1 in r$2) Object.prototype.hasOwnProperty.call(r$2, t$1) && (n$2[t$1] = r$2[t$1]);
			}, l(n$1, r$1);
		};
		function b(n$1, r$1) {
			if ("function" != typeof r$1 && null !== r$1) throw new TypeError("Class extends value " + String(r$1) + " is not a constructor or null");
			function t$1() {
				this.constructor = n$1;
			}
			l(n$1, r$1), n$1.prototype = null === r$1 ? Object.create(r$1) : (t$1.prototype = r$1.prototype, new t$1());
		}
		function S(n$1, r$1) {
			return n$1 << r$1 | n$1 >>> 32 - r$1;
		}
		function H(n$1, r$1) {
			return n$1 >>> r$1 | n$1 << 32 - r$1;
		}
		function d$1(n$1, r$1) {
			return n$1 >>> r$1;
		}
		function p(n$1, r$1, t$1) {
			return n$1 ^ r$1 ^ t$1;
		}
		function y$1(n$1, r$1, t$1) {
			return n$1 & r$1 ^ ~n$1 & t$1;
		}
		function m$1(n$1, r$1, t$1) {
			return n$1 & r$1 ^ n$1 & t$1 ^ r$1 & t$1;
		}
		function U(n$1) {
			return H(n$1, 2) ^ H(n$1, 13) ^ H(n$1, 22);
		}
		function R(n$1, r$1) {
			var t$1 = (65535 & n$1) + (65535 & r$1);
			return (65535 & (n$1 >>> 16) + (r$1 >>> 16) + (t$1 >>> 16)) << 16 | 65535 & t$1;
		}
		function T(n$1, r$1, t$1, e$1) {
			var i$1 = (65535 & n$1) + (65535 & r$1) + (65535 & t$1) + (65535 & e$1);
			return (65535 & (n$1 >>> 16) + (r$1 >>> 16) + (t$1 >>> 16) + (e$1 >>> 16) + (i$1 >>> 16)) << 16 | 65535 & i$1;
		}
		function C(n$1, r$1, t$1, e$1, i$1) {
			var o$1 = (65535 & n$1) + (65535 & r$1) + (65535 & t$1) + (65535 & e$1) + (65535 & i$1);
			return (65535 & (n$1 >>> 16) + (r$1 >>> 16) + (t$1 >>> 16) + (e$1 >>> 16) + (i$1 >>> 16) + (o$1 >>> 16)) << 16 | 65535 & o$1;
		}
		function F(n$1) {
			return H(n$1, 7) ^ H(n$1, 18) ^ d$1(n$1, 3);
		}
		function K$1(n$1) {
			return H(n$1, 6) ^ H(n$1, 11) ^ H(n$1, 25);
		}
		function g(n$1) {
			return [
				1732584193,
				4023233417,
				2562383102,
				271733878,
				3285377520
			];
		}
		function L(n$1, r$1) {
			var t$1, e$1, i$1, o$1, u$1, f$1, s$2, w$2 = [];
			for (t$1 = r$1[0], e$1 = r$1[1], i$1 = r$1[2], o$1 = r$1[3], u$1 = r$1[4], s$2 = 0; s$2 < 80; s$2 += 1) w$2[s$2] = s$2 < 16 ? n$1[s$2] : S(w$2[s$2 - 3] ^ w$2[s$2 - 8] ^ w$2[s$2 - 14] ^ w$2[s$2 - 16], 1), f$1 = s$2 < 20 ? C(S(t$1, 5), y$1(e$1, i$1, o$1), u$1, 1518500249, w$2[s$2]) : s$2 < 40 ? C(S(t$1, 5), p(e$1, i$1, o$1), u$1, 1859775393, w$2[s$2]) : s$2 < 60 ? C(S(t$1, 5), m$1(e$1, i$1, o$1), u$1, 2400959708, w$2[s$2]) : C(S(t$1, 5), p(e$1, i$1, o$1), u$1, 3395469782, w$2[s$2]), u$1 = o$1, o$1 = i$1, i$1 = S(e$1, 30), e$1 = t$1, t$1 = f$1;
			return r$1[0] = R(t$1, r$1[0]), r$1[1] = R(e$1, r$1[1]), r$1[2] = R(i$1, r$1[2]), r$1[3] = R(o$1, r$1[3]), r$1[4] = R(u$1, r$1[4]), r$1;
		}
		function B(n$1, r$1, t$1, e$1) {
			for (var i$1, o$1 = 15 + (r$1 + 65 >>> 9 << 4), f$1 = r$1 + t$1; n$1.length <= o$1;) n$1.push(0);
			for (n$1[r$1 >>> 5] |= 128 << 24 - r$1 % 32, n$1[o$1] = 4294967295 & f$1, n$1[o$1 - 1] = f$1 / u | 0, i$1 = 0; i$1 < n$1.length; i$1 += 16) e$1 = L(n$1.slice(i$1, i$1 + 16), e$1);
			return e$1;
		}
		"function" == typeof SuppressedError && SuppressedError;
		var k = function(n$1) {
			function r$1(r$2, t$1, e$1) {
				var o$1 = this;
				if ("SHA-1" !== r$2) throw new Error(a);
				var u$1 = e$1 || {};
				return (o$1 = n$1.call(this, r$2, t$1, e$1) || this).k = !0, o$1.K = o$1.N, o$1.F = -1, o$1.m = i(o$1.t, o$1.i, o$1.F), o$1.R = L, o$1.L = function(n$2) {
					return n$2.slice();
				}, o$1.B = g, o$1.g = B, o$1.U = [
					1732584193,
					4023233417,
					2562383102,
					271733878,
					3285377520
				], o$1.p = 512, o$1.T = 160, o$1.C = !1, u$1.hmacKey && o$1.Y(A("hmacKey", u$1.hmacKey, o$1.F)), o$1;
			}
			return b(r$1, n$1), r$1;
		}(E);
		function Y(n$1) {
			return "SHA-224" == n$1 ? s$1.slice() : w$1.slice();
		}
		function N(n$1, r$1) {
			var t$1, e$1, i$1, o$1, u$1, s$2, w$2, a$1, h$2, c$1, v$1, A$1, E$1 = [];
			for (t$1 = r$1[0], e$1 = r$1[1], i$1 = r$1[2], o$1 = r$1[3], u$1 = r$1[4], s$2 = r$1[5], w$2 = r$1[6], a$1 = r$1[7], v$1 = 0; v$1 < 64; v$1 += 1) E$1[v$1] = v$1 < 16 ? n$1[v$1] : T(H(A$1 = E$1[v$1 - 2], 17) ^ H(A$1, 19) ^ d$1(A$1, 10), E$1[v$1 - 7], F(E$1[v$1 - 15]), E$1[v$1 - 16]), h$2 = C(a$1, K$1(u$1), y$1(u$1, s$2, w$2), f[v$1], E$1[v$1]), c$1 = R(U(t$1), m$1(t$1, e$1, i$1)), a$1 = w$2, w$2 = s$2, s$2 = u$1, u$1 = R(o$1, h$2), o$1 = i$1, i$1 = e$1, e$1 = t$1, t$1 = R(h$2, c$1);
			return r$1[0] = R(t$1, r$1[0]), r$1[1] = R(e$1, r$1[1]), r$1[2] = R(i$1, r$1[2]), r$1[3] = R(o$1, r$1[3]), r$1[4] = R(u$1, r$1[4]), r$1[5] = R(s$2, r$1[5]), r$1[6] = R(w$2, r$1[6]), r$1[7] = R(a$1, r$1[7]), r$1;
		}
		var I = function(n$1) {
			function r$1(r$2, t$1, e$1) {
				var o$1 = this;
				if ("SHA-224" !== r$2 && "SHA-256" !== r$2) throw new Error(a);
				var f$1 = e$1 || {};
				return (o$1 = n$1.call(this, r$2, t$1, e$1) || this).K = o$1.N, o$1.k = !0, o$1.F = -1, o$1.m = i(o$1.t, o$1.i, o$1.F), o$1.R = N, o$1.L = function(n$2) {
					return n$2.slice();
				}, o$1.B = Y, o$1.g = function(n$2, t$2, e$2, i$1) {
					return function(n$3, r$3, t$3, e$3, i$2) {
						for (var o$2, f$2 = 15 + (r$3 + 65 >>> 9 << 4), s$2 = r$3 + t$3; n$3.length <= f$2;) n$3.push(0);
						for (n$3[r$3 >>> 5] |= 128 << 24 - r$3 % 32, n$3[f$2] = 4294967295 & s$2, n$3[f$2 - 1] = s$2 / u | 0, o$2 = 0; o$2 < n$3.length; o$2 += 16) e$3 = N(n$3.slice(o$2, o$2 + 16), e$3);
						return "SHA-224" === i$2 ? [
							e$3[0],
							e$3[1],
							e$3[2],
							e$3[3],
							e$3[4],
							e$3[5],
							e$3[6]
						] : e$3;
					}(n$2, t$2, e$2, i$1, r$2);
				}, o$1.U = Y(r$2), o$1.p = 512, o$1.T = "SHA-224" === r$2 ? 224 : 256, o$1.C = !1, f$1.hmacKey && o$1.Y(A("hmacKey", f$1.hmacKey, o$1.F)), o$1;
			}
			return b(r$1, n$1), r$1;
		}(E), M = function(n$1, r$1) {
			this.I = n$1, this.M = r$1;
		};
		function X(n$1, r$1) {
			var t$1;
			return r$1 > 32 ? (t$1 = 64 - r$1, new M(n$1.M << r$1 | n$1.I >>> t$1, n$1.I << r$1 | n$1.M >>> t$1)) : 0 !== r$1 ? (t$1 = 32 - r$1, new M(n$1.I << r$1 | n$1.M >>> t$1, n$1.M << r$1 | n$1.I >>> t$1)) : n$1;
		}
		function z(n$1, r$1) {
			var t$1;
			return r$1 < 32 ? (t$1 = 32 - r$1, new M(n$1.I >>> r$1 | n$1.M << t$1, n$1.M >>> r$1 | n$1.I << t$1)) : (t$1 = 64 - r$1, new M(n$1.M >>> r$1 | n$1.I << t$1, n$1.I >>> r$1 | n$1.M << t$1));
		}
		function O(n$1, r$1) {
			return new M(n$1.I >>> r$1, n$1.M >>> r$1 | n$1.I << 32 - r$1);
		}
		function j(n$1, r$1, t$1) {
			return new M(n$1.I & r$1.I ^ ~n$1.I & t$1.I, n$1.M & r$1.M ^ ~n$1.M & t$1.M);
		}
		function _(n$1, r$1, t$1) {
			return new M(n$1.I & r$1.I ^ n$1.I & t$1.I ^ r$1.I & t$1.I, n$1.M & r$1.M ^ n$1.M & t$1.M ^ r$1.M & t$1.M);
		}
		function x(n$1) {
			var r$1 = z(n$1, 28), t$1 = z(n$1, 34), e$1 = z(n$1, 39);
			return new M(r$1.I ^ t$1.I ^ e$1.I, r$1.M ^ t$1.M ^ e$1.M);
		}
		function P(n$1, r$1) {
			var t$1, e$1;
			t$1 = (65535 & n$1.M) + (65535 & r$1.M);
			var i$1 = (65535 & (e$1 = (n$1.M >>> 16) + (r$1.M >>> 16) + (t$1 >>> 16))) << 16 | 65535 & t$1;
			return t$1 = (65535 & n$1.I) + (65535 & r$1.I) + (e$1 >>> 16), e$1 = (n$1.I >>> 16) + (r$1.I >>> 16) + (t$1 >>> 16), new M((65535 & e$1) << 16 | 65535 & t$1, i$1);
		}
		function V(n$1, r$1, t$1, e$1) {
			var i$1, o$1;
			i$1 = (65535 & n$1.M) + (65535 & r$1.M) + (65535 & t$1.M) + (65535 & e$1.M);
			var u$1 = (65535 & (o$1 = (n$1.M >>> 16) + (r$1.M >>> 16) + (t$1.M >>> 16) + (e$1.M >>> 16) + (i$1 >>> 16))) << 16 | 65535 & i$1;
			return i$1 = (65535 & n$1.I) + (65535 & r$1.I) + (65535 & t$1.I) + (65535 & e$1.I) + (o$1 >>> 16), o$1 = (n$1.I >>> 16) + (r$1.I >>> 16) + (t$1.I >>> 16) + (e$1.I >>> 16) + (i$1 >>> 16), new M((65535 & o$1) << 16 | 65535 & i$1, u$1);
		}
		function Z(n$1, r$1, t$1, e$1, i$1) {
			var o$1, u$1;
			o$1 = (65535 & n$1.M) + (65535 & r$1.M) + (65535 & t$1.M) + (65535 & e$1.M) + (65535 & i$1.M);
			var f$1 = (65535 & (u$1 = (n$1.M >>> 16) + (r$1.M >>> 16) + (t$1.M >>> 16) + (e$1.M >>> 16) + (i$1.M >>> 16) + (o$1 >>> 16))) << 16 | 65535 & o$1;
			return o$1 = (65535 & n$1.I) + (65535 & r$1.I) + (65535 & t$1.I) + (65535 & e$1.I) + (65535 & i$1.I) + (u$1 >>> 16), u$1 = (n$1.I >>> 16) + (r$1.I >>> 16) + (t$1.I >>> 16) + (e$1.I >>> 16) + (i$1.I >>> 16) + (o$1 >>> 16), new M((65535 & u$1) << 16 | 65535 & o$1, f$1);
		}
		function q(n$1, r$1) {
			return new M(n$1.I ^ r$1.I, n$1.M ^ r$1.M);
		}
		function D(n$1) {
			var r$1 = z(n$1, 1), t$1 = z(n$1, 8), e$1 = O(n$1, 7);
			return new M(r$1.I ^ t$1.I ^ e$1.I, r$1.M ^ t$1.M ^ e$1.M);
		}
		function G(n$1) {
			var r$1 = z(n$1, 14), t$1 = z(n$1, 18), e$1 = z(n$1, 41);
			return new M(r$1.I ^ t$1.I ^ e$1.I, r$1.M ^ t$1.M ^ e$1.M);
		}
		var J = [
			new M(f[0], 3609767458),
			new M(f[1], 602891725),
			new M(f[2], 3964484399),
			new M(f[3], 2173295548),
			new M(f[4], 4081628472),
			new M(f[5], 3053834265),
			new M(f[6], 2937671579),
			new M(f[7], 3664609560),
			new M(f[8], 2734883394),
			new M(f[9], 1164996542),
			new M(f[10], 1323610764),
			new M(f[11], 3590304994),
			new M(f[12], 4068182383),
			new M(f[13], 991336113),
			new M(f[14], 633803317),
			new M(f[15], 3479774868),
			new M(f[16], 2666613458),
			new M(f[17], 944711139),
			new M(f[18], 2341262773),
			new M(f[19], 2007800933),
			new M(f[20], 1495990901),
			new M(f[21], 1856431235),
			new M(f[22], 3175218132),
			new M(f[23], 2198950837),
			new M(f[24], 3999719339),
			new M(f[25], 766784016),
			new M(f[26], 2566594879),
			new M(f[27], 3203337956),
			new M(f[28], 1034457026),
			new M(f[29], 2466948901),
			new M(f[30], 3758326383),
			new M(f[31], 168717936),
			new M(f[32], 1188179964),
			new M(f[33], 1546045734),
			new M(f[34], 1522805485),
			new M(f[35], 2643833823),
			new M(f[36], 2343527390),
			new M(f[37], 1014477480),
			new M(f[38], 1206759142),
			new M(f[39], 344077627),
			new M(f[40], 1290863460),
			new M(f[41], 3158454273),
			new M(f[42], 3505952657),
			new M(f[43], 106217008),
			new M(f[44], 3606008344),
			new M(f[45], 1432725776),
			new M(f[46], 1467031594),
			new M(f[47], 851169720),
			new M(f[48], 3100823752),
			new M(f[49], 1363258195),
			new M(f[50], 3750685593),
			new M(f[51], 3785050280),
			new M(f[52], 3318307427),
			new M(f[53], 3812723403),
			new M(f[54], 2003034995),
			new M(f[55], 3602036899),
			new M(f[56], 1575990012),
			new M(f[57], 1125592928),
			new M(f[58], 2716904306),
			new M(f[59], 442776044),
			new M(f[60], 593698344),
			new M(f[61], 3733110249),
			new M(f[62], 2999351573),
			new M(f[63], 3815920427),
			new M(3391569614, 3928383900),
			new M(3515267271, 566280711),
			new M(3940187606, 3454069534),
			new M(4118630271, 4000239992),
			new M(116418474, 1914138554),
			new M(174292421, 2731055270),
			new M(289380356, 3203993006),
			new M(460393269, 320620315),
			new M(685471733, 587496836),
			new M(852142971, 1086792851),
			new M(1017036298, 365543100),
			new M(1126000580, 2618297676),
			new M(1288033470, 3409855158),
			new M(1501505948, 4234509866),
			new M(1607167915, 987167468),
			new M(1816402316, 1246189591)
		];
		function Q(n$1) {
			return "SHA-384" === n$1 ? [
				new M(3418070365, s$1[0]),
				new M(1654270250, s$1[1]),
				new M(2438529370, s$1[2]),
				new M(355462360, s$1[3]),
				new M(1731405415, s$1[4]),
				new M(41048885895, s$1[5]),
				new M(3675008525, s$1[6]),
				new M(1203062813, s$1[7])
			] : [
				new M(w$1[0], 4089235720),
				new M(w$1[1], 2227873595),
				new M(w$1[2], 4271175723),
				new M(w$1[3], 1595750129),
				new M(w$1[4], 2917565137),
				new M(w$1[5], 725511199),
				new M(w$1[6], 4215389547),
				new M(w$1[7], 327033209)
			];
		}
		function W(n$1, r$1) {
			var t$1, e$1, i$1, o$1, u$1, f$1, s$2, w$2, a$1, h$2, c$1, v$1, A$1, E$1, l$1, b$1, S$1 = [];
			for (t$1 = r$1[0], e$1 = r$1[1], i$1 = r$1[2], o$1 = r$1[3], u$1 = r$1[4], f$1 = r$1[5], s$2 = r$1[6], w$2 = r$1[7], c$1 = 0; c$1 < 80; c$1 += 1) c$1 < 16 ? (v$1 = 2 * c$1, S$1[c$1] = new M(n$1[v$1], n$1[v$1 + 1])) : S$1[c$1] = V((A$1 = S$1[c$1 - 2], E$1 = void 0, l$1 = void 0, b$1 = void 0, E$1 = z(A$1, 19), l$1 = z(A$1, 61), b$1 = O(A$1, 6), new M(E$1.I ^ l$1.I ^ b$1.I, E$1.M ^ l$1.M ^ b$1.M)), S$1[c$1 - 7], D(S$1[c$1 - 15]), S$1[c$1 - 16]), a$1 = Z(w$2, G(u$1), j(u$1, f$1, s$2), J[c$1], S$1[c$1]), h$2 = P(x(t$1), _(t$1, e$1, i$1)), w$2 = s$2, s$2 = f$1, f$1 = u$1, u$1 = P(o$1, a$1), o$1 = i$1, i$1 = e$1, e$1 = t$1, t$1 = P(a$1, h$2);
			return r$1[0] = P(t$1, r$1[0]), r$1[1] = P(e$1, r$1[1]), r$1[2] = P(i$1, r$1[2]), r$1[3] = P(o$1, r$1[3]), r$1[4] = P(u$1, r$1[4]), r$1[5] = P(f$1, r$1[5]), r$1[6] = P(s$2, r$1[6]), r$1[7] = P(w$2, r$1[7]), r$1;
		}
		var $ = function(n$1) {
			function r$1(r$2, t$1, e$1) {
				var o$1 = this;
				if ("SHA-384" !== r$2 && "SHA-512" !== r$2) throw new Error(a);
				var f$1 = e$1 || {};
				return (o$1 = n$1.call(this, r$2, t$1, e$1) || this).K = o$1.N, o$1.k = !0, o$1.F = -1, o$1.m = i(o$1.t, o$1.i, o$1.F), o$1.R = W, o$1.L = function(n$2) {
					return n$2.slice();
				}, o$1.B = Q, o$1.g = function(n$2, t$2, e$2, i$1) {
					return function(n$3, r$3, t$3, e$3, i$2) {
						for (var o$2, f$2 = 31 + (r$3 + 129 >>> 10 << 5), s$2 = r$3 + t$3; n$3.length <= f$2;) n$3.push(0);
						for (n$3[r$3 >>> 5] |= 128 << 24 - r$3 % 32, n$3[f$2] = 4294967295 & s$2, n$3[f$2 - 1] = s$2 / u | 0, o$2 = 0; o$2 < n$3.length; o$2 += 32) e$3 = W(n$3.slice(o$2, o$2 + 32), e$3);
						return "SHA-384" === i$2 ? [
							e$3[0].I,
							e$3[0].M,
							e$3[1].I,
							e$3[1].M,
							e$3[2].I,
							e$3[2].M,
							e$3[3].I,
							e$3[3].M,
							e$3[4].I,
							e$3[4].M,
							e$3[5].I,
							e$3[5].M
						] : [
							e$3[0].I,
							e$3[0].M,
							e$3[1].I,
							e$3[1].M,
							e$3[2].I,
							e$3[2].M,
							e$3[3].I,
							e$3[3].M,
							e$3[4].I,
							e$3[4].M,
							e$3[5].I,
							e$3[5].M,
							e$3[6].I,
							e$3[6].M,
							e$3[7].I,
							e$3[7].M
						];
					}(n$2, t$2, e$2, i$1, r$2);
				}, o$1.U = Q(r$2), o$1.p = 1024, o$1.T = "SHA-384" === r$2 ? 384 : 512, o$1.C = !1, f$1.hmacKey && o$1.Y(A("hmacKey", f$1.hmacKey, o$1.F)), o$1;
			}
			return b(r$1, n$1), r$1;
		}(E), nn = [
			new M(0, 1),
			new M(0, 32898),
			new M(2147483648, 32906),
			new M(2147483648, 2147516416),
			new M(0, 32907),
			new M(0, 2147483649),
			new M(2147483648, 2147516545),
			new M(2147483648, 32777),
			new M(0, 138),
			new M(0, 136),
			new M(0, 2147516425),
			new M(0, 2147483658),
			new M(0, 2147516555),
			new M(2147483648, 139),
			new M(2147483648, 32905),
			new M(2147483648, 32771),
			new M(2147483648, 32770),
			new M(2147483648, 128),
			new M(0, 32778),
			new M(2147483648, 2147483658),
			new M(2147483648, 2147516545),
			new M(2147483648, 32896),
			new M(0, 2147483649),
			new M(2147483648, 2147516424)
		], rn = [
			[
				0,
				36,
				3,
				41,
				18
			],
			[
				1,
				44,
				10,
				45,
				2
			],
			[
				62,
				6,
				43,
				15,
				61
			],
			[
				28,
				55,
				25,
				21,
				56
			],
			[
				27,
				20,
				39,
				8,
				14
			]
		];
		function tn(n$1) {
			var r$1, t$1 = [];
			for (r$1 = 0; r$1 < 5; r$1 += 1) t$1[r$1] = [
				new M(0, 0),
				new M(0, 0),
				new M(0, 0),
				new M(0, 0),
				new M(0, 0)
			];
			return t$1;
		}
		function en(n$1) {
			var r$1, t$1 = [];
			for (r$1 = 0; r$1 < 5; r$1 += 1) t$1[r$1] = n$1[r$1].slice();
			return t$1;
		}
		function on(n$1, r$1) {
			var t$1, e$1, i$1, o$1, u$1, f$1, s$2, w$2, a$1, h$2 = [], c$1 = [];
			if (null !== n$1) for (e$1 = 0; e$1 < n$1.length; e$1 += 2) r$1[(e$1 >>> 1) % 5][(e$1 >>> 1) / 5 | 0] = q(r$1[(e$1 >>> 1) % 5][(e$1 >>> 1) / 5 | 0], new M(n$1[e$1 + 1], n$1[e$1]));
			for (t$1 = 0; t$1 < 24; t$1 += 1) {
				for (o$1 = tn(), e$1 = 0; e$1 < 5; e$1 += 1) h$2[e$1] = (u$1 = r$1[e$1][0], f$1 = r$1[e$1][1], s$2 = r$1[e$1][2], w$2 = r$1[e$1][3], a$1 = r$1[e$1][4], new M(u$1.I ^ f$1.I ^ s$2.I ^ w$2.I ^ a$1.I, u$1.M ^ f$1.M ^ s$2.M ^ w$2.M ^ a$1.M));
				for (e$1 = 0; e$1 < 5; e$1 += 1) c$1[e$1] = q(h$2[(e$1 + 4) % 5], X(h$2[(e$1 + 1) % 5], 1));
				for (e$1 = 0; e$1 < 5; e$1 += 1) for (i$1 = 0; i$1 < 5; i$1 += 1) r$1[e$1][i$1] = q(r$1[e$1][i$1], c$1[e$1]);
				for (e$1 = 0; e$1 < 5; e$1 += 1) for (i$1 = 0; i$1 < 5; i$1 += 1) o$1[i$1][(2 * e$1 + 3 * i$1) % 5] = X(r$1[e$1][i$1], rn[e$1][i$1]);
				for (e$1 = 0; e$1 < 5; e$1 += 1) for (i$1 = 0; i$1 < 5; i$1 += 1) r$1[e$1][i$1] = q(o$1[e$1][i$1], new M(~o$1[(e$1 + 1) % 5][i$1].I & o$1[(e$1 + 2) % 5][i$1].I, ~o$1[(e$1 + 1) % 5][i$1].M & o$1[(e$1 + 2) % 5][i$1].M));
				r$1[0][0] = q(r$1[0][0], nn[t$1]);
			}
			return r$1;
		}
		function un(n$1) {
			var r$1, t$1, e$1 = 0, i$1 = [0, 0], o$1 = [4294967295 & n$1, n$1 / u & 2097151];
			for (r$1 = 6; r$1 >= 0; r$1--) 0 === (t$1 = o$1[r$1 >> 2] >>> 8 * r$1 & 255) && 0 === e$1 || (i$1[e$1 + 1 >> 2] |= t$1 << 8 * (e$1 + 1), e$1 += 1);
			return e$1 = 0 !== e$1 ? e$1 : 1, i$1[0] |= e$1, {
				value: e$1 + 1 > 4 ? i$1 : [i$1[0]],
				binLen: 8 + 8 * e$1
			};
		}
		function fn(n$1) {
			return c(un(n$1.binLen), n$1);
		}
		function sn(n$1, r$1) {
			var t$1, e$1 = un(r$1), i$1 = r$1 >>> 2, o$1 = (i$1 - (e$1 = c(e$1, n$1)).value.length % i$1) % i$1;
			for (t$1 = 0; t$1 < o$1; t$1++) e$1.value.push(0);
			return e$1.value;
		}
		var wn = function(n$1) {
			function r$1(r$2, t$1, e$1) {
				var o$1 = this, u$1 = 6, f$1 = 0, s$2 = e$1 || {};
				if (1 !== (o$1 = n$1.call(this, r$2, t$1, e$1) || this).numRounds) {
					if (s$2.kmacKey || s$2.hmacKey) throw new Error(h$1);
					if ("CSHAKE128" === o$1.o || "CSHAKE256" === o$1.o) throw new Error("Cannot set numRounds for CSHAKE variants");
				}
				switch (o$1.F = 1, o$1.m = i(o$1.t, o$1.i, o$1.F), o$1.R = on, o$1.L = en, o$1.B = tn, o$1.U = tn(), o$1.C = !1, r$2) {
					case "SHA3-224":
						o$1.p = f$1 = 1152, o$1.T = 224, o$1.k = !0, o$1.K = o$1.N;
						break;
					case "SHA3-256":
						o$1.p = f$1 = 1088, o$1.T = 256, o$1.k = !0, o$1.K = o$1.N;
						break;
					case "SHA3-384":
						o$1.p = f$1 = 832, o$1.T = 384, o$1.k = !0, o$1.K = o$1.N;
						break;
					case "SHA3-512":
						o$1.p = f$1 = 576, o$1.T = 512, o$1.k = !0, o$1.K = o$1.N;
						break;
					case "SHAKE128":
						u$1 = 31, o$1.p = f$1 = 1344, o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = null;
						break;
					case "SHAKE256":
						u$1 = 31, o$1.p = f$1 = 1088, o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = null;
						break;
					case "KMAC128":
						u$1 = 4, o$1.p = f$1 = 1344, o$1.X(e$1), o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = o$1.O;
						break;
					case "KMAC256":
						u$1 = 4, o$1.p = f$1 = 1088, o$1.X(e$1), o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = o$1.O;
						break;
					case "CSHAKE128":
						o$1.p = f$1 = 1344, u$1 = o$1.j(e$1), o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = null;
						break;
					case "CSHAKE256":
						o$1.p = f$1 = 1088, u$1 = o$1.j(e$1), o$1.T = -1, o$1.C = !0, o$1.k = !1, o$1.K = null;
						break;
					default: throw new Error(a);
				}
				return o$1.g = function(n$2, r$3, t$2, e$2, i$1) {
					return function(n$3, r$4, t$3, e$3, i$2, o$2, u$2) {
						var f$2, s$3, w$2 = 0, a$1 = [], h$2 = i$2 >>> 5, c$1 = r$4 >>> 5;
						for (f$2 = 0; f$2 < c$1 && r$4 >= i$2; f$2 += h$2) e$3 = on(n$3.slice(f$2, f$2 + h$2), e$3), r$4 -= i$2;
						for (n$3 = n$3.slice(f$2), r$4 %= i$2; n$3.length < h$2;) n$3.push(0);
						for (n$3[(f$2 = r$4 >>> 3) >> 2] ^= o$2 << f$2 % 4 * 8, n$3[h$2 - 1] ^= 2147483648, e$3 = on(n$3, e$3); 32 * a$1.length < u$2 && (s$3 = e$3[w$2 % 5][w$2 / 5 | 0], a$1.push(s$3.M), !(32 * a$1.length >= u$2));) a$1.push(s$3.I), 0 == 64 * (w$2 += 1) % i$2 && (on(null, e$3), w$2 = 0);
						return a$1;
					}(n$2, r$3, 0, e$2, f$1, u$1, i$1);
				}, s$2.hmacKey && o$1.Y(A("hmacKey", s$2.hmacKey, o$1.F)), o$1;
			}
			return b(r$1, n$1), r$1.prototype.j = function(n$2, r$2) {
				var t$1 = function(n$3) {
					var r$3 = n$3 || {};
					return {
						funcName: A("funcName", r$3.funcName, 1, {
							value: [],
							binLen: 0
						}),
						customization: A("Customization", r$3.customization, 1, {
							value: [],
							binLen: 0
						})
					};
				}(n$2 || {});
				r$2 && (t$1.funcName = r$2);
				var e$1 = c(fn(t$1.funcName), fn(t$1.customization));
				if (0 !== t$1.customization.binLen || 0 !== t$1.funcName.binLen) {
					for (var i$1 = sn(e$1, this.p >>> 3), o$1 = 0; o$1 < i$1.length; o$1 += this.p >>> 5) this.U = this.R(i$1.slice(o$1, o$1 + (this.p >>> 5)), this.U), this.A += this.p;
					return 4;
				}
				return 31;
			}, r$1.prototype.X = function(n$2) {
				var r$2 = function(n$3) {
					var r$3 = n$3 || {};
					return {
						kmacKey: A("kmacKey", r$3.kmacKey, 1),
						funcName: {
							value: [1128353099],
							binLen: 32
						},
						customization: A("Customization", r$3.customization, 1, {
							value: [],
							binLen: 0
						})
					};
				}(n$2 || {});
				this.j(n$2, r$2.funcName);
				for (var t$1 = sn(fn(r$2.kmacKey), this.p >>> 3), e$1 = 0; e$1 < t$1.length; e$1 += this.p >>> 5) this.U = this.R(t$1.slice(e$1, e$1 + (this.p >>> 5)), this.U), this.A += this.p;
				this.l = !0;
			}, r$1.prototype.O = function(n$2) {
				var r$2 = c({
					value: this.u.slice(),
					binLen: this.h
				}, function(n$3) {
					var r$3, t$1, e$1 = 0, i$1 = [0, 0], o$1 = [4294967295 & n$3, n$3 / u & 2097151];
					for (r$3 = 6; r$3 >= 0; r$3--) 0 == (t$1 = o$1[r$3 >> 2] >>> 8 * r$3 & 255) && 0 === e$1 || (i$1[e$1 >> 2] |= t$1 << 8 * e$1, e$1 += 1);
					return i$1[(e$1 = 0 !== e$1 ? e$1 : 1) >> 2] |= e$1 << 8 * e$1, {
						value: e$1 + 1 > 4 ? i$1 : [i$1[0]],
						binLen: 8 + 8 * e$1
					};
				}(n$2.outputLen));
				return this.g(r$2.value, r$2.binLen, this.A, this.L(this.U), n$2.outputLen);
			}, r$1;
		}(E);
		return function() {
			function n$1(n$2, r$1, t$1) {
				if ("SHA-1" == n$2) this._ = new k(n$2, r$1, t$1);
				else if ("SHA-224" == n$2 || "SHA-256" == n$2) this._ = new I(n$2, r$1, t$1);
				else if ("SHA-384" == n$2 || "SHA-512" == n$2) this._ = new $(n$2, r$1, t$1);
				else {
					if ("SHA3-224" != n$2 && "SHA3-256" != n$2 && "SHA3-384" != n$2 && "SHA3-512" != n$2 && "SHAKE128" != n$2 && "SHAKE256" != n$2 && "CSHAKE128" != n$2 && "CSHAKE256" != n$2 && "KMAC128" != n$2 && "KMAC256" != n$2) throw new Error(a);
					this._ = new wn(n$2, r$1, t$1);
				}
			}
			return n$1.prototype.update = function(n$2) {
				return this._.update(n$2), this;
			}, n$1.prototype.getHash = function(n$2, r$1) {
				return this._.getHash(n$2, r$1);
			}, n$1.prototype.setHMACKey = function(n$2, r$1, t$1) {
				this._.setHMACKey(n$2, r$1, t$1);
			}, n$1.prototype.getHMAC = function(n$2, r$1) {
				return this._.getHMAC(n$2, r$1);
			}, n$1;
		}();
	});
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/crypto.js
var require_crypto = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/crypto.js"(exports) {
	var __importDefault$3 = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sha256BytesToBytes = exports.sha224BytesToString = exports.sha224StringToString = exports.sha384StringToBytes = exports.sha384BytesToBytes = exports.sha384BytesToString = exports.sha384StringToString = void 0;
	const jssha_1 = __importDefault$3(require_sha());
	function sha384StringToString(message) {
		const shaObj = new jssha_1.default("SHA-384", "TEXT");
		shaObj.update(message);
		return shaObj.getHash("HEX");
	}
	exports.sha384StringToString = sha384StringToString;
	function sha384BytesToString(message) {
		const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
		shaObj.update(message);
		return shaObj.getHash("HEX");
	}
	exports.sha384BytesToString = sha384BytesToString;
	function sha384BytesToBytes(message) {
		const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
		shaObj.update(message);
		return shaObj.getHash("UINT8ARRAY");
	}
	exports.sha384BytesToBytes = sha384BytesToBytes;
	function sha384StringToBytes(message) {
		const shaObj = new jssha_1.default("SHA-384", "TEXT");
		shaObj.update(message);
		return shaObj.getHash("UINT8ARRAY");
	}
	exports.sha384StringToBytes = sha384StringToBytes;
	function sha224StringToString(message) {
		const shaObj = new jssha_1.default("SHA-224", "TEXT");
		shaObj.update(message);
		return shaObj.getHash("HEX");
	}
	exports.sha224StringToString = sha224StringToString;
	function sha224BytesToString(message) {
		const shaObj = new jssha_1.default("SHA-224", "UINT8ARRAY");
		shaObj.update(message);
		return shaObj.getHash("HEX");
	}
	exports.sha224BytesToString = sha224BytesToString;
	function sha256BytesToBytes(message) {
		const shaObj = new jssha_1.default("SHA-256", "UINT8ARRAY");
		shaObj.update(message);
		return shaObj.getHash("UINT8ARRAY");
	}
	exports.sha256BytesToBytes = sha256BytesToBytes;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/bytes.js
var require_bytes = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/bytes.js"(exports) {
	var __importDefault$2 = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prefixBytesLength = exports.numberToUint32BigEndian = exports.numberToUint16LittleEndian = exports.concatBytes = exports.numberToUint64LittleEndian = exports.uint16BigEndianToNumber = exports.numberToUint16BigEndian = void 0;
	const long_1 = __importDefault$2(require_umd());
	function numberToUint16BigEndian(num) {
		if (num < 0 || num > 65535 || !Number.isInteger(num)) throw new Error("Number is out of range for uint16");
		const buffer = new ArrayBuffer(2);
		const view = new DataView(buffer);
		view.setUint16(0, num, false);
		return new Uint8Array(buffer);
	}
	exports.numberToUint16BigEndian = numberToUint16BigEndian;
	function uint16BigEndianToNumber(uint16) {
		if (uint16.length !== 2) throw new Error("uint16 must be 2 bytes");
		const view = new DataView(uint16.buffer);
		return view.getUint16(0, false);
	}
	exports.uint16BigEndianToNumber = uint16BigEndianToNumber;
	function numberToUint64LittleEndian(num) {
		const longNum = long_1.default.fromNumber(num, true);
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		view.setUint32(0, longNum.low, true);
		view.setUint32(4, longNum.high, true);
		return new Uint8Array(buffer);
	}
	exports.numberToUint64LittleEndian = numberToUint64LittleEndian;
	function concatBytes(...arrays) {
		let totalLength = 0;
		for (const arr of arrays) totalLength += arr.length;
		const result = new Uint8Array(totalLength);
		let offset = 0;
		for (const arr of arrays) {
			result.set(arr, offset);
			offset += arr.length;
		}
		return result;
	}
	exports.concatBytes = concatBytes;
	function numberToUint16LittleEndian(number) {
		if (number < 0 || number > 65535 || !Number.isInteger(number)) throw new RangeError("The number must be an integer between 0 and 65535.");
		const buffer = new ArrayBuffer(2);
		const view = new DataView(buffer);
		view.setUint16(0, number, true);
		return new Uint8Array(buffer);
	}
	exports.numberToUint16LittleEndian = numberToUint16LittleEndian;
	function numberToUint32LittleEndian(number) {
		if (number < 0 || number > 4294967295 || !Number.isInteger(number)) throw new RangeError("The number must be an integer between 0 and 4294967295.");
		const buffer = new ArrayBuffer(4);
		const view = new DataView(buffer);
		view.setUint32(0, number, true);
		return new Uint8Array(buffer);
	}
	function numberToUint32BigEndian(number) {
		if (number < 0 || number > 4294967295 || !Number.isInteger(number)) throw new RangeError("The number must be an integer between 0 and 4294967295.");
		const buffer = new ArrayBuffer(4);
		const view = new DataView(buffer);
		view.setUint32(0, number, false);
		return new Uint8Array(buffer);
	}
	exports.numberToUint32BigEndian = numberToUint32BigEndian;
	function prefixBytesLength(bytes) {
		const lengthBytes = numberToUint32LittleEndian(bytes.length);
		return concatBytes(lengthBytes, bytes);
	}
	exports.prefixBytesLength = prefixBytesLength;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/max.js
var require_max = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/max.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/nil.js
var require_nil = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/nil.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = "00000000-0000-0000-0000-000000000000";
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/regex.js
var require_regex = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/regex.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/validate.js
var require_validate = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/validate.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const regex_js_1 = require_regex();
	function validate(uuid) {
		return typeof uuid === "string" && regex_js_1.default.test(uuid);
	}
	exports.default = validate;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/parse.js
var require_parse = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/parse.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_js_1$3 = require_validate();
	function parse(uuid) {
		if (!(0, validate_js_1$3.default)(uuid)) throw TypeError("Invalid UUID");
		let v;
		return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
	}
	exports.default = parse;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/stringify.js
var require_stringify = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/stringify.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unsafeStringify = void 0;
	const validate_js_1$2 = require_validate();
	const byteToHex = [];
	for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
	function unsafeStringify(arr, offset = 0) {
		return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
	}
	exports.unsafeStringify = unsafeStringify;
	function stringify(arr, offset = 0) {
		const uuid = unsafeStringify(arr, offset);
		if (!(0, validate_js_1$2.default)(uuid)) throw TypeError("Stringified UUID is invalid");
		return uuid;
	}
	exports.default = stringify;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/rng.js
var require_rng = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/rng.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const crypto_1$6 = __require("crypto");
	const rnds8Pool = new Uint8Array(256);
	let poolPtr = rnds8Pool.length;
	function rng() {
		if (poolPtr > rnds8Pool.length - 16) {
			(0, crypto_1$6.randomFillSync)(rnds8Pool);
			poolPtr = 0;
		}
		return rnds8Pool.slice(poolPtr, poolPtr += 16);
	}
	exports.default = rng;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v1.js
var require_v1 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v1.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.updateV1State = void 0;
	const rng_js_1$2 = require_rng();
	const stringify_js_1$7 = require_stringify();
	const _state$1 = {};
	function v1(options, buf, offset) {
		let bytes;
		const isV6 = options?._v6 ?? false;
		if (options) {
			const optionsKeys = Object.keys(options);
			if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") options = void 0;
		}
		if (options) bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1$2.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
		else {
			const now = Date.now();
			const rnds = (0, rng_js_1$2.default)();
			updateV1State(_state$1, now, rnds);
			bytes = v1Bytes(rnds, _state$1.msecs, _state$1.nsecs, isV6 ? void 0 : _state$1.clockseq, isV6 ? void 0 : _state$1.node, buf, offset);
		}
		return buf ?? (0, stringify_js_1$7.unsafeStringify)(bytes);
	}
	function updateV1State(state$1, now, rnds) {
		state$1.msecs ??= -Infinity;
		state$1.nsecs ??= 0;
		if (now === state$1.msecs) {
			state$1.nsecs++;
			if (state$1.nsecs >= 1e4) {
				state$1.node = void 0;
				state$1.nsecs = 0;
			}
		} else if (now > state$1.msecs) state$1.nsecs = 0;
		else if (now < state$1.msecs) state$1.node = void 0;
		if (!state$1.node) {
			state$1.node = rnds.slice(10, 16);
			state$1.node[0] |= 1;
			state$1.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
		}
		state$1.msecs = now;
		return state$1;
	}
	exports.updateV1State = updateV1State;
	function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
		if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
		if (!buf) {
			buf = new Uint8Array(16);
			offset = 0;
		} else if (offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
		msecs ??= Date.now();
		nsecs ??= 0;
		clockseq ??= (rnds[8] << 8 | rnds[9]) & 16383;
		node ??= rnds.slice(10, 16);
		msecs += 122192928e5;
		const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
		buf[offset++] = tl >>> 24 & 255;
		buf[offset++] = tl >>> 16 & 255;
		buf[offset++] = tl >>> 8 & 255;
		buf[offset++] = tl & 255;
		const tmh = msecs / 4294967296 * 1e4 & 268435455;
		buf[offset++] = tmh >>> 8 & 255;
		buf[offset++] = tmh & 255;
		buf[offset++] = tmh >>> 24 & 15 | 16;
		buf[offset++] = tmh >>> 16 & 255;
		buf[offset++] = clockseq >>> 8 | 128;
		buf[offset++] = clockseq & 255;
		for (let n = 0; n < 6; ++n) buf[offset++] = node[n];
		return buf;
	}
	exports.default = v1;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v1ToV6.js
var require_v1ToV6 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v1ToV6.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const parse_js_1$3 = require_parse();
	const stringify_js_1$6 = require_stringify();
	function v1ToV6(uuid) {
		const v1Bytes$1 = typeof uuid === "string" ? (0, parse_js_1$3.default)(uuid) : uuid;
		const v6Bytes = _v1ToV6(v1Bytes$1);
		return typeof uuid === "string" ? (0, stringify_js_1$6.unsafeStringify)(v6Bytes) : v6Bytes;
	}
	exports.default = v1ToV6;
	function _v1ToV6(v1Bytes$1) {
		return Uint8Array.of((v1Bytes$1[6] & 15) << 4 | v1Bytes$1[7] >> 4 & 15, (v1Bytes$1[7] & 15) << 4 | (v1Bytes$1[4] & 240) >> 4, (v1Bytes$1[4] & 15) << 4 | (v1Bytes$1[5] & 240) >> 4, (v1Bytes$1[5] & 15) << 4 | (v1Bytes$1[0] & 240) >> 4, (v1Bytes$1[0] & 15) << 4 | (v1Bytes$1[1] & 240) >> 4, (v1Bytes$1[1] & 15) << 4 | (v1Bytes$1[2] & 240) >> 4, 96 | v1Bytes$1[2] & 15, v1Bytes$1[3], v1Bytes$1[8], v1Bytes$1[9], v1Bytes$1[10], v1Bytes$1[11], v1Bytes$1[12], v1Bytes$1[13], v1Bytes$1[14], v1Bytes$1[15]);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/md5.js
var require_md5 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/md5.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const crypto_1$5 = __require("crypto");
	function md5(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
		else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return (0, crypto_1$5.createHash)("md5").update(bytes).digest();
	}
	exports.default = md5;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v35.js
var require_v35 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v35.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.URL = exports.DNS = exports.stringToBytes = void 0;
	const parse_js_1$2 = require_parse();
	const stringify_js_1$5 = require_stringify();
	function stringToBytes(str) {
		str = unescape(encodeURIComponent(str));
		const bytes = new Uint8Array(str.length);
		for (let i = 0; i < str.length; ++i) bytes[i] = str.charCodeAt(i);
		return bytes;
	}
	exports.stringToBytes = stringToBytes;
	exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
	exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
	function v35(version$1, hash$1, value, namespace, buf, offset) {
		const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
		const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1$2.default)(namespace) : namespace;
		if (typeof namespace === "string") namespace = (0, parse_js_1$2.default)(namespace);
		if (namespace?.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
		let bytes = new Uint8Array(16 + valueBytes.length);
		bytes.set(namespaceBytes);
		bytes.set(valueBytes, namespaceBytes.length);
		bytes = hash$1(bytes);
		bytes[6] = bytes[6] & 15 | version$1;
		bytes[8] = bytes[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
			return buf;
		}
		return (0, stringify_js_1$5.unsafeStringify)(bytes);
	}
	exports.default = v35;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v3.js
var require_v3 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v3.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.URL = exports.DNS = void 0;
	const md5_js_1 = require_md5();
	const v35_js_1$1 = require_v35();
	var v35_js_2$1 = require_v35();
	Object.defineProperty(exports, "DNS", {
		enumerable: true,
		get: function() {
			return v35_js_2$1.DNS;
		}
	});
	Object.defineProperty(exports, "URL", {
		enumerable: true,
		get: function() {
			return v35_js_2$1.URL;
		}
	});
	function v3(value, namespace, buf, offset) {
		return (0, v35_js_1$1.default)(48, md5_js_1.default, value, namespace, buf, offset);
	}
	v3.DNS = v35_js_1$1.DNS;
	v3.URL = v35_js_1$1.URL;
	exports.default = v3;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/native.js
var require_native = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/native.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const crypto_1$4 = __require("crypto");
	exports.default = { randomUUID: crypto_1$4.randomUUID };
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v4.js
var require_v4 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v4.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const native_js_1 = require_native();
	const rng_js_1$1 = require_rng();
	const stringify_js_1$4 = require_stringify();
	function v4(options, buf, offset) {
		if (native_js_1.default.randomUUID && !buf && !options) return native_js_1.default.randomUUID();
		options = options || {};
		const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1$1.default)();
		if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
		rnds[6] = rnds[6] & 15 | 64;
		rnds[8] = rnds[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			if (offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
			for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
			return buf;
		}
		return (0, stringify_js_1$4.unsafeStringify)(rnds);
	}
	exports.default = v4;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/sha1.js
var require_sha1 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/sha1.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const crypto_1$3 = __require("crypto");
	function sha1(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
		else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return (0, crypto_1$3.createHash)("sha1").update(bytes).digest();
	}
	exports.default = sha1;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v5.js
var require_v5 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v5.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.URL = exports.DNS = void 0;
	const sha1_js_1 = require_sha1();
	const v35_js_1 = require_v35();
	var v35_js_2 = require_v35();
	Object.defineProperty(exports, "DNS", {
		enumerable: true,
		get: function() {
			return v35_js_2.DNS;
		}
	});
	Object.defineProperty(exports, "URL", {
		enumerable: true,
		get: function() {
			return v35_js_2.URL;
		}
	});
	function v5(value, namespace, buf, offset) {
		return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace, buf, offset);
	}
	v5.DNS = v35_js_1.DNS;
	v5.URL = v35_js_1.URL;
	exports.default = v5;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v6.js
var require_v6 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v6.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const stringify_js_1$3 = require_stringify();
	const v1_js_1$1 = require_v1();
	const v1ToV6_js_1$1 = require_v1ToV6();
	function v6(options, buf, offset) {
		options ??= {};
		offset ??= 0;
		let bytes = (0, v1_js_1$1.default)({
			...options,
			_v6: true
		}, new Uint8Array(16));
		bytes = (0, v1ToV6_js_1$1.default)(bytes);
		if (buf) {
			for (let i = 0; i < 16; i++) buf[offset + i] = bytes[i];
			return buf;
		}
		return (0, stringify_js_1$3.unsafeStringify)(bytes);
	}
	exports.default = v6;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v6ToV1.js
var require_v6ToV1 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v6ToV1.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const parse_js_1$1 = require_parse();
	const stringify_js_1$2 = require_stringify();
	function v6ToV1(uuid) {
		const v6Bytes = typeof uuid === "string" ? (0, parse_js_1$1.default)(uuid) : uuid;
		const v1Bytes$1 = _v6ToV1(v6Bytes);
		return typeof uuid === "string" ? (0, stringify_js_1$2.unsafeStringify)(v1Bytes$1) : v1Bytes$1;
	}
	exports.default = v6ToV1;
	function _v6ToV1(v6Bytes) {
		return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v7.js
var require_v7 = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/v7.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.updateV7State = void 0;
	const rng_js_1 = require_rng();
	const stringify_js_1$1 = require_stringify();
	const _state = {};
	function v7(options, buf, offset) {
		let bytes;
		if (options) bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
		else {
			const now = Date.now();
			const rnds = (0, rng_js_1.default)();
			updateV7State(_state, now, rnds);
			bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
		}
		return buf ?? (0, stringify_js_1$1.unsafeStringify)(bytes);
	}
	function updateV7State(state$1, now, rnds) {
		state$1.msecs ??= -Infinity;
		state$1.seq ??= 0;
		if (now > state$1.msecs) {
			state$1.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
			state$1.msecs = now;
		} else {
			state$1.seq = state$1.seq + 1 | 0;
			if (state$1.seq === 0) state$1.msecs++;
		}
		return state$1;
	}
	exports.updateV7State = updateV7State;
	function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
		if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
		if (!buf) {
			buf = new Uint8Array(16);
			offset = 0;
		} else if (offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
		msecs ??= Date.now();
		seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
		buf[offset++] = msecs / 1099511627776 & 255;
		buf[offset++] = msecs / 4294967296 & 255;
		buf[offset++] = msecs / 16777216 & 255;
		buf[offset++] = msecs / 65536 & 255;
		buf[offset++] = msecs / 256 & 255;
		buf[offset++] = msecs & 255;
		buf[offset++] = 112 | seq >>> 28 & 15;
		buf[offset++] = seq >>> 20 & 255;
		buf[offset++] = 128 | seq >>> 14 & 63;
		buf[offset++] = seq >>> 6 & 255;
		buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
		buf[offset++] = rnds[11];
		buf[offset++] = rnds[12];
		buf[offset++] = rnds[13];
		buf[offset++] = rnds[14];
		buf[offset++] = rnds[15];
		return buf;
	}
	exports.default = v7;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/version.js
var require_version = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/version.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const validate_js_1$1 = require_validate();
	function version(uuid) {
		if (!(0, validate_js_1$1.default)(uuid)) throw TypeError("Invalid UUID");
		return parseInt(uuid.slice(14, 15), 16);
	}
	exports.default = version;
} });

//#endregion
//#region ../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/index.js
var require_cjs = __commonJS({ "../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
	var max_js_1 = require_max();
	Object.defineProperty(exports, "MAX", {
		enumerable: true,
		get: function() {
			return max_js_1.default;
		}
	});
	var nil_js_1 = require_nil();
	Object.defineProperty(exports, "NIL", {
		enumerable: true,
		get: function() {
			return nil_js_1.default;
		}
	});
	var parse_js_1 = require_parse();
	Object.defineProperty(exports, "parse", {
		enumerable: true,
		get: function() {
			return parse_js_1.default;
		}
	});
	var stringify_js_1 = require_stringify();
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return stringify_js_1.default;
		}
	});
	var v1_js_1 = require_v1();
	Object.defineProperty(exports, "v1", {
		enumerable: true,
		get: function() {
			return v1_js_1.default;
		}
	});
	var v1ToV6_js_1 = require_v1ToV6();
	Object.defineProperty(exports, "v1ToV6", {
		enumerable: true,
		get: function() {
			return v1ToV6_js_1.default;
		}
	});
	var v3_js_1 = require_v3();
	Object.defineProperty(exports, "v3", {
		enumerable: true,
		get: function() {
			return v3_js_1.default;
		}
	});
	var v4_js_1 = require_v4();
	Object.defineProperty(exports, "v4", {
		enumerable: true,
		get: function() {
			return v4_js_1.default;
		}
	});
	var v5_js_1 = require_v5();
	Object.defineProperty(exports, "v5", {
		enumerable: true,
		get: function() {
			return v5_js_1.default;
		}
	});
	var v6_js_1 = require_v6();
	Object.defineProperty(exports, "v6", {
		enumerable: true,
		get: function() {
			return v6_js_1.default;
		}
	});
	var v6ToV1_js_1 = require_v6ToV1();
	Object.defineProperty(exports, "v6ToV1", {
		enumerable: true,
		get: function() {
			return v6ToV1_js_1.default;
		}
	});
	var v7_js_1 = require_v7();
	Object.defineProperty(exports, "v7", {
		enumerable: true,
		get: function() {
			return v7_js_1.default;
		}
	});
	var validate_js_1 = require_validate();
	Object.defineProperty(exports, "validate", {
		enumerable: true,
		get: function() {
			return validate_js_1.default;
		}
	});
	var version_js_1 = require_version();
	Object.defineProperty(exports, "version", {
		enumerable: true,
		get: function() {
			return version_js_1.default;
		}
	});
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/uuid.js
var require_uuid = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/uuid.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.convertUuidToBytes = exports.isUuid = void 0;
	const uuid_1$2 = require_cjs();
	function isUuid(value) {
		return (0, uuid_1$2.validate)(value);
	}
	exports.isUuid = isUuid;
	function convertUuidToBytes(uuid) {
		return (0, uuid_1$2.parse)(uuid);
	}
	exports.convertUuidToBytes = convertUuidToBytes;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/kwilEncoding.js
var require_kwilEncoding = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/kwilEncoding.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.encodeValue = exports.encodeTransfer = exports.encodeRawStatement = exports.encodeActionExecution = exports.encodeActionCall = exports.encodeAccountId = void 0;
	const base64_1$3 = require_base64();
	const bytes_1$1 = require_bytes();
	const serial_1$8 = require_serial();
	const uuid_1$1 = require_uuid();
	const enums_1$7 = require_enums();
	function encodeAccountId(accountId) {
		const encodedId = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.hexToBytes)(accountId.identifier));
		const encodedKeyType = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(accountId.key_type));
		return (0, bytes_1$1.concatBytes)(encodedId, encodedKeyType);
	}
	exports.encodeAccountId = encodeAccountId;
	function encodeActionCall(actionCall) {
		const actionCallVersion = 0;
		const encodedVersion = (0, bytes_1$1.numberToUint16LittleEndian)(actionCallVersion);
		const encodedDbId = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(actionCall.dbid));
		const encodedAction = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(actionCall.action));
		const encodedNumArgs = (0, bytes_1$1.numberToUint16LittleEndian)(actionCall.arguments ? actionCall.arguments.length : 0);
		let actionArguments = new Uint8Array();
		actionCall.arguments?.forEach((a) => {
			const aBytes = encodeEncodedValue(a);
			const prefixedABytes = (0, bytes_1$1.prefixBytesLength)(aBytes);
			actionArguments = (0, bytes_1$1.concatBytes)(actionArguments, prefixedABytes);
		});
		const encodedActionArguments = (0, bytes_1$1.concatBytes)(encodedNumArgs, actionArguments);
		return (0, base64_1$3.bytesToBase64)((0, bytes_1$1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
	}
	exports.encodeActionCall = encodeActionCall;
	function encodeActionExecution(action) {
		const actionExecutionVersion = 0;
		const encodedVersion = (0, bytes_1$1.numberToUint16LittleEndian)(actionExecutionVersion);
		const encodedDbId = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(action.dbid));
		const encodedAction = (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(action.action));
		const encodedNumArgs = (0, bytes_1$1.numberToUint16LittleEndian)(action.arguments ? action.arguments.length : 0);
		let actionArguments = new Uint8Array();
		action.arguments?.forEach((encodedValues) => {
			const argLength = (0, bytes_1$1.numberToUint16LittleEndian)(encodedValues.length);
			let argBytes = new Uint8Array();
			encodedValues.forEach((value) => {
				const evBytes = encodeEncodedValue(value);
				const prefixedEvBytes = (0, bytes_1$1.prefixBytesLength)(evBytes);
				argBytes = (0, bytes_1$1.concatBytes)(argBytes, prefixedEvBytes);
			});
			actionArguments = (0, bytes_1$1.concatBytes)(actionArguments, argLength, argBytes);
		});
		const encodedActionArguments = (0, bytes_1$1.concatBytes)(encodedNumArgs, actionArguments);
		return (0, base64_1$3.bytesToBase64)((0, bytes_1$1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
	}
	exports.encodeActionExecution = encodeActionExecution;
	function encodeRawStatement(statement) {
		const rawStatementVersion = 0;
		const encodedVersion = (0, bytes_1$1.numberToUint16LittleEndian)(rawStatementVersion);
		const statementBytes = (0, serial_1$8.stringToBytes)(statement.statement);
		const encodedStatement = (0, bytes_1$1.prefixBytesLength)(statementBytes);
		let encodedParameters;
		encodedParameters = (0, bytes_1$1.numberToUint16LittleEndian)(statement.parameters ? statement.parameters.length : 0);
		for (const param of statement.parameters) {
			const nameBytes = (0, serial_1$8.stringToBytes)(param.name);
			const prefixedNameBytes = (0, bytes_1$1.prefixBytesLength)(nameBytes);
			const valueBytes = encodeEncodedValue(param.value);
			const valueBytesPrefix = (0, bytes_1$1.prefixBytesLength)(valueBytes);
			encodedParameters = (0, bytes_1$1.concatBytes)(encodedParameters, prefixedNameBytes, valueBytesPrefix);
		}
		return (0, base64_1$3.bytesToBase64)((0, bytes_1$1.concatBytes)(encodedVersion, encodedStatement, encodedParameters));
	}
	exports.encodeRawStatement = encodeRawStatement;
	function encodeTransfer(transfer) {
		const transferVersion = 0;
		const encodedVersion = (0, bytes_1$1.numberToUint16LittleEndian)(transferVersion);
		const encodedTo = (0, bytes_1$1.prefixBytesLength)(encodeAccountId(transfer.to));
		const encodedAmount = (0, bytes_1$1.concatBytes)(new Uint8Array([1]), (0, bytes_1$1.prefixBytesLength)((0, serial_1$8.stringToBytes)(transfer.amount.toString())));
		return (0, base64_1$3.bytesToBase64)((0, bytes_1$1.concatBytes)(encodedVersion, encodedTo, encodedAmount));
	}
	exports.encodeTransfer = encodeTransfer;
	function encodeEncodedValue(ev) {
		const evVersion = 0;
		const encodedVersion = (0, bytes_1$1.numberToUint16LittleEndian)(evVersion);
		const dataTypeBytes = encodeDataType(ev.type);
		const encodedType = (0, bytes_1$1.prefixBytesLength)(dataTypeBytes);
		const dataLength = (0, bytes_1$1.numberToUint16LittleEndian)(ev.data.length);
		let encodedData = (0, bytes_1$1.concatBytes)(dataLength);
		for (const data of ev.data) encodedData = (0, bytes_1$1.concatBytes)(encodedData, (0, bytes_1$1.prefixBytesLength)(data));
		return (0, bytes_1$1.concatBytes)(encodedVersion, encodedType, encodedData);
	}
	function encodeDataType(dt) {
		const dtVersion = 0;
		const versionBytes = (0, bytes_1$1.numberToUint16BigEndian)(dtVersion);
		const nameBytes = (0, serial_1$8.stringToBytes)(dt.name);
		const nameLength = (0, bytes_1$1.numberToUint32BigEndian)(nameBytes.length);
		const isArray$1 = (0, serial_1$8.booleanToBytes)(dt.is_array);
		const metadataLength = (0, bytes_1$1.numberToUint16BigEndian)(dt.metadata?.[0] || 0);
		const precisionLength = (0, bytes_1$1.numberToUint16BigEndian)(dt.metadata?.[1] || 0);
		return (0, bytes_1$1.concatBytes)(versionBytes, nameLength, nameBytes, isArray$1, metadataLength, precisionLength);
	}
	function encodeValue(value, o) {
		if (o) return overrideValue(value, o);
		if (typeof value === "string" && (0, uuid_1$1.isUuid)(value)) return encodeNotNull((0, uuid_1$1.convertUuidToBytes)(value));
		if (value === null) return encodeNull();
		if (value instanceof Uint8Array) return encodeNotNull(value);
		if (typeof value === "number" && isDecimal(value)) return encodeNotNull((0, serial_1$8.stringToBytes)(value.toString()));
		switch (typeof value) {
			case "string": return encodeNotNull((0, serial_1$8.stringToBytes)(value));
			case "boolean": return encodeNotNull((0, serial_1$8.booleanToBytes)(value));
			case "number": return encodeNotNull((0, serial_1$8.numberToBytes)(value));
			case "undefined": return encodeNull();
			case "bigint": throw new Error("bigint not supported. convert to string.");
			default: throw new Error("invalid scalar value");
		}
	}
	exports.encodeValue = encodeValue;
	function overrideValue(v, o) {
		if (v === null || v === void 0) return encodeNull();
		switch (o) {
			case enums_1$7.VarType.NULL: return encodeNull();
			case enums_1$7.VarType.TEXT: return encodeNotNull((0, serial_1$8.stringToBytes)(v));
			case enums_1$7.VarType.INT8: return encodeNotNull((0, serial_1$8.numberToBytes)(v));
			case enums_1$7.VarType.BOOL: return encodeNotNull((0, serial_1$8.booleanToBytes)(v));
			case enums_1$7.VarType.NUMERIC: return encodeNotNull((0, serial_1$8.stringToBytes)(v.toString()));
			case enums_1$7.VarType.UUID: return encodeNotNull((0, uuid_1$1.convertUuidToBytes)(v));
			case enums_1$7.VarType.BYTEA: return encodeNotNull(v);
			default: throw new Error("invalid scalar value");
		}
	}
	function isDecimal(n) {
		const numStr = Math.abs(n).toString();
		const decimalIdx = numStr.indexOf(".");
		return decimalIdx !== -1;
	}
	function encodeNull() {
		return new Uint8Array([0]);
	}
	function encodeNotNull(v) {
		const bytes = new Uint8Array(v.length + 1);
		bytes[0] = 1;
		bytes.set(v, 1);
		return bytes;
	}
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/transaction/payloadTx.js
var require_payloadTx = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/transaction/payloadTx.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PayloadTx = void 0;
	const intern_1$1 = require_intern();
	const enums_1$6 = require_enums();
	const signature_1$3 = require_signature();
	const tx_1 = require_tx();
	const base64_1$2 = require_base64();
	const crypto_1$2 = require_crypto();
	const objects_1$3 = require_objects();
	const serial_1$7 = require_serial();
	const strings_1 = require_strings();
	const kwilEncoding_1$3 = require_kwilEncoding();
	/**
	* `Payload` class creates a transaction and call payloads that can be sent over GRPC.
	*/
	var PayloadTx = class PayloadTx {
		/**
		* Initializes a new `Payload` instance.
		*
		* @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
		*/
		constructor(kwil, options) {
			this.kwil = objects_1$3.objects.requireNonNil(kwil, "Client is required for TxnBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.");
			this.payload = objects_1$3.objects.requireNonNil(options.payload, "Payload is required for TxnBuilder. Please pass a valid payload.");
			objects_1$3.objects.validateOptionalFields(options, [
				"payloadType",
				"signer",
				"identifier",
				"signatureType",
				"chainId",
				"description",
				"nonce"
			]);
			this.payloadType = options.payloadType;
			this.signer = options.signer;
			this.identifier = options.identifier;
			this.signatureType = options.signatureType;
			this.chainId = options.chainId;
			this.description = options.description;
			this.nonce = options.nonce;
		}
		/**
		* Static factory method to create a new Payload instance.
		*
		* @param kwil - The Kwil client.
		* @param options - The options to configure the Payload instance.
		*/
		static createTx(kwil, options) {
			return new PayloadTx(kwil, options);
		}
		/**
		* Build the payload structure for a transaction.
		*/
		async buildTx() {
			const { signer, payloadType, identifier, signatureType, chainId } = objects_1$3.objects.validateFields({
				signer: this.signer,
				payloadType: this.payloadType,
				identifier: this.identifier,
				signatureType: this.signatureType,
				chainId: this.chainId
			}, (fieldName) => `${fieldName} is required to build a transaction.`);
			const preEstTxn = tx_1.Txn.create((tx) => {
				tx.body.payload = this.encodePayload(this.payloadType, this.payload);
				tx.body.type = payloadType;
				tx.sender = (0, serial_1$7.bytesToHex)(identifier);
			});
			const cost = await (0, intern_1$1.unwrap)(this.kwil)(preEstTxn);
			let nonce = this.nonce;
			if (!this.nonce) {
				const acct = await this.kwil.getAccount(identifier);
				nonce = Number(objects_1$3.objects.requireNonNil(acct.data?.nonce, "something went wrong retrieving your account nonce.")) + 1;
			}
			const encodedPayload = objects_1$3.objects.requireNonNil(preEstTxn.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
			const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx) => {
				tx.body.payload = (0, base64_1$2.base64ToBytes)(encodedPayload);
				tx.body.fee = BigInt(strings_1.strings.requireNonNil(cost.data, "something went wrong estimating the cost of your transaction."));
				tx.body.nonce = objects_1$3.objects.requireNonNil(nonce, "something went wrong retrieving your account nonce.");
				tx.body.chain_id = chainId;
			});
			if (this.signatureType === signature_1$3.SignatureType.SIGNATURE_TYPE_INVALID) throw new Error("Signature type is invalid.");
			return PayloadTx.signTx(postEstTxn, signer, identifier, signatureType, this.description);
		}
		/**
		* Signs the payload of a transaction / request to the broadcast GRPC endpoint.
		*
		* @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
		* @param {SignerSupplier} signer - The signer to be used to sign the transaction.
		* @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
		* @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
		* @param {string} description - The description to be included in the signature.
		* @returns {BaseTransaction} - A promise that resolves to the signed transaction.
		* @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
		*/
		static async signTx(tx, signer, identifier, signatureType, description) {
			const digest = (0, crypto_1$2.sha256BytesToBytes)(tx.body.payload).subarray(0, 20);
			/**
			* create the signature message
			* the signature message cannot have any preceding or succeeding white space. Must be exact length as server expects it
			*/
			const signatureMessage = `${description}

PayloadType: ${tx.body.type}
PayloadDigest: ${(0, serial_1$7.bytesToHex)(digest)}
Fee: ${tx.body.fee}
Nonce: ${tx.body.nonce}

Kwil Chain ID: ${tx.body.chain_id}
`;
			const signedMessage = await (0, signature_1$3.executeSign)((0, serial_1$7.stringToBytes)(signatureMessage), signer, signatureType);
			const encodedPayload = objects_1$3.objects.requireNonNil(tx.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
			return tx_1.Txn.copy(tx, (newTx) => {
				newTx.signature = {
					sig: (0, base64_1$2.bytesToBase64)(signedMessage),
					type: signatureType.toString()
				};
				newTx.body = {
					desc: description,
					payload: (0, base64_1$2.bytesToBase64)(encodedPayload),
					type: newTx.body.type,
					fee: newTx.body.fee?.toString() || "",
					nonce: newTx.body.nonce,
					chain_id: newTx.body.chain_id
				};
				newTx.sender = (0, serial_1$7.bytesToHex)(identifier);
				newTx.serialization = enums_1$6.SerializationType.SIGNED_MSG_CONCAT;
			});
		}
		encodePayload(payloadType, payload) {
			switch (payloadType) {
				case enums_1$6.PayloadType.EXECUTE_ACTION:
					if (!("action" in payload && "arguments" in payload)) throw new Error("Invalid payload type for EXECUTE_ACTION");
					return (0, kwilEncoding_1$3.encodeActionExecution)(payload);
				case enums_1$6.PayloadType.TRANSFER:
					if (!("to" in payload && "amount" in payload)) throw new Error("Invalid payload type for TRANSFER");
					return (0, kwilEncoding_1$3.encodeTransfer)(payload);
				case enums_1$6.PayloadType.RAW_STATEMENT:
					if (!("statement" in payload && "parameters" in payload)) throw new Error("Invalid payload type for RAW_STATEMENT");
					return (0, kwilEncoding_1$3.encodeRawStatement)(payload);
				default: throw new Error(`Unsupported payload type: ${payloadType}`);
			}
		}
	};
	exports.PayloadTx = PayloadTx;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/funder/funder.js
var require_funder = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/funder/funder.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Funder = void 0;
	const enums_1$5 = require_enums();
	const payloadTx_1$2 = require_payloadTx();
	const serial_1$6 = require_serial();
	var Funder = class {
		constructor(kwil, funderClient, chainId) {
			this.kwil = kwil;
			this.funderClient = funderClient;
			this.chainId = chainId;
		}
		async transfer(payload, signer, synchronous) {
			if (!payload.keyType) payload.keyType = enums_1$5.AccountKeyType.SECP256K1;
			if (payload.to instanceof Uint8Array) payload.to = (0, serial_1$6.bytesToHex)(payload.to);
			const txPayload = {
				to: {
					identifier: payload.to,
					key_type: payload.keyType
				},
				amount: payload.amount.toString()
			};
			const transaction = await payloadTx_1$2.PayloadTx.createTx(this.kwil, {
				chainId: this.chainId,
				description: payload.description || "",
				payload: txPayload,
				payloadType: enums_1$5.PayloadType.TRANSFER,
				identifier: signer.identifier,
				signer: signer.signer,
				signatureType: signer.signatureType
			}).buildTx();
			return await this.funderClient.broadcastClient(transaction, synchronous ? enums_1$5.BroadcastSyncType.COMMIT : enums_1$5.BroadcastSyncType.SYNC);
		}
	};
	exports.Funder = Funder;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/auth.js
var require_auth$1 = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/auth.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.verifyAuthProperties = exports.removeTrailingSlash = exports.generateSignatureText = exports.composeAuthMsg = void 0;
	function composeAuthMsg(authParam, domain, version$1, chainId) {
		let msg = "";
		msg += `${domain} wants you to sign in with your account:\n`;
		msg += `\n`;
		if (authParam.statement !== "") msg += `${authParam.statement}\n`;
		msg += "\n";
		msg += `URI: ${authParam.uri}\n`;
		msg += `Version: ${version$1}\n`;
		msg += `Chain ID: ${chainId}\n`;
		msg += `Nonce: ${authParam.nonce}\n`;
		msg += `Issue At: ${authParam.issue_at}\n`;
		msg += `Expiration Time: ${authParam.expiration_time}\n`;
		return msg;
	}
	exports.composeAuthMsg = composeAuthMsg;
	function generateSignatureText(namespace, action, digest, challenge) {
		let sigText = "Kwil view call.\n";
		sigText += "\n";
		sigText += `Namespace: ${namespace}\n`;
		sigText += `Method: ${action}\n`;
		sigText += `Digest: ${digest}\n`;
		sigText += `Challenge: ${challenge}\n`;
		return sigText;
	}
	exports.generateSignatureText = generateSignatureText;
	function removeTrailingSlash(url$2) {
		if (url$2.endsWith("/")) return url$2.slice(0, -1);
		return url$2;
	}
	exports.removeTrailingSlash = removeTrailingSlash;
	function verifyAuthProperties(authParm, domain, version$1, chainId) {
		if (authParm.domain && authParm.domain !== domain) throw new Error(`Domain mismatch: ${authParm.domain} !== ${domain}`);
		if (authParm.version && authParm.version !== version$1) throw new Error(`Version mismatch: ${authParm.version} !== ${version$1}`);
		if (authParm.chain_id && authParm.chain_id !== chainId) throw new Error(`Chain ID mismatch: ${authParm.chain_id} !== ${chainId}`);
	}
	exports.verifyAuthProperties = verifyAuthProperties;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/parameterEncoding.js
var require_parameterEncoding = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/parameterEncoding.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveValueType = exports.analyzeNumber = exports.encodeValueType = exports.encodeRawStatementParameters = exports.encodeParameters = void 0;
	const enums_1$4 = require_enums();
	const base64_1$1 = require_base64();
	const kwilEncoding_1$2 = require_kwilEncoding();
	const uuid_1 = require_uuid();
	function encodeParameters(params) {
		const encodedParams = {};
		Object.entries(params).forEach(([key$1, value]) => {
			encodedParams[key$1] = formatEncodedValueBase64(value);
		});
		return encodedParams;
	}
	exports.encodeParameters = encodeParameters;
	function formatEncodedValueBase64(val) {
		const base$1 = formatDataType(val);
		if (Array.isArray(val)) {
			const encodedValues = [];
			for (const v of val) encodedValues.push((0, base64_1$1.bytesToBase64)((0, kwilEncoding_1$2.encodeValue)(v)));
			return {
				type: base$1.type,
				data: encodedValues
			};
		}
		return {
			type: base$1.type,
			data: [(0, base64_1$1.bytesToBase64)((0, kwilEncoding_1$2.encodeValue)(base$1.data))]
		};
	}
	function encodeRawStatementParameters(params) {
		return Object.entries(params).map(([key$1, value]) => {
			const encodedValue = formatEncodedValue(value);
			return {
				name: key$1,
				value: encodedValue
			};
		});
	}
	exports.encodeRawStatementParameters = encodeRawStatementParameters;
	function formatEncodedValue(val, o) {
		const base$1 = formatDataType(val, o);
		if (Array.isArray(val)) {
			const encodedValues = [];
			for (const v of val) encodedValues.push((0, kwilEncoding_1$2.encodeValue)(v, o?.name));
			return {
				type: base$1.type,
				data: encodedValues
			};
		}
		return {
			type: base$1.type,
			data: [(0, kwilEncoding_1$2.encodeValue)(base$1.data, o?.name)]
		};
	}
	/**
	* Used when encoding values for an action
	* @param {ValueType[]} values - An array of input values to be executed by an action.
	* @returns formatted values used for an action
	*/
	function encodeValueType(values) {
		return values.map((val) => formatEncodedValue(val.v, val.o));
	}
	exports.encodeValueType = encodeValueType;
	function formatDataType(val, o) {
		if (o) return {
			type: o,
			data: val
		};
		const { metadata, varType } = resolveValueType(val);
		const dataType = {
			name: varType,
			is_array: Array.isArray(val),
			metadata
		};
		return {
			type: dataType,
			data: val
		};
	}
	function analyzeNumber(num) {
		const numStr = Math.abs(num).toString();
		const decimalIndex = numStr.indexOf(".");
		const hasDecimal = decimalIndex !== -1;
		const precision = hasDecimal ? numStr.length - 1 : numStr.length;
		const scale = hasDecimal ? numStr.length - decimalIndex - 1 : 0;
		return {
			hasDecimal,
			precision,
			scale
		};
	}
	exports.analyzeNumber = analyzeNumber;
	function resolveValueType(value) {
		if (Array.isArray(value)) return resolveValueType(value[0]);
		let metadata = [0, 0];
		let varType = enums_1$4.VarType.TEXT;
		switch (typeof value) {
			case "string":
				if ((0, uuid_1.isUuid)(value)) varType = enums_1$4.VarType.UUID;
				break;
			case "number":
				const numAnalysis = analyzeNumber(value);
				return {
					metadata: [numAnalysis.precision, numAnalysis.scale],
					varType: numAnalysis.hasDecimal ? enums_1$4.VarType.NUMERIC : enums_1$4.VarType.INT8
				};
			case "boolean":
				varType = enums_1$4.VarType.BOOL;
				break;
			case "object":
				if (value instanceof Uint8Array) {
					varType = enums_1$4.VarType.BYTEA;
					break;
				}
				if (value === null) {
					varType = enums_1$4.VarType.NULL;
					break;
				}
			case "undefined":
				varType = enums_1$4.VarType.NULL;
				break;
			default: throw new Error(`Unsupported type: ${typeof value}. If using a uuid, blob, or uint256, please convert to a JavaScript string.`);
		}
		return {
			metadata,
			varType
		};
	}
	exports.resolveValueType = resolveValueType;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/auth/auth.js
var require_auth = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/auth/auth.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Auth = void 0;
	const auth_1$1 = require_auth$1();
	const objects_1$2 = require_objects();
	const signature_1$2 = require_signature();
	const serial_1$5 = require_serial();
	const base64_1 = require_base64();
	const action_1$3 = require_action$1();
	const crypto_1$1 = require_crypto();
	const kwilEncoding_1$1 = require_kwilEncoding();
	const parameterEncoding_1$2 = require_parameterEncoding();
	var Auth = class {
		constructor(authClient, kwilProvider, chainId) {
			this.authClient = authClient;
			this.kwilProvider = kwilProvider;
			this.chainId = chainId;
		}
		/**
		* Authenticates a user with the Kwil Gateway (KGW). This is required to execute view actions with the `@kgw(authn='true')` annotation.
		*
		* This method should only be used if your Kwil Network is using the Kwil Gateway.
		*
		* @param {KwilSigner} signer - The signer for the authentication.
		* @returns A promise that resolves to the authentication success or failure.
		*/
		async authenticateKGW(signer) {
			const authParam = await this.authClient.getAuthenticateClient();
			const authProperties = objects_1$2.objects.requireNonNil(authParam.data, "something went wrong retrieving auth info from KGW");
			const domain = (0, auth_1$1.removeTrailingSlash)(this.kwilProvider);
			const version$1 = "1";
			(0, auth_1$1.verifyAuthProperties)(authProperties, domain, version$1, this.chainId);
			const msg = (0, auth_1$1.composeAuthMsg)(authProperties, domain, version$1, this.chainId);
			const signature = await (0, signature_1$2.executeSign)((0, serial_1$5.stringToBytes)(msg), signer.signer, signer.signatureType);
			const authBody = {
				nonce: authProperties.nonce,
				sender: (0, serial_1$5.bytesToHex)(signer.identifier),
				signature: {
					sig: (0, base64_1.bytesToBase64)(signature),
					type: signer.signatureType
				}
			};
			const res = await this.authClient.postAuthenticateClient(authBody);
			return res;
		}
		/**
		* Authenticates a user in private mode.
		*
		* This method should only be used if your Kwil Network is in private mode.
		*
		* @param {KwilSigner} signer - The signer for the authentication.
		* @param {CallBody} callBody - The body of the action to send. This should use the `ActionBody` interface.
		* @returns A promise that resolves a privateSignature => privateSignature = {sig: string (Base64), type: AnySignatureType}
		*/
		async authenticatePrivateMode(callBody, signer) {
			const challenge = await this.authClient.challengeClient();
			let msgChallenge = challenge.data;
			if (!msgChallenge) throw new Error("Challenge data is undefined. Something went wrong.");
			let inputs = {};
			if (callBody.inputs && action_1$3.transformActionInput.isActionInputArray(callBody.inputs)) inputs = action_1$3.transformActionInput.toSingleEntry(callBody.inputs);
			else if (callBody.inputs && action_1$3.transformPositionalParam.isPositionalParam(callBody.inputs)) inputs = action_1$3.transformPositionalParam.toNamedParam(callBody.inputs);
			else if (callBody.inputs) inputs = callBody.inputs;
			const actionValues = callBody?.inputs ? Object.values(inputs) : [];
			const value = (0, action_1$3.resolveParamTypes)(actionValues, callBody?.types);
			const payload = {
				dbid: callBody.namespace,
				action: callBody.name,
				arguments: (0, parameterEncoding_1$2.encodeValueType)(value)
			};
			const encodedPayload = (0, kwilEncoding_1$1.encodeActionCall)(payload);
			const uInt8ArrayPayload = (0, base64_1.base64ToBytes)(encodedPayload);
			const digest = (0, crypto_1$1.sha256BytesToBytes)(uInt8ArrayPayload).subarray(0, 20);
			const msg = (0, auth_1$1.generateSignatureText)(callBody.namespace, callBody.name, (0, serial_1$5.bytesToHex)(digest), msgChallenge);
			const signature = await (0, signature_1$2.executeSign)((0, serial_1$5.stringToBytes)(msg), signer.signer, signer.signatureType);
			const sig = (0, base64_1.bytesToBase64)(signature);
			const byteChallenge = (0, serial_1$5.hexToBytes)(msgChallenge);
			const base64Challenge = (0, base64_1.bytesToBase64)(byteChallenge);
			const res = {
				signature: sig,
				challenge: base64Challenge
			};
			return res;
		}
		async logoutKGW(signer) {
			const identifier = signer?.identifier || void 0;
			return await this.authClient.logoutClient(identifier);
		}
	};
	exports.Auth = Auth;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/message.js
var require_message = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/message.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Msg = exports.BaseMessage = void 0;
	const signature_1$1 = require_signature();
	/**
	* `BaseMessage` is the bass class for the payload structure for a request to the Kwil `call` GRPC endpoint {@link https://github.com/kwilteam/proto/blob/main/kwil/tx/v1/call.proto}.
	*
	* Bytes in the message can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the message within the SDK, and base64 should be used for the final message to be send over GRPC.
	*
	* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the message. Can be either base64 encoded or Uint8Array.
	* @implements {MsgData<T>} - The message data interface.
	*/
	var BaseMessage = class {
		constructor(data) {
			this.data = data || {
				body: {
					payload: null,
					challenge: ""
				},
				auth_type: signature_1$1.SignatureType.SECP256K1_PERSONAL,
				sender: null,
				signature: null
			};
		}
		get body() {
			return this.data.body;
		}
		get auth_type() {
			return this.data.auth_type;
		}
		get sender() {
			return this.data.sender;
		}
		get signature() {
			return this.data.signature;
		}
	};
	exports.BaseMessage = BaseMessage;
	var Msg;
	(function(Msg$1) {
		/**
		* Creates a new instance of the `BaseMessage` class.
		*
		* Bytes in the message can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the message within the SDK, and base64 should be used for the final message to be send over GRPC.
		*
		* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the message. Can be either base64 encoded or Uint8Array.
		* @param {(msg: MsgData<T>) => void} configure - A callback function that takes in a `MsgData` object and sets fields on it.
		* @returns {BaseMessage<T>} - A new instance of the `BaseMessage` class.
		*/
		function create(configure) {
			const msg = {
				body: {
					payload: null,
					challenge: ""
				},
				auth_type: signature_1$1.SignatureType.SECP256K1_PERSONAL,
				sender: null,
				signature: null
			};
			configure(msg);
			return new BaseMessage(msg);
		}
		Msg$1.create = create;
		/**
		* Copies an existing instance of the `BaseMessage` class and modifies certain fields.
		*
		* Bytes in the message can be typed to be either base64 encoded or Uint8Array. Uint8Array should be used when building the message within the SDK, and base64 should be used for the final message to be send over GRPC.
		*
		* @template {BytesEncodingStatus.BASE64_ENCODED | BytesEncodingStatus.UINT8_ENCODED} T - The type of bytes in the message. Can be either base64 encoded or Uint8Array.
		* @param {BaseMessage<PayloadBytesTypes>} source - The source message to copy from. It can be using either base64 or Uint8Array bytes.
		* @param {(msg: MsgData<T>) => void} configure - A callback function that takes in a `MsgData` object and sets fields on it.
		* @returns {BaseMessage<T>} - A new instance of the `BaseMessage` class.
		*/
		function copy(source, configure) {
			return Msg$1.create((msg) => {
				msg.body = source.body;
				msg.auth_type = source.auth_type;
				msg.sender = source.sender;
				msg.signature = source.signature;
				configure(msg);
			});
		}
		Msg$1.copy = copy;
	})(Msg || (exports.Msg = Msg = {}));
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/message/payloadMsg.js
var require_payloadMsg = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/message/payloadMsg.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PayloadMsg = void 0;
	const message_1 = require_message();
	const objects_1$1 = require_objects();
	const serial_1$4 = require_serial();
	const kwilEncoding_1 = require_kwilEncoding();
	/**
	* `PayloadMsg` class creates a call message payload that can be sent over GRPC.
	*/
	var PayloadMsg = class PayloadMsg {
		/**
		* Initializes a new `PayloadMsg` instance.
		*
		* @param {PayloadMsgOptions} options - Parameters interface to build a payload message.
		*/
		constructor(payload, options) {
			this.payload = objects_1$1.objects.requireNonNil(payload, "Payload is required for Payload Msg Builder. Please pass a valid payload.");
			objects_1$1.objects.validateOptionalFields(options, [
				"signature",
				"challenge",
				"signer",
				"identifier",
				"signatureType"
			]);
			this.signature = options.signature;
			this.challenge = options.challenge;
			this.signer = options.signer;
			this.identifier = options.identifier;
			this.signatureType = options.signatureType;
		}
		/**
		* Static factory method to create a new Payload instance.
		*
		* @param kwil - The Kwil client.
		* @param options - The options to configure the Payload instance.
		*/
		static createMsg(payload, options) {
			return new PayloadMsg(payload, options);
		}
		/**
		* Build the payload structure for a message.
		*/
		async buildMsg() {
			let msg = message_1.Msg.create((msg$1) => {
				msg$1.body.payload = this.payload;
				msg$1.body.challenge = this.challenge;
				msg$1.signature = this.signature;
			});
			if (this.signer) {
				const { identifier, signatureType } = objects_1$1.objects.validateFields({
					identifier: this.identifier,
					signatureType: this.signatureType
				}, (fieldName) => `${fieldName} required to build a message.`);
				if (identifier) return await PayloadMsg.authMsg(msg, identifier, signatureType);
			}
			return message_1.Msg.copy(msg, (msg$1) => {
				msg$1.body.payload = (0, kwilEncoding_1.encodeActionCall)(this.payload);
			});
		}
		/**
		* Adds the caller's sender address to the message.
		*
		* @param {Message} msg - The message to sign. See {@link Message} for more information.
		* @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
		* @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
		* @param {string} description - The description to be included in the signature.
		* @returns Message - A promise that resolves to the signed message.
		* @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
		*/
		static async authMsg(msg, identifier, signatureType) {
			const unencodedPayload = objects_1$1.objects.requireNonNil(msg.body.payload, "Payload is required to sign a message. This is likely an internal error. Please create an issue.");
			return message_1.Msg.copy(msg, (msg$1) => {
				msg$1.body.payload = (0, kwilEncoding_1.encodeActionCall)(unencodedPayload);
				msg$1.auth_type = signatureType;
				msg$1.sender = (0, serial_1$4.bytesToHex)(identifier);
			});
		}
	};
	exports.PayloadMsg = PayloadMsg;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/transaction/action.js
var require_action = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/transaction/action.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Action = void 0;
	const action_1$2 = require_action$1();
	const enums_1$3 = require_enums();
	const payloadTx_1$1 = require_payloadTx();
	const payloadMsg_1 = require_payloadMsg();
	const objects_1 = require_objects();
	const parameterEncoding_1$1 = require_parameterEncoding();
	const TXN_BUILD_IN_PROGRESS = [];
	/**
	* `Action` class creates a transaction to execute database actions on the Kwil network.
	*/
	var Action = class Action {
		/**
		* Initializes a new `Action` instance.
		* It helps in building transactions to execute database actions on the Kwil network.
		*
		* @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
		*/
		constructor(kwil, options) {
			this.kwil = objects_1.objects.requireNonNil(kwil, "Client is required for Action Builder. Please pass a valid Kwil Client.");
			objects_1.objects.validateRequiredFields(options, [
				"actionName",
				"namespace",
				"chainId",
				"description",
				"actionInputs"
			]);
			this.actionName = options.actionName;
			this.namespace = options.namespace;
			this.chainId = options.chainId;
			this.description = options.description;
			this.actionInputs = options.actionInputs;
			objects_1.objects.validateOptionalFields(options, [
				"signer",
				"identifier",
				"actionInputs",
				"signatureType",
				"nonce",
				"types"
			]);
			this.signer = options.signer;
			this.identifier = options.identifier;
			this.signatureType = options.signatureType;
			this.nonce = options.nonce;
			this.challenge = options.challenge;
			this.signature = options.signature;
			this.types = options.types;
		}
		/**
		* Static factory method to create a new Action instance.
		*
		* @param kwil - The Kwil client.
		* @param options - The options to configure the Action instance.
		*/
		static createTx(kwil, options) {
			return new Action(kwil, options);
		}
		/**
		* Build the action structure for a transaction.
		*/
		async buildTx(privateMode) {
			this.assertNotBuilding();
			const cachedActionInputs = this.actionInputs;
			this.actionInputs = TXN_BUILD_IN_PROGRESS;
			const payload = await this.buildTxPayload(privateMode, cachedActionInputs);
			const { signer, identifier, signatureType } = objects_1.objects.validateFields({
				signer: this.signer,
				identifier: this.identifier,
				signatureType: this.signatureType
			}, (fieldName) => `${fieldName} is required to build a transaction.`);
			return await payloadTx_1$1.PayloadTx.createTx(this.kwil, {
				payloadType: enums_1$3.PayloadType.EXECUTE_ACTION,
				payload,
				signer,
				signatureType,
				description: this.description,
				chainId: this.chainId,
				identifier,
				nonce: this.nonce
			}).buildTx().finally(() => this.actionInputs = cachedActionInputs);
		}
		/**
		* Builds the message structure for view actions. This can be provided to the `kwil.call()` api.
		*/
		async buildMsg(privateMode) {
			this.assertNotBuilding();
			const cachedActionInputs = this.actionInputs;
			this.actionInputs = TXN_BUILD_IN_PROGRESS;
			const payload = await this.buildMsgPayload(privateMode, cachedActionInputs);
			let msg = payloadMsg_1.PayloadMsg.createMsg(payload, {
				challenge: this.challenge,
				signature: this.signature
			});
			/**
			* if a signer is specified, add the signer, signature type, identifier, and description to the message
			* ex => if the @caller contextual variable is present in a kuneiform block for kwil.call()
			*/
			if (this.signer) {
				msg.signer = this.signer;
				msg.signatureType = this.signatureType;
				msg.identifier = this.identifier;
			}
			return await msg.buildMsg().finally(() => this.actionInputs = cachedActionInputs);
		}
		/**
		* Builds the payload for the execute action.
		*
		* @param {boolean} privateMode - Whether the action is being executed in private mode.
		* @param {ActionInput[]} actionInputs - The inputs for the action.
		* @returns {UnencodedActionPayload<PayloadType.EXECUTE_ACTION>} - The payload for the execute action.
		*/
		async buildTxPayload(privateMode, actionInputs) {
			const payload = {
				dbid: this.namespace,
				action: this.actionName,
				arguments: []
			};
			if (privateMode) {
				for (const actionInput of actionInputs) {
					const value = (0, action_1$2.resolveParamTypes)(actionInput, this.types);
					payload.arguments.push((0, parameterEncoding_1$1.encodeValueType)(value));
				}
				return payload;
			}
			const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
			if (modifiers.length > 0 && modifiers.includes(enums_1$3.AccessModifier.VIEW)) throw new Error(`Action / Procedure ${actionName} is a 'view' action. Please use kwil.call().`);
			payload.arguments = encodedActionInputs;
			return payload;
		}
		/**
		* Builds the payload for the call action.
		*
		* @param {boolean} privateMode - Whether the action is being executed in private mode.
		* @param {ActionInput[]} actionInputs - The inputs for the action.
		* @returns {UnencodedActionPayload<PayloadType.CALL_ACTION>} - The payload for the call action.
		*/
		async buildMsgPayload(privateMode, actionInputs) {
			const payload = {
				dbid: this.namespace,
				action: this.actionName,
				arguments: []
			};
			if (privateMode) {
				const actionValues = actionInputs.length > 0 ? Object.values(actionInputs[0]) : [];
				const value = (0, action_1$2.resolveParamTypes)(actionValues, this.types);
				payload.arguments = (0, parameterEncoding_1$1.encodeValueType)(value);
				return payload;
			}
			const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
			if (encodedActionInputs && encodedActionInputs.length > 1) throw new Error("Cannot pass more than one input to the call endpoint. Please pass only one input and try again.");
			if (modifiers.length > 0 && modifiers.includes(enums_1$3.AccessModifier.VIEW) === false) throw new Error(`Action ${actionName} is not a view only action. Please use kwil.execute().`);
			payload.arguments = encodedActionInputs[0];
			return payload;
		}
		/**
		* Checks the action definition and validates the action inputs
		*
		* @param {ActionInput[]} actionInputs - An array of action inputs to be executed.
		* @returns {ValidatedAction} - An object containing the database namespace, action name, modifiers, and encoded action inputs.
		*/
		async validatedActionRequest(actionInputs) {
			if ((0, action_1$2.isNamedParams)(actionInputs)) {
				const namespaceRequest = await this.kwil.getActions(this.namespace);
				if (namespaceRequest.status !== 200) throw new Error(`Failed to retrieve actions for namespace ${this.namespace}. Status: ${namespaceRequest.status}`);
				if (!namespaceRequest.data || namespaceRequest.data.length === 0) throw new Error(`No actions found for the namespace '${this.namespace}'. Please verify the namespace exists and contains the '${this.actionName}' action.`);
				const namespaceActions = namespaceRequest.data;
				const selectedAction = namespaceActions.find((a) => a.name === this.actionName);
				if (!selectedAction) throw new Error(`Action '${this.actionName}' not found in namespace '${this.namespace}'.`);
				if (!selectedAction.access_modifiers.includes(enums_1$3.AccessModifier.PUBLIC)) throw new Error(`Action '${this.actionName}' is not a public action.`);
				if (actionInputs) {
					for (const actionInput of actionInputs) if (!this.validateActionInputs(selectedAction, actionInput)) throw new Error(`Action inputs are invalid for action: ${selectedAction.name}.`);
				}
				const encodedActionInputs = [];
				for (const actionInput of actionInputs) {
					const value = (0, action_1$2.resolveParamTypes)(actionInput, this.types);
					encodedActionInputs.push((0, parameterEncoding_1$1.encodeValueType)(value));
				}
				return {
					actionName: selectedAction.name,
					modifiers: selectedAction.access_modifiers,
					encodedActionInputs
				};
			}
			let encValue = [];
			if (actionInputs.length > 0) for (const a of actionInputs) {
				const value = (0, action_1$2.resolveParamTypes)(a, this.types);
				encValue.push((0, parameterEncoding_1$1.encodeValueType)(value));
			}
			return {
				actionName: this.actionName,
				modifiers: [],
				encodedActionInputs: encValue
			};
		}
		/**
		* Validates that the action is not missing any inputs.
		*
		* @param {NamespaceAction} selectedAction - The schema of the action to be executed.
		* @param {ActionInput} actionInput - The values of the actions to be executed.
		* @returns {boolean} - True if the action inputs are valid, false otherwise.
		*/
		validateActionInputs(selectedAction, actionInputEntries) {
			const actionInputKeys = Object.keys(actionInputEntries);
			if ((!selectedAction.parameter_names || selectedAction.parameter_names.length === 0) && Object.keys(actionInputEntries).length === 0) return true;
			if ((!selectedAction.parameter_names || selectedAction.parameter_names.length === 0) && actionInputEntries.length !== 0) throw new Error(`No parameters found for action: ${this.actionName}.`);
			if (actionInputEntries.length == 0 && selectedAction.parameter_names.length > 0) throw new Error(`No action parameters have been included. Required parameters: ${selectedAction.parameter_names.join(", ")}`);
			if (Object.keys(actionInputEntries).every((key$1) => key$1.startsWith("$pstn_"))) return true;
			const missingParameters = new Set();
			selectedAction.parameter_names.forEach((parameterName) => {
				if (!actionInputKeys.includes(parameterName)) missingParameters.add(parameterName);
			});
			if (missingParameters.size > 0) throw new Error(`Missing parameters: ${Array.from(missingParameters).join(", ")} for action '${selectedAction.name}'`);
			const incorrectParameters = new Set();
			actionInputKeys.forEach((actionInputKey) => {
				if (!selectedAction.parameter_names.some((parameterName) => actionInputKey === parameterName)) incorrectParameters.add(actionInputKey);
			});
			if (incorrectParameters.size > 0) throw new Error(`Incorrect parameters: ${Array.from(incorrectParameters).join(", ")} for action '${selectedAction.name}'`);
			return true;
		}
		assertNotBuilding() {
			if (this.actionInputs === TXN_BUILD_IN_PROGRESS) throw new Error("Cannot modify the builder while a transaction is being built.");
		}
	};
	exports.Action = Action;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/dbid.js
var require_dbid = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/dbid.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateDBID = void 0;
	const bytes_1 = require_bytes();
	const crypto_1 = require_crypto();
	const serial_1$3 = require_serial();
	function generateDBID(owner, name) {
		if (typeof owner === "string") owner = (0, serial_1$3.hexToBytes)(owner);
		return "x" + (0, crypto_1.sha224BytesToString)((0, bytes_1.concatBytes)((0, serial_1$3.stringToBytes)(name.toLowerCase()), owner));
	}
	exports.generateDBID = generateDBID;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/namespace.js
var require_namespace = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/namespace.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveNamespace = exports.validateNamespace = void 0;
	const validateNamespace = (namespace) => {
		if (!namespace || typeof namespace !== "string") return false;
		if (/[';{}\\]/.test(namespace)) return false;
		if (!/^[a-zA-Z0-9_]+$/.test(namespace)) return false;
		return true;
	};
	exports.validateNamespace = validateNamespace;
	const resolveNamespace = (actionBody) => {
		if (actionBody.namespace) return actionBody.namespace;
		if (actionBody.dbid) {
			console.warn("Warning: The \"dbid\" field is deprecated. Please use \"namespace\" instead.");
			return actionBody.dbid;
		}
		throw new Error("Either \"namespace\" or \"dbid\" must be provided");
	};
	exports.resolveNamespace = resolveNamespace;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/keys.js
var require_keys = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/utils/keys.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.inferKeyType = void 0;
	const serial_1$2 = require_serial();
	const enums_1$2 = require_enums();
	function inferKeyType(owner) {
		if (typeof owner === "string") owner = (0, serial_1$2.hexToBytes)(owner);
		if (owner.length === 32) return enums_1$2.AccountKeyType.ED25519;
		if (owner.length === 20) return enums_1$2.AccountKeyType.SECP256K1;
		throw new Error("Cannot determine key type from owner.");
	}
	exports.inferKeyType = inferKeyType;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/kwil.js
var require_kwil = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/kwil.js"(exports) {
	var __importDefault$1 = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Kwil = void 0;
	const client_1$1 = __importDefault$1(require_client());
	const enums_1$1 = require_enums();
	const action_1$1 = require_action$1();
	const intern_1 = require_intern();
	const funder_1 = require_funder();
	const auth_1 = require_auth();
	const action_2 = require_action();
	const parameterEncoding_1 = require_parameterEncoding();
	const dbid_1$1 = require_dbid();
	const payloadTx_1 = require_payloadTx();
	const namespace_1 = require_namespace();
	const keys_1 = require_keys();
	const serial_1$1 = require_serial();
	/**
	* The main class for interacting with the Kwil network.
	*/
	var Kwil = class extends client_1$1.default {
		constructor(opts) {
			super(opts);
			this.chainId = opts.chainId;
			this.autoAuthenticate = opts.autoAuthenticate ?? true;
			this.funder = new funder_1.Funder(this, { broadcastClient: this.broadcastClient.bind(this) }, this.chainId);
			this.auth = new auth_1.Auth({
				getAuthenticateClient: this.getAuthenticateClient.bind(this),
				postAuthenticateClient: this.postAuthenticateClient.bind(this),
				challengeClient: this.challengeClient.bind(this),
				logoutClient: this.logoutClient.bind(this)
			}, this.config.kwilProvider, this.chainId);
			(0, intern_1.wrap)(this, this.estimateCostClient.bind(this));
		}
		/**
		* Retrieves the actions in a database given its namespace.
		*
		* @param namespace - The namespace of the actions to retrieve.
		* @returns A promise that resolves to the actions in the database.
		*/
		async getActions(namespace) {
			if (!(0, namespace_1.validateNamespace)(namespace)) throw new Error("Please provide a valid namespace");
			return await this.selectQuery("SELECT * FROM info.actions WHERE namespace = $namespace", { $namespace: namespace });
		}
		/**
		* Retrieves an account using the owner's Ethereum wallet address.
		*
		* @param owner - The owner's identifier (e.g. Ethereum wallet address or ED25119 keys). Ethereum addresses and ED25519 public keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
		* @returns A promise that resolves to an Account object. The account object includes the account's id, balance, and nonce.
		*/
		async getAccount(owner, keyType) {
			if (!keyType) keyType = (0, keys_1.inferKeyType)(owner);
			if (owner instanceof Uint8Array) owner = (0, serial_1$1.bytesToHex)(owner);
			return await this.getAccountClient({
				identifier: owner,
				key_type: keyType
			});
		}
		/**
		* Executes a transaction on a Kwil network. These are mutative actions that must be mined on the Kwil network's blockchain.
		*
		* @param actionBody - The body of the action to send. This should use the `ActionBody` interface.
		* @param kwilSigner - The signer for the action transactions.
		* @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
		* @returns A promise that resolves to the receipt of the transaction.
		*/
		async execute(actionBody, kwilSigner, synchronous) {
			if (!actionBody.name) throw new Error("name is required in actionBody");
			await this.ensureAuthenticationMode();
			const namespace = (0, namespace_1.resolveNamespace)(actionBody);
			let inputs = [];
			if (actionBody.inputs && action_1$1.transformActionInput.isActionInputArray(actionBody.inputs)) inputs = action_1$1.transformActionInput.toNamedParams(actionBody.inputs);
			else inputs = actionBody.inputs || [];
			let tx = action_2.Action.createTx(this, {
				namespace,
				actionName: actionBody.name.toLowerCase(),
				description: actionBody.description || "",
				identifier: kwilSigner.identifier,
				chainId: this.chainId,
				signer: kwilSigner.signer,
				signatureType: kwilSigner.signatureType,
				nonce: actionBody.nonce,
				actionInputs: inputs,
				types: actionBody.types
			});
			const transaction = await tx.buildTx(this.authMode === enums_1$1.AuthenticationMode.PRIVATE);
			return await this.broadcastClient(transaction, synchronous ? enums_1$1.BroadcastSyncType.COMMIT : enums_1$1.BroadcastSyncType.SYNC);
		}
		async selectQuery(query, params) {
			if (typeof params === "string") return this.legacySelectQuery(query, params);
			const encodedParams = (0, parameterEncoding_1.encodeParameters)(params || {});
			const q = {
				query,
				params: encodedParams
			};
			return await this.selectQueryClient(q);
		}
		async legacySelectQuery(dbid, query) {
			console.warn("WARNING: selectQuery(dbid, query) is deprecated and will be removed in the next major version. Use selectQuery(query, params?) instead.");
			const q = {
				query: `{${dbid}}${query}`,
				params: {}
			};
			return await this.selectQueryClient(q);
		}
		/**
		* Executes a mutative SQL query (INSERT, UPDATE, DELETE) on a database.
		*
		* @param query - The SQL query to execute, including the database identifier in curly braces.
		*               Use parameterized queries with @paramName placeholders for better security (recommended):
		*               '{dbname}INSERT INTO users (name) VALUES (@name)'
		*
		*               Raw queries are possible but discouraged:
		*               '{dbname}INSERT INTO users (name) VALUES ('john')'
		*
		* @param params - Object containing named parameters to bind to the query. Parameters are referenced
		*                using @paramName syntax in the query.
		* @param kwilSigner - Required signer for executing mutative queries
		* @param synchronous - (optional) If true, waits for transaction to be mined
		*
		* @example
		* // Insert with parameters
		* await kwil.execSql(
		*   '{mydb}INSERT INTO users (name, email) VALUES ($name, $email)',
		*   { $name: 'John', $email: 'john@example.com' },
		*   signer
		* );
		*
		* // Update with parameters
		* await kwil.execSql(
		*   '{mydb}UPDATE users SET status = $status WHERE id = $id',
		*   { $status: 'active', $id: 123 },
		*   signer
		* );
		*
		* // Delete with parameters
		* await kwil.execSql(
		*   '{mydb}DELETE FROM users WHERE id = $id',
		*   { $id: 123 },
		*   signer
		* );
		*
		* @returns Promise resolving to transaction receipt
		*/
		async execSql(query, params, signer, synchronous) {
			const encodedParams = (0, parameterEncoding_1.encodeRawStatementParameters)(params);
			const rawStatementPayload = {
				statement: query,
				parameters: encodedParams
			};
			const transaction = await payloadTx_1.PayloadTx.createTx(this, {
				chainId: this.chainId,
				description: `Performing a mutative query`,
				payload: rawStatementPayload,
				payloadType: enums_1$1.PayloadType.RAW_STATEMENT,
				identifier: signer.identifier,
				signer: signer.signer,
				signatureType: signer.signatureType
			}).buildTx();
			return await this.broadcastClient(transaction, synchronous ? enums_1$1.BroadcastSyncType.COMMIT : enums_1$1.BroadcastSyncType.SYNC);
		}
		/**
		* Retrieves information about a transaction given its hash.
		*
		* @param hash - The `tx_hash` of the transaction.
		* @returns A promise that resolves to the transaction info receipt.
		*/
		async txInfo(hash$1) {
			return await this.txInfoClient(hash$1);
		}
		/**
		* Retrieves the chain id, block height, and latest block hash of the configured network.
		*
		* Will log a warning if the returned chain id does not match the configured chain id.
		*
		* @param {ChainInfoOpts} opts - Options for the chain info request.
		* @returns {ChainInfo} - A promise that resolves to the chain info.
		*/
		async chainInfo(opts) {
			const info = await this.chainInfoClient();
			if (!opts?.disableWarning && info.data?.chain_id !== this.chainId) console.warn(`WARNING: Chain ID mismatch. Expected ${info.data?.chain_id}, got ${this.chainId}`);
			return info;
		}
		/**
		* Pings the server and gets a response.
		*
		* @returns A promise that resolves to a string indicating the server's response.
		*/
		async ping() {
			return await this.pingClient();
		}
		/**
		* Generates a unique database identifier (DBID) from the provided owner's identifier (e.g. wallet address, public key, etc.) and a database name.
		*
		* @param owner - The owner's identifier (e.g wallet address, public key, etc.). Ethereum addresses can be passed as a hex string (0x123...) or as bytes (Uint8Array). NEAR protocol public keys can be passed as the base58 encoded public key (with "ed25519:" prefix), a hex string, or bytes (Uint8Array).
		* @param name - The name of the database. This should be a unique name to identify the database.
		* @deprecated DBID's are no longer in use.  This method will be removed in the next major version.
		* @returns A string that represents the unique identifier for the database.
		*/
		getDBID(owner, name) {
			console.warn("WARNING: `getDBID()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
			return (0, dbid_1$1.generateDBID)(owner, name);
		}
		/**
		* Retrieves the schema of a database given its unique identifier (DBID).
		*
		* @param dbid - The unique identifier of the database. The DBID can be generated using the kwil.getDBID method.
		* @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
		* @returns A promise that resolves to the schema of the database.
		*/
		async getSchema(dbid) {
			console.warn("WARNING: `getSchema()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery()` instead.");
			throw new Error("The `getSchema()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
		}
		/**
		* Deploys a database to the Kwil network.
		*
		* @param deployBody - The body of the database to deploy. This should use the `DeployBody` interface.
		* @param kwilSigner - The signer for the database deployment.
		* @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
		* @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
		* @returns A promise that resolves to the receipt of the transaction.
		*/
		async deploy(deployBody, kwilSigner, synchronous) {
			console.warn("WARNING: `deploy()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
			throw new Error("The `deploy()` method is no longer supported. Please use `kwil.execSql()` instead.");
		}
		/**
		* Drops a database from the Kwil network.
		*
		* @param dropBody - The body of the database to drop. This should use the `DropBody` interface.
		* @param kwilSigner - The signer for the database drop.
		* @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
		* @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
		* @returns A promise that resolves to the receipt of the transaction.
		*/
		async drop(dropBody, kwilSigner, synchronous) {
			console.warn("WARNING: `drop()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
			throw new Error("The `drop()` method is no longer supported. Please use `kwil.execSql()` instead.");
		}
		/**
		* Lists all databases owned by a particular owner.
		*
		* @param owner (optional) - Lists the databases on a network. Can pass and owner identifier to see all the databases deployed by a specific account, or leave empty to see al the databases deployed on the network. The owner's public key (Ethereum or NEAR Protocol). Ethereum keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
		* @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
		* @returns A promise that resolves to a list of database names.
		*/
		async listDatabases(owner) {
			console.warn("WARNING: `listDatabases()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
			throw new Error("The `listDatabases()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
		}
		/**
		* Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
		*
		* @param {CallBody} callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
		* @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @param {(...args: any) => void} cookieHandlerCallback (optional) - the callback to handle the cookie if in the NODE environment
		* @returns A promise that resolves to the receipt of the message.
		*/
		async baseCall(callBody, kwilSigner, cookieHandlerCallback) {
			await this.ensureAuthenticationMode();
			if (this.authMode === enums_1$1.AuthenticationMode.OPEN) {
				if (cookieHandlerCallback) cookieHandlerCallback.setCookie();
				const message = await this.buildMessage(callBody, kwilSigner);
				const response = await this.callClient(message);
				if (cookieHandlerCallback) cookieHandlerCallback.resetCookie();
				if (response.authCode === enums_1$1.AuthErrorCodes.KGW_MODE && this.autoAuthenticate) {
					if (!kwilSigner) throw new Error("KGW authentication requires a KwilSigner");
					const res = await this.auth.authenticateKGW(kwilSigner);
					if (res.data && "cookie" in res.data) this.cookie = res.data.cookie;
					return await this.callClient(message);
				}
				return response;
			}
			if (this.authMode === enums_1$1.AuthenticationMode.PRIVATE) {
				const authBody = await this.handleAuthenticatePrivate(callBody, kwilSigner);
				const message = await this.buildMessage(callBody, kwilSigner, authBody.challenge, authBody.signature);
				return await this.callClient(message);
			}
			throw new Error("Unexpected authentication mode. If you hit this error, please report it to the Kwil team.");
		}
		/**
		* Check if authMode is already set, if not call healthModeCheckClient()
		* healthModeCheckClient => RPC call to retrieve health of blockchain and kwild mode (PRIVATE or OPEN (PUBLIC))
		*
		*/
		async ensureAuthenticationMode() {
			if (!this.authMode) {
				const health = await this.healthModeCheckClient();
				this.authMode = health.data?.mode;
			}
		}
		/**
		* Builds a message with a chainId, namespace, name, and description of the action.
		* NOT INCLUDED => challenge, sender, signature
		*
		* @param callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
		* @param kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @param challenge (optional) - To ensure a challenge is passed into the message before the signer in PRIVATE mode
		* @param signature (optional) - To ensure a signature is passed into the message before the signer in PRIVATE mode
		* @returns A message object that can be sent to the Kwil network.
		* @throws  Will throw an error if the action is being built or if there's an issue with the schema or account retrieval.
		* @throws  Will throw an error if the action is not a view action.
		*/
		async buildMessage(callBody, kwilSigner, challenge, signature) {
			if (!callBody.name) throw new Error("name is required in actionBody");
			const namespace = (0, namespace_1.resolveNamespace)(callBody);
			let inputs = [];
			if (callBody.inputs && action_1$1.transformActionInput.isActionInputArray(callBody.inputs)) inputs = [action_1$1.transformActionInput.toSingleEntry(callBody.inputs)];
			else if (callBody.inputs && (0, action_1$1.isNamedParam)(callBody.inputs)) inputs = [callBody.inputs];
			else inputs = callBody.inputs ? [callBody.inputs] : [];
			let msg = action_2.Action.createTx(this, {
				chainId: this.chainId,
				namespace,
				actionName: callBody.name,
				description: "",
				actionInputs: inputs,
				types: callBody.types
			});
			/**
			* PUBLIC MODE
			* include the sender when the user passes a KwilSigner to kwil.call().
			* This is because the sender is required for queries that use @caller
			*
			*/
			if (kwilSigner && this.authMode === enums_1$1.AuthenticationMode.OPEN) this.addSignerToMessage(msg, kwilSigner);
			/**
			* PRIVATE MODE
			* include the sender when the user passes a KwilSigner to kwil.call().
			* only AFTER a challenge and signature is attached to the message
			*
			*/
			if (kwilSigner && this.authMode === enums_1$1.AuthenticationMode.PRIVATE) {
				if (challenge && signature) {
					msg.challenge = challenge;
					msg.signature = signature;
					this.addSignerToMessage(msg, kwilSigner);
				}
			}
			return await msg.buildMsg(this.authMode === enums_1$1.AuthenticationMode.PRIVATE);
		}
		/**
		* Adds a signer to the message
		*
		* @param msgBuilder - The Action class that handles the building of the message
		* @param kwilSigner - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @returns the Action class responsible for building the view action message with the sender attached
		*
		*/
		addSignerToMessage(msg, kwilSigner) {
			msg.signer = kwilSigner.signer;
			msg.signatureType = kwilSigner.signatureType;
			msg.identifier = kwilSigner.identifier;
			return msg;
		}
		/**
		* Checks authentication errors for PRIVATE mode
		* Signs message and then retries request for successful response
		*
		* @param {CallBodyNode} actionBody - The message to send. The message can be built using the buildMsg() method in the Action class.
		* @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @returns the authentication body that consists of the challenge and signature required for PRIVATE mode
		*/
		async handleAuthenticatePrivate(actionBody, kwilSigner) {
			if (this.autoAuthenticate) try {
				if (this.authMode === enums_1$1.AuthenticationMode.PRIVATE) {
					if (!kwilSigner) throw new Error("Private mode authentication requires a KwilSigner.");
					return await this.auth.authenticatePrivateMode(actionBody, kwilSigner);
				}
			} catch (error) {
				throw new Error(`Authentication failed: ${error}`);
			}
			throw new Error("Authentication process did not complete successfully");
		}
	};
	exports.Kwil = Kwil;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/node/nodeKwil.js
var require_nodeKwil = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/node/nodeKwil.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NodeKwil = void 0;
	const kwil_1$1 = require_kwil();
	var NodeKwil$1 = class extends kwil_1$1.Kwil {
		constructor(opts) {
			super(opts);
		}
		/**
		* Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
		* If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
		*
		* @param {CallBodyNode} actionBody - The body of the action to send. This should use the `CallBody` interface.
		* @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @returns An Object[] with the result of the action
		*/
		async call(actionBody, kwilSigner) {
			const setCookie = () => {
				if (actionBody.cookie) this.setTemporaryCookie(actionBody.cookie);
			};
			const resetCookie = () => {
				if (this.tempCookie) this.resetTempCookie(this.tempCookie);
			};
			const cookieHandler = {
				setCookie,
				resetCookie
			};
			return await this.baseCall(actionBody, kwilSigner, cookieHandler);
		}
		/**
		* set the temp cookie to reset it after the call
		*
		* @param {string} cookie - The temporary cookie
		* @returns the temporary cookie to handle for Node
		*/
		setTemporaryCookie(cookie) {
			this.tempCookie = this.cookie;
			this.cookie = cookie;
		}
		/**
		* Resets the temporary cookie
		*
		* @param {string} tempCookie - the temporary cookie to be reset
		*/
		resetTempCookie(tempCookie) {
			this.cookie = tempCookie;
		}
	};
	exports.NodeKwil = NodeKwil$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/web/webKwil.js
var require_webKwil = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/client/web/webKwil.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.WebKwil = void 0;
	const kwil_1 = require_kwil();
	var WebKwil$1 = class extends kwil_1.Kwil {
		constructor(opts) {
			super(opts);
		}
		/**
		* Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
		* If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
		*
		* @param {CallBody} actionBody - The body of the action to send. This should use the `CallBody` interface.
		* @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
		* @returns An Object[] with the result of the action or a MsgReceipt
		*/
		async call(actionBody, kwilSigner) {
			return await this.baseCall(actionBody, kwilSigner);
		}
	};
	exports.WebKwil = WebKwil$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/database.js
var require_database = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/database.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DataType = void 0;
	const enums_1 = require_enums();
	var DataType$1;
	(function(DataType$2) {
		DataType$2.Uuid = {
			name: enums_1.VarType.UUID,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.UuidArray = {
			name: enums_1.VarType.UUID,
			is_array: true,
			metadata: [0, 0]
		};
		DataType$2.Text = {
			name: enums_1.VarType.TEXT,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.TextArray = {
			name: enums_1.VarType.TEXT,
			is_array: true,
			metadata: [0, 0]
		};
		DataType$2.Int = {
			name: enums_1.VarType.INT8,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.IntArray = {
			name: enums_1.VarType.INT8,
			is_array: true,
			metadata: [0, 0]
		};
		DataType$2.Boolean = {
			name: enums_1.VarType.BOOL,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.BooleanArray = {
			name: enums_1.VarType.BOOL,
			is_array: true,
			metadata: [0, 0]
		};
		DataType$2.Numeric = (precision, scale) => ({
			name: enums_1.VarType.NUMERIC,
			is_array: false,
			metadata: [precision, scale]
		});
		DataType$2.NumericArray = (precision, scale) => ({
			name: enums_1.VarType.NUMERIC,
			is_array: true,
			metadata: [precision, scale]
		});
		DataType$2.Null = {
			name: enums_1.VarType.NULL,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.NullArray = {
			name: enums_1.VarType.NULL,
			is_array: true,
			metadata: [0, 0]
		};
		DataType$2.Bytea = {
			name: enums_1.VarType.BYTEA,
			is_array: false,
			metadata: [0, 0]
		};
		DataType$2.ByteaArray = {
			name: enums_1.VarType.BYTEA,
			is_array: true,
			metadata: [0, 0]
		};
	})(DataType$1 || (exports.DataType = DataType$1 = {}));
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/kwilSigner.js
var require_kwilSigner = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/core/kwilSigner.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.KwilSigner = void 0;
	const serial_1 = require_serial();
	const signature_1 = require_signature();
	/**
	* The `KwilSigner` class is a utility class for storing a signer and its associated public key. It is used to sign transactions and messages on Kwil.
	*/
	var KwilSigner$1 = class {
		/**
		* Actual implementation of the KwilSigner constructor.
		*
		* @param {SignerSupplier} signer - Either an instance of EthSigner or CustomSigner.
		* @param {HexString | Uint8Array} identifier - The identifier associated with the signer (e.g. wallet address, public key, etc). Can be a hex string or bytes (Uint8Array).
		* @param {AnySignatureType} signatureType - (Optional) The type of the signature. If not provided,
		*                        the signature type is determined from the signer.
		*/
		constructor(signer, identifier, signatureType) {
			this.signer = signer;
			if (typeof identifier === "string") this.identifier = (0, serial_1.hexToBytes)(identifier);
			else this.identifier = identifier;
			if (signatureType) this.signatureType = signatureType;
			else {
				this.signatureType = (0, signature_1.getSignatureType)(signer);
				if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) throw new Error("Could not determine signature type from signer. Please pass a signature type to the KwilSigner constructor.");
			}
		}
	};
	exports.KwilSigner = KwilSigner$1;
} });

//#endregion
//#region ../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/index.js
var require_dist = __commonJS({ "../../node_modules/.pnpm/@kwilteam+kwil-js@0.9.4_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@kwilteam/kwil-js/dist/index.js"(exports) {
	var __importDefault = void 0 && (void 0).__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Client = exports.Utils = exports.KwilSigner = exports.WebKwil = exports.NodeKwil = void 0;
	const nodeKwil_1 = require_nodeKwil();
	Object.defineProperty(exports, "NodeKwil", {
		enumerable: true,
		get: function() {
			return nodeKwil_1.NodeKwil;
		}
	});
	const webKwil_1 = require_webKwil();
	Object.defineProperty(exports, "WebKwil", {
		enumerable: true,
		get: function() {
			return webKwil_1.WebKwil;
		}
	});
	const dbid_1 = require_dbid();
	const action_1 = require_action$1();
	const database_1 = require_database();
	const kwilSigner_1 = require_kwilSigner();
	Object.defineProperty(exports, "KwilSigner", {
		enumerable: true,
		get: function() {
			return kwilSigner_1.KwilSigner;
		}
	});
	const client_1 = __importDefault(require_client());
	exports.Client = client_1.default;
	var Utils$1;
	(function(Utils$2) {
		/**
		* `ActionInput` class is a utility class for creating action inputs.
		* @deprecated This class is deprecated and will be removed in the next major release.  Please use the `params` instead.
		*/
		Utils$2.ActionInput = action_1.ActionInput;
		/**
		* Generates a unique database identifier (DBID) from the provided owner's public key and a database name.
		* @deprecated This function is deprecated and will be removed in the next major release.
		*/
		Utils$2.generateDBID = dbid_1.generateDBID;
		/**
		* `DataType` holds the different data types that can be asserted as action inputs.
		*/
		Utils$2.DataType = database_1.DataType;
	})(Utils$1 || (exports.Utils = Utils$1 = {}));
} });

//#endregion
//#region ../@core/src/kwil-actions/schema.ts
var import_dist$2 = __toESM(require_dist(), 1);
const DataType = import_dist$2.Utils.DataType;
const actionSchema = {
	add_user_as_inserter: [{
		name: "id",
		type: DataType.Uuid
	}, {
		name: "recipient_encryption_public_key",
		type: DataType.Text
	}],
	update_user_pub_key_as_inserter: [{
		name: "id",
		type: DataType.Uuid
	}, {
		name: "recipient_encryption_public_key",
		type: DataType.Text
	}],
	get_user: [],
	get_user_as_inserter: [{
		name: "id",
		type: DataType.Uuid
	}],
	upsert_wallet_as_inserter: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "user_id",
			type: DataType.Uuid
		},
		{
			name: "address",
			type: DataType.Text
		},
		{
			name: "public_key",
			type: DataType.Text
		},
		{
			name: "wallet_type",
			type: DataType.Text
		},
		{
			name: "message",
			type: DataType.Text
		},
		{
			name: "signature",
			type: DataType.Text
		}
	],
	add_wallet: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "address",
			type: DataType.Text
		},
		{
			name: "public_key",
			type: DataType.Text
		},
		{
			name: "message",
			type: DataType.Text
		},
		{
			name: "signature",
			type: DataType.Text
		}
	],
	get_wallets: [],
	remove_wallet: [{
		name: "id",
		type: DataType.Uuid
	}],
	upsert_credential_as_inserter: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "user_id",
			type: DataType.Uuid
		},
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		},
		{
			name: "encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "content",
			type: DataType.Text
		},
		{
			name: "public_notes",
			type: DataType.Text
		},
		{
			name: "public_notes_signature",
			type: DataType.Text
		},
		{
			name: "broader_signature",
			type: DataType.Text
		}
	],
	add_credential: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		},
		{
			name: "encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "content",
			type: DataType.Text
		},
		{
			name: "public_notes",
			type: DataType.Text
		},
		{
			name: "public_notes_signature",
			type: DataType.Text
		},
		{
			name: "broader_signature",
			type: DataType.Text
		}
	],
	get_credentials: [],
	get_credentials_shared_by_user: [{
		name: "user_id",
		type: DataType.Uuid
	}, {
		name: "issuer_auth_public_key",
		type: DataType.Text
	}],
	edit_public_notes_as_issuer: [{
		name: "public_notes_id",
		type: DataType.Text
	}, {
		name: "public_notes",
		type: DataType.Text
	}],
	remove_credential: [{
		name: "id",
		type: DataType.Uuid
	}],
	share_credential: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "original_credential_id",
			type: DataType.Uuid
		},
		{
			name: "public_notes",
			type: DataType.Text
		},
		{
			name: "public_notes_signature",
			type: DataType.Text
		},
		{
			name: "broader_signature",
			type: DataType.Text
		},
		{
			name: "content",
			type: DataType.Text
		},
		{
			name: "content_hash",
			type: DataType.Text
		},
		{
			name: "encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		},
		{
			name: "grantee_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "locked_until",
			type: DataType.Int
		}
	],
	create_credential_copy: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "original_credential_id",
			type: DataType.Uuid
		},
		{
			name: "public_notes",
			type: DataType.Text
		},
		{
			name: "public_notes_signature",
			type: DataType.Text
		},
		{
			name: "broader_signature",
			type: DataType.Text
		},
		{
			name: "content",
			type: DataType.Text
		},
		{
			name: "encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		}
	],
	share_credential_through_dag: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "user_id",
			type: DataType.Uuid
		},
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		},
		{
			name: "encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "content",
			type: DataType.Text
		},
		{
			name: "content_hash",
			type: DataType.Text
		},
		{
			name: "public_notes",
			type: DataType.Text
		},
		{
			name: "public_notes_signature",
			type: DataType.Text
		},
		{
			name: "broader_signature",
			type: DataType.Text
		},
		{
			name: "original_credential_id",
			type: DataType.Uuid
		},
		{
			name: "dag_owner_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_grantee_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_locked_until",
			type: DataType.Int
		},
		{
			name: "dag_signature",
			type: DataType.Text
		}
	],
	create_credentials_by_dwg: [
		{
			name: "issuer_auth_public_key",
			type: DataType.Text
		},
		{
			name: "original_encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "original_credential_id",
			type: DataType.Uuid
		},
		{
			name: "original_content",
			type: DataType.Text
		},
		{
			name: "original_public_notes",
			type: DataType.Text
		},
		{
			name: "original_public_notes_signature",
			type: DataType.Text
		},
		{
			name: "original_broader_signature",
			type: DataType.Text
		},
		{
			name: "copy_encryptor_public_key",
			type: DataType.Text
		},
		{
			name: "copy_credential_id",
			type: DataType.Uuid
		},
		{
			name: "copy_content",
			type: DataType.Text
		},
		{
			name: "copy_public_notes_signature",
			type: DataType.Text
		},
		{
			name: "copy_broader_signature",
			type: DataType.Text
		},
		{
			name: "content_hash",
			type: DataType.Text
		},
		{
			name: "dwg_owner",
			type: DataType.Text
		},
		{
			name: "dwg_grantee",
			type: DataType.Text
		},
		{
			name: "dwg_issuer_public_key",
			type: DataType.Text
		},
		{
			name: "dwg_id",
			type: DataType.Uuid
		},
		{
			name: "dwg_access_grant_timelock",
			type: DataType.Text
		},
		{
			name: "dwg_not_before",
			type: DataType.Text
		},
		{
			name: "dwg_not_after",
			type: DataType.Text
		},
		{
			name: "dwg_signature",
			type: DataType.Text
		}
	],
	get_credential_owned: [{
		name: "id",
		type: DataType.Uuid
	}],
	get_credential_shared: [{
		name: "id",
		type: DataType.Uuid
	}],
	get_sibling_credential_id: [{
		name: "content_hash",
		type: DataType.Text
	}],
	add_attribute: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "attribute_key",
			type: DataType.Text
		},
		{
			name: "value",
			type: DataType.Text
		}
	],
	get_attributes: [],
	edit_attribute: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "attribute_key",
			type: DataType.Text
		},
		{
			name: "value",
			type: DataType.Text
		}
	],
	remove_attribute: [{
		name: "id",
		type: DataType.Uuid
	}],
	share_attribute: [
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "original_attribute_id",
			type: DataType.Uuid
		},
		{
			name: "attribute_key",
			type: DataType.Text
		},
		{
			name: "value",
			type: DataType.Text
		}
	],
	dwg_message: [
		{
			name: "owner_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "grantee_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "issuer_public_key",
			type: DataType.Text
		},
		{
			name: "id",
			type: DataType.Uuid
		},
		{
			name: "access_grant_timelock",
			type: DataType.Text
		},
		{
			name: "not_usable_before",
			type: DataType.Text
		},
		{
			name: "not_usable_after",
			type: DataType.Text
		}
	],
	revoke_access_grant: [{
		name: "id",
		type: DataType.Uuid
	}],
	get_access_grants_owned: [],
	get_access_grants_granted: [
		{
			name: "user_id",
			type: DataType.Uuid
		},
		{
			name: "page",
			type: DataType.Int
		},
		{
			name: "size",
			type: DataType.Int
		}
	],
	get_access_grants_granted_count: [{
		name: "user_id",
		type: DataType.Uuid
	}],
	has_locked_access_grants: [{
		name: "id",
		type: DataType.Uuid
	}],
	dag_message: [
		{
			name: "dag_owner_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_grantee_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_data_id",
			type: DataType.Uuid
		},
		{
			name: "dag_locked_until",
			type: DataType.Int
		},
		{
			name: "dag_content_hash",
			type: DataType.Text
		}
	],
	create_ag_by_dag_for_copy: [
		{
			name: "dag_owner_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_grantee_wallet_identifier",
			type: DataType.Text
		},
		{
			name: "dag_data_id",
			type: DataType.Uuid
		},
		{
			name: "dag_locked_until",
			type: DataType.Int
		},
		{
			name: "dag_content_hash",
			type: DataType.Text
		},
		{
			name: "dag_signature",
			type: DataType.Text
		}
	],
	get_access_grants_for_credential: [{
		name: "credential_id",
		type: DataType.Uuid
	}],
	has_profile: [{
		name: "address",
		type: DataType.Text
	}]
};

//#endregion
//#region ../@core/src/kwil-infra/create-kwil-client.ts
var import_dist$1 = __toESM(require_dist(), 1);
/**
* A client for interacting with kwil with type-safe abstractions for `call` and `execute`.
* Has utility methods for creating actions and setting a signer.
*/
var KwilActionClient = class {
	signer;
	client;
	constructor(client) {
		this.client = client;
	}
	#createActionInputs(actionName, params = {}) {
		if (!params || !Object.keys(params).length) return [];
		const args = actionSchema[actionName];
		return args.map(({ name }) => {
			const value = params[name];
			if (value === "" || value === 0) return value;
			return value ?? null;
		});
	}
	#actionTypes(actionName) {
		const args = actionSchema[actionName];
		return args.map((arg) => arg.type);
	}
	/**
	* Calls an action on the kwil nodes. This similar to `GET` like request.
	*/
	async call(params, signer = this.signer) {
		const action = {
			name: params.name,
			namespace: "main",
			inputs: this.#createActionInputs(params.name, params.inputs),
			types: this.#actionTypes(params.name)
		};
		const response = await this.client.call(action, signer);
		return response?.data?.result;
	}
	/**
	* Executes an action on the kwil nodes. This similar to `POST` like request.
	*/
	async execute(params, signer = this.signer, synchronous = true) {
		invariant(signer, "Signer is not set, you must set it before executing an action");
		const action = {
			name: params.name,
			namespace: "main",
			description: params.description,
			inputs: [this.#createActionInputs(params.name, params.inputs)],
			types: this.#actionTypes(params.name)
		};
		const response = await this.client.execute(action, signer, synchronous);
		return response.data?.tx_hash;
	}
	setSigner(signer) {
		this.signer = signer;
	}
};
const DEFAULT_TIMEOUT = 3e4;
const createKwilClient = (Cls) => async ({ nodeUrl: kwilProvider, chainId }) => {
	const _kwil = new Cls({
		kwilProvider,
		chainId: ""
	});
	chainId ||= (await _kwil.chainInfo({ disableWarning: true })).data?.chain_id;
	invariant(chainId, "Can't discover `chainId`. You must pass it explicitly.");
	return new KwilActionClient(new Cls({
		kwilProvider,
		chainId,
		timeout: DEFAULT_TIMEOUT
	}));
};
/**
* Create a kwil client for node.js environment
*/
const createNodeKwilClient = createKwilClient(import_dist$1.NodeKwil);
/**
* Create a kwil client for browser environment
*/
const createWebKwilClient = createKwilClient(import_dist$1.WebKwil);

//#endregion
//#region ../@core/src/kwil-nep413-signer/index.ts
function implicitAddressFromPublicKey(publicKey) {
	const key_without_prefix = publicKey.replace(/^ed25519:/, "");
	const implicitAddress = (0, import_hex.encode)(bs58Decode(key_without_prefix));
	return implicitAddress;
}
function kwilNep413Signer(recipient) {
	return (keyPair) => async (messageBytes) => {
		const message = (0, import_utf8$1.decode)(messageBytes);
		const nonceLength = 32;
		const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));
		const nep413BorschSchema = { struct: {
			message: "string",
			nonce: { array: {
				type: "u8",
				len: nonceLength
			} },
			recipient: "string",
			callbackUrl: { option: "string" }
		} };
		const tag = 2147484061;
		const { signature } = keyPair.sign((0, import_sha256.hash)((0, import_bytes.concat)(serialize("u32", tag), serialize(nep413BorschSchema, {
			message,
			nonce,
			recipient
		}))));
		const kwilNep413BorschSchema = { struct: {
			tag: "u32",
			...nep413BorschSchema.struct
		} };
		const kwilNep413BorshParams = {
			tag,
			message,
			nonce,
			recipient
		};
		const kwilNep413BorshPayload = serialize(kwilNep413BorschSchema, kwilNep413BorshParams);
		return (0, import_bytes.concat)((0, import_binary.writeUint16BE)(kwilNep413BorshPayload.length), kwilNep413BorshPayload, signature);
	};
}

//#endregion
//#region ../@core/src/kwil-infra/create-kwil-signer.ts
var import_dist = __toESM(require_dist(), 1);
/**
* Helper function to check if the given object is a `nacl.SignKeyPair`.
*/
function isNaclSignKeyPair(object) {
	return object !== null && typeof object === "object" && "publicKey" in object && object.publicKey instanceof Uint8Array && object.publicKey.length === nacl.sign.publicKeyLength && "secretKey" in object && object.secretKey instanceof Uint8Array && object.secretKey.length === nacl.sign.secretKeyLength;
}
/**
* Helper function to check if the given object is a NEAR KeyPair.
*/
function isNearKeyPair(object) {
	return object !== null && typeof object === "object" && "getPublicKey" in object && "sign" in object && typeof object.getPublicKey === "function" && typeof object.sign === "function";
}
/**
* Creates a `KwilSigner` and its associated `SignerAddress`.
*
* This function is explicitly marked as being for backend use only because it doesn't reset
* the KGW cookie when logging out and re-logging in with a different wallet.
*/
function createServerKwilSigner(signer) {
	if (isNaclSignKeyPair(signer)) return [new import_dist.KwilSigner(async (msg) => nacl.sign.detached(msg, signer.secretKey), signer.publicKey, "ed25519"), implicitAddressFromPublicKey(bs58Encode(signer.publicKey))];
	if (isNearKeyPair(signer)) {
		const publicKey = implicitAddressFromPublicKey(signer.getPublicKey().toString());
		return [new import_dist.KwilSigner(kwilNep413Signer("idos-issuer")(signer), publicKey, "nep413"), publicKey];
	}
	if ("address" in signer) return [new import_dist.KwilSigner(signer, signer.address), signer.address];
	return ((_) => {
		throw new Error("Invalid `signer` type");
	})(signer);
}

//#endregion
//#region src/services/credential.service.ts
var CredentialService = class {
	#kwilClient;
	#signingKeyPair;
	#encryptionSecretKey;
	constructor(kwilClient, signingKeyPair, encryptionSecretKey) {
		this.#kwilClient = kwilClient;
		this.#signingKeyPair = signingKeyPair;
		this.#encryptionSecretKey = encryptionSecretKey;
	}
	#buildInsertableIDOSCredential({ userId, publicNotes, plaintextContent, recipientEncryptionPublicKey }) {
		const ephemeralKeyPair = nacl.box.keyPair();
		const content = encryptContent(plaintextContent, recipientEncryptionPublicKey, ephemeralKeyPair.secretKey);
		const public_notes_signature = (0, import_base64.encode)(nacl.sign.detached((0, import_utf8$1.encode)(publicNotes), this.#signingKeyPair.secretKey));
		return {
			user_id: userId,
			content: (0, import_base64.encode)(content),
			public_notes: publicNotes,
			public_notes_signature,
			broader_signature: (0, import_base64.encode)(nacl.sign.detached(Uint8Array.from([...(0, import_base64.decode)(public_notes_signature), ...content]), this.#signingKeyPair.secretKey)),
			issuer_auth_public_key: (0, import_hex.encode)(this.#signingKeyPair.publicKey, true),
			encryptor_public_key: (0, import_base64.encode)(ephemeralKeyPair.publicKey)
		};
	}
	#ensureEntityId(entity) {
		if (!entity.id) entity.id = crypto.randomUUID();
		return entity;
	}
	async createCredentialByDelegatedWriteGrant(credentialParams, delegatedWriteGrant, consumerEncryptionPublicKey) {
		let recipientPublicKey = consumerEncryptionPublicKey;
		if (!recipientPublicKey) recipientPublicKey = nacl.box.keyPair.fromSecretKey(this.#encryptionSecretKey).publicKey;
		const originalCredential = this.#ensureEntityId(this.#buildInsertableIDOSCredential(credentialParams));
		const contentHash = hexEncodeSha256Hash(credentialParams.plaintextContent);
		const copyCredential = this.#ensureEntityId(this.#buildInsertableIDOSCredential({
			publicNotes: "",
			plaintextContent: credentialParams.plaintextContent,
			recipientEncryptionPublicKey: recipientPublicKey
		}));
		const payload = {
			issuer_auth_public_key: originalCredential.issuer_auth_public_key,
			original_encryptor_public_key: originalCredential.encryptor_public_key,
			original_credential_id: originalCredential.id,
			original_content: originalCredential.content,
			original_public_notes: originalCredential.public_notes,
			original_public_notes_signature: originalCredential.public_notes_signature,
			original_broader_signature: originalCredential.broader_signature,
			copy_encryptor_public_key: copyCredential.encryptor_public_key,
			copy_credential_id: copyCredential.id,
			copy_content: copyCredential.content,
			copy_public_notes_signature: copyCredential.public_notes_signature,
			copy_broader_signature: copyCredential.broader_signature,
			content_hash: contentHash,
			dwg_owner: delegatedWriteGrant.ownerWalletIdentifier,
			dwg_grantee: delegatedWriteGrant.consumerWalletIdentifier,
			dwg_issuer_public_key: delegatedWriteGrant.issuerPublicKey,
			dwg_id: delegatedWriteGrant.id,
			dwg_access_grant_timelock: delegatedWriteGrant.accessGrantTimelock,
			dwg_not_before: delegatedWriteGrant.notUsableBefore,
			dwg_not_after: delegatedWriteGrant.notUsableAfter,
			dwg_signature: delegatedWriteGrant.signature
		};
		await createCredentialByDelegatedWriteGrant(this.#kwilClient, payload);
		return {
			originalCredential,
			copyCredential
		};
	}
	async editCredentialAsIssuer(publicNotesId, publicNotes) {
		const payload = {
			public_notes_id: publicNotesId,
			public_notes: publicNotes
		};
		const result = await editCredentialAsIssuer(this.#kwilClient, payload);
		return result ?? null;
	}
	async getCredentialIdByContentHash(contentHash) {
		const id = await getCredentialIdByContentHash(this.#kwilClient, contentHash);
		invariant(id, "Required `idOSCredential` id not found");
		return id;
	}
	async getSharedCredential(id) {
		const result = await getSharedCredential(this.#kwilClient, id);
		return result ?? null;
	}
};

//#endregion
//#region src/assets/ed25519-signature-2020-v1.json
var __context$3 = {
	"id": "@id",
	"type": "@type",
	"@protected": true,
	"proof": {
		"@id": "https://w3id.org/security#proof",
		"@type": "@id",
		"@container": "@graph"
	},
	"Ed25519VerificationKey2020": {
		"@id": "https://w3id.org/security#Ed25519VerificationKey2020",
		"@context": {
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"controller": {
				"@id": "https://w3id.org/security#controller",
				"@type": "@id"
			},
			"revoked": {
				"@id": "https://w3id.org/security#revoked",
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
			},
			"publicKeyMultibase": {
				"@id": "https://w3id.org/security#publicKeyMultibase",
				"@type": "https://w3id.org/security#multibase"
			}
		}
	},
	"Ed25519Signature2020": {
		"@id": "https://w3id.org/security#Ed25519Signature2020",
		"@context": {
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"challenge": "https://w3id.org/security#challenge",
			"created": {
				"@id": "http://purl.org/dc/terms/created",
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
			},
			"domain": "https://w3id.org/security#domain",
			"expires": {
				"@id": "https://w3id.org/security#expiration",
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
			},
			"nonce": "https://w3id.org/security#nonce",
			"proofPurpose": {
				"@id": "https://w3id.org/security#proofPurpose",
				"@type": "@vocab",
				"@context": {
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"assertionMethod": {
						"@id": "https://w3id.org/security#assertionMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"authentication": {
						"@id": "https://w3id.org/security#authenticationMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"capabilityInvocation": {
						"@id": "https://w3id.org/security#capabilityInvocationMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"capabilityDelegation": {
						"@id": "https://w3id.org/security#capabilityDelegationMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"keyAgreement": {
						"@id": "https://w3id.org/security#keyAgreementMethod",
						"@type": "@id",
						"@container": "@set"
					}
				}
			},
			"proofValue": {
				"@id": "https://w3id.org/security#proofValue",
				"@type": "https://w3id.org/security#multibase"
			},
			"verificationMethod": {
				"@id": "https://w3id.org/security#verificationMethod",
				"@type": "@id"
			}
		}
	}
};
var ed25519_signature_2020_v1_default = { "@context": __context$3 };

//#endregion
//#region src/assets/idos-credential-subject-v1.json
var __context$2 = {
	"@version": 1.1,
	"@protected": true,
	"xsd": "http://www.w3.org/2001/XMLSchema#",
	"aux": "https://raw.githubusercontent.com/idos-network/idos-sdk-js/168f449a799620123bc7b01fc224423739500f94/packages/issuer-sdk-js/assets/country-codes.xml",
	"firstName": "xsd:string",
	"familyName": "xsd:string",
	"maidenName": "xsd:string",
	"governmentId": "xsd:string",
	"governmentIdType": "xsd:string",
	"dateOfBirth": "aux:date",
	"placeOfBirth": "xsd:string",
	"idDocumentCountry": "xsd:string",
	"idDocumentNumber": "xsd:string",
	"idDocumentType": "xsd:string",
	"idDocumentDateOfIssue": "aux:date",
	"idDocumentDateOfExpiry": "aux:date",
	"idDocumentFrontFile": "xsd:string",
	"idDocumentBackFile": "xsd:string",
	"selfieFile": "xsd:string",
	"residentialAddressStreet": "xsd:string",
	"residentialAddressHouseNumber": "xsd:string",
	"residentialAddressAdditionalAddressInfo": "xsd:string",
	"residentialAddressCity": "xsd:string",
	"residentialAddressPostalCode": "xsd:string",
	"residentialAddressCountry": "aux:ISO_3166-1_alpha-2",
	"residentialAddressProofCategory": "xsd:string",
	"residentialAddressProofDateOfIssue": "xsd:date",
	"residentialAddressProofFile": "xsd:string"
};
var idos_credential_subject_v1_default = { "@context": __context$2 };

//#endregion
//#region src/assets/idos-credentials-v1.json
var __context$1 = {
	"@version": 1.1,
	"@protected": true,
	"xsd": "http://www.w3.org/2001/XMLSchema#",
	"approvedAt": "xsd:date",
	"level": "xsd:string"
};
var idos_credentials_v1_default = { "@context": __context$1 };

//#endregion
//#region src/assets/v1.json
var __context = {
	"@version": 1.1,
	"@protected": true,
	"id": "@id",
	"type": "@type",
	"VerifiableCredential": {
		"@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"cred": "https://www.w3.org/2018/credentials#",
			"sec": "https://w3id.org/security#",
			"xsd": "http://www.w3.org/2001/XMLSchema#",
			"credentialSchema": {
				"@id": "cred:credentialSchema",
				"@type": "@id",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"cred": "https://www.w3.org/2018/credentials#",
					"JsonSchemaValidator2018": "cred:JsonSchemaValidator2018"
				}
			},
			"credentialStatus": {
				"@id": "cred:credentialStatus",
				"@type": "@id"
			},
			"credentialSubject": {
				"@id": "cred:credentialSubject",
				"@type": "@id"
			},
			"evidence": {
				"@id": "cred:evidence",
				"@type": "@id"
			},
			"expirationDate": {
				"@id": "cred:expirationDate",
				"@type": "xsd:dateTime"
			},
			"holder": {
				"@id": "cred:holder",
				"@type": "@id"
			},
			"issued": {
				"@id": "cred:issued",
				"@type": "xsd:dateTime"
			},
			"issuer": {
				"@id": "cred:issuer",
				"@type": "@id"
			},
			"issuanceDate": {
				"@id": "cred:issuanceDate",
				"@type": "xsd:dateTime"
			},
			"proof": {
				"@id": "sec:proof",
				"@type": "@id",
				"@container": "@graph"
			},
			"refreshService": {
				"@id": "cred:refreshService",
				"@type": "@id",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"cred": "https://www.w3.org/2018/credentials#",
					"ManualRefreshService2018": "cred:ManualRefreshService2018"
				}
			},
			"termsOfUse": {
				"@id": "cred:termsOfUse",
				"@type": "@id"
			},
			"validFrom": {
				"@id": "cred:validFrom",
				"@type": "xsd:dateTime"
			},
			"validUntil": {
				"@id": "cred:validUntil",
				"@type": "xsd:dateTime"
			}
		}
	},
	"VerifiablePresentation": {
		"@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"cred": "https://www.w3.org/2018/credentials#",
			"sec": "https://w3id.org/security#",
			"holder": {
				"@id": "cred:holder",
				"@type": "@id"
			},
			"proof": {
				"@id": "sec:proof",
				"@type": "@id",
				"@container": "@graph"
			},
			"verifiableCredential": {
				"@id": "cred:verifiableCredential",
				"@type": "@id",
				"@container": "@graph"
			}
		}
	},
	"EcdsaSecp256k1Signature2019": {
		"@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"sec": "https://w3id.org/security#",
			"xsd": "http://www.w3.org/2001/XMLSchema#",
			"challenge": "sec:challenge",
			"created": {
				"@id": "http://purl.org/dc/terms/created",
				"@type": "xsd:dateTime"
			},
			"domain": "sec:domain",
			"expires": {
				"@id": "sec:expiration",
				"@type": "xsd:dateTime"
			},
			"jws": "sec:jws",
			"nonce": "sec:nonce",
			"proofPurpose": {
				"@id": "sec:proofPurpose",
				"@type": "@vocab",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"sec": "https://w3id.org/security#",
					"assertionMethod": {
						"@id": "sec:assertionMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"authentication": {
						"@id": "sec:authenticationMethod",
						"@type": "@id",
						"@container": "@set"
					}
				}
			},
			"proofValue": "sec:proofValue",
			"verificationMethod": {
				"@id": "sec:verificationMethod",
				"@type": "@id"
			}
		}
	},
	"EcdsaSecp256r1Signature2019": {
		"@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"sec": "https://w3id.org/security#",
			"xsd": "http://www.w3.org/2001/XMLSchema#",
			"challenge": "sec:challenge",
			"created": {
				"@id": "http://purl.org/dc/terms/created",
				"@type": "xsd:dateTime"
			},
			"domain": "sec:domain",
			"expires": {
				"@id": "sec:expiration",
				"@type": "xsd:dateTime"
			},
			"jws": "sec:jws",
			"nonce": "sec:nonce",
			"proofPurpose": {
				"@id": "sec:proofPurpose",
				"@type": "@vocab",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"sec": "https://w3id.org/security#",
					"assertionMethod": {
						"@id": "sec:assertionMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"authentication": {
						"@id": "sec:authenticationMethod",
						"@type": "@id",
						"@container": "@set"
					}
				}
			},
			"proofValue": "sec:proofValue",
			"verificationMethod": {
				"@id": "sec:verificationMethod",
				"@type": "@id"
			}
		}
	},
	"Ed25519Signature2018": {
		"@id": "https://w3id.org/security#Ed25519Signature2018",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"id": "@id",
			"type": "@type",
			"sec": "https://w3id.org/security#",
			"xsd": "http://www.w3.org/2001/XMLSchema#",
			"challenge": "sec:challenge",
			"created": {
				"@id": "http://purl.org/dc/terms/created",
				"@type": "xsd:dateTime"
			},
			"domain": "sec:domain",
			"expires": {
				"@id": "sec:expiration",
				"@type": "xsd:dateTime"
			},
			"jws": "sec:jws",
			"nonce": "sec:nonce",
			"proofPurpose": {
				"@id": "sec:proofPurpose",
				"@type": "@vocab",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"sec": "https://w3id.org/security#",
					"assertionMethod": {
						"@id": "sec:assertionMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"authentication": {
						"@id": "sec:authenticationMethod",
						"@type": "@id",
						"@container": "@set"
					}
				}
			},
			"proofValue": "sec:proofValue",
			"verificationMethod": {
				"@id": "sec:verificationMethod",
				"@type": "@id"
			}
		}
	},
	"RsaSignature2018": {
		"@id": "https://w3id.org/security#RsaSignature2018",
		"@context": {
			"@version": 1.1,
			"@protected": true,
			"challenge": "sec:challenge",
			"created": {
				"@id": "http://purl.org/dc/terms/created",
				"@type": "xsd:dateTime"
			},
			"domain": "sec:domain",
			"expires": {
				"@id": "sec:expiration",
				"@type": "xsd:dateTime"
			},
			"jws": "sec:jws",
			"nonce": "sec:nonce",
			"proofPurpose": {
				"@id": "sec:proofPurpose",
				"@type": "@vocab",
				"@context": {
					"@version": 1.1,
					"@protected": true,
					"id": "@id",
					"type": "@type",
					"sec": "https://w3id.org/security#",
					"assertionMethod": {
						"@id": "sec:assertionMethod",
						"@type": "@id",
						"@container": "@set"
					},
					"authentication": {
						"@id": "sec:authenticationMethod",
						"@type": "@id",
						"@container": "@set"
					}
				}
			},
			"proofValue": "sec:proofValue",
			"verificationMethod": {
				"@id": "sec:verificationMethod",
				"@type": "@id"
			}
		}
	},
	"proof": {
		"@id": "https://w3id.org/security#proof",
		"@type": "@id",
		"@container": "@graph"
	}
};
var v1_default = { "@context": __context };

//#endregion
//#region src/services/credentials-builder.service.ts
const CONTEXT_V1 = "https://www.w3.org/2018/credentials/v1";
const CONTEXT_IDOS_CREDENTIALS_V1 = "https://raw.githubusercontent.com/idos-network/idos-sdk-js/1bc3503f5302a7e42777076445d5b05fec8db429/packages/issuer-sdk-js/assets/idos-credentials-v1.json";
const CONTEXT_IDOS_CREDENTIALS_V1_SUBJECT = "https://raw.githubusercontent.com/idos-network/idos-sdk-js/1bc3503f5302a7e42777076445d5b05fec8db429/packages/issuer-sdk-js/assets/idos-credential-subject-v1.json";
const CONTEXT_ED25519_SIGNATURE_2020_V1 = "https://w3id.org/security/suites/ed25519-2020/v1";
var CredentialsBuilderService = class {
	fileToBase85(file) {
		return base85.encode(file, "ascii85");
	}
	capitalizeFirstLetter(str) {
		return str[0].toUpperCase() + str.slice(1);
	}
	convertValues(fields, prefix) {
		const acc = {};
		for (const key$1 in fields) if (Object.hasOwn(fields, key$1)) {
			const value = fields[key$1];
			const name = prefix ? `${prefix}${this.capitalizeFirstLetter(key$1)}` : key$1;
			if (value instanceof Date) acc[name] = value.toISOString();
			else if (value instanceof Buffer) acc[name] = this.fileToBase85(value);
			else acc[name] = value;
		}
		return acc;
	}
	buildDocumentLoader() {
		const loader = new JsonLdDocumentLoader();
		loader.addStatic(CONTEXT_V1, v1_default);
		loader.addStatic(CONTEXT_IDOS_CREDENTIALS_V1, idos_credentials_v1_default);
		loader.addStatic(CONTEXT_IDOS_CREDENTIALS_V1_SUBJECT, idos_credential_subject_v1_default);
		loader.addStatic(CONTEXT_ED25519_SIGNATURE_2020_V1, ed25519_signature_2020_v1_default);
		return loader.build();
	}
	async buildCredentials(fields, subject, issuer) {
		const { residentialAddress,...subjectData } = subject;
		const credential = {
			"@context": [
				CONTEXT_V1,
				CONTEXT_IDOS_CREDENTIALS_V1,
				CONTEXT_ED25519_SIGNATURE_2020_V1
			],
			type: ["VerifiableCredential"],
			issuer: issuer.controller,
			...this.convertValues(fields),
			credentialSubject: {
				"@context": CONTEXT_IDOS_CREDENTIALS_V1_SUBJECT,
				...this.convertValues(subjectData),
				...residentialAddress ? this.convertValues(residentialAddress, "residentialAddress") : {}
			}
		};
		const key$1 = await Ed25519VerificationKey2020.from({
			...issuer,
			type: "Ed25519VerificationKey2020"
		});
		const suite = new Ed25519Signature2020({ key: key$1 });
		const documentLoader = this.buildDocumentLoader();
		return vc.issue({
			credential,
			suite,
			documentLoader
		});
	}
};

//#endregion
//#region src/services/grant.service.ts
var GrantService = class {
	#kwilClient;
	#encryptionSecretKey;
	constructor(kwilClient, encryptionSecretKey) {
		this.#kwilClient = kwilClient;
		this.#encryptionSecretKey = encryptionSecretKey;
	}
	async createAccessGrantFromDAG(params, getCredentialIdByContentHash$1, getSharedCredential$1) {
		const credentialId = await getCredentialIdByContentHash$1(params.dag_content_hash);
		invariant(credentialId, "Missing `idOSCredential` id");
		const credential = await getSharedCredential$1(credentialId);
		invariant(credential, "`idOSCredential` with id `{credentialId}` not found");
		const plaintextContent = await NoncedBox.nonceFromBase64SecretKey((0, import_base64.encode)(this.#encryptionSecretKey)).decrypt(credential.content, credential.encryptor_public_key);
		const contentHash = hexEncodeSha256Hash((0, import_utf8$1.encode)(plaintextContent));
		if (contentHash !== params.dag_content_hash) throw new Error("Hash mismatch between `DAG` and `idOSCredential` content");
		const result = await createAccessGrantByDag(this.#kwilClient, params);
		return result ?? null;
	}
};

//#endregion
//#region src/services/user.service.ts
var UserService = class {
	#kwilClient;
	constructor(kwilClient) {
		this.#kwilClient = kwilClient;
	}
	#ensureEntityId(entity) {
		if (!entity.id) entity.id = crypto.randomUUID();
		return entity;
	}
	async hasProfile(userAddress) {
		return hasProfile(this.#kwilClient, userAddress);
	}
	async createUserProfile(params) {
		const payload = this.#ensureEntityId(params);
		await createUser(this.#kwilClient, payload);
		return payload;
	}
	async upsertWalletAsInserter(params) {
		const payload = this.#ensureEntityId(params);
		await upsertWalletAsInserter(this.#kwilClient, payload);
		return payload;
	}
	async createUser(user, wallet) {
		const user_id = user.id ?? crypto.randomUUID();
		const wallet_id = wallet.id ?? crypto.randomUUID();
		const userReqParams = {
			...user,
			id: user_id
		};
		const userResponse = await this.createUserProfile(userReqParams);
		const walletReqParams = {
			...wallet,
			user_id,
			id: wallet_id
		};
		const walletResponse = await this.upsertWalletAsInserter(walletReqParams);
		return [userResponse, walletResponse];
	}
};

//#endregion
//#region src/index.ts
var idOSIssuer = class idOSIssuer {
	#credentialService;
	#grantService;
	#userService;
	#credentialsBuilderService;
	static async init(params) {
		const kwilClient = await createNodeKwilClient({
			nodeUrl: params.nodeUrl,
			chainId: params.chainId
		});
		const [signer] = createServerKwilSigner(params.signingKeyPair);
		kwilClient.setSigner(signer);
		const credentialService = new CredentialService(kwilClient, params.signingKeyPair, params.encryptionSecretKey);
		const grantService = new GrantService(kwilClient, params.encryptionSecretKey);
		const userService = new UserService(kwilClient);
		const credentialsBuilderService = new CredentialsBuilderService();
		return new idOSIssuer(credentialService, grantService, userService, credentialsBuilderService);
	}
	constructor(credentialService, grantService, userService, credentialsBuilderService) {
		this.#credentialService = credentialService;
		this.#grantService = grantService;
		this.#userService = userService;
		this.#credentialsBuilderService = credentialsBuilderService;
	}
	async hasProfile(userAddress) {
		return this.#userService.hasProfile(userAddress);
	}
	async createUserProfile(params) {
		return this.#userService.createUserProfile(params);
	}
	async upsertWalletAsInserter(params) {
		return this.#userService.upsertWalletAsInserter(params);
	}
	async createUser(user, wallet) {
		return this.#userService.createUser(user, wallet);
	}
	async createCredentialByDelegatedWriteGrant(credentialParams, delegatedWriteGrant, consumerEncryptionPublicKey) {
		return this.#credentialService.createCredentialByDelegatedWriteGrant(credentialParams, delegatedWriteGrant, consumerEncryptionPublicKey);
	}
	async editCredentialAsIssuer(publicNotesId, publicNotes) {
		return this.#credentialService.editCredentialAsIssuer(publicNotesId, publicNotes);
	}
	async getCredentialIdByContentHash(contentHash) {
		return this.#credentialService.getCredentialIdByContentHash(contentHash);
	}
	async getSharedCredential(id) {
		return this.#credentialService.getSharedCredential(id);
	}
	async createAccessGrantFromDAG(params) {
		return this.#grantService.createAccessGrantFromDAG(params, (contentHash) => this.getCredentialIdByContentHash(contentHash), (id) => this.getSharedCredential(id));
	}
	async buildCredentials(fields, subject, issuer) {
		return this.#credentialsBuilderService.buildCredentials(fields, subject, issuer);
	}
	buildDocumentLoader() {
		return this.#credentialsBuilderService.buildDocumentLoader();
	}
};

//#endregion
export { idOSIssuer };
//# sourceMappingURL=index.js.map