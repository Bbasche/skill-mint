"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base64_1 = require("../utils/base64");
const api_1 = require("./api");
const serial_1 = require("../utils/serial");
const enums_1 = require("../core/enums");
const jsonrpc_1 = require("../core/jsonrpc");
class Client extends api_1.Api {
    constructor(opts) {
        super(opts);
        this.jsonRpcId = 1;
        this.unconfirmedNonce = opts.unconfirmedNonce || false;
    }
    async getAuthenticateClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_PARAM, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result);
    }
    async postAuthenticateClient(authBody) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_AUTHN, authBody);
        const res = await super.post(`/rpc/v1`, body);
        if (typeof window === 'undefined') {
            return checkRes(res, (r) => {
                const cookie = res.headers['set-cookie'];
                if (!cookie) {
                    throw new Error('No cookie received from gateway. An error occurred with authentication.');
                }
                return {
                    ...r.result,
                    cookie: cookie[0],
                };
            });
        }
        // if we are in the browser, we don't need to return the cookie
        return checkRes(res, (r) => r.result);
    }
    // TODO: Update once KGW is updated for JSON RPC - DO NOT MERGE WITHOUT RESOLVING
    async logoutClient(identifier) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_LOGOUT, {
            account: identifier ? (0, serial_1.bytesToHex)(identifier) : '',
        });
        const res = await super.post(`/rpc/v1`, body);
        // if we are in nodejs, we need to return the cookie
        if (typeof window === 'undefined') {
            return checkRes(res, (r) => {
                const cookie = res.headers['set-cookie'];
                if (!cookie) {
                    throw new Error('No cookie received from gateway. An error occured with logout.');
                }
                // if the cookie is empty, set the cookie to undefined
                if (cookie[0].startsWith('kgw_session=;')) {
                    this.cookie = undefined;
                }
                else {
                    // set the cookie
                    this.cookie = cookie[0];
                }
                return {
                    ...r.result,
                    cookie: cookie[0],
                };
            });
        }
        // if we are in the browser, we don't need to return the cookie - the browser will handle it
        return checkRes(res, (r) => r.result);
    }
    async getAccountClient(accountId) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_ACCOUNT, {
            id: accountId,
            status: this.unconfirmedNonce ? enums_1.AccountStatus.PENDING : enums_1.AccountStatus.LATEST,
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
            return {
                ...r.result,
                id: r.result.id,
            };
        });
    }
    async listDatabasesClient(owner) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_DATABASES, {
            owner: owner ? (0, serial_1.bytesToHex)(owner) : undefined,
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
            if (!r.result.databases) {
                return [];
            }
            return r.result.databases.map((db) => {
                return {
                    ...db,
                    owner: (0, serial_1.hexToBytes)(db.owner),
                };
            });
        });
    }
    async estimateCostClient(tx) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PRICE, {
            tx: tx.txData,
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.price);
    }
    async broadcastClient(tx, broadcastSync) {
        if (!tx.isSigned()) {
            throw new Error('Tx must be signed before broadcasting.');
        }
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_BROADCAST, {
            tx: tx.txData,
            ...(broadcastSync ? { sync: broadcastSync } : {}),
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
            // if r.result.result is included, it means that the user sent the transaction with a sync type of COMMIT
            // if any error occured when submitting the transaction will be included in r.result.result
            // if r.result.result.code is not zero, it means that an error occured when committing the transaction to a block
            if (r.result.result && r.result.result?.code !== 0) {
                throw new Error(JSON.stringify(r.result) || `Transaction failed after broadcast.`);
            }
            return {
                tx_hash: (0, serial_1.base64ToHex)(r.result.tx_hash),
            };
        });
    }
    async pingClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PING, {
            message: 'ping',
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.message);
    }
    async chainInfoClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHAIN_INFO, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
            return {
                chain_id: r.result.chain_id,
                height: r.result.block_height.toString(),
                hash: r.result.block_hash,
            };
        });
    }
    async healthModeCheckClient() {
        // JsonRPCRequest to Determine mode (KGW or Private)
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_HEALTH, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result);
    }
    async challengeClient() {
        // JsonRPCRequest to generate a challenge
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHALLENGE, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.challenge);
    }
    async selectQueryClient(query) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_QUERY, query);
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => this.parseQueryResponse(r.result));
    }
    async txInfoClient(tx_hash) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_TX_QUERY, {
            tx_hash: (0, serial_1.hexToBase64)(tx_hash),
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
            return {
                ...r.result,
                tx: {
                    ...r.result.tx,
                    body: {
                        ...r.result.tx.body,
                        payload: (0, base64_1.base64ToBytes)(r.result.tx.body.payload),
                        fee: BigInt(r.result.tx.body.fee || 0),
                    },
                    signature: {
                        ...r.result.tx.signature,
                        sig: (0, base64_1.base64ToBytes)(r.result.tx.signature.sig),
                    },
                    sender: (0, serial_1.hexToBytes)(r.result.tx.sender || ''),
                },
            };
        });
    }
    async callClient(msg) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CALL, {
            body: msg.body,
            auth_type: msg.auth_type,
            sender: msg.sender || '',
            signature: msg.signature || '',
        });
        const res = await super.post(`/rpc/v1`, body);
        const errorResponse = this.checkAuthError(res);
        if (errorResponse) {
            return errorResponse;
        }
        return checkRes(res, (r) => {
            return {
                result: this.parseQueryResponse(r.result.query_result)
            };
        });
    }
    buildJsonRpcRequest(method, params) {
        return {
            jsonrpc: '2.0',
            id: this.jsonRpcId++,
            method,
            params,
        };
    }
    // Check for specific error codes and return http status, result of view action, and rpc authError code (if applicable)
    checkAuthError(res) {
        const errorCode = res.data.error?.code;
        if (errorCode === enums_1.AuthErrorCodes.PRIVATE_MODE || errorCode === enums_1.AuthErrorCodes.KGW_MODE) {
            return {
                status: res.status,
                data: undefined,
                authCode: errorCode,
            };
        }
        return null;
    }
    parseQueryResponse(queryResponse) {
        const { column_names, values } = queryResponse;
        if (!values || values.length === 0) {
            return [];
        }
        // Create a mapping function once that will be reused for all rows
        const mapValueToColumn = (rowValues) => {
            const obj = {};
            for (let i = 0; i < column_names.length; i++) {
                obj[column_names[i]] = rowValues[i];
            }
            return obj;
        };
        // Map each row of values to an object using the column mapping
        return values.map(mapValueToColumn);
    }
}
exports.default = Client;
function checkRes(res, selector) {
    switch (res.status) {
        case 200:
            break;
        case 401:
            throw new Error(JSON.stringify(res.data) || 'Unauthorized.');
        case 404:
            throw new Error(JSON.stringify(res.data) || 'Not found.');
        case 500:
            throw new Error(JSON.stringify(res.data) || 'Internal server error.');
        default:
            throw new Error(JSON.stringify(res.data) ||
                'An unknown error has occurred.  Please check your network connection.');
    }
    if (!res.data) {
        throw new Error(`failed to parse response: ${res}`);
    }
    if (res.data.error) {
        const data = res.data.error.data ? `, data: ${JSON.stringify(res.data.error.data)}` : '';
        throw new Error(`JSON RPC call error: code: ${res.data.error.code}, message: ${res.data.error.message}` + data);
    }
    if (res.data.jsonrpc !== '2.0') {
        throw new Error(JSON.stringify(res.data) || 'Invalid JSON RPC response.');
    }
    if (!res.data.result) {
        throw new Error(JSON.stringify(res.data) || 'No result in JSON RPC response.');
    }
    return {
        status: res.status,
        data: selector(res.data),
    };
}
//# sourceMappingURL=client.js.map