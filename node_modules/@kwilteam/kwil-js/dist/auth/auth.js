"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const auth_1 = require("../core/auth");
const objects_1 = require("../utils/objects");
const signature_1 = require("../core/signature");
const serial_1 = require("../utils/serial");
const base64_1 = require("../utils/base64");
const action_1 = require("../core/action");
const crypto_1 = require("../utils/crypto");
const kwilEncoding_1 = require("../utils/kwilEncoding");
const parameterEncoding_1 = require("../utils/parameterEncoding");
class Auth {
    constructor(authClient, kwilProvider, chainId) {
        this.authClient = authClient;
        this.kwilProvider = kwilProvider;
        this.chainId = chainId;
    }
    /**
     * Authenticates a user with the Kwil Gateway (KGW). This is required to execute view actions with the `@kgw(authn='true')` annotation.
     *
     * This method should only be used if your Kwil Network is using the Kwil Gateway.
     *
     * @param {KwilSigner} signer - The signer for the authentication.
     * @returns A promise that resolves to the authentication success or failure.
     */
    async authenticateKGW(signer) {
        // KGW rpc call
        const authParam = await this.authClient.getAuthenticateClient();
        const authProperties = objects_1.objects.requireNonNil(authParam.data, 'something went wrong retrieving auth info from KGW');
        const domain = (0, auth_1.removeTrailingSlash)(this.kwilProvider);
        const version = '1';
        (0, auth_1.verifyAuthProperties)(authProperties, domain, version, this.chainId);
        const msg = (0, auth_1.composeAuthMsg)(authProperties, domain, version, this.chainId);
        const signature = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(msg), signer.signer, signer.signatureType);
        const authBody = {
            nonce: authProperties.nonce,
            sender: (0, serial_1.bytesToHex)(signer.identifier),
            signature: {
                sig: (0, base64_1.bytesToBase64)(signature),
                type: signer.signatureType,
            },
        };
        // KGW rpc call
        const res = await this.authClient.postAuthenticateClient(authBody);
        return res;
    }
    /**
     * Authenticates a user in private mode.
     *
     * This method should only be used if your Kwil Network is in private mode.
     *
     * @param {KwilSigner} signer - The signer for the authentication.
     * @param {CallBody} callBody - The body of the action to send. This should use the `ActionBody` interface.
     * @returns A promise that resolves a privateSignature => privateSignature = {sig: string (Base64), type: AnySignatureType}
     */
    async authenticatePrivateMode(callBody, signer) {
        // get Challenge
        const challenge = await this.authClient.challengeClient();
        let msgChallenge = challenge.data;
        // Check if challenge.data is undefined
        if (!msgChallenge) {
            throw new Error('Challenge data is undefined. Something went wrong.');
        }
        // ActionInput[] is deprecated. So we are converting any ActionInput[] to an Entries[]
        let inputs = {};
        if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
            // For a call only one entry is allowed, so we only need to convert the first ActionInput
            inputs = action_1.transformActionInput.toSingleEntry(callBody.inputs);
        }
        else if (callBody.inputs && action_1.transformPositionalParam.isPositionalParam(callBody.inputs)) {
            inputs = action_1.transformPositionalParam.toNamedParam(callBody.inputs);
        }
        else if (callBody.inputs) {
            inputs = callBody.inputs;
        }
        const actionValues = callBody?.inputs ? Object.values(inputs) : [];
        const value = (0, action_1.resolveParamTypes)(actionValues, callBody?.types);
        // construct payload. If there are no prepared actions, then the payload is an empty array.
        const payload = {
            dbid: callBody.namespace,
            action: callBody.name,
            arguments: (0, parameterEncoding_1.encodeValueType)(value),
        };
        const encodedPayload = (0, kwilEncoding_1.encodeActionCall)(payload);
        const uInt8ArrayPayload = (0, base64_1.base64ToBytes)(encodedPayload);
        const digest = (0, crypto_1.sha256BytesToBytes)(uInt8ArrayPayload).subarray(0, 20);
        const msg = (0, auth_1.generateSignatureText)(callBody.namespace, callBody.name, (0, serial_1.bytesToHex)(digest), msgChallenge);
        const signature = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(msg), signer.signer, signer.signatureType);
        const sig = (0, base64_1.bytesToBase64)(signature);
        const byteChallenge = (0, serial_1.hexToBytes)(msgChallenge);
        const base64Challenge = (0, base64_1.bytesToBase64)(byteChallenge); // Challenge needs to be Base64 in the message
        const res = {
            signature: sig,
            challenge: base64Challenge,
        };
        return res;
    }
    async logoutKGW(signer) {
        const identifier = signer?.identifier || undefined;
        return await this.authClient.logoutClient(identifier);
    }
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map