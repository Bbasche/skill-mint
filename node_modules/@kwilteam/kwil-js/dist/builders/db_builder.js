"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBBuilderImpl = void 0;
const types_1 = require("../utils/types");
const objects_1 = require("../utils/objects");
const payload_builder_1 = require("./payload_builder");
const enums_1 = require("../core/enums");
const order_1 = require("../core/order");
const signature_1 = require("../core/signature");
/**
 * `DBBuilderImpl` class is an implementation of the `DBBuilder` interface.
 * It creates a transaction to deploy a new database on the Kwil network.
 */
class DBBuilderImpl {
    /**
     * Initializes a new `DBBuilderImpl` instance.
     *
     * @param {Kwil} client = The Kwil client, used to call higher level methods on the Kwil class.
     * @param {DeployOrDrop} payloadType - The payload type for the database transaction. This should be `PayloadType.DEPLOY_DATABASE` or `PayloadType.DROP_DATABASE`.
     * @returns {DBBuilder} A new `DBBuilderImpl` instance.
     */
    constructor(client, payloadType) {
        this._payload = null;
        this._signer = null;
        this._payloadType = null;
        this._identifier = null;
        this._chainId = null;
        this._description = null;
        this.client = client;
        this._payloadType = payloadType;
    }
    /**
     * Creates a new `DbBuilder` instance.
     *
     * @param {Kwil} client - The Kwil client, used to call higher level methods on the Kwil class.
     * @param {PayloadType} payloadType - The payload type for the database transaction. This should be `PayloadType.DEPLOY_DATABASE` or `PayloadType.DROP_DATABASE`.
     * @returns {DBBuilder} A new `DBBuilderImpl` instance.
     */
    static of(client, payloadType) {
        // throw runtime error if client or payloadType is null
        return new DBBuilderImpl(objects_1.objects.requireNonNil(client, 'client is required for DbBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.'), objects_1.objects.requireNonNil(payloadType, 'payloadType is required for DbBuilder. Please pass a valid PayloadType. This is an internal error, please create an issue.'));
    }
    /**
     * Specifies the signer for the database transaction.
     *
     * @param {SignerSupplier} signer - The signer for the database transaction. This can be a `Signer` from Ethers v5 or Ethers v6 or a custom signer function. Custom signers must be of the form `(message: Uint8Array, ...args: any[]) => Promise<Uint8Array>`.
     * @param {AnySignatureType} signatureType - The signature type for the database transaction. This is only required if the signer is a custom signer function.
     * @returns {DBBuilder} The current `DBBuilder` instance for chaining.
     * @throws Will throw an error if the signer is null or undefined.
     * @throws Will throw an error if the signature type is null or undefined.
     * @throws Will throw an error if it cannot infer the signature type from the signer.
     */
    signer(signer, signatureType) {
        // throw runtime error if signer is null
        this._signer = objects_1.objects.requireNonNil(signer, 'no signer provided. please specify a signing function or pass an Ethers signer in the KwilSigner.');
        if (!signatureType) {
            // infer signature type from signer
            this._signatureType = (0, signature_1.getSignatureType)(signer);
            // throw runtime error if signature type is null
            if (this._signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
                throw new Error('Could not determine signature type from signer. Please pass a signature type to .signer().');
            }
            return this;
        }
        // throw runtime error if signature type is null
        this._signatureType = objects_1.objects.requireNonNil(signatureType, 'signature type cannot be null or undefined. please specify signature type.');
        return this;
    }
    /**
     * The payload for the database deployment or database drop.
     *
     * @param {DbPayloadType<T>} payload - The payload for the database deployment or database drop. This should be a callback function that resolves to either a `CompiledKuneiform` or `DropDbPayload` object, or just objects that match either of those interfaces.
     * @returns {DBBuilder} The current `DBBuilder` instance for chaining.
     * @throws Will throw an error if the payload is null or undefined.
     */
    payload(payload) {
        // throw runtime error if payload is null
        const ensuredPayload = objects_1.objects.requireNonNil(payload, 'dbBuilder payload cannot be null');
        // ensure payload is a callback function for lazy evaluation
        this._payload =
            typeof ensuredPayload !== 'function'
                ? () => ensuredPayload
                : ensuredPayload;
        return this;
    }
    /**
     * Specifies the identifier (e.g. wallet, public key, etc) for the database deployment / drop.
     *
     * @param {string | Uint8Array} identifier - The identifier for the database deployment / drop.
     * @returns {DBBuilder} The current `DBBuilder` instance for chaining.
     * @throws Will throw an error if the identifier is null or undefined.
     */
    publicKey(identifier) {
        // throw runtime error if identifier is null
        this._identifier = objects_1.objects.requireNonNil(identifier, 'identifier is required for DbBuilder. Please pass a valid identifier to the .publicKey() method.');
        return this;
    }
    /**
     * Specifies the chain ID for the network being used.
     *
     * @param {string} chainId - The chain ID for the network being used.
     * @returns {DBBuilder} The current `ActionBuilder` instance for chaining.
     */
    chainId(chainId) {
        this._chainId = objects_1.objects.requireNonNil(chainId, 'chain ID cannot be null or undefined.');
        return this;
    }
    /**
     * Specifies the descriptions to be included in the message that is signed.
     *
     * @param {string} description - The description to be included in the message that is signed.
     * @returns {DBBuilder} The current `DBBuilder` instance for chaining.
     * @throws Will throw an error if the description is null or undefined.
     */
    description(description) {
        // throw runtime error if description is null
        this._description = objects_1.objects.requireNonNil(description, 'description cannot be null or undefined.');
        return this;
    }
    /**
     * Builds a Transaction. This will call the kwil network to retrieve the nonce for the signer.
     *
     * @returns {Promise<Transaction>} - A promise that resolves to a `Transaction` object. The `Transaction` object can be broadcasted to the Kwil network using `kwil.broadcast(tx)`.
     * @throws Will throw an error if there are any errors in the payload.
     * @throws Will throw an error if there is an issue with the account retrieval.
     */
    async buildTx() {
        // throw runtime error if payload is null
        const payload = objects_1.objects.requireNonNil(this._payload, 'payload cannot be null or undefined. please provide a payload to DBBuilder.');
        // create cleanedPayload that is equal to the current callback function
        let cleanedPayload = () => payload();
        // if it is a deploy database, we need to add all of the required fields and field order to make it RLP encodable. The Kuneiform parser does not include null fields.
        if (this._payloadType === enums_1.PayloadType.DEPLOY_DATABASE) {
            // make the payload encodable
            const encodablePayload = this.makePayloadEncodable(payload);
            // reassign cleanedPayload to be a callback function that returns the encodable payload with the correct order
            cleanedPayload = () => (0, order_1.enforceDatabaseOrder)(encodablePayload);
        }
        // throw runtime errors if any of the required fields are null
        const payloadType = objects_1.objects.requireNonNil(this._payloadType, 'payload type cannot be null or undefined. please specify a payload type.');
        const signer = objects_1.objects.requireNonNil(this._signer, 'signer cannot be null or undefined. please specify a signer.');
        const identifier = objects_1.objects.requireNonNil(this._identifier, 'identifier cannot be null or undefined. please specify a identifier.');
        const chainId = objects_1.objects.requireNonNil(this._chainId, 'chain ID cannot be null or undefined. please specify a chain ID.');
        const signatureType = await types_1.Promisy.resolveOrReject(this._signatureType, 'signature type cannot be null or undefined. please specify a signature type.');
        const tx = payload_builder_1.PayloadBuilderImpl.of(this.client)
            .payloadType(payloadType)
            .payload(cleanedPayload)
            .signer(signer, signatureType)
            .publicKey(identifier)
            .chainId(chainId)
            .description(this._description);
        return tx.buildTx();
    }
    /**
     * Ensures the compiled kuneiform schema has all of the required fields for RLP encoding.
     *
     * @param payload
     * @returns
     */
    makePayloadEncodable(payload) {
        // check if the payload has the required fields for the database
        const resolvedPayload = payload();
        let db = resolvedPayload;
        if (!db.owner) {
            db.owner = new Uint8Array();
        }
        if (!db.name) {
            db.name = '';
        }
        if (!db.tables) {
            db.tables = [];
        }
        db.tables &&
            db.tables.forEach((table) => {
                if (!table.name) {
                    table.name = '';
                }
                if (!table.columns) {
                    table.columns = [];
                }
                table.columns &&
                    table.columns.forEach((column) => {
                        if (!column.name) {
                            column.name = '';
                        }
                        if (!column.type) {
                            column.type = enums_1.DataType.NULL;
                        }
                        if (!column.attributes) {
                            column.attributes = [];
                        }
                        column.attributes &&
                            column.attributes.forEach((attribute) => {
                                if (!attribute.type) {
                                    attribute.type = enums_1.AttributeType.INVALID_TYPE;
                                }
                                if (!attribute.value) {
                                    attribute.value = '';
                                }
                            });
                    });
                if (!table.indexes) {
                    table.indexes = [];
                }
                table.indexes &&
                    table.indexes.forEach((index) => {
                        if (!index.name) {
                            index.name = '';
                        }
                        if (!index.columns) {
                            index.columns = [];
                        }
                        if (!index.type) {
                            index.type = enums_1.IndexType.INVALID_INDEX_TYPE;
                        }
                    });
                if (!table.foreign_keys) {
                    table.foreign_keys = [];
                }
                table.foreign_keys &&
                    table.foreign_keys.forEach((foreign_key) => {
                        if (!foreign_key.child_keys) {
                            foreign_key.child_keys = [];
                        }
                        if (!foreign_key.parent_keys) {
                            foreign_key.parent_keys = [];
                        }
                        if (!foreign_key.parent_table) {
                            foreign_key.parent_table = '';
                        }
                        if (!foreign_key.actions) {
                            foreign_key.actions = [];
                        }
                        foreign_key.actions &&
                            foreign_key.actions.forEach((action) => {
                                if (!action.on) {
                                    action.on = '';
                                }
                                if (!action.do) {
                                    action.do = '';
                                }
                            });
                    });
            });
        if (!db.actions) {
            db.actions = [];
        }
        db.actions &&
            db.actions.forEach((action) => {
                if (!action.name) {
                    action.name = '';
                }
                if (!action.annotations) {
                    action.annotations = [];
                }
                if (!action.inputs) {
                    action.inputs = [];
                }
                if (!action.mutability) {
                    action.mutability = '';
                }
                if (!action.auxiliaries) {
                    action.auxiliaries = [];
                }
                if (!action.public) {
                    action.public = true;
                }
                if (!action.statements) {
                    action.statements = [];
                }
            });
        if (!db.extensions) {
            db.extensions = [];
        }
        db.extensions &&
            db.extensions.forEach((extension) => {
                if (!extension.name) {
                    extension.name = '';
                }
                if (!extension.config) {
                    extension.config = [];
                }
                if (!extension.alias) {
                    extension.alias = '';
                }
                extension.config &&
                    extension.config.forEach((config) => {
                        if (!config.argument) {
                            config.argument = '';
                        }
                        if (!config.value) {
                            config.value = '';
                        }
                    });
            });
        return db;
    }
}
exports.DBBuilderImpl = DBBuilderImpl;
//# sourceMappingURL=db_builder.js.map