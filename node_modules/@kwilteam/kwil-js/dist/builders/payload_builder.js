"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadBuilderImpl = void 0;
const objects_1 = require("../utils/objects");
const strings_1 = require("../utils/strings");
const tx_1 = require("../core/tx");
const crypto_1 = require("../utils/crypto");
const base64_1 = require("../utils/base64");
const intern_1 = require("../client/intern");
const enums_1 = require("../core/enums");
const rlp_1 = require("../utils/rlp");
const serial_1 = require("../utils/serial");
const signature_1 = require("../core/signature");
const message_1 = require("../core/message");
const keys_1 = require("../utils/keys");
/**
 * PayloadBuilderImpl is the default implementation of PayloadBuilder. It allows for building transaction and call payloads that can be sent over GRPC.
 * See the proto files for more information on the structure of the payloads. {@link https://github.com/kwilteam/proto/tree/main/kwil/tx/v1}
 */
class PayloadBuilderImpl {
    /**
     * Initializes a new `PayloadBuilder` instance.
     *
     * @param {Kwil} client - The Kwil client, used to call higher level methods on the Kwil class.
     * @returns {PayloadBuilderImpl} - A new `PayloadBuilder` instance.
     */
    constructor(client) {
        this._payloadType = null;
        this._payload = null;
        this._signer = null;
        this._identifier = null;
        this._signatureType = null;
        this._chainId = null;
        this._description = '';
        this.client = objects_1.objects.requireNonNil(client, 'client is required for TxnBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.');
    }
    /**
     * Creates a new `PayloadBuilder` instance.
     *
     * @param {Kwil} client - The Kwil client, used to call higher level methods on the Kwil class.
     * @returns {PayloadBuilder} - A new `PayloadBuilder` instance.
     */
    static of(client) {
        return new PayloadBuilderImpl(client);
    }
    /**
     * Specify the payload type to be built.
     *
     * @param {PayloadType} payloadType - The payload type to be built. See {@link PayloadType} for more information.
     * @returns {PayloadBuilder} - The current `PayloadBuilder` instance for chaining.
     * @throws {Error} - If the payload type is null or undefined.
     */
    payloadType(payloadType) {
        // throw runtime error if payload type is null or undefined
        this._payloadType = objects_1.objects.requireNonNil(payloadType, 'payload type is required to build a transaction.');
        return this;
    }
    /**
     * Specify the signer and the signature type.
     *
     * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
     * @param {AnySignatureType} sigType - The signature type to be used to sign the transaction. See {@link SignatureType} for more information.
     * @returns The current `PayloadBuilder` instance for chaining.
     * @throws {Error} - If the signer is null or undefined.
     * @throws {Error} - If the signature type is null or undefined.
     */
    signer(signer, sigType) {
        // throw runtime errors if signer or signature type are null or undefined
        this._signer = objects_1.objects.requireNonNil(signer);
        this._signatureType = objects_1.objects.requireNonNil(sigType, 'signature type is required to build a transaction.');
        return this;
    }
    /**
     * Sets the content for the body of the payload object.
     *
     * @param {() => NonNil<AllPayloads> | NonNil<AllPayloads>} payload - The payload to be built. This can be a function that returns an object or an object.
     * @returns {PayloadBuilder} - The current `PayloadBuilder` instance for chaining.
     * @throws {Error} - If the payload is null or undefined.
     */
    payload(payload) {
        // throw runtime error if payload is null or undefined
        const ensuredPayload = objects_1.objects.requireNonNil(payload, 'transaction payload cannot be null.');
        // ensure payload is a function for lazy evaluation
        this._payload =
            typeof ensuredPayload !== 'function'
                ? () => ensuredPayload
                : ensuredPayload;
        return this;
    }
    /**
     * Specifies the identifier (e.g. wallet, public key, etc) for the payload signer.
     *
     * @param {HexString | Uint8Array} identifier - The identifier to be used to sign the transaction. This can be a hex string or a Uint8Array.
     * @returns {PayloadBuilder} - The current `PayloadBuilder` instance for chaining.
     * @throws {Error} - If the identifier is null or undefined.
     */
    publicKey(identifier) {
        // throw runtime error if public key is null or undefined
        let id = objects_1.objects.requireNonNil(identifier, 'public key is required to build a transaction.');
        // if near is string, convert to hex
        if (typeof id === 'string') {
            // accept near keys in their native format: ed25519:<base-58>
            if ((0, keys_1.isNearPubKey)(id)) {
                id = (0, keys_1.nearB58ToHex)(id);
            }
            // convert hex string to bytes
            id = (0, serial_1.hexToBytes)(id);
        }
        this._identifier = id;
        return this;
    }
    /**
     * Set the description to be included in the payload signature.
     *
     * @param {string | null} description - The description to be included in the payload signature.
     * @returns {PayloadBuilder} - The current `PayloadBuilder` instance for chaining.
     */
    description(description) {
        // assign description if it is not null or undefined
        // we do not want to throw an error if null because description is optional. The default value is empty string.
        if (description) {
            this._description = objects_1.objects.requireMaxLength(description, 200, `signature description cannot be longer than 200 characters. You provided ${description.length} characters.`);
        }
        return this;
    }
    /**
     * Specifies the chain ID for the network being used.
     *
     * @param {string} chainId - The chain ID for the network being used.
     * @returns {PayloadBuilder} The current `PayloadBuilder` instance for chaining.
     */
    chainId(chainId) {
        this._chainId = objects_1.objects.requireNonNil(chainId, 'chain ID is required to build a transaction.');
        return this;
    }
    /**
     * Builds the payload for the `kwil.broadcast()` method (i.e. the broadcast GRPC endpoint - see {@link https://github.com/kwilteam/proto/blob/main/kwil/tx/v1/tx.proto})
     *
     * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
     * @throws {Error} - If the required fields in the builder are null or undefined.
     */
    async buildTx() {
        // complete lazy evaluation of payload
        const resolvedPayload = await this.resolvePayload();
        // ensure required fields are not null or undefined
        const signer = objects_1.objects.requireNonNil(this._signer, 'signer is required to build a transaction.');
        const payloadType = objects_1.objects.requireNonNil(this._payloadType, 'payload type is required to build a transaction.');
        const identifier = objects_1.objects.requireNonNil(this._identifier, 'public key is required to build a transaction. Please chain the .publicKey() method to your builder.');
        const signatureType = objects_1.objects.requireNonNil(this._signatureType, 'signature type is required to build a transaction.');
        const chainId = objects_1.objects.requireNonNil(this._chainId, 'chain ID is required to build a transaction.');
        // create transaction payload for estimating cost. Set the Tx bytes type to base64 encoded because we need to make GRPC estimate cost request.
        const preEstTxn = tx_1.Txn.create((tx) => {
            // rlp encode the payload and convert to base64
            tx.body.payload = (0, base64_1.bytesToBase64)((0, rlp_1.kwilEncode)(resolvedPayload));
            tx.body.payload_type = payloadType;
        });
        // estimate the cost of the transaction with the estimateCost symbol from the client
        const cost = await (0, intern_1.unwrap)(this.client)(preEstTxn);
        // retrieve the account for the nonce
        const acct = await this.client.getAccount(identifier);
        // add the nonce and fee to the transaction. Set the tx bytes back to uint8 so we can do the signature.
        const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx) => {
            tx.body.payload = (0, base64_1.base64ToBytes)(preEstTxn.body.payload);
            tx.body.fee = BigInt(strings_1.strings.requireNonNil(cost.data, 'something went wrong estimating the cost of your transaction.'));
            tx.body.nonce =
                Number(objects_1.objects.requireNonNil(acct.data?.nonce, 'something went wrong retrieving your account nonce.')) + 1;
            tx.body.chain_id = chainId;
        });
        // check that a valid signature is used
        if (signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
            throw new Error('Signature type is invalid.');
        }
        return PayloadBuilderImpl.signTx(postEstTxn, signer, identifier, signatureType, this._description);
    }
    /**
     * Build the payload structure for message to the `kwil.call()` method (i.e. the call GRPC endpoint - see {@link https://github.com/kwilteam/proto/blob/main/kwil/tx/v1/call.proto})
     *
     * @returns {Message} - A promise that resolves to the built message, with signature if provided.
     * @throws {Error} - If the required fields in the builder are null or undefined.
     */
    async buildMsg() {
        // complete lazy evaluation of payload
        const resolvedPayload = await this.resolvePayload();
        // create the msg object with the payload, with the payload bytes type set to uint8 for RLP encoding.
        let msg = message_1.Msg.create((msg) => {
            msg.body.payload = resolvedPayload;
        });
        // if a signer has been provided, execute a signed `view` action
        if (this._signer) {
            // ensure required fields are provided in the builder
            const identifier = objects_1.objects.requireNonNil(this._identifier, 'public key is required to build a message that uses a signer.');
            const signatureType = objects_1.objects.requireNonNil(this._signatureType, 'signature type is required to build a signed message.');
            // ensure a valid signature type is used
            if (this._signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
                throw new Error('Signature type is invalid.');
            }
            // sign the message
            return await PayloadBuilderImpl.authMsg(msg, identifier, signatureType);
        }
        // return the unsigned message, with the payload base64 encoded
        return message_1.Msg.copy(msg, (msg) => {
            // rlp encode the payload and convert to base64 for transport over GRPC
            msg.body.payload = (0, base64_1.bytesToBase64)((0, rlp_1.kwilEncode)(resolvedPayload));
        });
    }
    /**
     * Execute lazy evaluation of payload.
     *
     * @returns {AllPayloads} - A promise that resolves to the provided payload object.
     */
    async resolvePayload() {
        const payloadFn = objects_1.objects.requireNonNil(this._payload, 'payload is required to build the payload.');
        const resolvedPayload = objects_1.objects.requireNonNil(payloadFn(), 'payload cannot resolve to be null.');
        return resolvedPayload;
    }
    /**
     * Signs the payload of a transaction / request to the broadcast GRPC endpoint.
     *
     * @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
     * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async signTx(tx, signer, identifier, signatureType, description) {
        // create the digest, which is the first bytes of the sha256 hash of the rlp-encoded payload
        const digest = (0, crypto_1.sha256BytesToBytes)(tx.body.payload).subarray(0, 20);
        // create the signature message
        const signatureMessage = `${description}

PayloadType: ${tx.body.payload_type}
PayloadDigest: ${(0, serial_1.bytesToHex)(digest)}
Fee: ${tx.body.fee}
Nonce: ${tx.body.nonce}

Kwil Chain ID: ${tx.body.chain_id}
`;
        // sign the above message
        const signedMessage = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(signatureMessage), signer, signatureType);
        // copy the transaction and add the signature
        return tx_1.Txn.copy(tx, (newTx) => {
            newTx.signature = {
                // bytes must be base64 encoded for transport over GRPC
                signature_bytes: (0, base64_1.bytesToBase64)(signedMessage),
                signature_type: signatureType.toString(),
            };
            newTx.body = {
                description: description,
                payload: (0, base64_1.bytesToBase64)(tx.body.payload),
                payload_type: newTx.body.payload_type,
                fee: newTx.body.fee?.toString(),
                nonce: newTx.body.nonce,
                chain_id: newTx.body.chain_id,
            };
            // bytes must be base64 encoded for transport over GRPC
            newTx.sender = (0, base64_1.bytesToBase64)(identifier);
            newTx.serialization = enums_1.SerializationType.SIGNED_MSG_CONCAT;
        });
    }
    /**
     * Adds the caller's sender address to the message.
     *
     * @param {Message} msg - The message to sign. See {@link Message} for more information.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns Message - A promise that resolves to the signed message.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async authMsg(msg, identifier, signatureType) {
        // rlp encode the payload
        const encodedPayload = (0, rlp_1.kwilEncode)(msg.body.payload);
        // copy the message and add the signature, with bytes set to base64 for transport over GRPC
        return message_1.Msg.copy(msg, (msg) => {
            // bytes must be base64 encoded for transport over GRPC
            msg.body.payload = (0, base64_1.bytesToBase64)(encodedPayload);
            msg.auth_type = signatureType;
            // bytes must be base64 encoded for transport over GRPC
            msg.sender = (0, base64_1.bytesToBase64)(identifier);
        });
    }
}
exports.PayloadBuilderImpl = PayloadBuilderImpl;
//# sourceMappingURL=payload_builder.js.map