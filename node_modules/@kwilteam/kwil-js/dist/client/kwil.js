"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kwil = void 0;
const client_1 = __importDefault(require("../api_client/client"));
const enums_1 = require("../core/enums");
const action_1 = require("../core/action");
const intern_1 = require("./intern");
const funder_1 = require("../funder/funder");
const auth_1 = require("../auth/auth");
const action_2 = require("../transaction/action");
const parameterEncoding_1 = require("../utils/parameterEncoding");
const dbid_1 = require("../utils/dbid");
const payloadTx_1 = require("../transaction/payloadTx");
const namespace_1 = require("../utils/namespace");
const keys_1 = require("../utils/keys");
const serial_1 = require("../utils/serial");
/**
 * The main class for interacting with the Kwil network.
 */
class Kwil extends client_1.default {
    constructor(opts) {
        super(opts);
        // set chainId
        this.chainId = opts.chainId;
        this.autoAuthenticate = opts.autoAuthenticate ?? true;
        // create funder
        this.funder = new funder_1.Funder(this, {
            broadcastClient: this.broadcastClient.bind(this),
        }, this.chainId);
        // create authenticate
        this.auth = new auth_1.Auth({
            getAuthenticateClient: this.getAuthenticateClient.bind(this),
            postAuthenticateClient: this.postAuthenticateClient.bind(this),
            challengeClient: this.challengeClient.bind(this),
            logoutClient: this.logoutClient.bind(this),
        }, this.config.kwilProvider, this.chainId);
        //create a wrapped symbol of estimateCost method
        (0, intern_1.wrap)(this, this.estimateCostClient.bind(this));
    }
    /**
     * Retrieves the actions in a database given its namespace.
     *
     * @param namespace - The namespace of the actions to retrieve.
     * @returns A promise that resolves to the actions in the database.
     */
    async getActions(namespace) {
        if (!(0, namespace_1.validateNamespace)(namespace)) {
            throw new Error('Please provide a valid namespace');
        }
        return await this.selectQuery('SELECT * FROM info.actions WHERE namespace = $namespace', {
            $namespace: namespace,
        });
    }
    /**
     * Retrieves an account using the owner's Ethereum wallet address.
     *
     * @param owner - The owner's identifier (e.g. Ethereum wallet address or ED25119 keys). Ethereum addresses and ED25519 public keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
     * @returns A promise that resolves to an Account object. The account object includes the account's id, balance, and nonce.
     */
    async getAccount(owner, keyType) {
        if (!keyType) {
            keyType = (0, keys_1.inferKeyType)(owner);
        }
        if (owner instanceof Uint8Array) {
            owner = (0, serial_1.bytesToHex)(owner);
        }
        return await this.getAccountClient({
            identifier: owner,
            key_type: keyType,
        });
    }
    /**
     * Executes a transaction on a Kwil network. These are mutative actions that must be mined on the Kwil network's blockchain.
     *
     * @param actionBody - The body of the action to send. This should use the `ActionBody` interface.
     * @param kwilSigner - The signer for the action transactions.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async execute(actionBody, kwilSigner, synchronous) {
        if (!actionBody.name) {
            throw new Error('name is required in actionBody');
        }
        // Ensure auth mode is set
        await this.ensureAuthenticationMode();
        const namespace = (0, namespace_1.resolveNamespace)(actionBody);
        // ActionInput[] has been deprecated.
        // This transforms the ActionInput[] into NamedInput[] to support legacy ActionInput[]
        let inputs = [];
        if (actionBody.inputs && action_1.transformActionInput.isActionInputArray(actionBody.inputs)) {
            inputs = action_1.transformActionInput.toNamedParams(actionBody.inputs);
        }
        else {
            inputs = actionBody.inputs || [];
        }
        // else if (actionBody.inputs && transformPositionalParam.isPositionalParams(actionBody.inputs)) {
        //   // handle positional parameters
        //   inputs = transformPositionalParam.toNamedParams(actionBody.inputs); 
        // } else {
        //   // If the inputs are not an ActionInput[] or PositionalParam[], we assume they are NamedParams[]
        //   inputs = actionBody.inputs || [];
        // }
        let tx = action_2.Action.createTx(this, {
            namespace,
            actionName: actionBody.name.toLowerCase(),
            description: actionBody.description || '',
            identifier: kwilSigner.identifier,
            chainId: this.chainId,
            signer: kwilSigner.signer,
            signatureType: kwilSigner.signatureType,
            nonce: actionBody.nonce,
            actionInputs: inputs,
            types: actionBody.types,
        });
        const transaction = await tx.buildTx(this.authMode === enums_1.AuthenticationMode.PRIVATE);
        return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
    }
    async selectQuery(query, params) {
        // If params is a string, we're using the legacy method call
        if (typeof params === 'string') {
            return this.legacySelectQuery(query, params);
        }
        const encodedParams = (0, parameterEncoding_1.encodeParameters)(params || {});
        const q = {
            query,
            params: encodedParams,
        };
        return await this.selectQueryClient(q);
    }
    async legacySelectQuery(dbid, query) {
        console.warn('WARNING: selectQuery(dbid, query) is deprecated and will be removed in the next major version. Use selectQuery(query, params?) instead.');
        const q = {
            query: `{${dbid}}${query}`,
            params: {},
        };
        return await this.selectQueryClient(q);
    }
    /**
     * Executes a mutative SQL query (INSERT, UPDATE, DELETE) on a database.
     *
     * @param query - The SQL query to execute, including the database identifier in curly braces.
     *               Use parameterized queries with @paramName placeholders for better security (recommended):
     *               '{dbname}INSERT INTO users (name) VALUES (@name)'
     *
     *               Raw queries are possible but discouraged:
     *               '{dbname}INSERT INTO users (name) VALUES ('john')'
     *
     * @param params - Object containing named parameters to bind to the query. Parameters are referenced
     *                using @paramName syntax in the query.
     * @param kwilSigner - Required signer for executing mutative queries
     * @param synchronous - (optional) If true, waits for transaction to be mined
     *
     * @example
     * // Insert with parameters
     * await kwil.execSql(
     *   '{mydb}INSERT INTO users (name, email) VALUES ($name, $email)',
     *   { $name: 'John', $email: 'john@example.com' },
     *   signer
     * );
     *
     * // Update with parameters
     * await kwil.execSql(
     *   '{mydb}UPDATE users SET status = $status WHERE id = $id',
     *   { $status: 'active', $id: 123 },
     *   signer
     * );
     *
     * // Delete with parameters
     * await kwil.execSql(
     *   '{mydb}DELETE FROM users WHERE id = $id',
     *   { $id: 123 },
     *   signer
     * );
     *
     * @returns Promise resolving to transaction receipt
     */
    async execSql(query, params, signer, synchronous) {
        const encodedParams = (0, parameterEncoding_1.encodeRawStatementParameters)(params);
        const rawStatementPayload = {
            statement: query,
            parameters: encodedParams,
        };
        const transaction = await payloadTx_1.PayloadTx.createTx(this, {
            chainId: this.chainId,
            description: `Performing a mutative query`,
            payload: rawStatementPayload,
            payloadType: enums_1.PayloadType.RAW_STATEMENT,
            identifier: signer.identifier,
            signer: signer.signer,
            signatureType: signer.signatureType,
        }).buildTx();
        return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
    }
    /**
     * Retrieves information about a transaction given its hash.
     *
     * @param hash - The `tx_hash` of the transaction.
     * @returns A promise that resolves to the transaction info receipt.
     */
    async txInfo(hash) {
        return await this.txInfoClient(hash);
    }
    /**
     * Retrieves the chain id, block height, and latest block hash of the configured network.
     *
     * Will log a warning if the returned chain id does not match the configured chain id.
     *
     * @param {ChainInfoOpts} opts - Options for the chain info request.
     * @returns {ChainInfo} - A promise that resolves to the chain info.
     */
    async chainInfo(opts) {
        const info = await this.chainInfoClient();
        if (!opts?.disableWarning && info.data?.chain_id !== this.chainId) {
            console.warn(`WARNING: Chain ID mismatch. Expected ${info.data?.chain_id}, got ${this.chainId}`);
        }
        return info;
    }
    /**
     * Pings the server and gets a response.
     *
     * @returns A promise that resolves to a string indicating the server's response.
     */
    async ping() {
        return await this.pingClient();
    }
    // DEPRECATED APIS BELOW
    /**
     * Generates a unique database identifier (DBID) from the provided owner's identifier (e.g. wallet address, public key, etc.) and a database name.
     *
     * @param owner - The owner's identifier (e.g wallet address, public key, etc.). Ethereum addresses can be passed as a hex string (0x123...) or as bytes (Uint8Array). NEAR protocol public keys can be passed as the base58 encoded public key (with "ed25519:" prefix), a hex string, or bytes (Uint8Array).
     * @param name - The name of the database. This should be a unique name to identify the database.
     * @deprecated DBID's are no longer in use.  This method will be removed in the next major version.
     * @returns A string that represents the unique identifier for the database.
     */
    getDBID(owner, name) {
        console.warn('WARNING: `getDBID()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.');
        return (0, dbid_1.generateDBID)(owner, name);
    }
    /**
     * Retrieves the schema of a database given its unique identifier (DBID).
     *
     * @param dbid - The unique identifier of the database. The DBID can be generated using the kwil.getDBID method.
     * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the schema of the database.
     */
    async getSchema(dbid) {
        console.warn('WARNING: `getSchema()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery()` instead.');
        throw new Error('The `getSchema()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.');
    }
    /**
     * Deploys a database to the Kwil network.
     *
     * @param deployBody - The body of the database to deploy. This should use the `DeployBody` interface.
     * @param kwilSigner - The signer for the database deployment.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async deploy(deployBody, kwilSigner, synchronous) {
        console.warn('WARNING: `deploy()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.');
        throw new Error('The `deploy()` method is no longer supported. Please use `kwil.execSql()` instead.');
    }
    /**
     * Drops a database from the Kwil network.
     *
     * @param dropBody - The body of the database to drop. This should use the `DropBody` interface.
     * @param kwilSigner - The signer for the database drop.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async drop(dropBody, kwilSigner, synchronous) {
        console.warn('WARNING: `drop()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.');
        throw new Error('The `drop()` method is no longer supported. Please use `kwil.execSql()` instead.');
    }
    /**
     * Lists all databases owned by a particular owner.
     *
     * @param owner (optional) - Lists the databases on a network. Can pass and owner identifier to see all the databases deployed by a specific account, or leave empty to see al the databases deployed on the network. The owner's public key (Ethereum or NEAR Protocol). Ethereum keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
     * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to a list of database names.
     */
    async listDatabases(owner) {
        console.warn('WARNING: `listDatabases()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.');
        throw new Error('The `listDatabases()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.');
    }
    /**
     * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
     *
     * @param {CallBody} callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @param {(...args: any) => void} cookieHandlerCallback (optional) - the callback to handle the cookie if in the NODE environment
     * @returns A promise that resolves to the receipt of the message.
     */
    async baseCall(callBody, kwilSigner, cookieHandlerCallback) {
        // Ensure auth mode is set
        await this.ensureAuthenticationMode();
        if (this.authMode === enums_1.AuthenticationMode.OPEN) {
            // if nodeJS user passes a cookie, use it for the call
            if (cookieHandlerCallback) {
                cookieHandlerCallback.setCookie();
            }
            const message = await this.buildMessage(callBody, kwilSigner);
            const response = await this.callClient(message);
            // if nodeJS user passes a cookie, reset it after the call
            if (cookieHandlerCallback) {
                cookieHandlerCallback.resetCookie();
            }
            // if the user is not authenticated, prompt the user to authenticate
            if (response.authCode === enums_1.AuthErrorCodes.KGW_MODE && this.autoAuthenticate) {
                if (!kwilSigner) {
                    throw new Error('KGW authentication requires a KwilSigner');
                }
                const res = await this.auth.authenticateKGW(kwilSigner);
                // if cookie was returned with res.data, we are in nodejs and need to set the cookie
                if (res.data && 'cookie' in res.data) {
                    this.cookie = res.data.cookie;
                }
                return await this.callClient(message);
            }
            return response;
        }
        if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
            const authBody = await this.handleAuthenticatePrivate(callBody, kwilSigner);
            const message = await this.buildMessage(callBody, kwilSigner, authBody.challenge, authBody.signature);
            return await this.callClient(message);
        }
        throw new Error('Unexpected authentication mode. If you hit this error, please report it to the Kwil team.');
    }
    /**
     * Check if authMode is already set, if not call healthModeCheckClient()
     * healthModeCheckClient => RPC call to retrieve health of blockchain and kwild mode (PRIVATE or OPEN (PUBLIC))
     *
     */
    async ensureAuthenticationMode() {
        if (!this.authMode) {
            const health = await this.healthModeCheckClient();
            this.authMode = health.data?.mode;
        }
    }
    /**
     * Builds a message with a chainId, namespace, name, and description of the action.
     * NOT INCLUDED => challenge, sender, signature
     *
     * @param callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @param challenge (optional) - To ensure a challenge is passed into the message before the signer in PRIVATE mode
     * @param signature (optional) - To ensure a signature is passed into the message before the signer in PRIVATE mode
     * @returns A message object that can be sent to the Kwil network.
     * @throws — Will throw an error if the action is being built or if there's an issue with the schema or account retrieval.
     * @throws — Will throw an error if the action is not a view action.
     */
    async buildMessage(callBody, kwilSigner, challenge, signature) {
        if (!callBody.name) {
            throw new Error('name is required in actionBody');
        }
        const namespace = (0, namespace_1.resolveNamespace)(callBody);
        // ActionInput[] is deprecated. So we are converting any ActionInput[] to an Entries[]
        let inputs = [];
        if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
            // For a call only one entry is allowed, so we only need to convert the first ActionInput
            inputs = [action_1.transformActionInput.toSingleEntry(callBody.inputs)];
        }
        else if (callBody.inputs && (0, action_1.isNamedParam)(callBody.inputs)) {
            inputs = [callBody.inputs];
        }
        else {
            inputs = callBody.inputs ? [callBody.inputs] : [];
        }
        // pre Challenge message
        let msg = action_2.Action.createTx(this, {
            chainId: this.chainId,
            namespace,
            actionName: callBody.name,
            description: '',
            actionInputs: inputs,
            types: callBody.types,
        });
        /**
         * PUBLIC MODE
         * include the sender when the user passes a KwilSigner to kwil.call().
         * This is because the sender is required for queries that use @caller
         *
         */
        if (kwilSigner && this.authMode === enums_1.AuthenticationMode.OPEN) {
            this.addSignerToMessage(msg, kwilSigner);
        }
        /**
         * PRIVATE MODE
         * include the sender when the user passes a KwilSigner to kwil.call().
         * only AFTER a challenge and signature is attached to the message
         *
         */
        if (kwilSigner && this.authMode === enums_1.AuthenticationMode.PRIVATE) {
            if (challenge && signature) {
                // add challenge and signature to the message
                msg.challenge = challenge;
                msg.signature = signature;
                this.addSignerToMessage(msg, kwilSigner);
            }
        }
        return await msg.buildMsg(this.authMode === enums_1.AuthenticationMode.PRIVATE);
    }
    /**
     * Adds a signer to the message
     *
     * @param msgBuilder - The Action class that handles the building of the message
     * @param kwilSigner - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns the Action class responsible for building the view action message with the sender attached
     *
     */
    addSignerToMessage(msg, kwilSigner) {
        msg.signer = kwilSigner.signer;
        msg.signatureType = kwilSigner.signatureType;
        msg.identifier = kwilSigner.identifier;
        return msg;
    }
    /**
     * Checks authentication errors for PRIVATE mode
     * Signs message and then retries request for successful response
     *
     * @param {CallBodyNode} actionBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns the authentication body that consists of the challenge and signature required for PRIVATE mode
     */
    async handleAuthenticatePrivate(actionBody, kwilSigner) {
        if (this.autoAuthenticate) {
            try {
                // PRIVATE MODE AUTHENTICATION
                if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
                    if (!kwilSigner) {
                        throw new Error('Private mode authentication requires a KwilSigner.');
                    }
                    return await this.auth.authenticatePrivateMode(actionBody, kwilSigner);
                }
            }
            catch (error) {
                throw new Error(`Authentication failed: ${error}`);
            }
        }
        throw new Error('Authentication process did not complete successfully');
    }
}
exports.Kwil = Kwil;
//# sourceMappingURL=kwil.js.map