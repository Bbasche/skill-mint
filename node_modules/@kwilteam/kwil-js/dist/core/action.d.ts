import { ValueType } from '../utils/types';
import { DataInfo } from './database';
import { AccessModifier } from './enums';
import { BytesEncodingStatus } from './enums';
import { EncodedValue } from './payload';
import { AnySignatureType, AuthBody, SignerSupplier } from './signature';
export type Entry<T extends ValueType | ValueType[]> = [string, T];
export type EntryType = Entry<ValueType> | Entry<ValueType[]>;
export type NamedParams = Record<string, ValueType | ValueType[]>;
export type NamedTypes = Record<string, DataInfo>;
export interface ParamsTypes {
    v: ValueType;
    o?: DataInfo;
}
export declare function resolveParamTypes(i: NamedParams | PositionalParams, types?: DataInfo[] | NamedTypes): ParamsTypes[];
export declare function isNamedParams(i: NamedParams[] | PositionalParams[]): i is NamedParams[];
export declare function isNamedParam(i: NamedParams | PositionalParams): i is NamedParams;
export type Predicate = (k: [key: string, v: ValueType | ValueType[]]) => boolean;
export type PositionalParams = ValueType[];
/**
 * ActionBody is the interface for executing an action with the `kwil.execute()` method.
 */
export interface ActionBody {
    /**
     * @deprecated - This field is deprecated and will be removed in the next major release. Please use the 'namespace' field instead.
     * dbid is the database ID of the record on which to execute the action.
     */
    dbid?: string;
    /**
     * namespace is the namespace of the record on which to execute the action.
     */
    namespace: string;
    /**
     * name is the name of the action or procedure to execute.
     */
    name: string;
    /**
     * inputs is an array of objects. Each object can contain string keys with ValueType values.
     * ActionInput[] is deprecated. Please use Record<string, ValueType>[] instead.
     * Example:
     * ```
     * // Old way (deprecated):
     * const input = ActionInput.of().put("name", "Alice").put("age", 25);
     *
     * // New way using named parameters:
     * const input = { name: "Alice", age: 25 };
     *
     * // New way using positional parameters:
     * const input = ["Alice", 25];
     * ```
     */
    inputs?: NamedParams[] | PositionalParams[] | ActionInput[];
    /**
     * types is an array for the data types of each input
     * You can use the DataType enum to specify the data type.
     * Example:
     * ```
     * import { Utils } from 'kwil-js';
     *
     * const { DataType } = Utils;
     *
     * const body = {
     *  inputs: ["Alice", 25, 1.25],
     *  types: [DataType.Text, DataType.Int8, DataType.Numeric(3, 2)]
     * }
     * ```
     *
     * If using named parameters, you can use the NamedTypes interface to specify the data types.
     * Example:
     * ```
     * const body = {
     * inputs: { $name: "Alice", $age: 25, $height: 1.25 },
     * types: { $name: DataType.Text, $age: DataType.Int8, $height: DataType.Numeric(3, 2) }
     * }
     * ``
     */
    types?: DataInfo[] | NamedTypes;
    /**
     * description is an optional description of the action.
     */
    description?: string;
    /**
     * nonce is an optional nonce value for the action.
     */
    nonce?: number;
}
/**
 * CallBody is the interface for calling an action with the `kwil.call()` method.
 */
export interface CallBody {
    /**
     * @deprecated - This field is deprecated and will be removed in the next major release. Please use the 'namespace' field instead.
     * dbid is the database ID of the record on which to execute the action.
     */
    dbid?: string;
    /**
     * namespace is the namespace of the record on which to execute the action.
     */
    namespace: string;
    /**
     * name is the name of the action or procedure to execute.
     */
    name: string;
    /**
     * inputs is an array of objects. Each object can contain string keys with ValueType values.
     * ActionInput[] is deprecated. Please use Record<string, ValueType>[] instead.
     * Example:
     * ```
     * // Old way (deprecated):
     * const input = ActionInput.of().put("name", "Alice").put("age", 25);
     *
     * // New way using named parameters:
     * const input = { name: "Alice", age: 25 };
     *
     * // New way using positional parameters:
     * const input = ["Alice", 25];
     * ```
     */
    inputs?: NamedParams | PositionalParams | ActionInput[];
    /**
     * types is an array for the data types of each input
     * You can use the DataType enum to specify the data type.
     * Example:
     * ```
     * import { Utils } from 'kwil-js';
     *
     * const { DataType } = Utils;
     *
     * const body = {
     *  inputs: ["Alice", 25, 1.25],
     *  types: [DataType.Text, DataType.Int8, DataType.Numeric(3, 2)]
     * }
     * ```
     *
     * If using named parameters, you can use the NamedTypes interface to specify the data types.
     * Example:
     * ```
     * const body = {
     * inputs: { $name: "Alice", $age: 25, $height: 1.25 },
     * types: { $name: DataType.Text, $age: DataType.Int8, $height: DataType.Numeric(3, 2) }
     * }
     * ``
     */
    types?: DataInfo[] | NamedTypes;
    /**
     * authBody is an optional value for the read/view action to be called in private mode
     * AuthBody interface => consisting of the signature and challenge for the message
     */
    authBody?: AuthBody;
}
export interface CallBodyNode extends CallBody {
    cookie?: string;
}
export interface ActionOptions {
    actionName: string;
    namespace: string;
    chainId: string;
    description: string;
    actionInputs: NamedParams[] | PositionalParams[];
    types?: DataInfo[] | NamedTypes;
    signer?: SignerSupplier;
    identifier?: Uint8Array;
    signatureType?: AnySignatureType;
    nonce?: number;
    challenge?: string;
    signature?: BytesEncodingStatus.BASE64_ENCODED;
}
export interface NamespaceAction {
    name: string;
    namespace: string;
    parameter_names: ReadonlyArray<string>;
    parameter_types: ReadonlyArray<string>;
    return_names: ReadonlyArray<string>;
    return_types: ReadonlyArray<string>;
    returns_table: boolean;
    access_modifiers: ReadonlyArray<AccessModifier>;
    built_in: boolean;
    raw_statement: string;
}
export interface ValidatedAction {
    actionName: string;
    modifiers: ReadonlyArray<AccessModifier>;
    encodedActionInputs: EncodedValue[][];
}
export declare const transformActionInput: {
    /**
     * Checks if all elements in the given array are instances of ActionInput.
     *
     * @param {unknown} i - The value to be checked.
     * @returns {boolean} - True if `inputs` is an array where every element is an ActionInput, otherwise false.
     */
    isActionInputArray(i: unknown): i is ActionInput[];
    /**
     * Transforms action inputs into entries format required by the API.
     * Used to support legacy ActionInput[] when calling a view action where only one input is required.
     *
     * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing a single Entries object
     * @throws {Error} - If inputs array is empty
     */
    toSingleEntry(inputs: ActionInput[] | NamedParams[]): NamedParams;
    /**
     * Transforms action inputs into entries format required by the API.
     * Used to support legacy ActionInput[] when calling an execute action where multiple inputs may be required.
     *
     * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing entries objects
     * @throws {Error} - If inputs array is not valid
     */
    toNamedParams(inputs: ActionInput[] | NamedParams[]): NamedParams[];
};
export declare const transformPositionalParam: {
    /**
   * Checks if all elements in a given array are PositionalParams
   * @param {unknown} i - The value to be checked.
   * @returns {boolean} - True if `inputs` is an array where every element is a PositionalParam, otherwise false.
   */
    isPositionalParams(i: unknown): i is PositionalParams[];
    /**
     * Checks if a given value is a PositionalParam
     * @param {unknown} i - The value to be checked.
     * @returns {boolean} - True if `i` is a PositionalParam, otherwise false.
     */
    isPositionalParam(i: unknown): i is PositionalParams;
    /**
     * Transforms positional parameters into named parameters to be used for validation
     *
     * @param {PositionalParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing entries objects
     */
    toNamedParams(inputs: PositionalParams[]): NamedParams[];
    toNamedParam(i: PositionalParams): NamedParams;
};
/**
 * @deprecated - This class is deprecated and will be removed in the next major release.  Please pass action inputs as an array of objects.
 * `ActionInput` class is a utility class for creating action inputs.
 */
export declare class ActionInput implements Iterable<EntryType> {
    private readonly map;
    constructor();
    /**
     * Adds or replaces a value for a single action input.
     *
     * @param key - The action input name.
     * @param value - The value to put for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    put<T extends ValueType>(key: string, value: T): ActionInput;
    /**
     * Adds a value for a single action input if the key is not already present.
     *
     * @param key - The action input name.
     * @param value - The value to put for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    putIfAbsent<T extends ValueType>(key: string, value: T): ActionInput;
    /**
     * Replaces a value for a single action input if the key is already present.
     *
     * @param key - The action input name.
     * @param value - The value to replace for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    replace<T extends ValueType>(key: string, value: T): ActionInput;
    /**
     * Retrieves an action input value given its key.
     *
     * @param key - The action input name.
     * @returns The value associated with the action input name.
     */
    get<T extends ValueType>(key: string): T;
    /**
     * Retrieves a value by its action input name, or a default value if the action input name is not present.
     *
     * @param key - The action input name.
     * @param defaultValue - The default value to return if the key is not present.
     * @returns The value associated with the key, or the default value.
     */
    getOrDefault<T extends ValueType>(key: string, defaultValue: T): T;
    /**
     * Checks if the map contains a specific action input name.
     *
     * @param key - The action input name.
     * @returns True if the action input name is present, false otherwise.
     */
    containsKey(key: string): boolean;
    /**
     * Removes a action input name and its associated value from the map.
     *
     * @param key - The action input name to remove.
     * @returns True if the key was present and is now removed, false otherwise.
     */
    remove(key: string): boolean;
    /**
     * Converts the map of action inputs to an array of entries.
     *
     * @param filter - An optional filter function.
     * @returns A read-only array of entries.
     */
    toArray(filter?: Predicate): ReadonlyArray<EntryType>;
    /**
     * Transforms the `ActionInput` to JSON.
     *
     * @returns A read-only map of entries.
     */
    toEntries(): Readonly<NamedParams>;
    /**
     * Allows `ActionInput` to be iterable.
     *
     * @returns An iterator over the array of entries.
     */
    [Symbol.iterator](): IterableIterator<EntryType>;
    /**
     * Adds or replaces values from and object of action name/key-value pairs.
     *
     * @param obj - The object from which to extract action name/key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    putFromObject<T extends {}>(obj: T): ActionInput;
    /**
     * Adds values from and object of action name/key-value pairs if the key is not already present.
     *
     * @param obj - The object from which to extract key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    putFromObjectIfAbsent<T extends {}>(obj: T): ActionInput;
    /**
     * Replaces values from and object of action name/key-value pairs if the key is already present.
     *
     * @param obj - The object from which to extract key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    replaceFromObject<T extends {}>(obj: T): ActionInput;
    /**
     * Creates multiple `ActionInput` instances from an array of objects.
     *
     * @param objs - An array of objects from which to create `ActionInput` instances.
     * @returns An array of `ActionInput` instances.
     */
    putFromObjects<T extends {}>(objs: T[]): ActionInput[];
    /**
     * Factory method to create a new instance of `ActionInput`.
     *
     * @returns A new `ActionInput` instance.
     */
    static of(): ActionInput;
    /**
     * Creates a new `ActionInput` instance from an iterable array of entries.
     *
     * @param entries - The iterable of set of entries. Entries should be formatted as an array of `[inputName, value]`.
     * @returns A new `ActionInput` instance.
     */
    static from(entries: Iterable<EntryType>): ActionInput;
    /**
     * Creates a new `ActionInput` instance from an object.
     *
     * @param obj - The object from which to create the `ActionInput`.
     * @returns A new `ActionInput` instance.
     */
    static fromObject<T extends {}>(obj: T): ActionInput;
    /**
     * Creates multiple `ActionInput` instances from an array of objects.
     *
     * @param objs - An array of objects from which to create `ActionInput` instances.
     * @returns An array of `ActionInput` instances.
     */
    static fromObjects<T extends {}>(objs: T[]): ActionInput[];
}
