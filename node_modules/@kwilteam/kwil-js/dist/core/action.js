"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionInput = exports.transformPositionalParam = exports.transformActionInput = exports.isNamedParam = exports.isNamedParams = exports.resolveParamTypes = void 0;
const objects_1 = require("../utils/objects");
const types_1 = require("../utils/types");
function resolveParamTypes(i, types) {
    const paramTypes = [];
    // if no types are provided, return paramtypes with no o property
    if (!types) {
        if (isNamedParam(i)) {
            for (const [k, v] of Object.entries(i)) {
                paramTypes.push({ v });
            }
        }
        else {
            for (let j = 0; j < i.length; j++) {
                paramTypes.push({ v: i[j] });
            }
        }
        return paramTypes;
    }
    // handle named parameters
    if (isNamedParam(i)) {
        // handle named types
        if (types && !Array.isArray(types)) {
            for (const [k, v] of Object.entries(i)) {
                paramTypes.push({ v, o: types[k] });
            }
        }
        else {
            // handle positional types, assume the order of the types matches the order of the parameters
            Object.entries(i).forEach(([k, v], idx) => {
                paramTypes.push({ v, o: types[idx] });
            });
        }
    }
    else {
        // handle positional parameters
        // handle named types
        if (types && !Array.isArray(types)) {
            // assume that the order of the types matches the order of the parameters
            const typeVals = Object.values(types);
            for (let j = 0; j < i.length; j++) {
                paramTypes.push({ v: i[j], o: typeVals[j] });
            }
        }
        else {
            // assume that the order of the types matches the order of the parameters
            for (let j = 0; j < i.length; j++) {
                paramTypes.push({ v: i[j], o: types[j] });
            }
        }
    }
    return paramTypes;
}
exports.resolveParamTypes = resolveParamTypes;
function isNamedParams(i) {
    let isNamedParams = false;
    for (const p of i) {
        if (isNamedParam(p)) {
            isNamedParams = true;
            break;
        }
    }
    return isNamedParams;
}
exports.isNamedParams = isNamedParams;
function isNamedParam(i) {
    return typeof i === "object" && i !== null && !Array.isArray(i);
}
exports.isNamedParam = isNamedParam;
/**
 * Asserts that a key is not null or undefined.
 *
 * @param key - The key to assert.
 * @returns The key if it is not null or undefined.
 * @throws Will throw an error if the key is null or undefined.
 */
function assertKey(key) {
    return objects_1.objects.requireNonNil(key, 'key cannot be nil');
}
function lowercaseKey(key) {
    return key.toLowerCase();
}
exports.transformActionInput = {
    /**
     * Checks if all elements in the given array are instances of ActionInput.
     *
     * @param {unknown} i - The value to be checked.
     * @returns {boolean} - True if `inputs` is an array where every element is an ActionInput, otherwise false.
     */
    isActionInputArray(i) {
        return Array.isArray(i) && i.length > 0 && i.every((item) => item instanceof ActionInput);
    },
    /**
     * Transforms action inputs into entries format required by the API.
     * Used to support legacy ActionInput[] when calling a view action where only one input is required.
     *
     * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing a single Entries object
     * @throws {Error} - If inputs array is empty
     */
    toSingleEntry(inputs) {
        if (!inputs.length) {
            return {};
        }
        const firstInput = inputs[0];
        if (firstInput instanceof ActionInput) {
            return firstInput.toEntries();
        }
        return firstInput;
    },
    /**
     * Transforms action inputs into entries format required by the API.
     * Used to support legacy ActionInput[] when calling an execute action where multiple inputs may be required.
     *
     * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing entries objects
     * @throws {Error} - If inputs array is not valid
     */
    toNamedParams(inputs) {
        if (!exports.transformActionInput.isActionInputArray(inputs)) {
            throw new Error('Inputs array  must be an array of Entries or ActionInput objects');
        }
        const np = [];
        for (const input of inputs) {
            if (input instanceof ActionInput) {
                np.push(input.toEntries());
            }
        }
        return np;
    },
};
exports.transformPositionalParam = {
    /**
   * Checks if all elements in a given array are PositionalParams
   * @param {unknown} i - The value to be checked.
   * @returns {boolean} - True if `inputs` is an array where every element is a PositionalParam, otherwise false.
   */
    isPositionalParams(i) {
        return Array.isArray(i) && i.every((p) => (0, types_1.isValueType)(p));
    },
    /**
     * Checks if a given value is a PositionalParam
     * @param {unknown} i - The value to be checked.
     * @returns {boolean} - True if `i` is a PositionalParam, otherwise false.
     */
    isPositionalParam(i) {
        return (0, types_1.isValueType)(i);
    },
    /**
     * Transforms positional parameters into named parameters to be used for validation
     *
     * @param {PositionalParams[]} inputs - The input array to transform
     * @returns {NamedParams[]} - Array containing entries objects
     */
    toNamedParams(inputs) {
        return inputs.map((i) => {
            return exports.transformPositionalParam.toNamedParam(i);
        });
    },
    toNamedParam(i) {
        const np = {};
        i.forEach((v, idx) => {
            np[`$pstn_${idx}`] = v;
        });
        return np;
    }
};
/**
 * @deprecated - This class is deprecated and will be removed in the next major release.  Please pass action inputs as an array of objects.
 * `ActionInput` class is a utility class for creating action inputs.
 */
class ActionInput {
    constructor() {
        this.map = {};
    }
    /**
     * Adds or replaces a value for a single action input.
     *
     * @param key - The action input name.
     * @param value - The value to put for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    put(key, value) {
        key = lowercaseKey(key);
        this.map[assertKey(key)] = value;
        return this;
    }
    /**
     * Adds a value for a single action input if the key is not already present.
     *
     * @param key - The action input name.
     * @param value - The value to put for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    putIfAbsent(key, value) {
        key = lowercaseKey(key);
        if (!this.containsKey(key)) {
            this.map[key] = value;
        }
        return this;
    }
    /**
     * Replaces a value for a single action input if the key is already present.
     *
     * @param key - The action input name.
     * @param value - The value to replace for the action input.
     * @returns The current `ActionInput` instance for chaining.
     */
    replace(key, value) {
        key = lowercaseKey(key);
        if (this.containsKey(key)) {
            this.map[key] = value;
        }
        return this;
    }
    /**
     * Retrieves an action input value given its key.
     *
     * @param key - The action input name.
     * @returns The value associated with the action input name.
     */
    get(key) {
        key = lowercaseKey(key);
        return this.map[assertKey(key)];
    }
    /**
     * Retrieves a value by its action input name, or a default value if the action input name is not present.
     *
     * @param key - The action input name.
     * @param defaultValue - The default value to return if the key is not present.
     * @returns The value associated with the key, or the default value.
     */
    getOrDefault(key, defaultValue) {
        key = lowercaseKey(key);
        return (this.map[assertKey(key)] ?? defaultValue);
    }
    /**
     * Checks if the map contains a specific action input name.
     *
     * @param key - The action input name.
     * @returns True if the action input name is present, false otherwise.
     */
    containsKey(key) {
        key = lowercaseKey(key);
        return this.map.hasOwnProperty(assertKey(key));
    }
    /**
     * Removes a action input name and its associated value from the map.
     *
     * @param key - The action input name to remove.
     * @returns True if the key was present and is now removed, false otherwise.
     */
    remove(key) {
        key = lowercaseKey(key);
        return delete this.map[key];
    }
    /**
     * Converts the map of action inputs to an array of entries.
     *
     * @param filter - An optional filter function.
     * @returns A read-only array of entries.
     */
    toArray(filter) {
        return Object.entries(this.map).filter(filter ?? (() => true));
    }
    /**
     * Transforms the `ActionInput` to JSON.
     *
     * @returns A read-only map of entries.
     */
    toEntries() {
        return this.map;
    }
    /**
     * Allows `ActionInput` to be iterable.
     *
     * @returns An iterator over the array of entries.
     */
    [Symbol.iterator]() {
        return this.toArray()[Symbol.iterator]();
    }
    /**
     * Adds or replaces values from and object of action name/key-value pairs.
     *
     * @param obj - The object from which to extract action name/key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    putFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
            key = lowercaseKey(key);
            this.map[assertKey(key)] = value;
        }
        return this;
    }
    /**
     * Adds values from and object of action name/key-value pairs if the key is not already present.
     *
     * @param obj - The object from which to extract key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    putFromObjectIfAbsent(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
            key = lowercaseKey(key);
            if (!this.containsKey(key)) {
                this.map[assertKey(key)] = value;
            }
        }
        return this;
    }
    /**
     * Replaces values from and object of action name/key-value pairs if the key is already present.
     *
     * @param obj - The object from which to extract key-value pairs.
     * @returns The current `ActionInput` instance for chaining.
     */
    replaceFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
            key = lowercaseKey(key);
            if (this.containsKey(key)) {
                this.map[assertKey(key)] = value;
            }
        }
        return this;
    }
    /**
     * Creates multiple `ActionInput` instances from an array of objects.
     *
     * @param objs - An array of objects from which to create `ActionInput` instances.
     * @returns An array of `ActionInput` instances.
     */
    putFromObjects(objs) {
        const actions = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
            actions.push(ActionInput.fromObject(obj));
        }
        return actions;
    }
    /**
     * Factory method to create a new instance of `ActionInput`.
     *
     * @returns A new `ActionInput` instance.
     */
    static of() {
        return new ActionInput();
    }
    /**
     * Creates a new `ActionInput` instance from an iterable array of entries.
     *
     * @param entries - The iterable of set of entries. Entries should be formatted as an array of `[inputName, value]`.
     * @returns A new `ActionInput` instance.
     */
    static from(entries) {
        const action = ActionInput.of();
        for (let [key, value] of entries) {
            key = lowercaseKey(key);
            action.map[assertKey(key)] = value;
        }
        return action;
    }
    /**
     * Creates a new `ActionInput` instance from an object.
     *
     * @param obj - The object from which to create the `ActionInput`.
     * @returns A new `ActionInput` instance.
     */
    static fromObject(obj) {
        const action = ActionInput.of();
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
            key = lowercaseKey(key);
            action.map[assertKey(key)] = value;
        }
        return action;
    }
    /**
     * Creates multiple `ActionInput` instances from an array of objects.
     *
     * @param objs - An array of objects from which to create `ActionInput` instances.
     * @returns An array of `ActionInput` instances.
     */
    static fromObjects(objs) {
        const actions = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
            actions.push(ActionInput.fromObject(obj));
        }
        return actions;
    }
}
exports.ActionInput = ActionInput;
//# sourceMappingURL=action.js.map