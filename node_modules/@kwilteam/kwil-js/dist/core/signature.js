"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeSign = exports.isEthersSigner = exports.getSignatureType = exports.SignatureType = void 0;
const serial_1 = require("../utils/serial");
var SignatureType;
(function (SignatureType) {
    SignatureType["SIGNATURE_TYPE_INVALID"] = "invalid";
    SignatureType["SECP256K1_PERSONAL"] = "secp256k1_ep";
    SignatureType["ED25519"] = "ed25519";
})(SignatureType || (exports.SignatureType = SignatureType = {}));
function getSignatureType(signer) {
    if (isEthersSigner(signer)) {
        return SignatureType.SECP256K1_PERSONAL;
    }
    return SignatureType.SIGNATURE_TYPE_INVALID;
}
exports.getSignatureType = getSignatureType;
async function ethSign(message, signer) {
    return await signer.signMessage(message);
}
function isEthersSigner(signer) {
    if (typeof signer === 'object' &&
        signer !== null &&
        'signMessage' in signer &&
        typeof signer.signMessage === 'function') {
        return true;
    }
    return false;
}
exports.isEthersSigner = isEthersSigner;
async function executeSign(msg, signer, signatureType) {
    if (isEthersSigner(signer) && signatureType === SignatureType.SECP256K1_PERSONAL) {
        const hexSig = await ethSign(msg, signer);
        let sigBytes = (0, serial_1.hexToBytes)(hexSig);
        return sigBytes;
    }
    if (!isEthersSigner(signer) && signatureType !== SignatureType.SIGNATURE_TYPE_INVALID) {
        if (typeof signer === 'function') {
            const signature = await signer(msg);
            return signature;
        }
        else {
            throw new Error('Something went wrong signing! Make sure your signer is a function that returns a Uint8Array.');
        }
    }
    throw new Error('Could not execute signature. Make sure you pass a signer from EtherJS or a function that returns a Uint8Array.');
}
exports.executeSign = executeSign;
//# sourceMappingURL=signature.js.map