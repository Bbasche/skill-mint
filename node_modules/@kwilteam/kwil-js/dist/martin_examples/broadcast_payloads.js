"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeActionCall = exports.encodeActionExecution = exports.PayloadType = exports.encodeRawStatement = void 0;
const base64_1 = require("../utils/base64");
const bytes_1 = require("../utils/bytes");
const serial_1 = require("../utils/serial");
var TxSync;
(function (TxSync) {
    // BroadcastSyncSync ensures the transaction is accepted to mempool before
    // responding. This is the default behavior.
    TxSync[TxSync["BroadcastSyncSync"] = 0] = "BroadcastSyncSync";
    // BroadcastSyncCommit will wait for the transaction to be included in a
    // block.
    TxSync[TxSync["BroadcastSyncCommit"] = 1] = "BroadcastSyncCommit";
})(TxSync || (TxSync = {}));
var PayloadType;
(function (PayloadType) {
    PayloadType["RAW_STATEMENT"] = "raw_statement";
    PayloadType["EXECUTE"] = "execute";
    PayloadType["TRANSFER"] = "transfer";
})(PayloadType || (exports.PayloadType = PayloadType = {}));
function encodeRawStatement(stmt) {
    // to encode RawStatement, we need to concat a bytes array of all the required properties.
    // the order of each property on the interfaces is important. If the bytes are concated in an incorrect order, the database engine will not know how to decode them.
    // ~ITEMS TO ENCODE~
    // Item 1. rsVersion
    // rsVersion is a versioning number for the RawStatement interface.
    // This is used in case we different interfaces in the future and want to maintain backwards compatibility.
    const rsVersion = 0;
    // rsVersion should be converted to Uint16 and concactenated with the rest of our bytes
    const CONCACTME_version = numberToUint16LittleEndian(rsVersion);
    // Item 2. Rawstatement.statement
    // We first need to convert the string to bytes
    const stmtBytes = (0, serial_1.stringToBytes)(stmt.statement);
    // then, we need to prefix the byte array with its length. The length must be represented by 4 bytes (uint32)
    const CONCACTME_statement = prefixBytesLength(stmtBytes);
    // Item 3. Rawstatement.parameters
    let CONCACTME_param;
    // We first need to append the number of parameters with two bytes (uint16)
    CONCACTME_param = numberToUint16LittleEndian(stmt.parameters.length);
    // then, for each parameter..
    for (const param of stmt.parameters) {
        // convert the string to bytes
        const nameBytes = (0, serial_1.stringToBytes)(param.name);
        // prefix bytes array with length
        const prefixedNameBytes = prefixBytesLength(nameBytes);
        // encode each value with the `encodeEncodedValue` function
        const valueBytes = encodeEncodedValue(param.value);
        // prefix value with its length
        const valueBytesPrefix = prefixBytesLength(valueBytes);
        // concatenate with our paramBytes
        CONCACTME_param = (0, bytes_1.concatBytes)(CONCACTME_param, prefixedNameBytes, valueBytesPrefix);
    }
    // concat all bytes IN ORDER they appear on the interface
    const bytes = (0, bytes_1.concatBytes)(CONCACTME_version, CONCACTME_statement, CONCACTME_param);
    // send to base64 on return
    return (0, base64_1.bytesToBase64)(bytes);
}
exports.encodeRawStatement = encodeRawStatement;
function encodeEncodedValue(ev) {
    // to encode an `EncodedValue` we need to concat a bytes array with all of the necessary elements
    // similar to earlier encoding functions, the order is important.
    // ~ITEMS TO ENCODE~
    // Item 1. evVersion
    // The versioning number for `EncodedValue`
    const evVersion = 0;
    // convert evVersion to Uint16
    const CONCACTME_version = numberToUint16LittleEndian(evVersion);
    // Item 2. EncodedValue.type
    // use the `encodeDataType` function to get the bytes
    const dataTypeBytes = encodeDataType(ev.type);
    const CONCACTME_type = prefixBytesLength(dataTypeBytes);
    // Item 3. EncodedValue.data
    // first, prepend 4 bytes (uint32) for the length of bytes
    const dataLength = numberToUint16LittleEndian(ev.data.length);
    let CONCACTME_data = (0, bytes_1.concatBytes)(dataLength);
    // then, for each element in the data array
    for (const data of ev.data) {
        CONCACTME_data = (0, bytes_1.concatBytes)(CONCACTME_data, prefixBytesLength(data));
    }
    // Concact bytes together
    // THE ORDER WE CONCACT IS IMPORTANT
    return (0, bytes_1.concatBytes)(CONCACTME_version, CONCACTME_type, CONCACTME_data);
}
function encodeDataType(dt) {
    // I will use less comments here, since the general encoding flow follows the same as previous
    const dtVersion = 0;
    // note that this one uses big endian - I don't think there is a reason, just a kwil-db inconsistency
    const versionBytes = (0, bytes_1.numberToUint16BigEndian)(dtVersion);
    const nameBytes = (0, serial_1.stringToBytes)(dt.name);
    const nameLength = numberToUint32BigEndian(nameBytes.length);
    const isArray = (0, serial_1.booleanToBytes)(dt.is_array);
    const metadataLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata[0]);
    const precisionLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata[1]);
    return (0, bytes_1.concatBytes)(versionBytes, nameLength, nameBytes, isArray, metadataLength, precisionLength);
}
function encodeActionExecution(act) {
    // ~ITEMS TO ENCODE~
    const aeVersion = 0;
    const CONCACTME_version = numberToUint16LittleEndian(aeVersion);
    const CONCACTME_dbid = prefixBytesLength((0, serial_1.stringToBytes)(act.dbid));
    const CONCATME_action = prefixBytesLength((0, serial_1.stringToBytes)(act.action));
    const numCalls = numberToUint16LittleEndian(act.arguments.length);
    let params = new Uint8Array();
    act.arguments.forEach((evArr) => {
        const argLength = numberToUint16LittleEndian(evArr.length);
        let argBytes = new Uint8Array();
        evArr.forEach((ev) => {
            const evBytes = encodeEncodedValue(ev);
            const prefixedEvBytes = prefixBytesLength(evBytes);
            argBytes = (0, bytes_1.concatBytes)(argBytes, prefixedEvBytes);
        });
        params = (0, bytes_1.concatBytes)(params, argLength, argBytes);
    });
    const CONCATME_params = (0, bytes_1.concatBytes)(numCalls, params);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(CONCACTME_version, CONCACTME_dbid, CONCATME_action, CONCATME_params));
}
exports.encodeActionExecution = encodeActionExecution;
function encodeActionCall(ac) {
    const acVersion = 0;
    const CONCACTME_version = numberToUint16LittleEndian(acVersion);
    const CONCATME_DBID = prefixBytesLength((0, serial_1.stringToBytes)(ac.dbid));
    const CONCATME_action = prefixBytesLength((0, serial_1.stringToBytes)(ac.action));
    const numArgs = numberToUint16LittleEndian(ac.arguments.length);
    let params = new Uint8Array();
    ac.arguments.forEach((a) => {
        const aBytes = encodeEncodedValue(a);
        const prefixedABytes = prefixBytesLength(aBytes);
        params = (0, bytes_1.concatBytes)(params, prefixedABytes);
    });
    const CONCACTME_params = (0, bytes_1.concatBytes)(numArgs, params);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(CONCACTME_version, CONCATME_DBID, CONCATME_action, CONCACTME_params));
}
exports.encodeActionCall = encodeActionCall;
// ~~UTILITY FUNCTIONS~~
// prefixBytesLength prefixes a Uint8array with the bytes length (uint32)
function prefixBytesLength(bytes) {
    const lengthBytes = numberToUint32LittleEndian(bytes.length);
    return (0, bytes_1.concatBytes)(lengthBytes, bytes);
}
function numberToUint16LittleEndian(number) {
    if (number < 0 || number > 0xFFFF || !Number.isInteger(number)) {
        throw new RangeError("The number must be an integer between 0 and 65535.");
    }
    const buffer = new ArrayBuffer(2); // Create a buffer of 2 bytes
    const view = new DataView(buffer);
    view.setUint16(0, number, true); // Set the number at byte offset 0 in little-endian
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
function numberToUint32LittleEndian(number) {
    if (number < 0 || number > 0xFFFFFFFF || !Number.isInteger(number)) {
        throw new RangeError("The number must be an integer between 0 and 4294967295.");
    }
    const buffer = new ArrayBuffer(4); // Create a buffer of 4 bytes
    const view = new DataView(buffer);
    view.setUint32(0, number, true); // Write the number at byte offset 0 in little-endian
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
function numberToUint32BigEndian(number) {
    if (number < 0 || number > 0xFFFFFFFF || !Number.isInteger(number)) {
        throw new RangeError("The number must be an integer between 0 and 4294967295.");
    }
    const buffer = new ArrayBuffer(4); // Create a buffer of 4 bytes
    const view = new DataView(buffer);
    view.setUint32(0, number, false); // Write the number in big-endian format (false)
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
//# sourceMappingURL=broadcast_payloads.js.map