"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadMsg = void 0;
const message_1 = require("../core/message");
const objects_1 = require("../utils/objects");
const serial_1 = require("../utils/serial");
const kwilEncoding_1 = require("../utils/kwilEncoding");
/**
 * `PayloadMsg` class creates a call message payload that can be sent over GRPC.
 */
class PayloadMsg {
    /**
     * Initializes a new `PayloadMsg` instance.
     *
     * @param {PayloadMsgOptions} options - Parameters interface to build a payload message.
     */
    constructor(payload, options) {
        this.payload = objects_1.objects.requireNonNil(payload, 'Payload is required for Payload Msg Builder. Please pass a valid payload.');
        // Validate optional parameters if passed into Payload Txn Builder
        objects_1.objects.validateOptionalFields(options, [
            'signature',
            'challenge',
            'signer',
            'identifier',
            'signatureType',
        ]);
        this.signature = options.signature;
        this.challenge = options.challenge;
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
    }
    /**
     * Static factory method to create a new Payload instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Payload instance.
     */
    static createMsg(payload, options) {
        return new PayloadMsg(payload, options);
    }
    /**
     * Build the payload structure for a message.
     */
    async buildMsg() {
        let msg = message_1.Msg.create((msg) => {
            msg.body.payload = this.payload;
            msg.body.challenge = this.challenge;
            msg.signature = this.signature;
        });
        if (this.signer) {
            // ensure required fields are not null or undefined
            const { identifier, signatureType } = objects_1.objects.validateFields({
                identifier: this.identifier,
                signatureType: this.signatureType,
            }, (fieldName) => `${fieldName} required to build a message.`);
            if (identifier) {
                return await PayloadMsg.authMsg(msg, identifier, signatureType);
            }
        }
        // return the unsigned message, with the payload base64 encoded
        return message_1.Msg.copy(msg, (msg) => {
            msg.body.payload = (0, kwilEncoding_1.encodeActionCall)(this.payload);
        });
    }
    /**
     * Adds the caller's sender address to the message.
     *
     * @param {Message} msg - The message to sign. See {@link Message} for more information.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns Message - A promise that resolves to the signed message.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async authMsg(msg, identifier, signatureType) {
        const unencodedPayload = objects_1.objects.requireNonNil(msg.body.payload, 'Payload is required to sign a message. This is likely an internal error. Please create an issue.');
        // copy the message and add the signature, with bytes set to base64 for transport over GRPC
        return message_1.Msg.copy(msg, (msg) => {
            msg.body.payload = (0, kwilEncoding_1.encodeActionCall)(unencodedPayload);
            msg.auth_type = signatureType;
            // bytes must be base64 encoded for transport over GRPC
            msg.sender = (0, serial_1.bytesToHex)(identifier);
        });
    }
}
exports.PayloadMsg = PayloadMsg;
//# sourceMappingURL=payloadMsg.js.map