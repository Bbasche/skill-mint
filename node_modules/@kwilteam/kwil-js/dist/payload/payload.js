"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Payload = void 0;
const intern_1 = require("../client/intern");
const enums_1 = require("../core/enums");
const message_1 = require("../core/message");
const signature_1 = require("../core/signature");
const tx_1 = require("../core/tx");
const base64_1 = require("../utils/base64");
const crypto_1 = require("../utils/crypto");
const rlp_1 = require("../utils/rlp");
const serial_1 = require("../utils/serial");
class Payload {
    /**
     * Initializes a new `Payload` instance.
     *
     * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
     */
    constructor(kwil, options) {
        this.description = '';
        this.challenge = '';
        this.kwil = kwil;
        this.payloadType = options.payloadType;
        this.payload = options.payload;
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
        this.chainId = options.chainId;
        this.description = options.description;
        this.nonce = options.nonce;
        this.challenge = options.challenge;
        this.signature = options.signature;
    }
    /**
     * Static factory method to create a new Payload instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Payload instance.
     */
    static create(kwil, options) {
        return new Payload(kwil, options);
    }
    /**
     * Build the payload structure for a transaction.
     */
    async buildTx() {
        const resolvedPayload = await this.resolvePayload();
        const preEstTxn = tx_1.Txn.create((tx) => {
            tx.body.payload = (0, base64_1.bytesToBase64)((0, rlp_1.kwilEncode)(resolvedPayload));
            tx.body.type = this.payloadType;
            tx.sender = (0, serial_1.bytesToHex)(this.identifier);
        });
        const cost = await (0, intern_1.unwrap)(this.kwil)(preEstTxn);
        const nonce = this.nonce ?? ((await this.kwil.getAccount(this.identifier)).data?.nonce || 0) + 1;
        const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx) => {
            tx.body.payload = (0, base64_1.base64ToBytes)(preEstTxn.body.payload);
            tx.body.fee = BigInt(cost.data);
            tx.body.nonce = nonce;
            tx.body.chain_id = this.chainId;
            //   tx.body.payload = base64ToBytes(preEstTxn.body.payload as string);
            //   tx.body.fee = BigInt(
            //     strings.requireNonNil(
            //       cost.data,
            //       'something went wrong estimating the cost of your transaction.'
            //     )
            //   );
            //   tx.body.nonce = objects.requireNonNil(
            //     nonce,
            //     'something went wrong retrieving your account nonce.'
            //   );
            //   tx.body.chain_id = this.chainId!;
        });
        // check that a valid signature is used
        if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
            throw new Error('Signature type is invalid.');
        }
        const signedTx = Payload.signTx(postEstTxn, this.signer, this.identifier, this.signatureType, this.description);
        // console.log("signed tx sender ===> ", ((await signedTx).sender));
        return signedTx;
    }
    /**
     * Signs the payload of a transaction / request to the broadcast GRPC endpoint.
     *
     * @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
     * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async signTx(tx, signer, identifier, signatureType, description) {
        // create the digest, which is the first bytes of the sha256 hash of the rlp-encoded payload
        const digest = (0, crypto_1.sha256BytesToBytes)(tx.body.payload).subarray(0, 20);
        // create the signature message
        const signatureMessage = `${description}\n\nPayloadType: ${tx.body.type}\nPayloadDigest: ${(0, serial_1.bytesToHex)(digest)}\nFee: ${tx.body.fee}\nNonce: ${tx.body.nonce}\nKwil Chain ID: ${tx.body.chain_id}\n`;
        // sign the above message
        const signedMessage = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(signatureMessage), signer, signatureType);
        // copy the transaction and add the signature
        return tx_1.Txn.copy(tx, (newTx) => {
            newTx.signature = {
                // bytes must be base64 encoded for transport over GRPC
                sig: (0, base64_1.bytesToBase64)(signedMessage),
                type: signatureType.toString(),
            };
            newTx.body = {
                desc: description,
                payload: (0, base64_1.bytesToBase64)(tx.body.payload),
                type: newTx.body.type,
                fee: newTx.body.fee?.toString() || '',
                nonce: newTx.body.nonce,
                chain_id: newTx.body.chain_id,
            };
            // bytes must be base64 encoded for transport over GRPC
            newTx.sender = (0, serial_1.bytesToHex)(identifier);
            newTx.serialization = enums_1.SerializationType.SIGNED_MSG_CONCAT;
        });
    }
    /**
     * Build the payload structure for a message.
     */
    async buildMsg() {
        const resolvedPayload = await this.resolvePayload();
        let msg = message_1.Msg.create((msg) => {
            msg.body.payload = resolvedPayload;
            msg.body.challenge = this.challenge;
            msg.signature = this.signature;
        });
        if (this.identifier) {
            return await Payload.authMsg(msg, this.identifier, this.signatureType);
        }
        // return the unsigned message, with the payload base64 encoded
        return message_1.Msg.copy(msg, (msg) => {
            // rlp encode the payload and convert to base64 for transport over GRPC
            msg.body.payload = (0, base64_1.bytesToBase64)((0, rlp_1.kwilEncode)(resolvedPayload));
        });
    }
    /**
     * Adds the caller's sender address to the message.
     *
     * @param {Message} msg - The message to sign. See {@link Message} for more information.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns Message - A promise that resolves to the signed message.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async authMsg(msg, identifier, signatureType) {
        // rlp encode the payload
        const encodedPayload = (0, rlp_1.kwilEncode)(msg.body.payload);
        // copy the message and add the signature, with bytes set to base64 for transport over GRPC
        return message_1.Msg.copy(msg, (msg) => {
            // bytes must be base64 encoded for transport over GRPC
            msg.body.payload = (0, base64_1.bytesToBase64)(encodedPayload);
            msg.auth_type = signatureType;
            // bytes must be base64 encoded for transport over GRPC
            msg.sender = (0, serial_1.bytesToHex)(identifier);
        });
    }
    /**
     * Method to resolve the payload from either direct value or a function.
     */
    async resolvePayload() {
        if (typeof this.payload === 'function') {
            const resolvedPayload = this.payload();
            if (resolvedPayload === undefined) {
                throw new Error('Payload function returned undefined.');
            }
            // Cast resolvedPayload as AllPayloads, as we've checked it can't be undefined.
            return resolvedPayload;
        }
        throw new Error('Payload is missing.');
    }
}
exports.Payload = Payload;
// TODO => refactor all of the build functions
// buildTx() => builds the payload for kwil.broadcast() method (GRPC broadcast endpoint) - resolves to the signed transaction
// buildMsg() => builds the payload structure for message to the kwil.call() method - resolves to the message with signature if provided
// resolvePayload() => resolves the provided payload object
// signTx() => signs the payload of a transaction to the GRPC broadcast endpoint
// authMsg() => adds caller's sender address to the message - resolves to the signed message
// TODO => create a function that streamlines the repetitiveness in lines 155-175
// somehow maybe map through all of the txPayload properties you want to provide and then...
// ...dynamically create txPayload.param = objects.requireNonNil(param, `${param} is required`)
// TODO => Think about this...
// see if you even need to preassign variables like above (txPayload). May be able to directly call buildTx to build it vs all of the chaining non-sense
// may not even need the top part. may just need to call the functions without them
//# sourceMappingURL=payload.js.map