"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadTx = void 0;
const intern_1 = require("../client/intern");
const enums_1 = require("../core/enums");
const signature_1 = require("../core/signature");
const tx_1 = require("../core/tx");
const base64_1 = require("../utils/base64");
const crypto_1 = require("../utils/crypto");
const objects_1 = require("../utils/objects");
const serial_1 = require("../utils/serial");
const strings_1 = require("../utils/strings");
const kwilEncoding_1 = require("../utils/kwilEncoding");
/**
 * `Payload` class creates a transaction and call payloads that can be sent over GRPC.
 */
class PayloadTx {
    /**
     * Initializes a new `Payload` instance.
     *
     * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
     */
    constructor(kwil, options) {
        this.kwil = objects_1.objects.requireNonNil(kwil, 'Client is required for TxnBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.');
        this.payload = objects_1.objects.requireNonNil(options.payload, 'Payload is required for TxnBuilder. Please pass a valid payload.');
        // Validate optional parameters if passed into Payload Txn Builder
        objects_1.objects.validateOptionalFields(options, [
            'payloadType',
            'signer',
            'identifier',
            'signatureType',
            'chainId',
            'description',
            'nonce',
        ]);
        this.payloadType = options.payloadType;
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
        this.chainId = options.chainId;
        this.description = options.description;
        this.nonce = options.nonce;
    }
    /**
     * Static factory method to create a new Payload instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Payload instance.
     */
    static createTx(kwil, options) {
        return new PayloadTx(kwil, options);
    }
    /**
     * Build the payload structure for a transaction.
     */
    async buildTx() {
        // ensure required fields are not null or undefined
        const { signer, payloadType, identifier, signatureType, chainId } = objects_1.objects.validateFields({
            signer: this.signer,
            payloadType: this.payloadType,
            identifier: this.identifier,
            signatureType: this.signatureType,
            chainId: this.chainId,
        }, (fieldName) => `${fieldName} is required to build a transaction.`);
        // create transaction payload for estimating cost. Set the Tx bytes type to base64 encoded because we need to make GRPC estimate cost request.
        const preEstTxn = tx_1.Txn.create((tx) => {
            // Encode the payload depending on the payload type
            tx.body.payload = this.encodePayload(this.payloadType, this.payload);
            tx.body.type = payloadType;
            tx.sender = (0, serial_1.bytesToHex)(identifier);
        });
        // estimate the cost of the transaction with the estimateCost symbol from the client
        const cost = await (0, intern_1.unwrap)(this.kwil)(preEstTxn);
        // retrieve the account for the nonce, if one is provided
        let nonce = this.nonce;
        // if no nonce is provided, retrieve the nonce from the account
        if (!this.nonce) {
            const acct = await this.kwil.getAccount(identifier);
            nonce =
                Number(objects_1.objects.requireNonNil(acct.data?.nonce, 'something went wrong retrieving your account nonce.')) + 1;
        }
        const encodedPayload = objects_1.objects.requireNonNil(preEstTxn.body.payload, 'encoded payload is null. This is likely an internal error, please create an issue.');
        // add the nonce and fee to the transaction. Set the tx bytes back to uint8 so we can do the signature.
        const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx) => {
            tx.body.payload = (0, base64_1.base64ToBytes)(encodedPayload);
            tx.body.fee = BigInt(strings_1.strings.requireNonNil(cost.data, 'something went wrong estimating the cost of your transaction.'));
            tx.body.nonce = objects_1.objects.requireNonNil(nonce, 'something went wrong retrieving your account nonce.');
            tx.body.chain_id = chainId;
        });
        // check that a valid signature is used
        if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
            throw new Error('Signature type is invalid.');
        }
        // sign the transaction
        return PayloadTx.signTx(postEstTxn, signer, identifier, signatureType, this.description);
    }
    /**
     * Signs the payload of a transaction / request to the broadcast GRPC endpoint.
     *
     * @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
     * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async signTx(tx, signer, identifier, signatureType, description) {
        // create the digest, which is the first bytes of the sha256 hash of the rlp-encoded payload
        const digest = (0, crypto_1.sha256BytesToBytes)(tx.body.payload).subarray(0, 20);
        /**
         * create the signature message
         * the signature message cannot have any preceding or succeeding white space. Must be exact length as server expects it
         */
        const signatureMessage = `${description}

PayloadType: ${tx.body.type}
PayloadDigest: ${(0, serial_1.bytesToHex)(digest)}
Fee: ${tx.body.fee}
Nonce: ${tx.body.nonce}

Kwil Chain ID: ${tx.body.chain_id}
`;
        // sign the above message
        const signedMessage = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(signatureMessage), signer, signatureType);
        const encodedPayload = objects_1.objects.requireNonNil(tx.body.payload, 'encoded payload is null. This is likely an internal error, please create an issue.');
        // copy the transaction and add the signature
        return tx_1.Txn.copy(tx, (newTx) => {
            newTx.signature = {
                // bytes must be base64 encoded for transport over GRPC
                sig: (0, base64_1.bytesToBase64)(signedMessage),
                type: signatureType.toString(),
            };
            newTx.body = {
                desc: description,
                payload: (0, base64_1.bytesToBase64)(encodedPayload),
                type: newTx.body.type,
                fee: newTx.body.fee?.toString() || '',
                nonce: newTx.body.nonce,
                chain_id: newTx.body.chain_id,
            };
            // bytes must be base64 encoded for transport over GRPC
            newTx.sender = (0, serial_1.bytesToHex)(identifier);
            newTx.serialization = enums_1.SerializationType.SIGNED_MSG_CONCAT;
        });
    }
    encodePayload(payloadType, payload) {
        switch (payloadType) {
            case enums_1.PayloadType.EXECUTE_ACTION:
                if (!('action' in payload && 'arguments' in payload)) {
                    throw new Error('Invalid payload type for EXECUTE_ACTION');
                }
                return (0, kwilEncoding_1.encodeActionExecution)(payload);
            case enums_1.PayloadType.TRANSFER:
                if (!('to' in payload && 'amount' in payload)) {
                    throw new Error('Invalid payload type for TRANSFER');
                }
                return (0, kwilEncoding_1.encodeTransfer)(payload);
            case enums_1.PayloadType.RAW_STATEMENT:
                if (!('statement' in payload && 'parameters' in payload)) {
                    throw new Error('Invalid payload type for RAW_STATEMENT');
                }
                return (0, kwilEncoding_1.encodeRawStatement)(payload);
            default:
                throw new Error(`Unsupported payload type: ${payloadType}`);
        }
    }
}
exports.PayloadTx = PayloadTx;
//# sourceMappingURL=payloadTx.js.map