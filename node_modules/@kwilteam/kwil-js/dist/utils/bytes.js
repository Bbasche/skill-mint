"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixBytesLength = exports.numberToUint32BigEndian = exports.numberToUint16LittleEndian = exports.concatBytes = exports.numberToUint64LittleEndian = exports.uint16BigEndianToNumber = exports.numberToUint16BigEndian = void 0;
// The GRPC gateway "bytes" type requires base64url encoded strings.
const long_1 = __importDefault(require("long"));
// Convert function to Uint16Array
function numberToUint16BigEndian(num) {
    if (num < 0 || num > 65535 || !Number.isInteger(num)) {
        throw new Error('Number is out of range for uint16');
    }
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setUint16(0, num, false); // big endian
    return new Uint8Array(buffer);
}
exports.numberToUint16BigEndian = numberToUint16BigEndian;
// Converts a uint8array in uint16 format to a number
function uint16BigEndianToNumber(uint16) {
    if (uint16.length !== 2) {
        throw new Error('uint16 must be 2 bytes');
    }
    const view = new DataView(uint16.buffer);
    return view.getUint16(0, false); // big endian
}
exports.uint16BigEndianToNumber = uint16BigEndianToNumber;
function numberToUint64LittleEndian(num) {
    const longNum = long_1.default.fromNumber(num, true);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setUint32(0, longNum.low, true);
    view.setUint32(4, longNum.high, true);
    return new Uint8Array(buffer);
}
exports.numberToUint64LittleEndian = numberToUint64LittleEndian;
function concatBytes(...arrays) {
    let totalLength = 0;
    for (const arr of arrays) {
        totalLength += arr.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function numberToUint16LittleEndian(number) {
    if (number < 0 || number > 0xffff || !Number.isInteger(number)) {
        throw new RangeError('The number must be an integer between 0 and 65535.');
    }
    const buffer = new ArrayBuffer(2); // Create a buffer of 2 bytes
    const view = new DataView(buffer);
    view.setUint16(0, number, true); // Set the number at byte offset 0 in little-endian
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
exports.numberToUint16LittleEndian = numberToUint16LittleEndian;
function numberToUint32LittleEndian(number) {
    if (number < 0 || number > 0xffffffff || !Number.isInteger(number)) {
        throw new RangeError('The number must be an integer between 0 and 4294967295.');
    }
    const buffer = new ArrayBuffer(4); // Create a buffer of 4 bytes
    const view = new DataView(buffer);
    view.setUint32(0, number, true); // Write the number at byte offset 0 in little-endian
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
function numberToUint32BigEndian(number) {
    if (number < 0 || number > 0xffffffff || !Number.isInteger(number)) {
        throw new RangeError('The number must be an integer between 0 and 4294967295.');
    }
    const buffer = new ArrayBuffer(4); // Create a buffer of 4 bytes
    const view = new DataView(buffer);
    view.setUint32(0, number, false); // Write the number in big-endian format (false)
    return new Uint8Array(buffer); // Convert to Uint8Array for easier use
}
exports.numberToUint32BigEndian = numberToUint32BigEndian;
// prefixBytesLength prefixes a Uint8array with the bytes length (uint32)
function prefixBytesLength(bytes) {
    const lengthBytes = numberToUint32LittleEndian(bytes.length);
    return concatBytes(lengthBytes, bytes);
}
exports.prefixBytesLength = prefixBytesLength;
//# sourceMappingURL=bytes.js.map