"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
var Cache;
(function (Cache) {
    /**
     * Create a new TTL cache that proactively checks for expired items at regular intervals (defined by cleanupIntervalSeconds).
        * @param ttlSeconds - Time to live for each cache entry in seconds. If none is specified, it defaults to 10 minutes.
        * @param cleanupIntervalSeconds - Interval in seconds between each cleanup run. If not set, it defaults to 60 seconds. If set to -1, the cache will run in passive mode and only check for expired items when get() is called.
        * @returns Cache<T>
    */
    function active(ttlSeconds = 10 * 60, cleanupIntervalSeconds = 60) {
        return new TtlCache(ttlSeconds, cleanupIntervalSeconds);
    }
    Cache.active = active;
    /**
     * Create a new TTL cache that only checks for expired items when get() is called.
     * @param ttlSeconds - Time to live for each cache entry in seconds. If none is specified, it defaults to 10 minutes.
     * @returns Cache<T>
    */
    function passive(ttlSeconds = 10 * 60) {
        return new TtlCache(ttlSeconds, -1);
    }
    Cache.passive = passive;
})(Cache || (exports.Cache = Cache = {}));
class TtlCache {
    constructor(ttlSeconds, cleanupIntervalSeconds) {
        this.cache = new Map();
        this.ttl = ttlSeconds * 1000;
        this.cleanupIntervalSeconds = cleanupIntervalSeconds;
        this.cleanupQueue = [];
        console.log(`Cache TTL set to ${this.ttl} milliseconds.`);
        if (!this.isPassiveMode()) {
            console.log(`Cache cleanup interval set to ${cleanupIntervalSeconds} seconds.`);
        }
        else {
            console.log(`Cache cleanup running in passive mode.`);
        }
    }
    /**
     * Set a value in the cache
     * @param k - Key for the cache entry.
     * @param v - Value to be stored.
     */
    set(k, v) {
        this.ensureCleanRunning();
        const d = Date.now() + this.ttl;
        this.cache.set(k, { d, v });
        if (!this.isPassiveMode()) {
            this.cleanupQueue.push({ d, k });
        }
    }
    /**
     * Get a value from the cache. If the value is not found or has expired, null is returned.
     * @param k - Key for the cache entry.
     * @param v - Value to be stored.
    */
    get(k) {
        const entry = this.cache.get(k);
        if (entry && entry.d < Date.now()) {
            this.cache.delete(k);
            return null;
        }
        return entry?.v || null;
    }
    /**
     * This will shutdown the cache cleanup timer.
     * @returns void
    */
    shutdown() {
        if (this.cleanupTimerId) {
            clearInterval(this.cleanupTimerId);
        }
    }
    /**
     * Ensures that the background cleanup is running and the timer is set.
     * @returns void
     * @private
     */
    ensureCleanRunning() {
        if (this.isPassiveMode()) {
            return;
        }
        if (!this.cleanupTimerId) {
            this.cleanupTimerId =
                setInterval(this.cleanup.bind(this), this.cleanupIntervalSeconds * 1000);
            console.log(`Background cache cleanup started. Interval of ${this.cleanupIntervalSeconds} seconds between cleaup.`);
        }
    }
    /**
     * Checks if the cache is running in passive mode.
     * @returns boolean
     * @private
     */
    isPassiveMode() {
        return this.cleanupIntervalSeconds <= 0;
    }
    /**
     * Cleanup the cache. This will remove all expired entries from the cache.
     * @returns void
     * @private
    */
    cleanup() {
        let removed = 0;
        while (this.cleanupQueue.length > 0) {
            const entry = this.cleanupQueue[0];
            if (entry.d > Date.now()) {
                break;
            }
            const cacheEntry = this.cache.get(entry.k);
            if (cacheEntry && cacheEntry.d < Date.now()) {
                this.cache.delete(entry.k);
                removed++;
            }
            this.cleanupQueue.shift();
        }
        console.log(`Running background cache cleanup. Removed ${removed} entries.`);
    }
}
//# sourceMappingURL=cache.js.map