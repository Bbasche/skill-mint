"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeValue = exports.encodeTransfer = exports.encodeRawStatement = exports.encodeActionExecution = exports.encodeActionCall = exports.encodeAccountId = void 0;
const base64_1 = require("./base64");
const bytes_1 = require("./bytes");
const serial_1 = require("./serial");
const uuid_1 = require("./uuid");
const enums_1 = require("../core/enums");
function encodeAccountId(accountId) {
    const encodedId = (0, bytes_1.prefixBytesLength)((0, serial_1.hexToBytes)(accountId.identifier));
    const encodedKeyType = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(accountId.key_type));
    return (0, bytes_1.concatBytes)(encodedId, encodedKeyType);
}
exports.encodeAccountId = encodeAccountId;
function encodeActionCall(actionCall) {
    // // The version of the action call encoding used by the Kwil DB Engine
    const actionCallVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionCallVersion);
    const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(actionCall.dbid));
    // Action name
    const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(actionCall.action));
    const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(actionCall.arguments ? actionCall.arguments.length : 0);
    let actionArguments = new Uint8Array();
    actionCall.arguments?.forEach((a) => {
        const aBytes = encodeEncodedValue(a);
        const prefixedABytes = (0, bytes_1.prefixBytesLength)(aBytes);
        actionArguments = (0, bytes_1.concatBytes)(actionArguments, prefixedABytes);
    });
    const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
}
exports.encodeActionCall = encodeActionCall;
function encodeActionExecution(action) {
    // The version of the action execution encoding used by the Kwil DB Engine
    const actionExecutionVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionExecutionVersion);
    const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(action.dbid));
    // Action name
    const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(action.action));
    const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(action.arguments ? action.arguments.length : 0);
    let actionArguments = new Uint8Array();
    action.arguments?.forEach((encodedValues) => {
        const argLength = (0, bytes_1.numberToUint16LittleEndian)(encodedValues.length);
        let argBytes = new Uint8Array();
        encodedValues.forEach((value) => {
            const evBytes = encodeEncodedValue(value);
            const prefixedEvBytes = (0, bytes_1.prefixBytesLength)(evBytes);
            argBytes = (0, bytes_1.concatBytes)(argBytes, prefixedEvBytes);
        });
        actionArguments = (0, bytes_1.concatBytes)(actionArguments, argLength, argBytes);
    });
    const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
}
exports.encodeActionExecution = encodeActionExecution;
function encodeRawStatement(statement) {
    // to encode RawStatement, we need to concat a bytes array of all the required properties.
    // the order of each property on the interfaces is important. If the bytes are concated in an incorrect order, the database engine will not know how to decode them.
    // ~ITEMS TO ENCODE~
    // Item 1. rsVersion
    // rsVersion is a versioning number for the RawStatement interface.
    // This is used in case we different interfaces in the future and want to maintain backwards compatibility.
    const rawStatementVersion = 0;
    // rsVersion should be converted to Uint16 and concactenated with the rest of our bytes
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(rawStatementVersion);
    // Item 2. Rawstatement.statement
    // We first need to convert the string to bytes
    const statementBytes = (0, serial_1.stringToBytes)(statement.statement);
    // then, we need to prefix the byte array with its length. The length must be represented by 4 bytes (uint32)
    const encodedStatement = (0, bytes_1.prefixBytesLength)(statementBytes);
    // Item 3. Rawstatement.parameters
    let encodedParameters;
    // We first need to append the number of parameters with two bytes (uint16)
    encodedParameters = (0, bytes_1.numberToUint16LittleEndian)(statement.parameters ? statement.parameters.length : 0);
    // then, for each parameter..
    for (const param of statement.parameters) {
        // convert the string to bytes
        const nameBytes = (0, serial_1.stringToBytes)(param.name);
        // prefix bytes array with length
        const prefixedNameBytes = (0, bytes_1.prefixBytesLength)(nameBytes);
        // encode each value with the `encodeEncodedValue` function
        const valueBytes = encodeEncodedValue(param.value);
        // prefix value with its length
        const valueBytesPrefix = (0, bytes_1.prefixBytesLength)(valueBytes);
        // concatenate with our paramBytes
        encodedParameters = (0, bytes_1.concatBytes)(encodedParameters, prefixedNameBytes, valueBytesPrefix);
    }
    // concat all bytes IN ORDER they appear on the interface
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedStatement, encodedParameters));
}
exports.encodeRawStatement = encodeRawStatement;
function encodeTransfer(transfer) {
    const transferVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(transferVersion);
    const encodedTo = (0, bytes_1.prefixBytesLength)(encodeAccountId(transfer.to));
    // for BigInt Serialization, add a single byte and then encode it as a string
    const encodedAmount = (0, bytes_1.concatBytes)(new Uint8Array([1]), (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(transfer.amount.toString())));
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedTo, encodedAmount));
}
exports.encodeTransfer = encodeTransfer;
function encodeEncodedValue(ev) {
    // To encode an `EncodedValue` we need to concat a bytes array with all of the necessary elements
    // The order is important.
    // The versioning number for `EncodedValue`
    const evVersion = 0;
    // convert evVersion to Uint16
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(evVersion);
    // EncodedValue.type - the `encodeDataType` function to get the bytes
    const dataTypeBytes = encodeDataType(ev.type);
    const encodedType = (0, bytes_1.prefixBytesLength)(dataTypeBytes);
    // EncodedValue.data - first, prepend 4 bytes (uint32) for the length of bytes
    const dataLength = (0, bytes_1.numberToUint16LittleEndian)(ev.data.length);
    let encodedData = (0, bytes_1.concatBytes)(dataLength);
    // then, for each element in the data array
    for (const data of ev.data) {
        encodedData = (0, bytes_1.concatBytes)(encodedData, (0, bytes_1.prefixBytesLength)(data));
    }
    // Concact bytes together in correct order
    return (0, bytes_1.concatBytes)(encodedVersion, encodedType, encodedData);
}
function encodeDataType(dt) {
    // I will use less comments here, since the general encoding flow follows the same as previous
    const dtVersion = 0;
    // note that this one uses big endian - I don't think there is a reason, just a kwil-db inconsistency
    const versionBytes = (0, bytes_1.numberToUint16BigEndian)(dtVersion);
    const nameBytes = (0, serial_1.stringToBytes)(dt.name);
    const nameLength = (0, bytes_1.numberToUint32BigEndian)(nameBytes.length);
    const isArray = (0, serial_1.booleanToBytes)(dt.is_array);
    const metadataLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[0] || 0);
    const precisionLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[1] || 0);
    return (0, bytes_1.concatBytes)(versionBytes, nameLength, nameBytes, isArray, metadataLength, precisionLength);
}
function encodeValue(value, o) {
    // handle override case
    if (o) {
        return overrideValue(value, o);
    }
    // handle uuid case
    if (typeof value === 'string' && (0, uuid_1.isUuid)(value)) {
        return encodeNotNull((0, uuid_1.convertUuidToBytes)(value));
    }
    // handle null case
    if (value === null) {
        return encodeNull();
    }
    // handle Uint8Array case
    if (value instanceof Uint8Array) {
        return encodeNotNull(value);
    }
    // handle decimal case
    if (typeof value === 'number' && isDecimal(value)) {
        return encodeNotNull((0, serial_1.stringToBytes)(value.toString()));
    }
    // handle other scalar value cases
    switch (typeof value) {
        case 'string':
            return encodeNotNull((0, serial_1.stringToBytes)(value));
        case 'boolean':
            return encodeNotNull((0, serial_1.booleanToBytes)(value));
        case 'number':
            return encodeNotNull((0, serial_1.numberToBytes)(value));
        case 'undefined':
            return encodeNull();
        case 'bigint':
            throw new Error('bigint not supported. convert to string.');
        default:
            throw new Error('invalid scalar value');
    }
}
exports.encodeValue = encodeValue;
function overrideValue(v, o) {
    if (v === null || v === undefined) {
        return encodeNull();
    }
    switch (o) {
        case enums_1.VarType.NULL:
            return encodeNull();
        case enums_1.VarType.TEXT:
            return encodeNotNull((0, serial_1.stringToBytes)(v));
        case enums_1.VarType.INT8:
            return encodeNotNull((0, serial_1.numberToBytes)(v));
        case enums_1.VarType.BOOL:
            return encodeNotNull((0, serial_1.booleanToBytes)(v));
        case enums_1.VarType.NUMERIC:
            return encodeNotNull((0, serial_1.stringToBytes)(v.toString()));
        case enums_1.VarType.UUID:
            return encodeNotNull((0, uuid_1.convertUuidToBytes)(v));
        case enums_1.VarType.BYTEA:
            return encodeNotNull(v);
        default:
            throw new Error('invalid scalar value');
    }
}
function isDecimal(n) {
    const numStr = Math.abs(n).toString();
    const decimalIdx = numStr.indexOf('.');
    return decimalIdx !== -1;
}
function encodeNull() {
    return new Uint8Array([0]);
}
function encodeNotNull(v) {
    const bytes = new Uint8Array(v.length + 1);
    bytes[0] = 1;
    bytes.set(v, 1);
    return bytes;
}
//# sourceMappingURL=kwilEncoding.js.map