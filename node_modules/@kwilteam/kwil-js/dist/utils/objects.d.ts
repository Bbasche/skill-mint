import { NonNil } from './types';
declare const NillablErrorSymbol: unique symbol;
export declare class NillableError extends Error {
    constructor(message?: NonNil<string>);
    private get [NillablErrorSymbol]();
}
export declare const objects: {
    isNilError: (error: Error) => boolean;
    isNil: <T>(value: T) => boolean;
    isNotNil: <T_1>(value: T_1) => boolean;
    /**
     * Helper function to validate required fields with a requireNonNil error.
     * @param values An object containing field names and their corresponding values.
     * @param errorMessageTemplate A function to generate error messages dynamically.
     */
    validateFields: <T_2 extends Record<string, any>>(values: T_2, errorMessageTemplate: (fieldName: keyof T_2) => string) => { [K in keyof T_2]: NonNil<T_2[K]>; };
    requireNonNil: <T_3>(value: T_3, message?: string | ((v: T_3) => Error) | undefined) => NonNil<T_3>;
    requireNonNilNumber: <T_4>(value: T_4, message?: string | ((v: T_4) => Error) | undefined) => NonNil<number>;
    requireMaxLength: <T_5 extends {
        toString(): string;
    }>(value: T_5, maxLength: number, message?: string | ((v: T_5) => Error) | undefined) => NonNil<T_5>;
    /**
     * Validates that optional parameters, if provided, are not null.
     *
     * @param options - The options object containing the parameters to validate.
     * @param fields - An array of field names to validate.
     * @throws Error if any field is explicitly provided but null.
     */
    validateOptionalFields<T_6>(options: T_6, fields: (keyof T_6)[]): void;
    /**
     * Validates required parameters for the class or function, are not null or undefined.
     *
     * @param options - The options object containing the parameters to validate.
     * @param fields - An array of field names to validate.
     * @throws Error if any field is explicitly provided but null.
     */
    validateRequiredFields<T_7>(options: T_7, fields: (keyof T_7)[]): T_7;
};
export {};
