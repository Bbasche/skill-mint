"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objects = exports.NillableError = void 0;
const NillablErrorSymbol = Symbol();
const NILL_ERROR_MESSAGE = 'value cannot be null or undefined';
class NillableError extends Error {
    constructor(message = NILL_ERROR_MESSAGE) {
        super(message || NILL_ERROR_MESSAGE);
    }
    get [NillablErrorSymbol]() {
        return true;
    }
}
exports.NillableError = NillableError;
exports.objects = {
    isNilError: (error) => {
        return error[NillablErrorSymbol] === true;
    },
    // returns true if the value is null or undefined,
    // else will return false.
    isNil: (value) => {
        return value === null || value === undefined;
    },
    // returns false if the value is null or undefined,
    // else will return true.
    isNotNil: (value) => {
        return !exports.objects.isNil(value);
    },
    /**
     * Helper function to validate required fields with a requireNonNil error.
     * @param values An object containing field names and their corresponding values.
     * @param errorMessageTemplate A function to generate error messages dynamically.
     */
    validateFields: (values, errorMessageTemplate) => {
        for (const key in values) {
            exports.objects.requireNonNil(values[key], errorMessageTemplate(key));
        }
        return values;
    },
    // If value is null or undefined, then an error is thrown, else
    // value is returned.
    requireNonNil: (value, message) => {
        if (!exports.objects.isNil(value)) {
            return value;
        }
        if (typeof message === 'function') {
            throw message(value);
        }
        throw new NillableError(message);
    },
    // If value is null or undefined, then an error is thrown, else
    // value is returned.
    requireNonNilNumber: (value, message) => {
        if (typeof value === 'number') {
            return value;
        }
        if (typeof message === 'function') {
            throw message(value);
        }
        if (!value) {
            throw new NillableError(message);
        }
        throw new Error('value is not a number, it is a ' + typeof value);
    },
    requireMaxLength: (value, maxLength, message) => {
        if (!value) {
            if (typeof message === 'function') {
                throw message(value);
            }
            throw new Error(message || 'value is null or undefined');
        }
        if (typeof value.toString !== 'function') {
            throw new Error('value does not have a toString() method');
        }
        if (value.toString().length > maxLength) {
            if (typeof message === 'function') {
                throw message(value);
            }
            throw new Error(message || `value is longer than ${maxLength} characters`);
        }
        return value;
    },
    /**
     * Validates that optional parameters, if provided, are not null.
     *
     * @param options - The options object containing the parameters to validate.
     * @param fields - An array of field names to validate.
     * @throws Error if any field is explicitly provided but null.
     */
    validateOptionalFields(options, fields) {
        fields.forEach((field) => {
            if (options[field] !== undefined && options[field] === null) {
                throw new Error(`${String(field)} must not be null.`);
            }
        });
    },
    /**
     * Validates required parameters for the class or function, are not null or undefined.
     *
     * @param options - The options object containing the parameters to validate.
     * @param fields - An array of field names to validate.
     * @throws Error if any field is explicitly provided but null.
     */
    validateRequiredFields(options, fields) {
        fields.forEach((field) => {
            if (options[field] === undefined && options[field] === null) {
                throw new Error(`${String(field)} must not be null.`);
            }
        });
        return options;
    },
};
//# sourceMappingURL=objects.js.map