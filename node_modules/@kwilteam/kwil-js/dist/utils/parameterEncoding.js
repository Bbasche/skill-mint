"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveValueType = exports.analyzeNumber = exports.encodeValueType = exports.encodeRawStatementParameters = exports.encodeParameters = void 0;
const enums_1 = require("../core/enums");
const base64_1 = require("./base64");
const kwilEncoding_1 = require("./kwilEncoding");
const uuid_1 = require("./uuid");
// Used by the selectQuery() method
function encodeParameters(params) {
    const encodedParams = {};
    Object.entries(params).forEach(([key, value]) => {
        encodedParams[key] = formatEncodedValueBase64(value);
    });
    return encodedParams;
}
exports.encodeParameters = encodeParameters;
// The selectQuery() method uses base64 encoding for the values here because they are not encoded into a base64 payload string when sent to the server
function formatEncodedValueBase64(val) {
    const base = formatDataType(val);
    // If the value is an array, we need to encode each value in the array
    if (Array.isArray(val)) {
        const encodedValues = [];
        for (const v of val) {
            encodedValues.push((0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(v)));
        }
        return {
            type: base.type,
            data: encodedValues,
        };
    }
    return {
        type: base.type,
        data: [(0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(base.data))],
    };
}
// Used by the executeSql() method
// The executeSql() method has the entire payload encoded into a base64 string when being sent to the server
// And the structure of the parameters is different as we have name (of the parameter) and value which is not the same as selectQuery()
function encodeRawStatementParameters(params) {
    return Object.entries(params).map(([key, value]) => {
        const encodedValue = formatEncodedValue(value);
        return {
            name: key,
            value: encodedValue,
        };
    });
}
exports.encodeRawStatementParameters = encodeRawStatementParameters;
// Used by the executeSql() method and the encodeActionInputs() method
function formatEncodedValue(val, o) {
    const base = formatDataType(val, o);
    if (Array.isArray(val)) {
        const encodedValues = [];
        for (const v of val) {
            encodedValues.push((0, kwilEncoding_1.encodeValue)(v, o?.name));
        }
        return {
            type: base.type,
            data: encodedValues,
        };
    }
    return {
        type: base.type,
        data: [(0, kwilEncoding_1.encodeValue)(base.data, o?.name)],
    };
}
/**
 * Used when encoding values for an action
 * @param {ValueType[]} values - An array of input values to be executed by an action.
 * @returns formatted values used for an action
 */
function encodeValueType(values) {
    return values.map((val) => formatEncodedValue(val.v, val.o));
}
exports.encodeValueType = encodeValueType;
function formatDataType(val, o) {
    // handle override case
    if (o) {
        return {
            type: o,
            data: val,
        };
    }
    const { metadata, varType } = resolveValueType(val);
    const dataType = {
        name: varType,
        is_array: Array.isArray(val),
        metadata,
    };
    return { type: dataType, data: val };
}
function analyzeNumber(num) {
    // Convert the number to a string and handle potential negative sign
    const numStr = Math.abs(num).toString();
    const decimalIndex = numStr.indexOf('.');
    const hasDecimal = decimalIndex !== -1;
    // Precision represents the total number of digits (excluding the decimal point)
    const precision = hasDecimal ? numStr.length - 1 : numStr.length;
    // Scale represents the number of digits after the decimal point
    const scale = hasDecimal ? numStr.length - decimalIndex - 1 : 0;
    // e.g. 123.456
    // precision = 6
    // scale = 3
    return {
        hasDecimal,
        precision,
        scale,
    };
}
exports.analyzeNumber = analyzeNumber;
function resolveValueType(value) {
    if (Array.isArray(value)) {
        // In Kwil, if there is an array of values, each value in the array must be of the same type.
        return resolveValueType(value[0]);
    }
    let metadata = [0, 0];
    // Default to text string
    // Only other types are null or blob. For client-side tooling, everything else can be sent as a string, and Kwil will handle the conversion.
    let varType = enums_1.VarType.TEXT;
    switch (typeof value) {
        case 'string':
            if ((0, uuid_1.isUuid)(value)) {
                varType = enums_1.VarType.UUID;
            }
            break;
        case 'number':
            const numAnalysis = analyzeNumber(value);
            return {
                metadata: [numAnalysis.precision, numAnalysis.scale],
                varType: numAnalysis.hasDecimal ? enums_1.VarType.NUMERIC : enums_1.VarType.INT8,
            };
        case 'boolean':
            varType = enums_1.VarType.BOOL;
            break;
        case 'object':
            if (value instanceof Uint8Array) {
                varType = enums_1.VarType.BYTEA;
                break;
            }
            if (value === null) {
                varType = enums_1.VarType.NULL;
                break;
            }
        case 'undefined':
            varType = enums_1.VarType.NULL;
            break;
        default:
            throw new Error(`Unsupported type: ${typeof value}. If using a uuid, blob, or uint256, please convert to a JavaScript string.`);
    }
    return {
        metadata,
        varType,
    };
}
exports.resolveValueType = resolveValueType;
//# sourceMappingURL=parameterEncoding.js.map