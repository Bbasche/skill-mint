"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeSingleArguments = exports.encodeNestedArguments = exports.analyzeVariable = exports.kwilDecode = exports.kwilEncode = void 0;
const bytes_1 = require("./bytes");
const serial_1 = require("./serial");
const ethers_1 = require("ethers");
const enums_1 = require("../core/enums");
function _objToNestedArray(input) {
    if (Array.isArray(input) && !(input instanceof Uint8Array)) {
        return input.map((item) => _objToNestedArray(item));
    }
    else if (typeof input === 'object' && input !== null && !(input instanceof Uint8Array)) {
        const entries = Object.entries(input);
        const structured = [];
        for (const [_, value] of entries) {
            structured.push(_objToNestedArray(value));
        }
        return structured;
    }
    else {
        return inputToHex(input);
    }
}
// takes any input and returns it as a hex string
function inputToHex(val) {
    if (typeof val === 'string') {
        // Convert only non-hex strings to hex
        return (0, serial_1.stringToEthHex)(val);
    }
    else if (typeof val === 'number' || typeof val === 'bigint') {
        const num = Number(val);
        if (num === 0) {
            return '0x'; // special case for RLP encoding 0
        }
        return (0, serial_1.numberToEthHex)(num);
    }
    else if (val instanceof Uint8Array) {
        return (0, serial_1.bytesToEthHex)(val);
    }
    else if (typeof val === 'boolean') {
        return val ? '0x01' : '0x';
    }
    else if (val === null || val === undefined) {
        return (0, serial_1.bytesToEthHex)(new Uint8Array(0));
    }
    else {
        // Convert any other value to a string first
        throw new Error(`unknown type for value: ${val}`);
    }
}
function kwilEncode(obj) {
    const rlp = _objToNestedArray(obj);
    const rlpBytes = (0, ethers_1.encodeRlp)(rlp); // returned as hex string
    const encodingType = (0, bytes_1.numberToUint16BigEndian)(enums_1.EncodingType.RLP_ENCODING);
    return (0, bytes_1.concatBytes)(encodingType, (0, serial_1.hexToBytes)(rlpBytes));
}
exports.kwilEncode = kwilEncode;
function kwilDecode(encoding) {
    const encodingBytes = encoding.slice(0, 2);
    const encodingType = (0, bytes_1.uint16BigEndianToNumber)(encodingBytes);
    // check if encoding type exists in the enum
    if (!Object.values(enums_1.EncodingType).includes(encodingType)) {
        throw new Error(`unknown encoding type: ${encodingType}`);
    }
    const rlpBytes = encoding.slice(2);
    const rlpHex = (0, serial_1.bytesToEthHex)(rlpBytes);
    const rlp = (0, ethers_1.decodeRlp)(rlpHex);
    return _recursivelyDeHexlify(rlp);
}
exports.kwilDecode = kwilDecode;
function _recursivelyDeHexlify(obj) {
    if (Array.isArray(obj)) {
        return obj.map((item) => {
            return _recursivelyDeHexlify(item);
        });
    }
    return _convertDecodedType((0, serial_1.hexToString)(obj));
}
function _convertDecodedType(val) {
    if (!isNaN(Number(val))) {
        return Number(val);
    }
    if (val === 'true') {
        return true;
    }
    if (val === 'false') {
        return false;
    }
    return val;
}
function analyzeNumber(num) {
    // Convert the number to a string and handle potential negative sign
    const numStr = Math.abs(num).toString();
    // Check for the presence of a decimal point
    const decimalIndex = numStr.indexOf('.');
    const hasDecimal = decimalIndex !== -1;
    // Calculate total digits (excluding the decimal point)
    const totalDigits = hasDecimal ? numStr.length - 1 : numStr.length;
    // Analysis object to hold the results
    const analysis = {
        hasDecimal: hasDecimal,
        totalDigits: totalDigits,
        decimalPosition: hasDecimal ? decimalIndex : -1,
    };
    return analysis;
}
function analyzeVariable(val) {
    if (Array.isArray(val)) {
        // In Kwil, if there is an array of values, each value in the array must be of the same type.
        return analyzeVariable(val[0]);
    }
    let metadata = [0, 0];
    // Default to text string
    // Only other types are null or blob. For client-side tooling, everything else can be sent as a string, and Kwil will handle the conversion.
    let varType = enums_1.VarType.TEXT;
    switch (typeof val) {
        case 'string':
            break;
        case 'number':
            const numAnalysis = analyzeNumber(val);
            if (numAnalysis.hasDecimal) {
                metadata = [numAnalysis.totalDigits, numAnalysis.decimalPosition];
            }
            break;
        case 'boolean':
            break;
        case 'object':
            if (val instanceof Uint8Array) {
                varType = enums_1.VarType.BLOB;
                break;
            }
            if (val === null) {
                varType = enums_1.VarType.NULL;
                break;
            }
        case 'undefined':
            varType = enums_1.VarType.NULL;
            break;
        default:
            throw new Error(`Unsupported type: ${typeof val}. If using a uuid, blob, or uint256, please convert to a JavaScript string.`);
    }
    return {
        metadata,
        varType,
    };
}
exports.analyzeVariable = analyzeVariable;
/**
 *
 * @param {ValueType[][]} preparedActions - The values of the actions to be executed.
 * @returns nested values used for actions (ActionBuilder)
 */
function encodeNestedArguments(preparedAction) {
    return preparedAction.map((action) => {
        return encodeSingleArguments(action);
    });
}
exports.encodeNestedArguments = encodeNestedArguments;
/**
 *
 * @param {ValueType[]} preparedAction - The values of the actions to be executed.
 * @returns single EncodedValue (authenticatePrivateMode())
 */
function encodeSingleArguments(preparedAction) {
    return preparedAction.map((val) => {
        const { metadata, varType } = analyzeVariable(val);
        const metadataSpread = metadata ? { metadata } : {};
        const dataType = {
            name: varType,
            is_array: Array.isArray(val),
            ...metadataSpread,
        };
        let data = [];
        if (Array.isArray(val) && !(val instanceof Uint8Array)) {
            data = val.map((v) => {
                return v?.toString() || '';
            });
        }
        else if (val instanceof Uint8Array) {
            data = [val];
        }
        else {
            data = [val?.toString() || ''];
        }
        return {
            type: dataType,
            data,
        };
    });
}
exports.encodeSingleArguments = encodeSingleArguments;
//# sourceMappingURL=rlp.js.map