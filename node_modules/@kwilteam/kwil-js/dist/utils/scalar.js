"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeScalar = void 0;
const uuid_1 = require("uuid");
const serial_1 = require("./serial");
function encodeScalar(s) {
    // handle uuid case
    if (typeof s === 'string' && (0, uuid_1.validate)(s)) {
        return encodeNotNull((0, uuid_1.parse)(s));
    }
    // handle null case
    if (s === null) {
        return encodeNull();
    }
    // handle Uint8Array case
    if (s instanceof Uint8Array) {
        return encodeNotNull(s);
    }
    // handle decimal case
    if (typeof s === 'number' && isDecimal(s)) {
        return encodeNotNull((0, serial_1.stringToBytes)(s.toString()));
    }
    // handle other scalar value cases
    switch (typeof s) {
        case 'string':
            return encodeNotNull((0, serial_1.stringToBytes)(s));
        case 'boolean':
            return encodeNotNull((0, serial_1.booleanToBytes)(s));
        case 'number':
            return encodeNotNull((0, serial_1.numberToBytes)(s));
        case 'undefined':
            return encodeNull();
        case 'bigint':
            throw new Error('bigint not supported. convert to string.');
        default:
            throw new Error('invalid scalar value');
    }
}
exports.encodeScalar = encodeScalar;
function encodeNull() {
    return new Uint8Array([0]);
}
function encodeNotNull(v) {
    const bytes = new Uint8Array(v.length + 1);
    bytes[0] = 1;
    bytes.set(v, 1);
    return bytes;
}
function isDecimal(n) {
    const numStr = Math.abs(n).toString();
    const decimalIdx = numStr.indexOf('.');
    return decimalIdx !== -1;
}
//# sourceMappingURL=scalar.js.map