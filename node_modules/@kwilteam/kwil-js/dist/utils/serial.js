"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToBoolean = exports.booleanToBytes = exports.bytesToInt64 = exports.int64ToBytes = exports.bytesToInt32 = exports.int32ToBytes = exports.bytesToString = exports.hexToBase64 = exports.base64ToHex = exports.hexToBytes = exports.bytesToHex = exports.bytesToEthHex = exports.hexToNumber = exports.numberToHex = exports.numberToEthHex = exports.numberToBytes = exports.hexToString = exports.stringToHex = exports.stringToEthHex = exports.stringToBytes = void 0;
const long_1 = __importDefault(require("long"));
const strings_1 = require("./strings");
const objects_1 = require("./objects");
const base64_1 = require("./base64");
// converts string to bytes using utf-8 encoding
function stringToBytes(str) {
    return new TextEncoder().encode(str);
}
exports.stringToBytes = stringToBytes;
function stringToEthHex(str) {
    let hex = '0x';
    hex += stringToHex(str);
    return hex;
}
exports.stringToEthHex = stringToEthHex;
function stringToHex(str) {
    return stringToBytes(str).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
}
exports.stringToHex = stringToHex;
function hexToString(hex) {
    strings_1.strings.requireNonNil(hex);
    return bytesToString(hexToBytes(hex));
}
exports.hexToString = hexToString;
function numberToBytes(num) {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    if (typeof num === 'number') {
        if (num < 0 || num > 9007199254740991) { // 2^53 - 1
            throw new Error('Number out of bounds for safe integer representation');
        }
        const high = Math.floor(num / 4294967296); // 2^32
        const low = num % 4294967296;
        view.setUint32(0, high); // High 32 bits
        view.setUint32(4, low); // Low 32 bits
    }
    else if (typeof num === 'bigint') {
        if (num < 0n || num > 0xffffffffffffffffn) {
            throw new Error('Number out of bounds for Uint64 representation');
        }
        const high = Number(num >> 32n);
        const low = Number(num & 0xffffffffn);
        view.setUint32(0, high);
        view.setUint32(4, low);
    }
    else {
        throw new Error('Unsupported type for conversion to bytes');
    }
    return new Uint8Array(buffer);
}
exports.numberToBytes = numberToBytes;
function numberToEthHex(num) {
    return '0x' + numberToHex(num);
}
exports.numberToEthHex = numberToEthHex;
function numberToHex(num) {
    let hex = num.toString(16);
    if (hex.length % 2 !== 0) {
        hex = '0' + hex;
    }
    return hex;
}
exports.numberToHex = numberToHex;
function hexToNumber(hex) {
    strings_1.strings.requireNonNil(hex);
    if (hex.length % 2 !== 0) {
        throw new Error(`invalid hex string: ${hex}`);
    }
    // strip 0x prefix
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    return parseInt(hex, 16);
}
exports.hexToNumber = hexToNumber;
function bytesToEthHex(bytes) {
    return '0x' + bytesToHex(bytes);
}
exports.bytesToEthHex = bytesToEthHex;
function bytesToHex(bytes) {
    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
}
exports.bytesToHex = bytesToHex;
function hexToBytes(hex) {
    strings_1.strings.requireNonNil(hex);
    if (hex.length % 2 !== 0) {
        throw new Error(`invalid hex string: ${hex}`);
    }
    // strip 0x prefix
    if (hex.startsWith('0x')) {
        hex = hex.slice(2);
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
function base64ToHex(base64) {
    return bytesToHex((0, base64_1.base64ToBytes)(base64));
}
exports.base64ToHex = base64ToHex;
function hexToBase64(hex) {
    return (0, base64_1.bytesToBase64)(hexToBytes(hex));
}
exports.hexToBase64 = hexToBase64;
function bytesToString(bytes) {
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
function int32ToBytes(num) {
    objects_1.objects.requireNonNilNumber(num);
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setInt32(0, num, true);
    return new Uint8Array(buffer);
}
exports.int32ToBytes = int32ToBytes;
function bytesToInt32(bytes) {
    objects_1.objects.requireNonNil(bytes);
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes.length; i++) {
        view.setInt8(i, bytes[i]);
    }
    return view.getInt32(0, true);
}
exports.bytesToInt32 = bytesToInt32;
function int64ToBytes(num) {
    objects_1.objects.requireNonNilNumber(num);
    const longNum = long_1.default.fromNumber(num, true);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setInt32(0, longNum.low, true);
    view.setInt32(4, longNum.high, true);
    return new Uint8Array(buffer);
}
exports.int64ToBytes = int64ToBytes;
function bytesToInt64(bytes) {
    objects_1.objects.requireNonNil(bytes);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes.length; i++) {
        view.setInt8(i, bytes[i]);
    }
    return view.getInt32(0, true);
}
exports.bytesToInt64 = bytesToInt64;
function booleanToBytes(bool) {
    objects_1.objects.requireNonNil(bool);
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    view.setUint8(0, bool ? 1 : 0);
    return new Uint8Array(buffer);
}
exports.booleanToBytes = booleanToBytes;
function bytesToBoolean(bytes) {
    objects_1.objects.requireNonNil(bytes);
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes.length; i++) {
        view.setUint8(i, bytes[i]);
    }
    return view.getUint8(0) === 1;
}
exports.bytesToBoolean = bytesToBoolean;
//# sourceMappingURL=serial.js.map