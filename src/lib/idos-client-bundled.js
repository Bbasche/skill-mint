var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/pad-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position++);
      }
      return buffer.toString();
    }
    exports.default = padString;
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/base64url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode9(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode10(base64url4, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url4), "base64").toString(encoding);
    }
    function toBase64(base64url4) {
      base64url4 = base64url4.toString();
      return pad_string_1.default(base64url4).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base642) {
      return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url4) {
      return Buffer.from(toBase64(base64url4), "base64");
    }
    var base64url3 = encode9;
    base64url3.encode = encode9;
    base64url3.decode = decode10;
    base64url3.toBase64 = toBase64;
    base64url3.fromBase64 = fromBase64;
    base64url3.toBuffer = toBuffer;
    exports.default = base64url3;
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/index.js"(exports, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string3, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string3, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array2[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3
        );
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string3, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string3.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string3, offset, length) {
      return blitBuffer(utf8ToBytes(string3, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string3, offset, length) {
      return blitBuffer(asciiToBytes(string3), buf, offset, length);
    }
    function base64Write(buf, string3, offset, length) {
      return blitBuffer(base64ToBytes(string3), buf, offset, length);
    }
    function ucs2Write(buf, string3, offset, length) {
      return blitBuffer(utf16leToBytes(string3, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string3, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string3.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length);
          case "base64":
            return base64Write(this, string3, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet2[i] + alphabet2[j];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/.pnpm/base85@3.2.0/node_modules/base85/lib/alphabets.js
var require_alphabets = __commonJS({
  "node_modules/.pnpm/base85@3.2.0/node_modules/base85/lib/alphabets.js"(exports, module) {
    "use strict";
    var alphabet2 = {};
    var build = (chars) => {
      var codec = {};
      codec.chars = chars;
      codec.enc = Array.from(chars);
      codec.dec = {};
      codec.enc.forEach((val, index) => {
        codec.dec[val.charCodeAt(0)] = index;
      });
      return codec;
    };
    alphabet2.ascii85 = build("!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu");
    alphabet2.btoa = build("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~");
    alphabet2.z85 = build("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#");
    alphabet2.z85pad = alphabet2.z85;
    alphabet2.a85 = alphabet2.ascii85;
    alphabet2.ipv6 = alphabet2.btoa;
    module.exports = alphabet2;
  }
});

// node_modules/.pnpm/jsbn@1.1.0/node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/.pnpm/jsbn@1.1.0/node_modules/jsbn/index.js"(exports, module) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return this.s < 0 ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null) q.fromInt(0);
          if (r != null) this.copyTo(r);
          return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd) r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms) BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r);
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven()) z2 = new Classic(m);
        else z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0) x[0] &= (1 << t2) - 1;
          else x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r);
        else this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r);
        else this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1) w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r = this[0] % n;
          else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d);
        else return d;
        if (d.signum() < 0) return d.add(m);
        else return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
          return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length) t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports !== "undefined") {
        exports = module.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports);
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/common.js"(exports) {
    "use strict";
    var falseIfInvalid = exports.falseIfInvalid = function(fn) {
      return function() {
        if (!this.valid) {
          return false;
        }
        return fn.apply(this, arguments);
      };
    };
    exports.isInSubnet = falseIfInvalid(function(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    });
    exports.isCorrect = function(defaultBits) {
      return falseIfInvalid(function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      });
    };
  }
});

// node_modules/.pnpm/sprintf-js@1.1.2/node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/.pnpm/sprintf-js@1.1.2/node_modules/sprintf-js/src/sprintf.js"(exports) {
    !(function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign2 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    })();
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag2] = typedArrayTags[arrayBufferTag2] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag2] = typedArrayTags[dateTag2] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag2] = typedArrayTags[numberTag2] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag2] = typedArrayTags[setTag2] = typedArrayTags[stringTag2] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current = iteratee(array2[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key) {
        return object2 == null ? undefined2 : object2[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index = string3.length;
        while (index-- && reWhitespace.test(string3.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = (function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = (function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        })();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ (function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject3(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined2;
            return result2;
          };
        })();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex2(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array2, n) {
          return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined2 && !eq2(object2[key], value) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty.call(object2, key) && eq2(objValue, value)) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq2(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get2(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number3, lower, upper) {
          if (number3 === number3) {
            if (upper !== undefined2) {
              number3 = number3 <= upper ? number3 : upper;
            }
            if (lower !== undefined2) {
              number3 = number3 >= lower ? number3 : lower;
            }
          }
          return number3;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject3(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag2 || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value = object2[key];
            if (value === undefined2 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value = array2[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object2[key]);
          });
        }
        function baseGet(object2, path) {
          path = castPath(path, object2);
          var index = 0, length = path.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey2(path[index++])];
          }
          return index && index == length ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number3, start, end) {
          return number3 >= nativeMin(start, end) && number3 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key, object3) {
            setter(accumulator, iteratee2(value), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path, args) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          var func = object2 == null ? object2 : object2[toKey2(last(path))];
          return func == null ? undefined2 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag2;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag2;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag2 : getTag2(object2), othTag = othIsArr ? arrayTag2 : getTag2(other);
          objTag = objTag == argsTag ? objectTag2 : objTag;
          othTag = othTag == argsTag ? objectTag2 : othTag;
          var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag2(value) == mapTag2;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject3(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag2;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag2(value) == setTag2;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property2(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject3(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike3(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey2(path), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject3(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject3(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex2(n, length) ? array2[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path) {
            return hasIn(object2, path);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object2, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function basePullAll(array2, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
          if (array2 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex2(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string3, n) {
          var result2 = "";
          if (!string3 || n < 1 || n > MAX_SAFE_INTEGER2) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string3;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string3 += string3;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array2 = values(collection);
          return shuffleSelf(array2, baseClamp(n, 0, array2.length));
        }
        function baseSet(object2, path, value, customizer) {
          if (!isObject3(object2)) {
            return object2;
          }
          path = castPath(path, object2);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey2(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject3(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string3) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array2);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          return object2 == null || delete object2[toKey2(last(path))];
        }
        function baseUpdate(object2, path, updater, customizer) {
          return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols2(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer3) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer3 ? initializer3() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike3(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString2(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject3(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike3(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number3, precision) {
            number3 = toNumber(number3);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number3)) {
              var pair = (toString2(number3) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number3);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag2(object2);
            if (tag == mapTag2) {
              return mapToArray(object2);
            }
            if (tag == setTag2) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject3(objValue) && isObject3(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag2:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag2:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag2:
            case numberTag2:
              return eq2(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag2:
            case stringTag2:
              return object2 == other + "";
            case mapTag2:
              var convert = mapToArray;
            case setTag2:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag2:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols2);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length = result2.length;
          while (length--) {
            var key = result2[length], value = object2[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value = getValue(object2, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols2 = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols2(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag2 = baseGetTag;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
          getTag2 = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag2 ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag2;
                case mapCtorString:
                  return mapTag2;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag2;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path, hasFunc) {
          path = castPath(path, object2);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey2(path[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength2(length) && isIndex2(key, length) && (isArray(object2) || isArguments2(object2));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag2:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag2:
              return new Ctor(+object2);
            case dataViewTag2:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag2:
              return new Ctor();
            case numberTag2:
            case stringTag2:
              return new Ctor(object2);
            case regexpTag2:
              return cloneRegExp(object2);
            case setTag2:
              return new Ctor();
            case symbolTag2:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex2(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall2(value, index, object2) {
          if (!isObject3(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike3(object2) && isIndex2(index, object2.length) : type == "string" && index in object2) {
            return eq2(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject3(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform3(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path) {
          return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex2(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match, number3, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
          });
          return result2;
        });
        function toKey2(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size2, guard) {
          if (guard ? isIterateeCall2(array2, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function dropRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall2(array2, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined2;
        }
        function lastIndexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n) {
          return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
        }
        function pullAllBy(array2, values2, iteratee2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values2, comparator) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex2(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall2(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value);
            if (index < length && eq2(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq2(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take(array2, n, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function takeRight(array2, n, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array2, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike3(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike3(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall2(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike3(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag2(collection);
          if (tag == mapTag2 || tag == setTag2) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject3(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time3) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time3;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time3) {
            lastInvokeTime = time3;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time3) : result2;
          }
          function remainingWait(time3) {
            var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time3) {
            var timeSinceLastCall = time3 - lastCallTime, timeSinceLastInvoke = time3 - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time3 = now();
            if (shouldInvoke(time3)) {
              return trailingEdge(time3);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time3));
          }
          function trailingEdge(time3) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time3);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time3 = now(), isInvoking = shouldInvoke(time3);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time3;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial2 = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial2));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject3(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial2(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep3(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith3(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike3(value) {
          return value != null && isLength2(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike3(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike3(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag2(value);
          if (tag == mapTag2 || tag == setTag2) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject3(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength2(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
        }
        function isObject3(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch2(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith2(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag2;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag2) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger2(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag2;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag2;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag2(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike3(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag2(value), func = tag == mapTag2 ? mapToArray : tag == setTag2 ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject3(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject3(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike3(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path, defaultValue) {
          var result2 = object2 == null ? undefined2 : baseGet(object2, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has2(object2, path) {
          return object2 != null && hasPath(object2, path, baseHas);
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        var invert2 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike3(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike3(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, iteratee2(value, key, object3), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, key, iteratee2(value, key, object3));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object2);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object2, path, defaultValue) {
          path = castPath(path, object2);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object2 = undefined2;
          }
          while (++index < length) {
            var value = object2 == null ? undefined2 : object2[toKey2(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object2 = isFunction(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set(object2, path, value) {
          return object2 == null ? object2 : baseSet(object2, path, value);
        }
        function setWith(object2, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseSet(object2, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray2(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject3(object2)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee2(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path) {
          return object2 == null ? true : baseUnset(object2, path);
        }
        function update(object2, path, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
        }
        function updateWith(object2, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
        }
        function values(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number3, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number3), lower, upper);
        }
        function inRange(number3, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number3 = toNumber(number3);
          return baseInRange(number3, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string3) {
          return upperFirst(toString2(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString2(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string3, target, position) {
          string3 = toString2(string3);
          target = baseToString(target);
          var length = string3.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string3.slice(position, end) == target;
        }
        function escape(string3) {
          string3 = toString2(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString2(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length, chars) {
          string3 = toString2(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          if (!length || strLength >= length) {
            return string3;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length, chars) {
          string3 = toString2(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
        }
        function padStart(string3, length, chars) {
          string3 = toString2(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n, guard) {
          if (guard ? isIterateeCall2(string3, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string3), n);
        }
        function replace() {
          var args = arguments, string3 = toString2(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall2(string3, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString2(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position) {
          string3 = toString2(string3);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position, position + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall2(string3, options, guard)) {
            options = undefined2;
          }
          string3 = toString2(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString2(string3);
          if (string3 && (guard || chars === undefined2)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string3, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject3(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString2(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string3;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string3.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string3) {
          string3 = toString2(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern, guard) {
          string3 = toString2(string3);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey2(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches2(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty2(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object2) {
            return baseInvoke(object2, path, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path) {
            return baseInvoke(object2, path, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property2(path) {
          return isKey(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
        }
        function propertyOf(object2) {
          return function(path) {
            return object2 == null ? undefined2 : baseGet(object2, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER2) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath2(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey2);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
        }
        function uniqueId(prefix2) {
          var id = ++idCounter;
          return toString2(prefix2) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined2;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array2) {
          return baseMean(array2, identity2);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity2) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat2;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert2;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches2;
        lodash.matchesProperty = matchesProperty2;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit2;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial2;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy;
        lodash.property = property2;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath2;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep3;
        lodash.cloneDeepWith = cloneDeepWith3;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every2;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has2;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments2;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike3;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength2;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch2;
        lodash.isMatchWith = isMatchWith2;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject3;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger2;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString2;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        })(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v4/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v4/constants.js"(exports) {
    exports.BITS = 32;
    exports.GROUPS = 4;
    exports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/ipv4.js"(exports, module) {
    "use strict";
    var BigInteger = require_jsbn().BigInteger;
    var common = require_common();
    var sprintf = require_sprintf().sprintf;
    var _ = require_lodash();
    var constants = require_constants();
    function Address4(address) {
      this.valid = false;
      this.address = address;
      this.groups = constants.GROUPS;
      this.v4 = true;
      this.subnet = "/32";
      this.subnetMask = 32;
      var subnet = constants.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = "/" + this.subnetMask;
        if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
          this.valid = false;
          this.error = "Invalid subnet mask.";
          return;
        }
        address = address.replace(constants.RE_SUBNET_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(address);
    }
    Address4.prototype.parse = function(address) {
      var groups = address.split(".");
      if (address.match(constants.RE_ADDRESS)) {
        this.valid = true;
      } else {
        this.error = "Invalid IPv4 address.";
      }
      return groups;
    };
    Address4.prototype.isValid = function() {
      return this.valid;
    };
    Address4.prototype.correctForm = function() {
      return this.parsedAddress.map(function(part) {
        return parseInt(part, 10);
      }).join(".");
    };
    Address4.prototype.isCorrect = common.isCorrect(constants.BITS);
    Address4.fromHex = function(hex) {
      var padded = _.padStart(hex.replace(/:/g, ""), 8, "0");
      var groups = [];
      var i;
      for (i = 0; i < 8; i += 2) {
        var h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }
      return new Address4(groups.join("."));
    };
    Address4.fromInteger = function(integer2) {
      return Address4.fromHex(integer2.toString(16));
    };
    Address4.prototype.toHex = function() {
      return this.parsedAddress.map(function(part) {
        return sprintf("%02x", parseInt(part, 10));
      }).join(":");
    };
    Address4.prototype.toArray = function() {
      return this.parsedAddress.map(function(part) {
        return parseInt(part, 10);
      });
    };
    Address4.prototype.toGroup6 = function() {
      var output = [];
      var i;
      for (i = 0; i < constants.GROUPS; i += 2) {
        var hex = sprintf(
          "%02x%02x",
          parseInt(this.parsedAddress[i], 10),
          parseInt(this.parsedAddress[i + 1], 10)
        );
        output.push(sprintf("%x", parseInt(hex, 16)));
      }
      return output.join(":");
    };
    Address4.prototype.bigInteger = function() {
      if (!this.valid) {
        return null;
      }
      return new BigInteger(this.parsedAddress.map(function(n) {
        return sprintf("%02x", parseInt(n, 10));
      }).join(""), 16);
    };
    Address4.prototype._startAddress = function() {
      return new BigInteger(
        this.mask() + _.repeat("0", constants.BITS - this.subnetMask),
        2
      );
    };
    Address4.prototype.startAddress = function() {
      return Address4.fromBigInteger(this._startAddress());
    };
    Address4.prototype.startAddressExclusive = function() {
      var adjust = new BigInteger("1");
      return Address4.fromBigInteger(this._startAddress().add(adjust));
    };
    Address4.prototype._endAddress = function() {
      return new BigInteger(
        this.mask() + _.repeat("1", constants.BITS - this.subnetMask),
        2
      );
    };
    Address4.prototype.endAddress = function() {
      return Address4.fromBigInteger(this._endAddress());
    };
    Address4.prototype.endAddressExclusive = function() {
      var adjust = new BigInteger("1");
      return Address4.fromBigInteger(this._endAddress().subtract(adjust));
    };
    Address4.fromBigInteger = function(bigInteger) {
      return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
    };
    Address4.prototype.mask = function(optionalMask) {
      if (optionalMask === void 0) {
        optionalMask = this.subnetMask;
      }
      return this.getBitsBase2(0, optionalMask);
    };
    Address4.prototype.getBitsBase2 = function(start, end) {
      return this.binaryZeroPad().slice(start, end);
    };
    Address4.prototype.isInSubnet = common.isInSubnet;
    Address4.prototype.binaryZeroPad = function() {
      return _.padStart(this.bigInteger().toString(2), constants.BITS, "0");
    };
    module.exports = Address4;
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/constants.js"(exports) {
    exports.BITS = 128;
    exports.GROUPS = 8;
    exports.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports.RE_BAD_CHARACTERS = /([^0-9a-f:\/%])/ig;
    exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/ig;
    exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports.RE_ZONE_STRING = /%.*$/;
    exports.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/attributes.js
var require_attributes = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/attributes.js"(exports) {
    "use strict";
    var common = require_common();
    var v6 = require_constants2();
    exports.isValid = function() {
      return this.valid;
    };
    exports.isInSubnet = common.isInSubnet;
    exports.isCorrect = common.isCorrect(v6.BITS);
    exports.isCanonical = common.falseIfInvalid(function() {
      return this.addressMinusSuffix === this.canonicalForm();
    });
    exports.isLinkLocal = common.falseIfInvalid(function() {
      if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
        return true;
      }
      return false;
    });
    exports.isMulticast = common.falseIfInvalid(function() {
      return this.getType() === "Multicast";
    });
    exports.is4 = common.falseIfInvalid(function() {
      return this.v4;
    });
    exports.isTeredo = common.falseIfInvalid(function() {
      return this.isInSubnet(new this.constructor("2001::/32"));
    });
    exports.is6to4 = common.falseIfInvalid(function() {
      return this.isInSubnet(new this.constructor("2002::/16"));
    });
    exports.isLoopback = common.falseIfInvalid(function() {
      return this.getType() === "Loopback";
    });
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/helpers.js"(exports) {
    "use strict";
    var sprintf = require_sprintf().sprintf;
    var spanAllZeroes = exports.spanAllZeroes = function(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    };
    exports.spanAll = function(s, optionalOffset) {
      if (optionalOffset === void 0) {
        optionalOffset = 0;
      }
      var letters = s.split("");
      return letters.map(function(n, i) {
        return sprintf(
          '<span class="digit value-%s position-%d">%s</span>',
          n,
          i + optionalOffset,
          spanAllZeroes(n)
        );
      }).join("");
    };
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    exports.spanLeadingZeroes = function(address) {
      var groups = address.split(":");
      return groups.map(function(g) {
        return spanLeadingZeroesSimple(g);
      }).join(":");
    };
    exports.simpleGroup = function(addressString, offset) {
      var groups = addressString.split(":");
      if (!offset) {
        offset = 0;
      }
      return groups.map(function(g, i) {
        if (/group-v4/.test(g)) {
          return g;
        }
        return sprintf(
          '<span class="hover-group group-%d">%s</span>',
          i + offset,
          spanLeadingZeroesSimple(g)
        );
      }).join(":");
    };
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/html.js
var require_html = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/html.js"(exports) {
    "use strict";
    var constants4 = require_constants();
    var helpers = require_helpers();
    var sprintf = require_sprintf().sprintf;
    exports.href = function(optionalPort) {
      if (optionalPort === void 0) {
        optionalPort = "";
      } else {
        optionalPort = sprintf(":%s", optionalPort);
      }
      return sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
    };
    exports.link = function(options) {
      if (!options) {
        options = {};
      }
      if (options.className === void 0) {
        options.className = "";
      }
      if (options.prefix === void 0) {
        options.prefix = "/#address=";
      }
      if (options.v4 === void 0) {
        options.v4 = false;
      }
      var formFunction = this.correctForm;
      if (options.v4) {
        formFunction = this.to4in6;
      }
      if (options.className) {
        return sprintf(
          '<a href="%1$s%2$s" class="%3$s">%2$s</a>',
          options.prefix,
          formFunction.call(this),
          options.className
        );
      }
      return sprintf(
        '<a href="%1$s%2$s">%2$s</a>',
        options.prefix,
        formFunction.call(this)
      );
    };
    exports.group = function() {
      var address4 = this.address.match(constants4.RE_ADDRESS);
      var i;
      if (address4) {
        var segments = address4[0].split(".");
        this.address = this.address.replace(
          constants4.RE_ADDRESS,
          sprintf(
            '<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>',
            segments.slice(0, 2).join("."),
            segments.slice(2, 4).join(".")
          )
        );
      }
      if (this.elidedGroups === 0) {
        return helpers.simpleGroup(this.address);
      }
      var output = [];
      var halves = this.address.split("::");
      if (halves[0].length) {
        output.push(helpers.simpleGroup(halves[0]));
      } else {
        output.push("");
      }
      var classes = ["hover-group"];
      for (i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
        classes.push(sprintf("group-%d", i));
      }
      output.push(sprintf('<span class="%s"></span>', classes.join(" ")));
      if (halves[1].length) {
        output.push(helpers.simpleGroup(halves[1], this.elisionEnd));
      } else {
        output.push("");
      }
      return output.join(":");
    };
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/v6/regular-expressions.js"(exports) {
    "use strict";
    var sprintf = require_sprintf().sprintf;
    var v6 = require_constants2();
    function groupPossibilities(possibilities) {
      return sprintf("(%s)", possibilities.join("|"));
    }
    function padGroup(group) {
      if (group.length < 4) {
        return sprintf("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    function simpleRegularExpression(groups) {
      var zeroIndexes = [];
      groups.forEach(function(group, i) {
        var groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      var possibilities = zeroIndexes.map(function(zeroIndex) {
        return groups.map(function(group, i) {
          if (i === zeroIndex) {
            var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
            return groupPossibilities([padGroup(group), elision]);
          }
          return padGroup(group);
        }).join(":");
      });
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      var left = moreLeft ? "" : ":";
      var right = moreRight ? "" : ":";
      var possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push(sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push(sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push(sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (var groups = 1; groups < elidedGroups - 1; groups++) {
        for (var position = 1; position < elidedGroups - groups; position++) {
          possibilities.push(sprintf(
            "(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}",
            position,
            elidedGroups - position - groups - 1
          ));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports.regularExpressionString = function(optionalSubString) {
      if (optionalSubString === void 0) {
        optionalSubString = false;
      }
      var output = [];
      var address6 = new this.constructor(this.correctForm());
      if (address6.elidedGroups === 0) {
        output.push(simpleRegularExpression(address6.parsedAddress));
      } else if (address6.elidedGroups === v6.GROUPS) {
        output.push(possibleElisions(v6.GROUPS));
      } else {
        var halves = address6.address.split("::");
        if (halves[0].length) {
          output.push(simpleRegularExpression(halves[0].split(":")));
        }
        output.push(possibleElisions(
          address6.elidedGroups,
          halves[0].length !== 0,
          halves[1].length !== 0
        ));
        if (halves[1].length) {
          output.push(simpleRegularExpression(halves[1].split(":")));
        }
        output = [output.join(":")];
      }
      if (!optionalSubString) {
        output = [].concat("(?=^|\\b|[^\\w\\:])(", output, ")(?=[^\\w\\:]|\\b|$)");
      }
      return output.join("");
    };
    exports.regularExpression = function(optionalSubstring) {
      return new RegExp(this.regularExpressionString(optionalSubstring), "i");
    };
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/lib/ipv6.js"(exports, module) {
    "use strict";
    var BigInteger = require_jsbn().BigInteger;
    var sprintf = require_sprintf().sprintf;
    var _ = require_lodash();
    var constants4 = require_constants();
    var constants6 = require_constants2();
    var Address4 = require_ipv4();
    function addCommas(number3) {
      var r = /(\d+)(\d{3})/;
      while (r.test(number3)) {
        number3 = number3.replace(r, "$1,$2");
      }
      return number3;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function Address6(address, optionalGroups) {
      if (optionalGroups === void 0) {
        this.groups = constants6.GROUPS;
      } else {
        this.groups = optionalGroups;
      }
      this.v4 = false;
      this.subnet = "/128";
      this.subnetMask = 128;
      this.zone = "";
      this.address = address;
      var subnet = constants6.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = "/" + this.subnetMask;
        if (isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
          this.valid = false;
          this.error = "Invalid subnet mask.";
          return;
        }
        address = address.replace(constants6.RE_SUBNET_STRING, "");
      } else if (/\//.test(address)) {
        this.valid = false;
        this.error = "Invalid subnet mask.";
        return;
      }
      var zone = constants6.RE_ZONE_STRING.exec(address);
      if (zone) {
        this.zone = zone[0];
        address = address.replace(constants6.RE_ZONE_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(this.addressMinusSuffix);
    }
    _.merge(Address6.prototype, require_attributes());
    _.merge(Address6.prototype, require_html());
    _.merge(Address6.prototype, require_regular_expressions());
    Address6.fromBigInteger = function(bigInteger) {
      var hex = _.padStart(bigInteger.toString(16), 32, "0");
      var groups = [];
      var i;
      for (i = 0; i < constants6.GROUPS; i++) {
        groups.push(hex.slice(i * 4, (i + 1) * 4));
      }
      return new Address6(groups.join(":"));
    };
    Address6.fromURL = function(url) {
      var host;
      var port;
      var result;
      if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
        result = constants6.RE_URL_WITH_PORT.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address with port",
            address: null,
            port: null
          };
        }
        host = result[1];
        port = result[2];
      } else if (url.indexOf("/") !== -1) {
        url = url.replace(/^[a-z0-9]+:\/\//, "");
        result = constants6.RE_URL.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address from URL",
            address: null,
            port: null
          };
        }
        host = result[1];
      } else {
        host = url;
      }
      if (port) {
        port = parseInt(port, 10);
        if (port < 0 || port > 65536) {
          port = null;
        }
      } else {
        port = null;
      }
      return {
        address: new Address6(host),
        port
      };
    };
    Address6.fromAddress4 = function(address4) {
      var address4 = new Address4(address4);
      var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
      return new Address6("::ffff:" + address4.correctForm() + "/" + mask6);
    };
    Address6.fromArpa = function(arpaFormAddress) {
      var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
      var semicolonAmount = 7;
      if (address.length !== 63) {
        address = {
          error: "Not Valid 'ip6.arpa' form",
          address: null
        };
        return address;
      }
      address = address.split(".").reverse();
      for (var i = semicolonAmount; i > 0; i--) {
        var insertIndex = i * 4;
        address.splice(insertIndex, 0, ":");
      }
      address = address.join("");
      return new Address6(address);
    };
    function compact(address, slice) {
      var s1 = [];
      var s2 = [];
      var i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    Address6.prototype.microsoftTranscription = function() {
      return sprintf(
        "%s.ipv6-literal.net",
        this.correctForm().replace(/:/g, "-")
      );
    };
    Address6.prototype.mask = function(optionalMask) {
      if (optionalMask === void 0) {
        optionalMask = this.subnetMask;
      }
      return this.getBitsBase2(0, optionalMask);
    };
    Address6.prototype.possibleSubnets = function(optionalSubnetSize) {
      if (optionalSubnetSize === void 0) {
        optionalSubnetSize = 128;
      }
      var availableBits = constants6.BITS - this.subnetMask;
      var subnetBits = Math.abs(optionalSubnetSize - constants6.BITS);
      var subnetPowers = availableBits - subnetBits;
      if (subnetPowers < 0) {
        return "0";
      }
      return addCommas(new BigInteger("2", 10).pow(subnetPowers).toString(10));
    };
    Address6.prototype._startAddress = function() {
      return new BigInteger(
        this.mask() + _.repeat("0", constants6.BITS - this.subnetMask),
        2
      );
    };
    Address6.prototype.startAddress = function() {
      return Address6.fromBigInteger(this._startAddress());
    };
    Address6.prototype.startAddressExclusive = function() {
      var adjust = new BigInteger("1");
      return Address6.fromBigInteger(this._startAddress().add(adjust));
    };
    Address6.prototype._endAddress = function() {
      return new BigInteger(
        this.mask() + _.repeat("1", constants6.BITS - this.subnetMask),
        2
      );
    };
    Address6.prototype.endAddress = function() {
      return Address6.fromBigInteger(this._endAddress());
    };
    Address6.prototype.endAddressExclusive = function() {
      var adjust = new BigInteger("1");
      return Address6.fromBigInteger(this._endAddress().subtract(adjust));
    };
    Address6.prototype.getScope = function() {
      var scope = constants6.SCOPES[this.getBits(12, 16)];
      if (this.getType() === "Global unicast" && scope !== "Link local") {
        scope = "Global";
      }
      return scope;
    };
    Address6.prototype.getType = function() {
      var self2 = this;
      function isType(name, type) {
        return self2.isInSubnet(new Address6(type));
      }
      return _.find(constants6.TYPES, isType) || "Global unicast";
    };
    Address6.prototype.getBits = function(start, end) {
      return new BigInteger(this.getBitsBase2(start, end), 2);
    };
    Address6.prototype.getBitsBase2 = function(start, end) {
      return this.binaryZeroPad().slice(start, end);
    };
    Address6.prototype.getBitsBase16 = function(start, end) {
      var length = end - start;
      if (length % 4 !== 0) {
        return null;
      }
      return _.padStart(this.getBits(start, end).toString(16), length / 4, "0");
    };
    Address6.prototype.getBitsPastSubnet = function() {
      return this.getBitsBase2(this.subnetMask, constants6.BITS);
    };
    Address6.prototype.reverseForm = function(options) {
      if (!options) {
        options = {};
      }
      var characters = Math.floor(this.subnetMask / 4);
      var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
      if (characters > 0) {
        if (options.omitSuffix) {
          return reversed;
        }
        return sprintf("%s.ip6.arpa.", reversed);
      }
      if (options.omitSuffix) {
        return "";
      }
      return "ip6.arpa.";
    };
    Address6.prototype.correctForm = function() {
      if (!this.parsedAddress) {
        return null;
      }
      var i;
      var groups = [];
      var zeroCounter = 0;
      var zeroes = [];
      for (i = 0; i < this.parsedAddress.length; i++) {
        var value = parseInt(this.parsedAddress[i], 16);
        if (value === 0) {
          zeroCounter++;
        }
        if (value !== 0 && zeroCounter > 0) {
          if (zeroCounter > 1) {
            zeroes.push([i - zeroCounter, i - 1]);
          }
          zeroCounter = 0;
        }
      }
      if (zeroCounter > 1) {
        zeroes.push([
          this.parsedAddress.length - zeroCounter,
          this.parsedAddress.length - 1
        ]);
      }
      var zeroLengths = zeroes.map(function(n) {
        return n[1] - n[0] + 1;
      });
      if (zeroes.length > 0) {
        var index = zeroLengths.indexOf(_.max(zeroLengths));
        groups = compact(this.parsedAddress, zeroes[index]);
      } else {
        groups = this.parsedAddress;
      }
      for (i = 0; i < groups.length; i++) {
        if (groups[i] !== "compact") {
          groups[i] = parseInt(groups[i], 16).toString(16);
        }
      }
      var correct = groups.join(":");
      correct = correct.replace(/^compact$/, "::");
      correct = correct.replace(/^compact|compact$/, ":");
      correct = correct.replace(/compact/, "");
      return correct;
    };
    Address6.prototype.binaryZeroPad = function() {
      return _.padStart(this.bigInteger().toString(2), constants6.BITS, "0");
    };
    Address6.prototype.parse4in6 = function(address) {
      var groups = address.split(":");
      var lastGroup = groups.slice(-1)[0];
      var address4 = lastGroup.match(constants4.RE_ADDRESS);
      if (address4) {
        var temp4 = new Address4(address4[0]);
        for (var i = 0; i < temp4.groups; i++) {
          if (/^0[0-9]+/.test(temp4.parsedAddress[i])) {
            this.valid = false;
            this.error = "IPv4 addresses can not have leading zeroes.";
            this.parseError = address.replace(
              constants4.RE_ADDRESS,
              temp4.parsedAddress.map(spanLeadingZeroes4).join(".")
            );
            return null;
          }
        }
        this.v4 = true;
        groups[groups.length - 1] = temp4.toGroup6();
        address = groups.join(":");
      }
      return address;
    };
    Address6.prototype.parse = function(address) {
      address = this.parse4in6(address);
      if (this.error) {
        return null;
      }
      var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
      if (badCharacters) {
        this.valid = false;
        this.error = sprintf(
          "Bad character%s detected in address: %s",
          badCharacters.length > 1 ? "s" : "",
          badCharacters.join("")
        );
        this.parseError = address.replace(
          constants6.RE_BAD_CHARACTERS,
          '<span class="parse-error">$1</span>'
        );
        return null;
      }
      var badAddress = address.match(constants6.RE_BAD_ADDRESS);
      if (badAddress) {
        this.valid = false;
        this.error = sprintf("Address failed regex: %s", badAddress.join(""));
        this.parseError = address.replace(
          constants6.RE_BAD_ADDRESS,
          '<span class="parse-error">$1</span>'
        );
        return null;
      }
      var groups = [];
      var halves = address.split("::");
      if (halves.length === 2) {
        var first = halves[0].split(":");
        var last = halves[1].split(":");
        if (first.length === 1 && first[0] === "") {
          first = [];
        }
        if (last.length === 1 && last[0] === "") {
          last = [];
        }
        var remaining = this.groups - (first.length + last.length);
        if (!remaining) {
          this.valid = false;
          this.error = "Error parsing groups";
          return null;
        }
        this.elidedGroups = remaining;
        this.elisionBegin = first.length;
        this.elisionEnd = first.length + this.elidedGroups;
        first.forEach(function(group) {
          groups.push(group);
        });
        for (var i = 0; i < remaining; i++) {
          groups.push(0);
        }
        last.forEach(function(group) {
          groups.push(group);
        });
      } else if (halves.length === 1) {
        groups = address.split(":");
        this.elidedGroups = 0;
      } else {
        this.valid = false;
        this.error = "Too many :: groups found";
        return null;
      }
      groups = groups.map(function(g) {
        return sprintf("%x", parseInt(g, 16));
      });
      if (groups.length !== this.groups) {
        this.valid = false;
        this.error = "Incorrect number of groups found";
        return null;
      }
      this.valid = true;
      return groups;
    };
    function paddedHex(octet) {
      return sprintf("%04x", parseInt(octet, 16));
    }
    Address6.prototype.canonicalForm = function() {
      if (!this.valid) {
        return null;
      }
      return this.parsedAddress.map(paddedHex).join(":");
    };
    Address6.prototype.decimal = function() {
      if (!this.valid) {
        return null;
      }
      return this.parsedAddress.map(function(n) {
        return sprintf("%05d", parseInt(n, 16));
      }).join(":");
    };
    Address6.prototype.bigInteger = function() {
      if (!this.valid) {
        return null;
      }
      return new BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
    };
    Address6.prototype.to4 = function() {
      var binary = this.binaryZeroPad().split("");
      return Address4.fromHex(new BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
    };
    Address6.prototype.to4in6 = function() {
      var address4 = this.to4();
      var address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
      var correct = address6.correctForm();
      var infix = "";
      if (!/:$/.test(correct)) {
        infix = ":";
      }
      return address6.correctForm() + infix + address4.address;
    };
    Address6.prototype.inspectTeredo = function() {
      var prefix2 = this.getBitsBase16(0, 32);
      var udpPort = this.getBits(80, 96).xor(new BigInteger("ffff", 16)).toString();
      var server4 = Address4.fromHex(this.getBitsBase16(32, 64));
      var client4 = Address4.fromHex(this.getBits(96, 128).xor(new BigInteger("ffffffff", 16)).toString(16));
      var flags = this.getBits(64, 80);
      var flagsBase2 = this.getBitsBase2(64, 80);
      var coneNat = flags.testBit(15);
      var reserved = flags.testBit(14);
      var groupIndividual = flags.testBit(8);
      var universalLocal = flags.testBit(9);
      var nonce = new BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
      return {
        prefix: sprintf("%s:%s", prefix2.slice(0, 4), prefix2.slice(4, 8)),
        server4: server4.address,
        client4: client4.address,
        flags: flagsBase2,
        coneNat,
        microsoft: {
          reserved,
          universalLocal,
          groupIndividual,
          nonce
        },
        udpPort
      };
    };
    Address6.prototype.inspect6to4 = function() {
      var prefix2 = this.getBitsBase16(0, 16);
      var gateway = Address4.fromHex(this.getBitsBase16(16, 48));
      return {
        prefix: sprintf("%s", prefix2.slice(0, 4)),
        gateway: gateway.address
      };
    };
    Address6.prototype.to6to4 = function() {
      if (!this.is4()) {
        return null;
      }
      var addr6to4 = [
        "2002",
        this.getBitsBase16(96, 112),
        this.getBitsBase16(112, 128),
        "",
        "/16"
      ].join(":");
      return new Address6(addr6to4);
    };
    Address6.prototype.toByteArray = function() {
      var byteArray = this.bigInteger().toByteArray();
      if (byteArray.length === 17 && byteArray[0] === 0) {
        return byteArray.slice(1);
      }
      return byteArray;
    };
    function unsignByte(b) {
      return b & 255;
    }
    Address6.prototype.toUnsignedByteArray = function() {
      return this.toByteArray().map(unsignByte);
    };
    Address6.fromByteArray = function(bytes) {
      return this.fromUnsignedByteArray(bytes.map(unsignByte));
    };
    Address6.fromUnsignedByteArray = function(bytes) {
      var BYTE_MAX = new BigInteger("256", 10);
      var result = new BigInteger("0", 10);
      var multiplier = new BigInteger("1", 10);
      for (var i = bytes.length - 1; i >= 0; i--) {
        result = result.add(
          multiplier.multiply(new BigInteger(bytes[i].toString(10), 10))
        );
        multiplier = multiplier.multiply(BYTE_MAX);
      }
      return Address6.fromBigInteger(result);
    };
    module.exports = Address6;
  }
});

// node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/.pnpm/ip-address@5.9.4/node_modules/ip-address/ip-address.js"(exports) {
    "use strict";
    exports.Address4 = require_ipv4();
    exports.Address6 = require_ipv6();
    exports.v6 = {
      helpers: require_helpers()
    };
  }
});

// node_modules/.pnpm/base85@3.2.0/node_modules/base85/lib/base85.js
var require_base85 = __commonJS({
  "node_modules/.pnpm/base85@3.2.0/node_modules/base85/lib/base85.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var alphabets = require_alphabets();
    var Address6 = require_ip_address().Address6;
    var NUM_MAXVALUE = Math.pow(2, 32) - 1;
    var QUAD85 = 85 * 85 * 85 * 85;
    var TRIO85 = 85 * 85 * 85;
    var DUO85 = 85 * 85;
    var SING85 = 85;
    var DEFAULT_ENCODING = "z85";
    var LBigInt = typeof window !== "undefined" ? window.BigInt : global.BigInt;
    var IGNORE_CHARS = [
      9,
      /* horizontal tab */
      10,
      /* line feed, new line */
      11,
      /* vertical tab */
      12,
      /* form feed, new page */
      13,
      /* carriage return */
      32
      /* space */
    ];
    var ASCII85_ENC_START = "<~";
    var ASCII85_ENC_END = "~>";
    function bufferToBigInt(buffer) {
      return LBigInt("0x" + Buffer2.from(buffer).toString("hex"));
    }
    function pad(width, number3) {
      return new Array(1 + width - number3.length).join("0") + number3;
    }
    function encodeBignumIPv6(num) {
      const enctable = alphabets.ipv6.enc;
      const enc = [];
      for (let i = 1; i < 20; ++i) {
        enc.push(enctable[Number(num % 85n)]);
        num = num / 85n;
      }
      enc.push(enctable[Number(num)]);
      return enc.reverse().join("");
    }
    function encodeBufferIPv6(buffer) {
      if (16 !== buffer.length) {
        return false;
      }
      return encodeBignumIPv6(bufferToBigInt(buffer));
    }
    function encodeStringIPv6(string3) {
      const addr = new Address6(string3);
      if (!addr.isValid()) {
        return false;
      }
      const hex = addr.parsedAddress.map(function(el) {
        return pad(4, el);
      }).join("");
      const num = LBigInt(`0x${hex}`);
      return encodeBignumIPv6(num);
    }
    function decodeStringIPv6(string3) {
      if (20 !== string3.length) {
        return false;
      }
      const dectable = alphabets.ipv6.dec;
      let i = 0;
      try {
        const binary = string3.split("").reduceRight(function(memo, el) {
          const num = LBigInt(dectable[el.charCodeAt(0)]);
          const fact = LBigInt(85) ** LBigInt(i++);
          const contrib = num * fact;
          return memo + contrib;
        }, LBigInt(0));
        return Address6.fromBigInteger(binary).correctForm();
      } catch (e) {
        return false;
      }
    }
    function decodeBufferIPv6(buffer) {
      return decodeStringIPv6(buffer.toString());
    }
    function encodeBuffer(buffer, encoding) {
      if ("z85" === encoding && buffer.length % 4 !== 0) {
        return false;
      }
      const enctable = alphabets[encoding].enc;
      const padding = buffer.length % 4 === 0 ? 0 : 4 - buffer.length % 4;
      let result = "";
      for (let i = 0; i < buffer.length; i += 4) {
        let num = (buffer[i] << 24 >>> 0) + // Shift right to force unsigned number
        ((i + 1 > buffer.length ? 0 : buffer[i + 1]) << 16 >>> 0) + ((i + 2 > buffer.length ? 0 : buffer[i + 2]) << 8 >>> 0) + ((i + 3 > buffer.length ? 0 : buffer[i + 3]) << 0 >>> 0);
        let block = [];
        for (let j = 0; j < 5; ++j) {
          block.unshift(enctable[num % 85]);
          num = Math.floor(num / 85);
        }
        block = block.join("");
        if (block === "!!!!!" && "ascii85" === encoding) {
          block = "z";
        }
        result += block;
      }
      return ("ascii85" === encoding ? ASCII85_ENC_START : "") + result.substring(0, result.length - padding) + ("ascii85" === encoding ? ASCII85_ENC_END : "");
    }
    function encodeString(string3, encoding) {
      const buffer = Buffer2.from(string3, "utf8");
      return encodeBuffer(buffer, encoding);
    }
    function decodeBuffer(buffer, encoding) {
      const dectable = alphabets[encoding].dec;
      let dataLength = buffer.length;
      if ("ascii85" === encoding) {
        dataLength -= ASCII85_ENC_START.length + ASCII85_ENC_END.length;
      }
      if ("z85" === encoding && dataLength % 5 !== 0) {
        return false;
      }
      let padding = dataLength % 5 === 0 ? 0 : 5 - dataLength % 5;
      const bufferStart = "ascii85" === encoding ? ASCII85_ENC_START.length : 0;
      const bufferEnd = bufferStart + dataLength;
      const result = Buffer2.alloc(4 * Math.ceil((bufferEnd - bufferStart) / 5));
      const nextValidByte = function(index) {
        if (index < bufferEnd) {
          while (-1 !== IGNORE_CHARS.indexOf(buffer[index])) {
            padding = (padding + 1) % 5;
            index++;
          }
        }
        return index;
      };
      let writeIndex = 0;
      for (let i = bufferStart; i < bufferEnd; ) {
        let num = 0;
        const starti = i;
        i = nextValidByte(i);
        num = dectable[buffer[i]] * QUAD85;
        i = nextValidByte(i + 1);
        num += (i >= bufferEnd ? 84 : dectable[buffer[i]]) * TRIO85;
        i = nextValidByte(i + 1);
        num += (i >= bufferEnd ? 84 : dectable[buffer[i]]) * DUO85;
        i = nextValidByte(i + 1);
        num += (i >= bufferEnd ? 84 : dectable[buffer[i]]) * SING85;
        i = nextValidByte(i + 1);
        num += i >= bufferEnd ? 84 : dectable[buffer[i]];
        i = nextValidByte(i + 1);
        if ("z85" === encoding && starti + 5 !== i) {
          return false;
        }
        if (num > NUM_MAXVALUE || num < 0) {
          return false;
        }
        result.writeUInt32BE(num, writeIndex);
        writeIndex += 4;
      }
      return result.slice(0, writeIndex - padding);
    }
    function decodeString(string3, encoding) {
      if ("ascii85" === encoding) {
        string3 = string3.replace("z", "!!!!!");
      }
      let buffer = Buffer2.from(string3, "utf8");
      return decodeBuffer(buffer, encoding);
    }
    function encode9(data, encoding) {
      encoding = encoding || DEFAULT_ENCODING;
      if (!alphabets.hasOwnProperty(encoding)) {
        return false;
      }
      if (Buffer2.isBuffer(data)) {
        return "ipv6" === encoding ? encodeBufferIPv6(data) : encodeBuffer(data, encoding);
      }
      if (typeof data === "string") {
        return "ipv6" === encoding ? encodeStringIPv6(data) : encodeString(data, encoding);
      }
      return false;
    }
    function decode10(data, encoding) {
      encoding = encoding || DEFAULT_ENCODING;
      if (!alphabets.hasOwnProperty(encoding)) {
        return false;
      }
      if (Buffer2.isBuffer(data)) {
        return "ipv6" === encoding ? decodeBufferIPv6(data) : decodeBuffer(data, encoding);
      }
      if (typeof data === "string") {
        return "ipv6" === encoding ? decodeStringIPv6(data) : decodeString(data, encoding);
      }
      return false;
    }
    module.exports = {
      alphabets,
      encode: encode9,
      decode: decode10
    };
  }
});

// node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl3) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac2, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac2[macpos + 0] = this.h[0] >>> 0 & 255;
        mac2[macpos + 1] = this.h[0] >>> 8 & 255;
        mac2[macpos + 2] = this.h[1] >>> 0 & 255;
        mac2[macpos + 3] = this.h[1] >>> 8 & 255;
        mac2[macpos + 4] = this.h[2] >>> 0 & 255;
        mac2[macpos + 5] = this.h[2] >>> 8 & 255;
        mac2[macpos + 6] = this.h[3] >>> 0 & 255;
        mac2[macpos + 7] = this.h[3] >>> 8 & 255;
        mac2[macpos + 8] = this.h[4] >>> 0 & 255;
        mac2[macpos + 9] = this.h[4] >>> 8 & 255;
        mac2[macpos + 10] = this.h[5] >>> 0 & 255;
        mac2[macpos + 11] = this.h[5] >>> 8 & 255;
        mac2[macpos + 12] = this.h[6] >>> 0 & 255;
        mac2[macpos + 13] = this.h[6] >>> 8 & 255;
        mac2[macpos + 14] = this.h[7] >>> 0 & 255;
        mac2[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i * 2];
            l = K2[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl3.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl3.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl3.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl3.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl3.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl3.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl3.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl3.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl3.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl3.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl3.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl3.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox(msg, nonce, k);
      };
      nacl3.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl3.box.after = nacl3.secretbox;
      nacl3.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox.open(msg, nonce, k);
      };
      nacl3.box.open.after = nacl3.secretbox.open;
      nacl3.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl3.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl3.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl3.box.nonceLength = crypto_box_NONCEBYTES;
      nacl3.box.overheadLength = nacl3.secretbox.overheadLength;
      nacl3.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl3.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl3.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl3.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl3.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl3.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl3.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl3.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl3.sign.signatureLength = crypto_sign_BYTES;
      nacl3.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl3.hash.hashLength = crypto_hash_BYTES;
      nacl3.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl3.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto4 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto4 && crypto4.getRandomValues) {
          var QUOTA = 65536;
          nacl3.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto4.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto4 = __require("crypto");
          if (crypto4 && crypto4.randomBytes) {
            nacl3.setPRNG(function(x, n) {
              var i, v = crypto4.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base64ToBytes = exports.bytesToBase64 = void 0;
    var base64abc = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "+",
      "/"
    ];
    var base64codes = [
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      62,
      255,
      255,
      255,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      255,
      255,
      255,
      0,
      255,
      255,
      255,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      255,
      255,
      255,
      255,
      255,
      255,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    function getBase64Code(charCode) {
      if (charCode >= base64codes.length) {
        throw new Error("Unable to parse base64 string.");
      }
      const code = base64codes[charCode];
      if (code === 255) {
        throw new Error("Unable to parse base64 string.");
      }
      return code;
    }
    function bytesToBase64(bytes) {
      let result = "", i, l = bytes.length;
      for (i = 2; i < l; i += 3) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
        result += base64abc[bytes[i] & 63];
      }
      if (i === l + 1) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4];
        result += "==";
      }
      if (i === l) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 15) << 2];
        result += "=";
      }
      return result;
    }
    exports.bytesToBase64 = bytesToBase64;
    function base64ToBytes(str) {
      if (str.length % 4 !== 0) {
        throw new Error("Unable to parse base64 string.");
      }
      const index = str.indexOf("=");
      if (index !== -1 && index < str.length - 2) {
        throw new Error("Unable to parse base64 string.");
      }
      let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n = str.length, result = new Uint8Array(3 * (n / 4)), buffer;
      for (let i = 0, j = 0; i < n; i += 4, j += 3) {
        buffer = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));
        result[j] = buffer >> 16;
        result[j + 1] = buffer >> 8 & 255;
        result[j + 2] = buffer & 255;
      }
      return result.subarray(0, result.length - missingOctets);
    }
    exports.base64ToBytes = base64ToBytes;
  }
});

// node_modules/.pnpm/axios@1.13.5/node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/.pnpm/axios@1.13.5/node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString: toString2 } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString2.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject3 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject2 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject3(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject3(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = [
      "ReadableStream",
      "Request",
      "Response",
      "Headers"
    ].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge2() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return;
        }
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
          result[targetKey] = merge2(result[targetKey], val);
        } else if (isPlainObject2(val)) {
          result[targetKey] = merge2({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend2 = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(
        b,
        (val, key) => {
          if (thisArg && isFunction$1(val)) {
            Object.defineProperty(a, key, {
              value: bind(val, thisArg),
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            Object.defineProperty(a, key, {
              value: val,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        },
        { allOwnKeys }
      );
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors) => {
      constructor.prototype = Object.create(
        superConstructor.prototype,
        descriptors
      );
      Object.defineProperty(constructor.prototype, "constructor", {
        value: constructor,
        writable: true,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches2;
      const arr = [];
      while ((matches2 = regExp.exec(str)) !== null) {
        arr.push(matches2);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      });
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject3(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject3(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener(
          "message",
          ({ source, data }) => {
            if (source === _global && data === token) {
              callbacks.length && callbacks.shift()();
            }
          },
          false
        );
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(typeof setImmediate === "function", isFunction$1(_global.postMessage));
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject3,
      isPlainObject: isPlainObject2,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray: isTypedArray2,
      isFileList,
      forEach,
      merge: merge2,
      extend: extend2,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    var AxiosError = class _AxiosError extends Error {
      static from(error, code, config2, request, response, customProps) {
        const axiosError = new _AxiosError(error.message, code || error.code, config2, request, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      }
      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [config] The config.
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       *
       * @returns {Error} The created error.
       */
      constructor(message, code, config2, request, response) {
        super(message);
        this.name = "AxiosError";
        this.isAxiosError = true;
        code && (this.code = code);
        config2 && (this.config = config2);
        request && (this.request = request);
        if (response) {
          this.response = response;
          this.status = response.status;
        }
      }
      toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    };
    AxiosError.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
    AxiosError.ERR_BAD_OPTION = "ERR_BAD_OPTION";
    AxiosError.ECONNABORTED = "ECONNABORTED";
    AxiosError.ETIMEDOUT = "ETIMEDOUT";
    AxiosError.ERR_NETWORK = "ERR_NETWORK";
    AxiosError.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
    AxiosError.ERR_DEPRECATED = "ERR_DEPRECATED";
    AxiosError.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
    AxiosError.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
    AxiosError.ERR_CANCELED = "ERR_CANCELED";
    AxiosError.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
    AxiosError.ERR_INVALID_URL = "ERR_INVALID_URL";
    var AxiosError$1 = AxiosError;
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString3(encoder) {
      const _encode2 = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode2(pair[0]) + "=" + _encode2(pair[1]);
      }, "").join("&");
    };
    function encode9(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode2 = options && options.encode || encode9;
      const _options = utils$1.isFunction(options) ? {
        serialize: options
      } : options;
      const serializeFn = _options && _options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, _options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, _options).toString(_encode2);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       * @param {Object} options The options for the interceptor, synchronous and runWhen
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false,
      legacyInterceptorReqResOrdering: true
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils2,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = /* @__PURE__ */ Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config2 = this || defaults$1;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform2(fn) {
        data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    var CanceledError = class extends AxiosError$1 {
      /**
       * A `CanceledError` is an object that is thrown when an operation is canceled.
       *
       * @param {string=} message The message.
       * @param {Object=} config The config.
       * @param {Object=} request The request.
       *
       * @returns {CanceledError} The created error.
       */
      constructor(message, config2, request) {
        super(message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request);
        this.name = "CanceledError";
        this.__CANCEL__ = true;
      }
    };
    var CanceledError$1 = CanceledError;
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError$1(
          "Request failed with status code " + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
      url = new URL(url, platform.origin);
      return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      if (typeof url !== "string") {
        return false;
      }
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(
        Object.keys({ ...config1, ...config2 }),
        function computeConfigValue(prop) {
          if (prop === "__proto__" || prop === "constructor" || prop === "prototype")
            return;
          const merge3 = utils$1.hasOwnProp(mergeMap, prop) ? mergeMap[prop] : mergeDeepProperties;
          const configValue = merge3(config1[prop], config2[prop], prop);
          utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
        }
      );
      return config3;
    }
    var resolveConfig = (config2) => {
      const newConfig = mergeConfig({}, config2);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config2);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config2, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError$1(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted2;
        const onabort = function(reason) {
          if (!aborted2) {
            aborted2 = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError$1(`timeout of ${timeout}ms exceeded`, AxiosError$1.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream) {
      if (stream[Symbol.asyncIterator]) {
        yield* stream;
        return;
      }
      const reader = stream.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder2
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config2) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config2) => {
        let {
          url,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config2);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config2,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request, err && err.response),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError$1.from(err, err && err.code, config2, request, err && err.response);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config2) => {
      let env = config2 && config2.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
        map = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config2) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError$1(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter, config2);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var VERSION = "1.13.5";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError$1(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError$1.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config2) {
        try {
          return await this._request(configOrUrl, config2);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean),
            legacyInterceptorReqResOrdering: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config2.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config2.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config2, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          const transitional2 = config2.transitional || transitionalDefaults;
          const legacyInterceptorReqResOrdering = transitional2 && transitional2.legacyInterceptorReqResOrdering;
          if (legacyInterceptorReqResOrdering) {
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          } else {
            requestInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          }
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config2, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError$1(message, config2, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError$1;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError$1;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/api_client/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/api_client/api.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Api = void 0;
    var axios_1 = __importDefault(require_axios());
    var Api = class {
      constructor(opts) {
        this.config = this.mergeDefaults(opts);
      }
      mergeDefaults(opts) {
        if (!opts.kwilProvider) {
          throw new Error("No Kwil provider URL provided in configuration");
        }
        return {
          kwilProvider: opts.kwilProvider,
          timeout: opts.timeout || 1e4,
          logging: opts.logging || false,
          logger: opts.logger || console.log,
          cache: opts.cache || 10 * 60
        };
      }
      async get(endpoint, config2) {
        try {
          return await this.request().get(endpoint, config2);
        } catch (error) {
          if (error.response && error.response.status) {
            return error.response;
          }
          throw error;
        }
      }
      async post(endpoint, body, config2) {
        try {
          return await this.request().post(endpoint, body, config2);
        } catch (error) {
          if (error.response && error.response.status) {
            return error.response;
          }
          throw error;
        }
      }
      /**
       * Get an AxiosInstance with the base configuration setup to fire off
       * a request to the network.
       */
      request() {
        let headers = {};
        if (this.cookie) {
          headers.Cookie = this.cookie;
        }
        let instance = axios_1.default.create({
          baseURL: this.config.kwilProvider,
          timeout: this.config.timeout,
          maxContentLength: 1024 * 1024 * 512,
          withCredentials: true,
          headers
        });
        if (this.config.logging) {
          instance.interceptors.request.use((request) => {
            this.config.logger(`Requesting: ${request.baseURL}${request.url}`);
            return request;
          });
          instance.interceptors.response.use((response) => {
            this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
            return response;
          });
        }
        return instance;
      }
    };
    exports.Api = Api;
  }
});

// node_modules/.pnpm/long@5.3.0/node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/.pnpm/long@5.3.0/node_modules/long/umd/index.js"(exports, module) {
    var Long = (function(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          // \0asm
          0,
          97,
          115,
          109,
          // version 1
          1,
          0,
          0,
          0,
          // section "type"
          1,
          13,
          2,
          // 0, () => i32
          96,
          0,
          1,
          127,
          // 1, (i32, i32, i32, i32) => i32
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          // section "function"
          3,
          7,
          6,
          // 0, type 0
          0,
          // 1, type 1
          1,
          // 2, type 1
          1,
          // 3, type 1
          1,
          // 4, type 1
          1,
          // 5, type 1
          1,
          // section "global"
          6,
          6,
          1,
          // 0, "high", mutable i32
          127,
          1,
          65,
          0,
          11,
          // section "export"
          7,
          50,
          6,
          // 0, "mul"
          3,
          109,
          117,
          108,
          0,
          1,
          // 1, "div_s"
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          // 2, "div_u"
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          // 3, "rem_s"
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          // 4, "rem_u"
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          // 5, "get_high"
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          // section "code"
          10,
          191,
          1,
          6,
          // 0, "get_high"
          4,
          0,
          35,
          0,
          11,
          // 1, "mul"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 2, "div_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 3, "div_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 4, "rem_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 5, "rem_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache) UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache) INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0) return UZERO;
          if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result;
          else {
            while (digits.length < 6) digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isSafeInteger = function isSafeInteger2() {
        var top11Bits = this.high >> 21;
        if (!top11Bits) return true;
        if (this.unsigned) return false;
        return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
          else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      if (typeof BigInt === "function") {
        Long2.fromBigInt = function fromBigInt2(value, unsigned) {
          var lowBits = Number(BigInt.asIntN(32, value));
          var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
          return fromBits(lowBits, highBits, unsigned);
        };
        Long2.fromValue = function fromValueWithBigInt(value, unsigned) {
          if (typeof value === "bigint") return fromBigInt(value, unsigned);
          return fromValue(value, unsigned);
        };
        LongPrototype.toBigInt = function toBigInt() {
          var lowBigInt = BigInt(this.low >>> 0);
          var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
          return highBigInt << BigInt(32) | lowBigInt;
        };
      }
      var _default2 = exports2.default = Long2;
      return "default" in exports2 ? exports2.default : exports2;
    })({});
    if (typeof define === "function" && define.amd) define([], function() {
      return Long;
    });
    else if (typeof module === "object" && typeof exports === "object") module.exports = Long;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/objects.js
var require_objects = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.NillableError = void 0;
    var NillablErrorSymbol = /* @__PURE__ */ Symbol();
    var NILL_ERROR_MESSAGE = "value cannot be null or undefined";
    var NillableError = class extends Error {
      constructor(message = NILL_ERROR_MESSAGE) {
        super(message || NILL_ERROR_MESSAGE);
      }
      get [NillablErrorSymbol]() {
        return true;
      }
    };
    exports.NillableError = NillableError;
    exports.objects = {
      isNilError: (error) => {
        return error[NillablErrorSymbol] === true;
      },
      // returns true if the value is null or undefined,
      // else will return false.
      isNil: (value) => {
        return value === null || value === void 0;
      },
      // returns false if the value is null or undefined,
      // else will return true.
      isNotNil: (value) => {
        return !exports.objects.isNil(value);
      },
      /**
       * Helper function to validate required fields with a requireNonNil error.
       * @param values An object containing field names and their corresponding values.
       * @param errorMessageTemplate A function to generate error messages dynamically.
       */
      validateFields: (values, errorMessageTemplate) => {
        for (const key in values) {
          exports.objects.requireNonNil(values[key], errorMessageTemplate(key));
        }
        return values;
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNil: (value, message) => {
        if (!exports.objects.isNil(value)) {
          return value;
        }
        if (typeof message === "function") {
          throw message(value);
        }
        throw new NillableError(message);
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNilNumber: (value, message) => {
        if (typeof value === "number") {
          return value;
        }
        if (typeof message === "function") {
          throw message(value);
        }
        if (!value) {
          throw new NillableError(message);
        }
        throw new Error("value is not a number, it is a " + typeof value);
      },
      requireMaxLength: (value, maxLength, message) => {
        if (!value) {
          if (typeof message === "function") {
            throw message(value);
          }
          throw new Error(message || "value is null or undefined");
        }
        if (typeof value.toString !== "function") {
          throw new Error("value does not have a toString() method");
        }
        if (value.toString().length > maxLength) {
          if (typeof message === "function") {
            throw message(value);
          }
          throw new Error(message || `value is longer than ${maxLength} characters`);
        }
        return value;
      },
      /**
       * Validates that optional parameters, if provided, are not null.
       *
       * @param options - The options object containing the parameters to validate.
       * @param fields - An array of field names to validate.
       * @throws Error if any field is explicitly provided but null.
       */
      validateOptionalFields(options, fields) {
        fields.forEach((field) => {
          if (options[field] !== void 0 && options[field] === null) {
            throw new Error(`${String(field)} must not be null.`);
          }
        });
      },
      /**
       * Validates required parameters for the class or function, are not null or undefined.
       *
       * @param options - The options object containing the parameters to validate.
       * @param fields - An array of field names to validate.
       * @throws Error if any field is explicitly provided but null.
       */
      validateRequiredFields(options, fields) {
        fields.forEach((field) => {
          if (options[field] === void 0 && options[field] === null) {
            throw new Error(`${String(field)} must not be null.`);
          }
        });
        return options;
      }
    };
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/strings.js
var require_strings = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.strings = void 0;
    var objects_1 = require_objects();
    exports.strings = {
      is: (value) => {
        return typeof value === "string";
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNil: (value, message) => {
        if (exports.strings.is(value)) {
          return value;
        }
        if (typeof message === "function") {
          throw message();
        }
        throw new Error("value is not a string, it is a " + (!value ? "null or undefined" : typeof value));
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNilElse: (value, defaultValue) => {
        if (!objects_1.objects.isNil(value)) {
          return value;
        }
        if (typeof defaultValue === "function") {
          defaultValue(value);
        }
        if (exports.strings.is(defaultValue)) {
          return defaultValue;
        }
        throw new Error("defaultValue is not a string, it is a " + (!value ? "null or undefined" : typeof value));
      },
      // NOTE: Will throw an exception if not a string/null/undefined.
      isNilOrEmpty: (value) => {
        if (objects_1.objects.isNil(value)) {
          return true;
        }
        if (exports.strings.is(value)) {
          return value === "";
        }
        throw new Error("value is not a string or null, it is a " + (!value ? "undefined" : typeof value));
      },
      // NOTE: Will throw an exception if not a string/null/undefined.
      isNilOrWhitespace: (value) => {
        return exports.strings.isNilOrEmpty(value) || value.trim().length === 0;
      }
    };
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/serial.js
var require_serial = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/serial.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToBoolean = exports.booleanToBytes = exports.bytesToInt64 = exports.int64ToBytes = exports.bytesToInt32 = exports.int32ToBytes = exports.bytesToString = exports.hexToBase64 = exports.base64ToHex = exports.hexToBytes = exports.bytesToHex = exports.bytesToEthHex = exports.hexToNumber = exports.numberToHex = exports.numberToEthHex = exports.numberToBytes = exports.hexToString = exports.stringToHex = exports.stringToEthHex = exports.stringToBytes = void 0;
    var long_1 = __importDefault(require_umd());
    var strings_1 = require_strings();
    var objects_1 = require_objects();
    var base64_1 = require_base64();
    function stringToBytes(str) {
      return new TextEncoder().encode(str);
    }
    exports.stringToBytes = stringToBytes;
    function stringToEthHex(str) {
      let hex = "0x";
      hex += stringToHex(str);
      return hex;
    }
    exports.stringToEthHex = stringToEthHex;
    function stringToHex(str) {
      return stringToBytes(str).reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
    }
    exports.stringToHex = stringToHex;
    function hexToString(hex) {
      strings_1.strings.requireNonNil(hex);
      return bytesToString(hexToBytes2(hex));
    }
    exports.hexToString = hexToString;
    function numberToBytes(num) {
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      if (typeof num === "number") {
        if (num < 0 || num > 9007199254740991) {
          throw new Error("Number out of bounds for safe integer representation");
        }
        const high = Math.floor(num / 4294967296);
        const low = num % 4294967296;
        view.setUint32(0, high);
        view.setUint32(4, low);
      } else if (typeof num === "bigint") {
        if (num < 0n || num > 0xffffffffffffffffn) {
          throw new Error("Number out of bounds for Uint64 representation");
        }
        const high = Number(num >> 32n);
        const low = Number(num & 0xffffffffn);
        view.setUint32(0, high);
        view.setUint32(4, low);
      } else {
        throw new Error("Unsupported type for conversion to bytes");
      }
      return new Uint8Array(buffer);
    }
    exports.numberToBytes = numberToBytes;
    function numberToEthHex(num) {
      return "0x" + numberToHex(num);
    }
    exports.numberToEthHex = numberToEthHex;
    function numberToHex(num) {
      let hex = num.toString(16);
      if (hex.length % 2 !== 0) {
        hex = "0" + hex;
      }
      return hex;
    }
    exports.numberToHex = numberToHex;
    function hexToNumber(hex) {
      strings_1.strings.requireNonNil(hex);
      if (hex.length % 2 !== 0) {
        throw new Error(`invalid hex string: ${hex}`);
      }
      if (hex.startsWith("0x")) {
        hex = hex.slice(2);
      }
      return parseInt(hex, 16);
    }
    exports.hexToNumber = hexToNumber;
    function bytesToEthHex(bytes) {
      return "0x" + bytesToHex2(bytes);
    }
    exports.bytesToEthHex = bytesToEthHex;
    function bytesToHex2(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    exports.bytesToHex = bytesToHex2;
    function hexToBytes2(hex) {
      strings_1.strings.requireNonNil(hex);
      if (hex.length % 2 !== 0) {
        throw new Error(`invalid hex string: ${hex}`);
      }
      if (hex.startsWith("0x")) {
        hex = hex.slice(2);
      }
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
      }
      return bytes;
    }
    exports.hexToBytes = hexToBytes2;
    function base64ToHex(base642) {
      return bytesToHex2((0, base64_1.base64ToBytes)(base642));
    }
    exports.base64ToHex = base64ToHex;
    function hexToBase64(hex) {
      return (0, base64_1.bytesToBase64)(hexToBytes2(hex));
    }
    exports.hexToBase64 = hexToBase64;
    function bytesToString(bytes) {
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
    function int32ToBytes(num) {
      objects_1.objects.requireNonNilNumber(num);
      const buffer = new ArrayBuffer(4);
      const view = new DataView(buffer);
      view.setInt32(0, num, true);
      return new Uint8Array(buffer);
    }
    exports.int32ToBytes = int32ToBytes;
    function bytesToInt32(bytes) {
      objects_1.objects.requireNonNil(bytes);
      const buffer = new ArrayBuffer(4);
      const view = new DataView(buffer);
      for (let i = 0; i < bytes.length; i++) {
        view.setInt8(i, bytes[i]);
      }
      return view.getInt32(0, true);
    }
    exports.bytesToInt32 = bytesToInt32;
    function int64ToBytes(num) {
      objects_1.objects.requireNonNilNumber(num);
      const longNum = long_1.default.fromNumber(num, true);
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      view.setInt32(0, longNum.low, true);
      view.setInt32(4, longNum.high, true);
      return new Uint8Array(buffer);
    }
    exports.int64ToBytes = int64ToBytes;
    function bytesToInt64(bytes) {
      objects_1.objects.requireNonNil(bytes);
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      for (let i = 0; i < bytes.length; i++) {
        view.setInt8(i, bytes[i]);
      }
      return view.getInt32(0, true);
    }
    exports.bytesToInt64 = bytesToInt64;
    function booleanToBytes(bool) {
      objects_1.objects.requireNonNil(bool);
      const buffer = new ArrayBuffer(1);
      const view = new DataView(buffer);
      view.setUint8(0, bool ? 1 : 0);
      return new Uint8Array(buffer);
    }
    exports.booleanToBytes = booleanToBytes;
    function bytesToBoolean(bytes) {
      objects_1.objects.requireNonNil(bytes);
      const buffer = new ArrayBuffer(1);
      const view = new DataView(buffer);
      for (let i = 0; i < bytes.length; i++) {
        view.setUint8(i, bytes[i]);
      }
      return view.getUint8(0) === 1;
    }
    exports.bytesToBoolean = bytesToBoolean;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/enums.js
var require_enums = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccessModifier = exports.AccountKeyType = exports.AccountStatus = exports.AuthErrorCodes = exports.BroadcastSyncType = exports.AuthenticationMode = exports.EnvironmentType = exports.BytesEncodingStatus = exports.SerializationType = exports.PayloadType = exports.EncodingType = exports.IndexType = exports.AttributeType = exports.VarType = void 0;
    var VarType;
    (function(VarType2) {
      VarType2["UUID"] = "uuid";
      VarType2["TEXT"] = "text";
      VarType2["INT8"] = "int8";
      VarType2["BOOL"] = "bool";
      VarType2["NUMERIC"] = "numeric";
      VarType2["NULL"] = "null";
      VarType2["BYTEA"] = "bytea";
      VarType2["UNKNOWN"] = "unknown";
    })(VarType = exports.VarType || (exports.VarType = {}));
    var AttributeType;
    (function(AttributeType2) {
      AttributeType2["INVALID_TYPE"] = "";
      AttributeType2["PRIMARY_KEY"] = "PRIMARY_KEY";
      AttributeType2["UNIQUE"] = "UNIQUE";
      AttributeType2["NOT_NULL"] = "NOT_NULL";
      AttributeType2["DEFAULT"] = "DEFAULT";
      AttributeType2["MIN"] = "MIN";
      AttributeType2["MAX"] = "MAX";
      AttributeType2["MIN_LENGTH"] = "MIN_LENGTH";
      AttributeType2["MAX_LENGTH"] = "MAX_LENGTH";
    })(AttributeType = exports.AttributeType || (exports.AttributeType = {}));
    var IndexType;
    (function(IndexType2) {
      IndexType2["INVALID_INDEX_TYPE"] = "";
      IndexType2["BTREE"] = "BTREE";
      IndexType2["UNIQUE_BTREE"] = "UNIQUE_BTREE";
    })(IndexType = exports.IndexType || (exports.IndexType = {}));
    var EncodingType;
    (function(EncodingType2) {
      EncodingType2[EncodingType2["INVALID_ENCODING_TYPE"] = 0] = "INVALID_ENCODING_TYPE";
      EncodingType2[EncodingType2["RLP_ENCODING"] = 1] = "RLP_ENCODING";
    })(EncodingType = exports.EncodingType || (exports.EncodingType = {}));
    var PayloadType;
    (function(PayloadType2) {
      PayloadType2["INVALID_PAYLOAD_TYPE"] = "invalid";
      PayloadType2["EXECUTE_ACTION"] = "execute";
      PayloadType2["CALL_ACTION"] = "call_action";
      PayloadType2["TRANSFER"] = "transfer";
      PayloadType2["RAW_STATEMENT"] = "raw_statement";
    })(PayloadType = exports.PayloadType || (exports.PayloadType = {}));
    var SerializationType;
    (function(SerializationType2) {
      SerializationType2["INVALID_SERIALIZATION_TYPE"] = "invalid";
      SerializationType2["SIGNED_MSG_CONCAT"] = "concat";
      SerializationType2["SIGNED_MSG_EIP712"] = "eip712";
    })(SerializationType = exports.SerializationType || (exports.SerializationType = {}));
    var BytesEncodingStatus;
    (function(BytesEncodingStatus2) {
      BytesEncodingStatus2["INVALID_ENCODING_STATUS"] = "invalid";
      BytesEncodingStatus2["BASE64_ENCODED"] = "base64_encoded";
      BytesEncodingStatus2["HEX_ENCODED"] = "hex_encoded";
      BytesEncodingStatus2["UINT8_ENCODED"] = "uint8_encoded";
    })(BytesEncodingStatus = exports.BytesEncodingStatus || (exports.BytesEncodingStatus = {}));
    var EnvironmentType;
    (function(EnvironmentType2) {
      EnvironmentType2["BROWSER"] = "browser";
      EnvironmentType2["NODE"] = "node";
    })(EnvironmentType = exports.EnvironmentType || (exports.EnvironmentType = {}));
    var AuthenticationMode;
    (function(AuthenticationMode2) {
      AuthenticationMode2["PRIVATE"] = "private";
      AuthenticationMode2["OPEN"] = "open";
    })(AuthenticationMode = exports.AuthenticationMode || (exports.AuthenticationMode = {}));
    var BroadcastSyncType;
    (function(BroadcastSyncType2) {
      BroadcastSyncType2[BroadcastSyncType2["SYNC"] = 0] = "SYNC";
      BroadcastSyncType2[BroadcastSyncType2["COMMIT"] = 1] = "COMMIT";
    })(BroadcastSyncType = exports.BroadcastSyncType || (exports.BroadcastSyncType = {}));
    var AuthErrorCodes;
    (function(AuthErrorCodes2) {
      AuthErrorCodes2[AuthErrorCodes2["PRIVATE_MODE"] = -1001] = "PRIVATE_MODE";
      AuthErrorCodes2[AuthErrorCodes2["KGW_MODE"] = -901] = "KGW_MODE";
    })(AuthErrorCodes = exports.AuthErrorCodes || (exports.AuthErrorCodes = {}));
    var AccountStatus;
    (function(AccountStatus2) {
      AccountStatus2[AccountStatus2["LATEST"] = 0] = "LATEST";
      AccountStatus2[AccountStatus2["PENDING"] = 1] = "PENDING";
    })(AccountStatus = exports.AccountStatus || (exports.AccountStatus = {}));
    var AccountKeyType;
    (function(AccountKeyType2) {
      AccountKeyType2["SECP256K1"] = "secp256k1";
      AccountKeyType2["ED25519"] = "ed25519";
    })(AccountKeyType = exports.AccountKeyType || (exports.AccountKeyType = {}));
    var AccessModifier;
    (function(AccessModifier2) {
      AccessModifier2["PUBLIC"] = "PUBLIC";
      AccessModifier2["PRIVATE"] = "PRIVATE";
      AccessModifier2["VIEW"] = "VIEW";
    })(AccessModifier = exports.AccessModifier || (exports.AccessModifier = {}));
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["METHOD_HEALTH"] = "user.health";
      JSONRPCMethod2["METHOD_PING"] = "user.ping";
      JSONRPCMethod2["METHOD_CHAIN_INFO"] = "user.chain_info";
      JSONRPCMethod2["METHOD_ACCOUNT"] = "user.account";
      JSONRPCMethod2["METHOD_BROADCAST"] = "user.broadcast";
      JSONRPCMethod2["METHOD_CALL"] = "user.call";
      JSONRPCMethod2["METHOD_DATABASES"] = "user.databases";
      JSONRPCMethod2["METHOD_PRICE"] = "user.estimate_price";
      JSONRPCMethod2["METHOD_QUERY"] = "user.query";
      JSONRPCMethod2["METHOD_TX_QUERY"] = "user.tx_query";
      JSONRPCMethod2["METHOD_SCHEMA"] = "user.schema";
      JSONRPCMethod2["METHOD_KGW_PARAM"] = "kgw.authn_param";
      JSONRPCMethod2["METHOD_KGW_AUTHN"] = "kgw.authn";
      JSONRPCMethod2["METHOD_KGW_LOGOUT"] = "kgw.logout";
      JSONRPCMethod2["METHOD_CHALLENGE"] = "user.challenge";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/api_client/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/api_client/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base64_1 = require_base64();
    var api_1 = require_api();
    var serial_1 = require_serial();
    var enums_1 = require_enums();
    var jsonrpc_1 = require_jsonrpc();
    var Client = class extends api_1.Api {
      constructor(opts) {
        super(opts);
        this.jsonRpcId = 1;
        this.unconfirmedNonce = opts.unconfirmedNonce || false;
      }
      async getAuthenticateClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_PARAM, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result);
      }
      async postAuthenticateClient(authBody) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_AUTHN, authBody);
        const res = await super.post(`/rpc/v1`, body);
        if (typeof window === "undefined") {
          return checkRes(res, (r) => {
            const cookie = res.headers["set-cookie"];
            if (!cookie) {
              throw new Error("No cookie received from gateway. An error occurred with authentication.");
            }
            return {
              ...r.result,
              cookie: cookie[0]
            };
          });
        }
        return checkRes(res, (r) => r.result);
      }
      // TODO: Update once KGW is updated for JSON RPC - DO NOT MERGE WITHOUT RESOLVING
      async logoutClient(identifier) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_LOGOUT, {
          account: identifier ? (0, serial_1.bytesToHex)(identifier) : ""
        });
        const res = await super.post(`/rpc/v1`, body);
        if (typeof window === "undefined") {
          return checkRes(res, (r) => {
            const cookie = res.headers["set-cookie"];
            if (!cookie) {
              throw new Error("No cookie received from gateway. An error occured with logout.");
            }
            if (cookie[0].startsWith("kgw_session=;")) {
              this.cookie = void 0;
            } else {
              this.cookie = cookie[0];
            }
            return {
              ...r.result,
              cookie: cookie[0]
            };
          });
        }
        return checkRes(res, (r) => r.result);
      }
      async getAccountClient(accountId) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_ACCOUNT, {
          id: accountId,
          status: this.unconfirmedNonce ? enums_1.AccountStatus.PENDING : enums_1.AccountStatus.LATEST
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
          return {
            ...r.result,
            id: r.result.id
          };
        });
      }
      async listDatabasesClient(owner) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_DATABASES, {
          owner: owner ? (0, serial_1.bytesToHex)(owner) : void 0
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
          if (!r.result.databases) {
            return [];
          }
          return r.result.databases.map((db) => {
            return {
              ...db,
              owner: (0, serial_1.hexToBytes)(db.owner)
            };
          });
        });
      }
      async estimateCostClient(tx) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PRICE, {
          tx: tx.txData
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.price);
      }
      async broadcastClient(tx, broadcastSync) {
        if (!tx.isSigned()) {
          throw new Error("Tx must be signed before broadcasting.");
        }
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_BROADCAST, {
          tx: tx.txData,
          ...broadcastSync ? { sync: broadcastSync } : {}
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
          if (r.result.result && r.result.result?.code !== 0) {
            throw new Error(JSON.stringify(r.result) || `Transaction failed after broadcast.`);
          }
          return {
            tx_hash: (0, serial_1.base64ToHex)(r.result.tx_hash)
          };
        });
      }
      async pingClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PING, {
          message: "ping"
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.message);
      }
      async chainInfoClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHAIN_INFO, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
          return {
            chain_id: r.result.chain_id,
            height: r.result.block_height.toString(),
            hash: r.result.block_hash
          };
        });
      }
      async healthModeCheckClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_HEALTH, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result);
      }
      async challengeClient() {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHALLENGE, {});
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => r.result.challenge);
      }
      async selectQueryClient(query) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_QUERY, query);
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => this.parseQueryResponse(r.result));
      }
      async txInfoClient(tx_hash) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_TX_QUERY, {
          tx_hash: (0, serial_1.hexToBase64)(tx_hash)
        });
        const res = await super.post(`/rpc/v1`, body);
        return checkRes(res, (r) => {
          return {
            ...r.result,
            tx: {
              ...r.result.tx,
              body: {
                ...r.result.tx.body,
                payload: (0, base64_1.base64ToBytes)(r.result.tx.body.payload),
                fee: BigInt(r.result.tx.body.fee || 0)
              },
              signature: {
                ...r.result.tx.signature,
                sig: (0, base64_1.base64ToBytes)(r.result.tx.signature.sig)
              },
              sender: (0, serial_1.hexToBytes)(r.result.tx.sender || "")
            }
          };
        });
      }
      async callClient(msg) {
        const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CALL, {
          body: msg.body,
          auth_type: msg.auth_type,
          sender: msg.sender || "",
          signature: msg.signature || ""
        });
        const res = await super.post(`/rpc/v1`, body);
        const errorResponse = this.checkAuthError(res);
        if (errorResponse) {
          return errorResponse;
        }
        return checkRes(res, (r) => {
          return {
            result: this.parseQueryResponse(r.result.query_result),
            logs: r.result.logs
          };
        });
      }
      buildJsonRpcRequest(method, params) {
        return {
          jsonrpc: "2.0",
          id: this.jsonRpcId++,
          method,
          params
        };
      }
      // Check for specific error codes and return http status, result of view action, and rpc authError code (if applicable)
      checkAuthError(res) {
        const errorCode = res.data.error?.code;
        if (errorCode === enums_1.AuthErrorCodes.PRIVATE_MODE || errorCode === enums_1.AuthErrorCodes.KGW_MODE) {
          return {
            status: res.status,
            data: void 0,
            authCode: errorCode
          };
        }
        return null;
      }
      parseQueryResponse(queryResponse) {
        const { column_names, values } = queryResponse;
        if (!values || values.length === 0) {
          return [];
        }
        const mapValueToColumn = (rowValues) => {
          const obj = {};
          for (let i = 0; i < column_names.length; i++) {
            obj[column_names[i]] = rowValues[i];
          }
          return obj;
        };
        return values.map(mapValueToColumn);
      }
    };
    exports.default = Client;
    function checkRes(res, selector) {
      switch (res.status) {
        case 200:
          break;
        case 401:
          throw new Error(JSON.stringify(res.data) || "Unauthorized.");
        case 404:
          throw new Error(JSON.stringify(res.data) || "Not found.");
        case 500:
          throw new Error(JSON.stringify(res.data) || "Internal server error.");
        default:
          throw new Error(JSON.stringify(res.data) || "An unknown error has occurred.  Please check your network connection.");
      }
      if (!res.data) {
        throw new Error(`failed to parse response: ${res}`);
      }
      if (res.data.error) {
        const data = res.data.error.data ? `, data: ${JSON.stringify(res.data.error.data)}` : "";
        throw new Error(`JSON RPC call error: code: ${res.data.error.code}, message: ${res.data.error.message}` + data);
      }
      if (res.data.jsonrpc !== "2.0") {
        throw new Error(JSON.stringify(res.data) || "Invalid JSON RPC response.");
      }
      if (!res.data.result) {
        throw new Error(JSON.stringify(res.data) || "No result in JSON RPC response.");
      }
      return {
        status: res.status,
        data: selector(res.data)
      };
    }
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValueType = exports.Promisy = void 0;
    var objects_1 = require_objects();
    var Promisy;
    (function(Promisy2) {
      async function resolve(promisy) {
        const fov = objects_1.objects.requireNonNil(promisy);
        const awaitable = typeof fov === "function" ? fov() : fov;
        return await awaitable;
      }
      Promisy2.resolve = resolve;
      async function resolveOrReject(promisy, nilError) {
        return objects_1.objects.isNil(promisy) ? Promise.reject(new objects_1.NillableError(nilError)) : resolve(promisy);
      }
      Promisy2.resolveOrReject = resolveOrReject;
    })(Promisy = exports.Promisy || (exports.Promisy = {}));
    function isValueType(v) {
      if (v === null || v === void 0 || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v instanceof Uint8Array) {
        return true;
      }
      if (Array.isArray(v)) {
        return v.every(isValueType);
      }
      return false;
    }
    exports.isValueType = isValueType;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/action.js
var require_action = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/action.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionInput = exports.transformPositionalParam = exports.transformActionInput = exports.isNamedParam = exports.isNamedParams = exports.resolveParamTypes = void 0;
    var objects_1 = require_objects();
    var types_1 = require_types();
    function resolveParamTypes(i, types) {
      const paramTypes = [];
      if (!types) {
        if (isNamedParam(i)) {
          for (const [k, v] of Object.entries(i)) {
            paramTypes.push({ v });
          }
        } else {
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j] });
          }
        }
        return paramTypes;
      }
      if (isNamedParam(i)) {
        if (types && !Array.isArray(types)) {
          for (const [k, v] of Object.entries(i)) {
            paramTypes.push({ v, o: types[k] });
          }
        } else {
          Object.entries(i).forEach(([k, v], idx) => {
            paramTypes.push({ v, o: types[idx] });
          });
        }
      } else {
        if (types && !Array.isArray(types)) {
          const typeVals = Object.values(types);
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j], o: typeVals[j] });
          }
        } else {
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j], o: types[j] });
          }
        }
      }
      return paramTypes;
    }
    exports.resolveParamTypes = resolveParamTypes;
    function isNamedParams(i) {
      let isNamedParams2 = false;
      for (const p of i) {
        if (isNamedParam(p)) {
          isNamedParams2 = true;
          break;
        }
      }
      return isNamedParams2;
    }
    exports.isNamedParams = isNamedParams;
    function isNamedParam(i) {
      return typeof i === "object" && i !== null && !Array.isArray(i);
    }
    exports.isNamedParam = isNamedParam;
    function assertKey(key) {
      return objects_1.objects.requireNonNil(key, "key cannot be nil");
    }
    function lowercaseKey(key) {
      return key.toLowerCase();
    }
    exports.transformActionInput = {
      /**
       * Checks if all elements in the given array are instances of ActionInput.
       *
       * @param {unknown} i - The value to be checked.
       * @returns {boolean} - True if `inputs` is an array where every element is an ActionInput, otherwise false.
       */
      isActionInputArray(i) {
        return Array.isArray(i) && i.length > 0 && i.every((item) => item instanceof ActionInput);
      },
      /**
       * Transforms action inputs into entries format required by the API.
       * Used to support legacy ActionInput[] when calling a view action where only one input is required.
       *
       * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing a single Entries object
       * @throws {Error} - If inputs array is empty
       */
      toSingleEntry(inputs) {
        if (!inputs.length) {
          return {};
        }
        const firstInput = inputs[0];
        if (firstInput instanceof ActionInput) {
          return firstInput.toEntries();
        }
        return firstInput;
      },
      /**
       * Transforms action inputs into entries format required by the API.
       * Used to support legacy ActionInput[] when calling an execute action where multiple inputs may be required.
       *
       * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing entries objects
       * @throws {Error} - If inputs array is not valid
       */
      toNamedParams(inputs) {
        if (!exports.transformActionInput.isActionInputArray(inputs)) {
          throw new Error("Inputs array  must be an array of Entries or ActionInput objects");
        }
        const np = [];
        for (const input of inputs) {
          if (input instanceof ActionInput) {
            np.push(input.toEntries());
          }
        }
        return np;
      }
    };
    exports.transformPositionalParam = {
      /**
      * Checks if all elements in a given array are PositionalParams
      * @param {unknown} i - The value to be checked.
      * @returns {boolean} - True if `inputs` is an array where every element is a PositionalParam, otherwise false.
      */
      isPositionalParams(i) {
        return Array.isArray(i) && i.every((p) => (0, types_1.isValueType)(p));
      },
      /**
       * Checks if a given value is a PositionalParam
       * @param {unknown} i - The value to be checked.
       * @returns {boolean} - True if `i` is a PositionalParam, otherwise false.
       */
      isPositionalParam(i) {
        return (0, types_1.isValueType)(i);
      },
      /**
       * Transforms positional parameters into named parameters to be used for validation
       *
       * @param {PositionalParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing entries objects
       */
      toNamedParams(inputs) {
        return inputs.map((i) => {
          return exports.transformPositionalParam.toNamedParam(i);
        });
      },
      toNamedParam(i) {
        const np = {};
        i.forEach((v, idx) => {
          np[`$pstn_${idx}`] = v;
        });
        return np;
      }
    };
    var ActionInput = class _ActionInput {
      constructor() {
        this.map = {};
      }
      /**
       * Adds or replaces a value for a single action input.
       *
       * @param key - The action input name.
       * @param value - The value to put for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      put(key, value) {
        key = lowercaseKey(key);
        this.map[assertKey(key)] = value;
        return this;
      }
      /**
       * Adds a value for a single action input if the key is not already present.
       *
       * @param key - The action input name.
       * @param value - The value to put for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      putIfAbsent(key, value) {
        key = lowercaseKey(key);
        if (!this.containsKey(key)) {
          this.map[key] = value;
        }
        return this;
      }
      /**
       * Replaces a value for a single action input if the key is already present.
       *
       * @param key - The action input name.
       * @param value - The value to replace for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      replace(key, value) {
        key = lowercaseKey(key);
        if (this.containsKey(key)) {
          this.map[key] = value;
        }
        return this;
      }
      /**
       * Retrieves an action input value given its key.
       *
       * @param key - The action input name.
       * @returns The value associated with the action input name.
       */
      get(key) {
        key = lowercaseKey(key);
        return this.map[assertKey(key)];
      }
      /**
       * Retrieves a value by its action input name, or a default value if the action input name is not present.
       *
       * @param key - The action input name.
       * @param defaultValue - The default value to return if the key is not present.
       * @returns The value associated with the key, or the default value.
       */
      getOrDefault(key, defaultValue) {
        key = lowercaseKey(key);
        return this.map[assertKey(key)] ?? defaultValue;
      }
      /**
       * Checks if the map contains a specific action input name.
       *
       * @param key - The action input name.
       * @returns True if the action input name is present, false otherwise.
       */
      containsKey(key) {
        key = lowercaseKey(key);
        return this.map.hasOwnProperty(assertKey(key));
      }
      /**
       * Removes a action input name and its associated value from the map.
       *
       * @param key - The action input name to remove.
       * @returns True if the key was present and is now removed, false otherwise.
       */
      remove(key) {
        key = lowercaseKey(key);
        return delete this.map[key];
      }
      /**
       * Converts the map of action inputs to an array of entries.
       *
       * @param filter - An optional filter function.
       * @returns A read-only array of entries.
       */
      toArray(filter) {
        return Object.entries(this.map).filter(filter ?? (() => true));
      }
      /**
       * Transforms the `ActionInput` to JSON.
       *
       * @returns A read-only map of entries.
       */
      toEntries() {
        return this.map;
      }
      /**
       * Allows `ActionInput` to be iterable.
       *
       * @returns An iterator over the array of entries.
       */
      [Symbol.iterator]() {
        return this.toArray()[Symbol.iterator]();
      }
      /**
       * Adds or replaces values from and object of action name/key-value pairs.
       *
       * @param obj - The object from which to extract action name/key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      putFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          this.map[assertKey(key)] = value;
        }
        return this;
      }
      /**
       * Adds values from and object of action name/key-value pairs if the key is not already present.
       *
       * @param obj - The object from which to extract key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      putFromObjectIfAbsent(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          if (!this.containsKey(key)) {
            this.map[assertKey(key)] = value;
          }
        }
        return this;
      }
      /**
       * Replaces values from and object of action name/key-value pairs if the key is already present.
       *
       * @param obj - The object from which to extract key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      replaceFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          if (this.containsKey(key)) {
            this.map[assertKey(key)] = value;
          }
        }
        return this;
      }
      /**
       * Creates multiple `ActionInput` instances from an array of objects.
       *
       * @param objs - An array of objects from which to create `ActionInput` instances.
       * @returns An array of `ActionInput` instances.
       */
      putFromObjects(objs) {
        const actions = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
          actions.push(_ActionInput.fromObject(obj));
        }
        return actions;
      }
      /**
       * Factory method to create a new instance of `ActionInput`.
       *
       * @returns A new `ActionInput` instance.
       */
      static of() {
        return new _ActionInput();
      }
      /**
       * Creates a new `ActionInput` instance from an iterable array of entries.
       *
       * @param entries - The iterable of set of entries. Entries should be formatted as an array of `[inputName, value]`.
       * @returns A new `ActionInput` instance.
       */
      static from(entries) {
        const action = _ActionInput.of();
        for (let [key, value] of entries) {
          key = lowercaseKey(key);
          action.map[assertKey(key)] = value;
        }
        return action;
      }
      /**
       * Creates a new `ActionInput` instance from an object.
       *
       * @param obj - The object from which to create the `ActionInput`.
       * @returns A new `ActionInput` instance.
       */
      static fromObject(obj) {
        const action = _ActionInput.of();
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          action.map[assertKey(key)] = value;
        }
        return action;
      }
      /**
       * Creates multiple `ActionInput` instances from an array of objects.
       *
       * @param objs - An array of objects from which to create `ActionInput` instances.
       * @returns An array of `ActionInput` instances.
       */
      static fromObjects(objs) {
        const actions = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
          actions.push(_ActionInput.fromObject(obj));
        }
        return actions;
      }
    };
    exports.ActionInput = ActionInput;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/intern.js
var require_intern = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/intern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrap = exports.unwrap = void 0;
    var objects_1 = require_objects();
    var key = /* @__PURE__ */ Symbol("estimate");
    function unwrap(kwil) {
      objects_1.objects.requireNonNil(kwil);
      return objects_1.objects.requireNonNil(kwil[key]);
    }
    exports.unwrap = unwrap;
    function wrap(kwil, method) {
      objects_1.objects.requireNonNil(kwil);
      kwil[key] = method;
    }
    exports.wrap = wrap;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeSign = exports.isEthersSigner = exports.getSignatureType = exports.SignatureType = void 0;
    var serial_1 = require_serial();
    var SignatureType;
    (function(SignatureType2) {
      SignatureType2["SIGNATURE_TYPE_INVALID"] = "invalid";
      SignatureType2["SECP256K1_PERSONAL"] = "secp256k1_ep";
      SignatureType2["ED25519"] = "ed25519";
    })(SignatureType = exports.SignatureType || (exports.SignatureType = {}));
    function getSignatureType(signer) {
      if (isEthersSigner(signer)) {
        return SignatureType.SECP256K1_PERSONAL;
      }
      return SignatureType.SIGNATURE_TYPE_INVALID;
    }
    exports.getSignatureType = getSignatureType;
    async function ethSign(message, signer) {
      return await signer.signMessage(message);
    }
    function isEthersSigner(signer) {
      if (typeof signer === "object" && signer !== null && "signMessage" in signer && typeof signer.signMessage === "function") {
        return true;
      }
      return false;
    }
    exports.isEthersSigner = isEthersSigner;
    async function executeSign(msg, signer, signatureType) {
      if (isEthersSigner(signer) && signatureType === SignatureType.SECP256K1_PERSONAL) {
        const hexSig = await ethSign(msg, signer);
        let sigBytes = (0, serial_1.hexToBytes)(hexSig);
        return sigBytes;
      }
      if (!isEthersSigner(signer) && signatureType !== SignatureType.SIGNATURE_TYPE_INVALID) {
        if (typeof signer === "function") {
          const signature = await signer(msg);
          return signature;
        } else {
          throw new Error("Something went wrong signing! Make sure your signer is a function that returns a Uint8Array.");
        }
      }
      throw new Error("Could not execute signature. Make sure you pass a signer from EtherJS or a function that returns a Uint8Array.");
    }
    exports.executeSign = executeSign;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/tx.js
var require_tx = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Txn = exports.BaseTransaction = void 0;
    var signature_1 = require_signature();
    var strings_1 = require_strings();
    var enums_1 = require_enums();
    var BaseTransaction = class {
      constructor(data) {
        this.data = data || {
          signature: {
            sig: null,
            type: signature_1.SignatureType.SIGNATURE_TYPE_INVALID
          },
          body: {
            desc: "",
            payload: null,
            type: enums_1.PayloadType.INVALID_PAYLOAD_TYPE,
            fee: null,
            nonce: null,
            chain_id: ""
          },
          sender: null,
          serialization: enums_1.SerializationType.SIGNED_MSG_CONCAT
        };
      }
      get txData() {
        return this.data;
      }
      isSigned() {
        return !strings_1.strings.isNilOrEmpty(this.data.signature.sig);
      }
      get signature() {
        return this.data.signature;
      }
      get sender() {
        return this.data.sender;
      }
      get body() {
        return this.data.body;
      }
      get serialization() {
        return this.data.serialization;
      }
    };
    exports.BaseTransaction = BaseTransaction;
    var Txn;
    (function(Txn2) {
      function create(configure) {
        const tx = {
          signature: {
            sig: null,
            type: signature_1.SignatureType.SECP256K1_PERSONAL
          },
          body: {
            desc: "",
            payload: null,
            type: enums_1.PayloadType.INVALID_PAYLOAD_TYPE,
            fee: null,
            nonce: null,
            chain_id: ""
          },
          sender: null,
          serialization: enums_1.SerializationType.SIGNED_MSG_CONCAT
        };
        configure(tx);
        return new BaseTransaction(tx);
      }
      Txn2.create = create;
      function copy(source, configure) {
        return Txn2.create((tx) => {
          tx.body = source.body;
          tx.signature = source.signature;
          tx.body = source.body;
          tx.sender = source.sender;
          tx.serialization = source.serialization;
          configure(tx);
        });
      }
      Txn2.copy = copy;
    })(Txn = exports.Txn || (exports.Txn = {}));
  }
});

// node_modules/.pnpm/jssha@3.3.1/node_modules/jssha/dist/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/jssha@3.3.1/node_modules/jssha/dist/sha.js"(exports, module) {
    !(function(n, r) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
    })(exports, (function() {
      "use strict";
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "ARRAYBUFFER not supported by this environment", t = "UINT8ARRAY not supported by this environment";
      function e(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], s2 = (t2 = t2 || 0) >>> 3, w2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o2 = (u2 = i2 + s2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (w2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function i(i2, o2, u2) {
        switch (o2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (i2) {
          case "HEX":
            return function(n2, r2, t2) {
              return (function(n3, r3, t3, e2) {
                var i3, o3, u3, f2;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var s2 = r3 || [0], w2 = (t3 = t3 || 0) >>> 3, a2 = -1 === e2 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o3 = parseInt(n3.substr(i3, 2), 16), isNaN(o3)) throw new Error("String of HEX type contains invalid characters");
                  for (u3 = (f2 = (i3 >>> 1) + w2) >>> 2; s2.length <= u3; ) s2.push(0);
                  s2[u3] |= o3 << 8 * (a2 + e2 * (f2 % 4));
                }
                return { value: s2, binLen: 4 * n3.length + t3 };
              })(n2, r2, t2, u2);
            };
          case "TEXT":
            return function(n2, r2, t2) {
              return (function(n3, r3, t3, e2, i3) {
                var o3, u3, f2, s2, w2, a2, h2, c2, v2 = 0, A2 = t3 || [0], E2 = (e2 = e2 || 0) >>> 3;
                if ("UTF8" === r3) for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1) for (u3 = [], 128 > (o3 = n3.charCodeAt(f2)) ? u3.push(o3) : 2048 > o3 ? (u3.push(192 | o3 >>> 6), u3.push(128 | 63 & o3)) : 55296 > o3 || 57344 <= o3 ? u3.push(224 | o3 >>> 12, 128 | o3 >>> 6 & 63, 128 | 63 & o3) : (f2 += 1, o3 = 65536 + ((1023 & o3) << 10 | 1023 & n3.charCodeAt(f2)), u3.push(240 | o3 >>> 18, 128 | o3 >>> 12 & 63, 128 | o3 >>> 6 & 63, 128 | 63 & o3)), s2 = 0; s2 < u3.length; s2 += 1) {
                  for (w2 = (a2 = v2 + E2) >>> 2; A2.length <= w2; ) A2.push(0);
                  A2[w2] |= u3[s2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                }
                else for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                  for (o3 = n3.charCodeAt(f2), true === c2 && (o3 = (s2 = 255 & o3) << 8 | o3 >>> 8), w2 = (a2 = v2 + E2) >>> 2; A2.length <= w2; ) A2.push(0);
                  A2[w2] |= o3 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                }
                return { value: A2, binLen: 8 * v2 + e2 };
              })(n2, o2, r2, t2, u2);
            };
          case "B64":
            return function(r2, t2, e2) {
              return (function(r3, t3, e3, i3) {
                var o3, u3, f2, s2, w2, a2, h2 = 0, c2 = t3 || [0], v2 = (e3 = e3 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o3 = 0; o3 < r3.length; o3 += 4) {
                  for (s2 = r3.substr(o3, 4), f2 = 0, u3 = 0; u3 < s2.length; u3 += 1) f2 |= n.indexOf(s2.charAt(u3)) << 18 - 6 * u3;
                  for (u3 = 0; u3 < s2.length - 1; u3 += 1) {
                    for (w2 = (a2 = h2 + v2) >>> 2; c2.length <= w2; ) c2.push(0);
                    c2[w2] |= (f2 >>> 16 - 8 * u3 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e3 };
              })(r2, t2, e2, u2);
            };
          case "BYTES":
            return function(n2, r2, t2) {
              return (function(n3, r3, t3, e2) {
                var i3, o3, u3, f2, s2 = r3 || [0], w2 = (t3 = t3 || 0) >>> 3, a2 = -1 === e2 ? 3 : 0;
                for (o3 = 0; o3 < n3.length; o3 += 1) i3 = n3.charCodeAt(o3), u3 = (f2 = o3 + w2) >>> 2, s2.length <= u3 && s2.push(0), s2[u3] |= i3 << 8 * (a2 + e2 * (f2 % 4));
                return { value: s2, binLen: 8 * n3.length + t3 };
              })(n2, r2, t2, u2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error(r);
            }
            return function(n2, r2, t2) {
              return (function(n3, r3, t3, i3) {
                return e(new Uint8Array(n3), r3, t3, i3);
              })(n2, r2, t2, u2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error(t);
            }
            return function(n2, r2, t2) {
              return e(n2, r2, t2, u2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function o(e2, i2, o2, u2) {
        switch (e2) {
          case "HEX":
            return function(n2) {
              return (function(n3, r2, t2, e3) {
                var i3, o3, u3 = "0123456789abcdef", f2 = "", s2 = r2 / 8, w2 = -1 === t2 ? 3 : 0;
                for (i3 = 0; i3 < s2; i3 += 1) o3 = n3[i3 >>> 2] >>> 8 * (w2 + t2 * (i3 % 4)), f2 += u3.charAt(o3 >>> 4 & 15) + u3.charAt(15 & o3);
                return e3.outputUpper ? f2.toUpperCase() : f2;
              })(n2, i2, o2, u2);
            };
          case "B64":
            return function(r2) {
              return (function(r3, t2, e3, i3) {
                var o3, u3, f2, s2, w2, a2 = "", h2 = t2 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o3 = 0; o3 < h2; o3 += 3) for (s2 = o3 + 1 < h2 ? r3[o3 + 1 >>> 2] : 0, w2 = o3 + 2 < h2 ? r3[o3 + 2 >>> 2] : 0, f2 = (r3[o3 >>> 2] >>> 8 * (c2 + e3 * (o3 % 4)) & 255) << 16 | (s2 >>> 8 * (c2 + e3 * ((o3 + 1) % 4)) & 255) << 8 | w2 >>> 8 * (c2 + e3 * ((o3 + 2) % 4)) & 255, u3 = 0; u3 < 4; u3 += 1) a2 += 8 * o3 + 6 * u3 <= t2 ? n.charAt(f2 >>> 6 * (3 - u3) & 63) : i3.b64Pad;
                return a2;
              })(r2, i2, o2, u2);
            };
          case "BYTES":
            return function(n2) {
              return (function(n3, r2, t2) {
                var e3, i3, o3 = "", u3 = r2 / 8, f2 = -1 === t2 ? 3 : 0;
                for (e3 = 0; e3 < u3; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f2 + t2 * (e3 % 4)) & 255, o3 += String.fromCharCode(i3);
                return o3;
              })(n2, i2, o2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error(r);
            }
            return function(n2) {
              return (function(n3, r2, t2) {
                var e3, i3 = r2 / 8, o3 = new ArrayBuffer(i3), u3 = new Uint8Array(o3), f2 = -1 === t2 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u3[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t2 * (e3 % 4)) & 255;
                return o3;
              })(n2, i2, o2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error(t);
            }
            return function(n2) {
              return (function(n3, r2, t2) {
                var e3, i3 = r2 / 8, o3 = -1 === t2 ? 3 : 0, u3 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u3[e3] = n3[e3 >>> 2] >>> 8 * (o3 + t2 * (e3 % 4)) & 255;
                return u3;
              })(n2, i2, o2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var u = 4294967296, f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], w = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], a = "Chosen SHA variant is not supported", h = "Cannot set numRounds with MAC";
      function c(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function v(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function A(n2, r2, t2, e2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!e2) throw new Error(o2);
          return e2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o2);
        return i(r2.format, r2.encoding || "UTF8", t2)(r2.value);
      }
      var E = (function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.h = 0, this.v = false, this.A = 0, this.l = false, this.S = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.p >>> 5, i2 = this.m(n3, this.u, this.h), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2) t2 + this.p <= o2 && (this.U = this.R(u2.slice(r2, r2 + e2), this.U), t2 += this.p);
          return this.A += t2, this.u = u2.slice(t2 >>> 5), this.h = o2 % this.p, this.v = true, this;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, e2, i2 = this.T, u2 = v(r2);
          if (this.C) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            i2 = u2.outputLen;
          }
          var f2 = o(n3, i2, this.F, u2);
          if (this.l && this.K) return f2(this.K(u2));
          for (e2 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), i2), t2 = 1; t2 < this.numRounds; t2 += 1) this.C && i2 % 32 != 0 && (e2[e2.length - 1] &= 16777215 >>> 24 - i2 % 32), e2 = this.g(e2, i2, 0, this.B(this.o), i2);
          return f2(e2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          if (!this.k) throw new Error("Variant does not support HMAC");
          if (this.v) throw new Error("Cannot set MAC key after calling update");
          var e2 = i(r2, (t2 || {}).encoding || "UTF8", this.F);
          this.Y(e2(n3));
        }, n2.prototype.Y = function(n3) {
          var r2, t2 = this.p >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error(h);
          if (this.l) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.g(n3.value, n3.binLen, 0, this.B(this.o), this.T)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.S[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.U = this.R(this.S, this.U), this.A = this.p, this.l = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = v(r2);
          return o(n3, this.T, this.F, t2)(this.N());
        }, n2.prototype.N = function() {
          var n3;
          if (!this.l) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), this.T);
          return n3 = this.R(this.H, this.B(this.o)), n3 = this.g(r2, this.T, this.p, n3, this.T);
        }, n2;
      })(), l = function(n2, r2) {
        return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        }, l(n2, r2);
      };
      function b(n2, r2) {
        if ("function" != typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
        function t2() {
          this.constructor = n2;
        }
        l(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function S(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function H(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function d(n2, r2) {
        return n2 >>> r2;
      }
      function p(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function y(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function m(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function U(n2) {
        return H(n2, 2) ^ H(n2, 13) ^ H(n2, 22);
      }
      function R(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function T(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function C(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function F(n2) {
        return H(n2, 7) ^ H(n2, 18) ^ d(n2, 3);
      }
      function K2(n2) {
        return H(n2, 6) ^ H(n2, 11) ^ H(n2, 25);
      }
      function g(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function L(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], s2 = 0; s2 < 80; s2 += 1) w2[s2] = s2 < 16 ? n2[s2] : S(w2[s2 - 3] ^ w2[s2 - 8] ^ w2[s2 - 14] ^ w2[s2 - 16], 1), f2 = s2 < 20 ? C(S(t2, 5), y(e2, i2, o2), u2, 1518500249, w2[s2]) : s2 < 40 ? C(S(t2, 5), p(e2, i2, o2), u2, 1859775393, w2[s2]) : s2 < 60 ? C(S(t2, 5), m(e2, i2, o2), u2, 2400959708, w2[s2]) : C(S(t2, 5), p(e2, i2, o2), u2, 3395469782, w2[s2]), u2 = o2, o2 = i2, i2 = S(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = R(t2, r2[0]), r2[1] = R(e2, r2[1]), r2[2] = R(i2, r2[2]), r2[3] = R(o2, r2[3]), r2[4] = R(u2, r2[4]), r2;
      }
      function B(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), f2 = r2 + t2; n2.length <= o2; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & f2, n2[o2 - 1] = f2 / u | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = L(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      "function" == typeof SuppressedError && SuppressedError;
      var k = (function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-1" !== r3) throw new Error(a);
          var u2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).k = true, o2.K = o2.N, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = L, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = g, o2.g = B, o2.U = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.p = 512, o2.T = 160, o2.C = false, u2.hmacKey && o2.Y(A("hmacKey", u2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      })(E);
      function Y(n2) {
        return "SHA-224" == n2 ? s.slice() : w.slice();
      }
      function N(n2, r2) {
        var t2, e2, i2, o2, u2, s2, w2, a2, h2, c2, v2, A2, E2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], s2 = r2[5], w2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1) E2[v2] = v2 < 16 ? n2[v2] : T(H(A2 = E2[v2 - 2], 17) ^ H(A2, 19) ^ d(A2, 10), E2[v2 - 7], F(E2[v2 - 15]), E2[v2 - 16]), h2 = C(a2, K2(u2), y(u2, s2, w2), f[v2], E2[v2]), c2 = R(U(t2), m(t2, e2, i2)), a2 = w2, w2 = s2, s2 = u2, u2 = R(o2, h2), o2 = i2, i2 = e2, e2 = t2, t2 = R(h2, c2);
        return r2[0] = R(t2, r2[0]), r2[1] = R(e2, r2[1]), r2[2] = R(i2, r2[2]), r2[3] = R(o2, r2[3]), r2[4] = R(u2, r2[4]), r2[5] = R(s2, r2[5]), r2[6] = R(w2, r2[6]), r2[7] = R(a2, r2[7]), r2;
      }
      var I = (function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(a);
          var f2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).K = o2.N, o2.k = true, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = N, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = Y, o2.g = function(n3, t3, e3, i2) {
            return (function(n4, r4, t4, e4, i3) {
              for (var o3, f3 = 15 + (r4 + 65 >>> 9 << 4), s2 = r4 + t4; n4.length <= f3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[f3] = 4294967295 & s2, n4[f3 - 1] = s2 / u | 0, o3 = 0; o3 < n4.length; o3 += 16) e4 = N(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i3 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            })(n3, t3, e3, i2, r3);
          }, o2.U = Y(r3), o2.p = 512, o2.T = "SHA-224" === r3 ? 224 : 256, o2.C = false, f2.hmacKey && o2.Y(A("hmacKey", f2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      })(E), M = function(n2, r2) {
        this.I = n2, this.M = r2;
      };
      function X(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new M(n2.M << r2 | n2.I >>> t2, n2.I << r2 | n2.M >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new M(n2.I << r2 | n2.M >>> t2, n2.M << r2 | n2.I >>> t2)) : n2;
      }
      function z(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new M(n2.I >>> r2 | n2.M << t2, n2.M >>> r2 | n2.I << t2)) : (t2 = 64 - r2, new M(n2.M >>> r2 | n2.I << t2, n2.I >>> r2 | n2.M << t2));
      }
      function O(n2, r2) {
        return new M(n2.I >>> r2, n2.M >>> r2 | n2.I << 32 - r2);
      }
      function j(n2, r2, t2) {
        return new M(n2.I & r2.I ^ ~n2.I & t2.I, n2.M & r2.M ^ ~n2.M & t2.M);
      }
      function _(n2, r2, t2) {
        return new M(n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I, n2.M & r2.M ^ n2.M & t2.M ^ r2.M & t2.M);
      }
      function x(n2) {
        var r2 = z(n2, 28), t2 = z(n2, 34), e2 = z(n2, 39);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      function P(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.M) + (65535 & r2.M);
        var i2 = (65535 & (e2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.I) + (65535 & r2.I) + (e2 >>> 16), e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16), new M((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function V(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.M) + (65535 & r2.M) + (65535 & t2.M) + (65535 & e2.M);
        var u2 = (65535 & (o2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2.M >>> 16) + (e2.M >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (o2 >>> 16), o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16), new M((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function Z(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.M) + (65535 & r2.M) + (65535 & t2.M) + (65535 & e2.M) + (65535 & i2.M);
        var f2 = (65535 & (u2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2.M >>> 16) + (e2.M >>> 16) + (i2.M >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I) + (u2 >>> 16), u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16), new M((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function q(n2, r2) {
        return new M(n2.I ^ r2.I, n2.M ^ r2.M);
      }
      function D(n2) {
        var r2 = z(n2, 1), t2 = z(n2, 8), e2 = O(n2, 7);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      function G(n2) {
        var r2 = z(n2, 14), t2 = z(n2, 18), e2 = z(n2, 41);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      var J = [new M(f[0], 3609767458), new M(f[1], 602891725), new M(f[2], 3964484399), new M(f[3], 2173295548), new M(f[4], 4081628472), new M(f[5], 3053834265), new M(f[6], 2937671579), new M(f[7], 3664609560), new M(f[8], 2734883394), new M(f[9], 1164996542), new M(f[10], 1323610764), new M(f[11], 3590304994), new M(f[12], 4068182383), new M(f[13], 991336113), new M(f[14], 633803317), new M(f[15], 3479774868), new M(f[16], 2666613458), new M(f[17], 944711139), new M(f[18], 2341262773), new M(f[19], 2007800933), new M(f[20], 1495990901), new M(f[21], 1856431235), new M(f[22], 3175218132), new M(f[23], 2198950837), new M(f[24], 3999719339), new M(f[25], 766784016), new M(f[26], 2566594879), new M(f[27], 3203337956), new M(f[28], 1034457026), new M(f[29], 2466948901), new M(f[30], 3758326383), new M(f[31], 168717936), new M(f[32], 1188179964), new M(f[33], 1546045734), new M(f[34], 1522805485), new M(f[35], 2643833823), new M(f[36], 2343527390), new M(f[37], 1014477480), new M(f[38], 1206759142), new M(f[39], 344077627), new M(f[40], 1290863460), new M(f[41], 3158454273), new M(f[42], 3505952657), new M(f[43], 106217008), new M(f[44], 3606008344), new M(f[45], 1432725776), new M(f[46], 1467031594), new M(f[47], 851169720), new M(f[48], 3100823752), new M(f[49], 1363258195), new M(f[50], 3750685593), new M(f[51], 3785050280), new M(f[52], 3318307427), new M(f[53], 3812723403), new M(f[54], 2003034995), new M(f[55], 3602036899), new M(f[56], 1575990012), new M(f[57], 1125592928), new M(f[58], 2716904306), new M(f[59], 442776044), new M(f[60], 593698344), new M(f[61], 3733110249), new M(f[62], 2999351573), new M(f[63], 3815920427), new M(3391569614, 3928383900), new M(3515267271, 566280711), new M(3940187606, 3454069534), new M(4118630271, 4000239992), new M(116418474, 1914138554), new M(174292421, 2731055270), new M(289380356, 3203993006), new M(460393269, 320620315), new M(685471733, 587496836), new M(852142971, 1086792851), new M(1017036298, 365543100), new M(1126000580, 2618297676), new M(1288033470, 3409855158), new M(1501505948, 4234509866), new M(1607167915, 987167468), new M(1816402316, 1246189591)];
      function Q(n2) {
        return "SHA-384" === n2 ? [new M(3418070365, s[0]), new M(1654270250, s[1]), new M(2438529370, s[2]), new M(355462360, s[3]), new M(1731405415, s[4]), new M(41048885895, s[5]), new M(3675008525, s[6]), new M(1203062813, s[7])] : [new M(w[0], 4089235720), new M(w[1], 2227873595), new M(w[2], 4271175723), new M(w[3], 1595750129), new M(w[4], 2917565137), new M(w[5], 725511199), new M(w[6], 4215389547), new M(w[7], 327033209)];
      }
      function W(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2, a2, h2, c2, v2, A2, E2, l2, b2, S2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], s2 = r2[6], w2 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v2 = 2 * c2, S2[c2] = new M(n2[v2], n2[v2 + 1])) : S2[c2] = V((A2 = S2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = z(A2, 19), l2 = z(A2, 61), b2 = O(A2, 6), new M(E2.I ^ l2.I ^ b2.I, E2.M ^ l2.M ^ b2.M)), S2[c2 - 7], D(S2[c2 - 15]), S2[c2 - 16]), a2 = Z(w2, G(u2), j(u2, f2, s2), J[c2], S2[c2]), h2 = P(x(t2), _(t2, e2, i2)), w2 = s2, s2 = f2, f2 = u2, u2 = P(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = P(a2, h2);
        return r2[0] = P(t2, r2[0]), r2[1] = P(e2, r2[1]), r2[2] = P(i2, r2[2]), r2[3] = P(o2, r2[3]), r2[4] = P(u2, r2[4]), r2[5] = P(f2, r2[5]), r2[6] = P(s2, r2[6]), r2[7] = P(w2, r2[7]), r2;
      }
      var $ = (function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(a);
          var f2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).K = o2.N, o2.k = true, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = W, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = Q, o2.g = function(n3, t3, e3, i2) {
            return (function(n4, r4, t4, e4, i3) {
              for (var o3, f3 = 31 + (r4 + 129 >>> 10 << 5), s2 = r4 + t4; n4.length <= f3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[f3] = 4294967295 & s2, n4[f3 - 1] = s2 / u | 0, o3 = 0; o3 < n4.length; o3 += 32) e4 = W(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i3 ? [e4[0].I, e4[0].M, e4[1].I, e4[1].M, e4[2].I, e4[2].M, e4[3].I, e4[3].M, e4[4].I, e4[4].M, e4[5].I, e4[5].M] : [e4[0].I, e4[0].M, e4[1].I, e4[1].M, e4[2].I, e4[2].M, e4[3].I, e4[3].M, e4[4].I, e4[4].M, e4[5].I, e4[5].M, e4[6].I, e4[6].M, e4[7].I, e4[7].M];
            })(n3, t3, e3, i2, r3);
          }, o2.U = Q(r3), o2.p = 1024, o2.T = "SHA-384" === r3 ? 384 : 512, o2.C = false, f2.hmacKey && o2.Y(A("hmacKey", f2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      })(E), nn = [new M(0, 1), new M(0, 32898), new M(2147483648, 32906), new M(2147483648, 2147516416), new M(0, 32907), new M(0, 2147483649), new M(2147483648, 2147516545), new M(2147483648, 32777), new M(0, 138), new M(0, 136), new M(0, 2147516425), new M(0, 2147483658), new M(0, 2147516555), new M(2147483648, 139), new M(2147483648, 32905), new M(2147483648, 32771), new M(2147483648, 32770), new M(2147483648, 128), new M(0, 32778), new M(2147483648, 2147483658), new M(2147483648, 2147516545), new M(2147483648, 32896), new M(0, 2147483649), new M(2147483648, 2147516424)], rn = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function tn(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new M(0, 0), new M(0, 0), new M(0, 0), new M(0, 0), new M(0, 0)];
        return t2;
      }
      function en(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function on(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2, a2, h2 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = q(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new M(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = tn(), e2 = 0; e2 < 5; e2 += 1) h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], s2 = r2[e2][2], w2 = r2[e2][3], a2 = r2[e2][4], new M(u2.I ^ f2.I ^ s2.I ^ w2.I ^ a2.I, u2.M ^ f2.M ^ s2.M ^ w2.M ^ a2.M));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = q(h2[(e2 + 4) % 5], X(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = q(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o2[i2][(2 * e2 + 3 * i2) % 5] = X(r2[e2][i2], rn[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = q(o2[e2][i2], new M(~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I, ~o2[(e2 + 1) % 5][i2].M & o2[(e2 + 2) % 5][i2].M));
          r2[0][0] = q(r2[0][0], nn[t2]);
        }
        return r2;
      }
      function un(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / u & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function fn(n2) {
        return c(un(n2.binLen), n2);
      }
      function sn(n2, r2) {
        var t2, e2 = un(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = c(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++) e2.value.push(0);
        return e2.value;
      }
      var wn = (function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this, u2 = 6, f2 = 0, s2 = e2 || {};
          if (1 !== (o2 = n2.call(this, r3, t2, e2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey) throw new Error(h);
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.F = 1, o2.m = i(o2.t, o2.i, o2.F), o2.R = on, o2.L = en, o2.B = tn, o2.U = tn(), o2.C = false, r3) {
            case "SHA3-224":
              o2.p = f2 = 1152, o2.T = 224, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-256":
              o2.p = f2 = 1088, o2.T = 256, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-384":
              o2.p = f2 = 832, o2.T = 384, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-512":
              o2.p = f2 = 576, o2.T = 512, o2.k = true, o2.K = o2.N;
              break;
            case "SHAKE128":
              u2 = 31, o2.p = f2 = 1344, o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.p = f2 = 1088, o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "KMAC128":
              u2 = 4, o2.p = f2 = 1344, o2.X(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = o2.O;
              break;
            case "KMAC256":
              u2 = 4, o2.p = f2 = 1088, o2.X(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = o2.O;
              break;
            case "CSHAKE128":
              o2.p = f2 = 1344, u2 = o2.j(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "CSHAKE256":
              o2.p = f2 = 1088, u2 = o2.j(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            default:
              throw new Error(a);
          }
          return o2.g = function(n3, r4, t3, e3, i2) {
            return (function(n4, r5, t4, e4, i3, o3, u3) {
              var f3, s3, w2 = 0, a2 = [], h2 = i3 >>> 5, c2 = r5 >>> 5;
              for (f3 = 0; f3 < c2 && r5 >= i3; f3 += h2) e4 = on(n4.slice(f3, f3 + h2), e4), r5 -= i3;
              for (n4 = n4.slice(f3), r5 %= i3; n4.length < h2; ) n4.push(0);
              for (n4[(f3 = r5 >>> 3) >> 2] ^= o3 << f3 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = on(n4, e4); 32 * a2.length < u3 && (s3 = e4[w2 % 5][w2 / 5 | 0], a2.push(s3.M), !(32 * a2.length >= u3)); ) a2.push(s3.I), 0 == 64 * (w2 += 1) % i3 && (on(null, e4), w2 = 0);
              return a2;
            })(n3, r4, 0, e3, f2, u2, i2);
          }, s2.hmacKey && o2.Y(A("hmacKey", s2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2.prototype.j = function(n3, r3) {
          var t2 = (function(n4) {
            var r4 = n4 || {};
            return { funcName: A("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: A("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = c(fn(t2.funcName), fn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = sn(e2, this.p >>> 3), o2 = 0; o2 < i2.length; o2 += this.p >>> 5) this.U = this.R(i2.slice(o2, o2 + (this.p >>> 5)), this.U), this.A += this.p;
            return 4;
          }
          return 31;
        }, r2.prototype.X = function(n3) {
          var r3 = (function(n4) {
            var r4 = n4 || {};
            return { kmacKey: A("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: A("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          this.j(n3, r3.funcName);
          for (var t2 = sn(fn(r3.kmacKey), this.p >>> 3), e2 = 0; e2 < t2.length; e2 += this.p >>> 5) this.U = this.R(t2.slice(e2, e2 + (this.p >>> 5)), this.U), this.A += this.p;
          this.l = true;
        }, r2.prototype.O = function(n3) {
          var r3 = c({ value: this.u.slice(), binLen: this.h }, (function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / u & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          })(n3.outputLen));
          return this.g(r3.value, r3.binLen, this.A, this.L(this.U), n3.outputLen);
        }, r2;
      })(E);
      return (function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this._ = new k(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this._ = new I(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this._ = new $(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(a);
            this._ = new wn(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          return this._.update(n3), this;
        }, n2.prototype.getHash = function(n3, r2) {
          return this._.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this._.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this._.getHMAC(n3, r2);
        }, n2;
      })();
    }));
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/crypto.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256BytesToBytes = exports.sha224BytesToString = exports.sha224StringToString = exports.sha384StringToBytes = exports.sha384BytesToBytes = exports.sha384BytesToString = exports.sha384StringToString = void 0;
    var jssha_1 = __importDefault(require_sha());
    function sha384StringToString(message) {
      const shaObj = new jssha_1.default("SHA-384", "TEXT");
      shaObj.update(message);
      return shaObj.getHash("HEX");
    }
    exports.sha384StringToString = sha384StringToString;
    function sha384BytesToString(message) {
      const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
      shaObj.update(message);
      return shaObj.getHash("HEX");
    }
    exports.sha384BytesToString = sha384BytesToString;
    function sha384BytesToBytes(message) {
      const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
      shaObj.update(message);
      return shaObj.getHash("UINT8ARRAY");
    }
    exports.sha384BytesToBytes = sha384BytesToBytes;
    function sha384StringToBytes(message) {
      const shaObj = new jssha_1.default("SHA-384", "TEXT");
      shaObj.update(message);
      return shaObj.getHash("UINT8ARRAY");
    }
    exports.sha384StringToBytes = sha384StringToBytes;
    function sha224StringToString(message) {
      const shaObj = new jssha_1.default("SHA-224", "TEXT");
      shaObj.update(message);
      return shaObj.getHash("HEX");
    }
    exports.sha224StringToString = sha224StringToString;
    function sha224BytesToString(message) {
      const shaObj = new jssha_1.default("SHA-224", "UINT8ARRAY");
      shaObj.update(message);
      return shaObj.getHash("HEX");
    }
    exports.sha224BytesToString = sha224BytesToString;
    function sha256BytesToBytes(message) {
      const shaObj = new jssha_1.default("SHA-256", "UINT8ARRAY");
      shaObj.update(message);
      return shaObj.getHash("UINT8ARRAY");
    }
    exports.sha256BytesToBytes = sha256BytesToBytes;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/bytes.js
var require_bytes = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/bytes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prefixBytesLength = exports.numberToUint32BigEndian = exports.numberToUint16LittleEndian = exports.concatBytes = exports.numberToUint64LittleEndian = exports.uint16BigEndianToNumber = exports.numberToUint16BigEndian = void 0;
    var long_1 = __importDefault(require_umd());
    function numberToUint16BigEndian(num) {
      if (num < 0 || num > 65535 || !Number.isInteger(num)) {
        throw new Error("Number is out of range for uint16");
      }
      const buffer = new ArrayBuffer(2);
      const view = new DataView(buffer);
      view.setUint16(0, num, false);
      return new Uint8Array(buffer);
    }
    exports.numberToUint16BigEndian = numberToUint16BigEndian;
    function uint16BigEndianToNumber(uint16) {
      if (uint16.length !== 2) {
        throw new Error("uint16 must be 2 bytes");
      }
      const view = new DataView(uint16.buffer);
      return view.getUint16(0, false);
    }
    exports.uint16BigEndianToNumber = uint16BigEndianToNumber;
    function numberToUint64LittleEndian(num) {
      const longNum = long_1.default.fromNumber(num, true);
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      view.setUint32(0, longNum.low, true);
      view.setUint32(4, longNum.high, true);
      return new Uint8Array(buffer);
    }
    exports.numberToUint64LittleEndian = numberToUint64LittleEndian;
    function concatBytes2(...arrays) {
      let totalLength = 0;
      for (const arr of arrays) {
        totalLength += arr.length;
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes2;
    function numberToUint16LittleEndian(number3) {
      if (number3 < 0 || number3 > 65535 || !Number.isInteger(number3)) {
        throw new RangeError("The number must be an integer between 0 and 65535.");
      }
      const buffer = new ArrayBuffer(2);
      const view = new DataView(buffer);
      view.setUint16(0, number3, true);
      return new Uint8Array(buffer);
    }
    exports.numberToUint16LittleEndian = numberToUint16LittleEndian;
    function numberToUint32LittleEndian(number3) {
      if (number3 < 0 || number3 > 4294967295 || !Number.isInteger(number3)) {
        throw new RangeError("The number must be an integer between 0 and 4294967295.");
      }
      const buffer = new ArrayBuffer(4);
      const view = new DataView(buffer);
      view.setUint32(0, number3, true);
      return new Uint8Array(buffer);
    }
    function numberToUint32BigEndian(number3) {
      if (number3 < 0 || number3 > 4294967295 || !Number.isInteger(number3)) {
        throw new RangeError("The number must be an integer between 0 and 4294967295.");
      }
      const buffer = new ArrayBuffer(4);
      const view = new DataView(buffer);
      view.setUint32(0, number3, false);
      return new Uint8Array(buffer);
    }
    exports.numberToUint32BigEndian = numberToUint32BigEndian;
    function prefixBytesLength(bytes) {
      const lengthBytes = numberToUint32LittleEndian(bytes.length);
      return concatBytes2(lengthBytes, bytes);
    }
    exports.prefixBytesLength = prefixBytesLength;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var regex_js_1 = require_regex();
    function validate(uuid3) {
      return typeof uuid3 === "string" && regex_js_1.default.test(uuid3);
    }
    exports.default = validate;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function parse3(uuid3) {
      if (!(0, validate_js_1.default)(uuid3)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      return Uint8Array.of((v = parseInt(uuid3.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid3.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid3.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid3.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid3.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
    }
    exports.default = parse3;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsafeStringify = void 0;
    var validate_js_1 = require_validate();
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    exports.unsafeStringify = unsafeStringify;
    function stringify(arr, offset = 0) {
      const uuid3 = unsafeStringify(arr, offset);
      if (!(0, validate_js_1.default)(uuid3)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid3;
    }
    exports.default = stringify;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        if (typeof crypto === "undefined" || !crypto.getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
      }
      return getRandomValues(rnds8);
    }
    exports.default = rng;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV1State = void 0;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v1(options, buf, offset) {
      let bytes;
      const isV6 = options?._v6 ?? false;
      if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
          options = void 0;
        }
      }
      if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
      }
      return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV1State(state, now, rnds) {
      state.msecs ?? (state.msecs = -Infinity);
      state.nsecs ?? (state.nsecs = 0);
      if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 1e4) {
          state.node = void 0;
          state.nsecs = 0;
        }
      } else if (now > state.msecs) {
        state.nsecs = 0;
      } else if (now < state.msecs) {
        state.node = void 0;
      }
      if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 1;
        state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
      }
      state.msecs = now;
      return state;
    }
    exports.updateV1State = updateV1State;
    function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      } else {
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
      }
      msecs ?? (msecs = Date.now());
      nsecs ?? (nsecs = 0);
      clockseq ?? (clockseq = (rnds[8] << 8 | rnds[9]) & 16383);
      node ?? (node = rnds.slice(10, 16));
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      buf[offset++] = tl >>> 24 & 255;
      buf[offset++] = tl >>> 16 & 255;
      buf[offset++] = tl >>> 8 & 255;
      buf[offset++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      buf[offset++] = tmh >>> 8 & 255;
      buf[offset++] = tmh & 255;
      buf[offset++] = tmh >>> 24 & 15 | 16;
      buf[offset++] = tmh >>> 16 & 255;
      buf[offset++] = clockseq >>> 8 | 128;
      buf[offset++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        buf[offset++] = node[n];
      }
      return buf;
    }
    exports.default = v1;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v1ToV6.js
var require_v1ToV6 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v1ToV6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v1ToV6(uuid3) {
      const v1Bytes = typeof uuid3 === "string" ? (0, parse_js_1.default)(uuid3) : uuid3;
      const v6Bytes = _v1ToV6(v1Bytes);
      return typeof uuid3 === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
    }
    exports.default = v1ToV6;
    function _v1ToV6(v1Bytes) {
      return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
    }
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function md5(bytes) {
      const words = uint8ToUint32(bytes);
      const md5Bytes = wordsToMd5(words, bytes.length * 8);
      return uint32ToUint8(md5Bytes);
    }
    function uint32ToUint8(input) {
      const bytes = new Uint8Array(input.length * 4);
      for (let i = 0; i < input.length * 4; i++) {
        bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
      }
      return bytes;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      const xpad = new Uint32Array(getOutputLength(len)).fill(0);
      xpad.set(x);
      xpad[len >> 5] |= 128 << len % 32;
      xpad[xpad.length - 1] = len;
      x = xpad;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return Uint32Array.of(a, b, c, d);
    }
    function uint8ToUint32(input) {
      if (input.length === 0) {
        return new Uint32Array();
      }
      const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
      for (let i = 0; i < input.length; i++) {
        output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    exports.default = md5;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = exports.stringToBytes = void 0;
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    exports.stringToBytes = stringToBytes;
    exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    function v35(version2, hash2, value, namespace, buf, offset) {
      const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
      const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1.default)(namespace) : namespace;
      if (typeof namespace === "string") {
        namespace = (0, parse_js_1.default)(namespace);
      }
      if (namespace?.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + valueBytes.length);
      bytes.set(namespaceBytes);
      bytes.set(valueBytes, namespaceBytes.length);
      bytes = hash2(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports.default = v35;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    var md5_js_1 = require_md5();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v3(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value, namespace, buf, offset);
    }
    v3.DNS = v35_js_1.DNS;
    v3.URL = v35_js_1.URL;
    exports.default = v3;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/native.js
var require_native = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    exports.default = { randomUUID };
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var native_js_1 = require_native();
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    function v4(options, buf, offset) {
      if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(rnds);
    }
    exports.default = v4;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      const newBytes = new Uint8Array(bytes.length + 1);
      newBytes.set(bytes);
      newBytes[bytes.length] = 128;
      bytes = newBytes;
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
    }
    exports.default = sha1;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    var sha1_js_1 = require_sha1();
    var v35_js_1 = require_v35();
    var v35_js_2 = require_v35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v5(value, namespace, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace, buf, offset);
    }
    v5.DNS = v35_js_1.DNS;
    v5.URL = v35_js_1.URL;
    exports.default = v5;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v6.js
var require_v6 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stringify_js_1 = require_stringify();
    var v1_js_1 = require_v1();
    var v1ToV6_js_1 = require_v1ToV6();
    function v6(options, buf, offset) {
      options ?? (options = {});
      offset ?? (offset = 0);
      let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
      bytes = (0, v1ToV6_js_1.default)(bytes);
      if (buf) {
        for (let i = 0; i < 16; i++) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, stringify_js_1.unsafeStringify)(bytes);
    }
    exports.default = v6;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v6ToV1.js
var require_v6ToV1 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v6ToV1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parse_js_1 = require_parse();
    var stringify_js_1 = require_stringify();
    function v6ToV1(uuid3) {
      const v6Bytes = typeof uuid3 === "string" ? (0, parse_js_1.default)(uuid3) : uuid3;
      const v1Bytes = _v6ToV1(v6Bytes);
      return typeof uuid3 === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
    }
    exports.default = v6ToV1;
    function _v6ToV1(v6Bytes) {
      return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
    }
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v7.js
var require_v7 = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/v7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateV7State = void 0;
    var rng_js_1 = require_rng();
    var stringify_js_1 = require_stringify();
    var _state = {};
    function v7(options, buf, offset) {
      let bytes;
      if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
      } else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
      }
      return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
    }
    function updateV7State(state, now, rnds) {
      state.msecs ?? (state.msecs = -Infinity);
      state.seq ?? (state.seq = 0);
      if (now > state.msecs) {
        state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
        state.msecs = now;
      } else {
        state.seq = state.seq + 1 | 0;
        if (state.seq === 0) {
          state.msecs++;
        }
      }
      return state;
    }
    exports.updateV7State = updateV7State;
    function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
      if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
      }
      if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
      } else {
        if (offset < 0 || offset + 16 > buf.length) {
          throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
      }
      msecs ?? (msecs = Date.now());
      seq ?? (seq = rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9]);
      buf[offset++] = msecs / 1099511627776 & 255;
      buf[offset++] = msecs / 4294967296 & 255;
      buf[offset++] = msecs / 16777216 & 255;
      buf[offset++] = msecs / 65536 & 255;
      buf[offset++] = msecs / 256 & 255;
      buf[offset++] = msecs & 255;
      buf[offset++] = 112 | seq >>> 28 & 15;
      buf[offset++] = seq >>> 20 & 255;
      buf[offset++] = 128 | seq >>> 14 & 63;
      buf[offset++] = seq >>> 6 & 255;
      buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
      buf[offset++] = rnds[11];
      buf[offset++] = rnds[12];
      buf[offset++] = rnds[13];
      buf[offset++] = rnds[14];
      buf[offset++] = rnds[15];
      return buf;
    }
    exports.default = v7;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_js_1 = require_validate();
    function version2(uuid3) {
      if (!(0, validate_js_1.default)(uuid3)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid3.slice(14, 15), 16);
    }
    exports.default = version2;
  }
});

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/index.js
var require_cjs_browser = __commonJS({
  "node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/cjs-browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
    var max_js_1 = require_max();
    Object.defineProperty(exports, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = require_nil();
    Object.defineProperty(exports, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = require_v1();
    Object.defineProperty(exports, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = require_v1ToV6();
    Object.defineProperty(exports, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = require_v3();
    Object.defineProperty(exports, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = require_v4();
    Object.defineProperty(exports, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = require_v5();
    Object.defineProperty(exports, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = require_v6();
    Object.defineProperty(exports, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = require_v6ToV1();
    Object.defineProperty(exports, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = require_v7();
    Object.defineProperty(exports, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = require_validate();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = require_version();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertUuidToBytes = exports.isUuid = void 0;
    var uuid_1 = require_cjs_browser();
    function isUuid(value) {
      return (0, uuid_1.validate)(value);
    }
    exports.isUuid = isUuid;
    function convertUuidToBytes(uuid3) {
      return (0, uuid_1.parse)(uuid3);
    }
    exports.convertUuidToBytes = convertUuidToBytes;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/kwilEncoding.js
var require_kwilEncoding = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/kwilEncoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeValue = exports.encodeTransfer = exports.encodeRawStatement = exports.encodeActionExecution = exports.encodeActionCall = exports.encodeAccountId = void 0;
    var base64_1 = require_base64();
    var bytes_1 = require_bytes();
    var serial_1 = require_serial();
    var uuid_1 = require_uuid();
    var enums_1 = require_enums();
    function encodeAccountId(accountId) {
      const encodedId = (0, bytes_1.prefixBytesLength)((0, serial_1.hexToBytes)(accountId.identifier));
      const encodedKeyType = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(accountId.key_type));
      return (0, bytes_1.concatBytes)(encodedId, encodedKeyType);
    }
    exports.encodeAccountId = encodeAccountId;
    function encodeActionCall(actionCall) {
      const actionCallVersion = 0;
      const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionCallVersion);
      const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(actionCall.dbid));
      const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(actionCall.action));
      const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(actionCall.arguments ? actionCall.arguments.length : 0);
      let actionArguments = new Uint8Array();
      actionCall.arguments?.forEach((a) => {
        const aBytes = encodeEncodedValue(a);
        const prefixedABytes = (0, bytes_1.prefixBytesLength)(aBytes);
        actionArguments = (0, bytes_1.concatBytes)(actionArguments, prefixedABytes);
      });
      const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
      return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
    }
    exports.encodeActionCall = encodeActionCall;
    function encodeActionExecution(action) {
      const actionExecutionVersion = 0;
      const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionExecutionVersion);
      const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(action.dbid));
      const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(action.action));
      const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(action.arguments ? action.arguments.length : 0);
      let actionArguments = new Uint8Array();
      action.arguments?.forEach((encodedValues) => {
        const argLength = (0, bytes_1.numberToUint16LittleEndian)(encodedValues.length);
        let argBytes = new Uint8Array();
        encodedValues.forEach((value) => {
          const evBytes = encodeEncodedValue(value);
          const prefixedEvBytes = (0, bytes_1.prefixBytesLength)(evBytes);
          argBytes = (0, bytes_1.concatBytes)(argBytes, prefixedEvBytes);
        });
        actionArguments = (0, bytes_1.concatBytes)(actionArguments, argLength, argBytes);
      });
      const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
      return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
    }
    exports.encodeActionExecution = encodeActionExecution;
    function encodeRawStatement(statement) {
      const rawStatementVersion = 0;
      const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(rawStatementVersion);
      const statementBytes = (0, serial_1.stringToBytes)(statement.statement);
      const encodedStatement = (0, bytes_1.prefixBytesLength)(statementBytes);
      let encodedParameters;
      encodedParameters = (0, bytes_1.numberToUint16LittleEndian)(statement.parameters ? statement.parameters.length : 0);
      for (const param of statement.parameters) {
        const nameBytes = (0, serial_1.stringToBytes)(param.name);
        const prefixedNameBytes = (0, bytes_1.prefixBytesLength)(nameBytes);
        const valueBytes = encodeEncodedValue(param.value);
        const valueBytesPrefix = (0, bytes_1.prefixBytesLength)(valueBytes);
        encodedParameters = (0, bytes_1.concatBytes)(encodedParameters, prefixedNameBytes, valueBytesPrefix);
      }
      return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedStatement, encodedParameters));
    }
    exports.encodeRawStatement = encodeRawStatement;
    function encodeTransfer(transfer) {
      const transferVersion = 0;
      const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(transferVersion);
      const encodedTo = (0, bytes_1.prefixBytesLength)(encodeAccountId(transfer.to));
      const encodedAmount = (0, bytes_1.concatBytes)(new Uint8Array([1]), (0, bytes_1.prefixBytesLength)((0, serial_1.stringToBytes)(transfer.amount.toString())));
      return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedTo, encodedAmount));
    }
    exports.encodeTransfer = encodeTransfer;
    function encodeEncodedValue(ev) {
      const evVersion = 0;
      const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(evVersion);
      const dataTypeBytes = encodeDataType(ev.type);
      const encodedType = (0, bytes_1.prefixBytesLength)(dataTypeBytes);
      const dataLength = (0, bytes_1.numberToUint16LittleEndian)(ev.data.length);
      let encodedData = (0, bytes_1.concatBytes)(dataLength);
      for (const data of ev.data) {
        encodedData = (0, bytes_1.concatBytes)(encodedData, (0, bytes_1.prefixBytesLength)(data));
      }
      return (0, bytes_1.concatBytes)(encodedVersion, encodedType, encodedData);
    }
    function encodeDataType(dt) {
      const dtVersion = 0;
      const versionBytes = (0, bytes_1.numberToUint16BigEndian)(dtVersion);
      const nameBytes = (0, serial_1.stringToBytes)(dt.name);
      const nameLength = (0, bytes_1.numberToUint32BigEndian)(nameBytes.length);
      const isArray = (0, serial_1.booleanToBytes)(dt.is_array);
      const metadataLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[0] || 0);
      const precisionLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[1] || 0);
      return (0, bytes_1.concatBytes)(versionBytes, nameLength, nameBytes, isArray, metadataLength, precisionLength);
    }
    function encodeValue(value, o) {
      if (o) {
        return overrideValue(value, o);
      }
      if (typeof value === "string" && (0, uuid_1.isUuid)(value)) {
        return encodeNotNull((0, uuid_1.convertUuidToBytes)(value));
      }
      if (value === null) {
        return encodeNull();
      }
      if (value instanceof Uint8Array) {
        return encodeNotNull(value);
      }
      if (typeof value === "number" && isDecimal(value)) {
        return encodeNotNull((0, serial_1.stringToBytes)(value.toString()));
      }
      switch (typeof value) {
        case "string":
          return encodeNotNull((0, serial_1.stringToBytes)(value));
        case "boolean":
          return encodeNotNull((0, serial_1.booleanToBytes)(value));
        case "number":
          return encodeNotNull((0, serial_1.numberToBytes)(value));
        case "undefined":
          return encodeNull();
        case "bigint":
          throw new Error("bigint not supported. convert to string.");
        default:
          throw new Error("invalid scalar value");
      }
    }
    exports.encodeValue = encodeValue;
    function overrideValue(v, o) {
      if (v === null || v === void 0) {
        return encodeNull();
      }
      switch (o) {
        case enums_1.VarType.NULL:
          return encodeNull();
        case enums_1.VarType.TEXT:
          return encodeNotNull((0, serial_1.stringToBytes)(v));
        case enums_1.VarType.INT8:
          return encodeNotNull((0, serial_1.numberToBytes)(v));
        case enums_1.VarType.BOOL:
          return encodeNotNull((0, serial_1.booleanToBytes)(v));
        case enums_1.VarType.NUMERIC:
          return encodeNotNull((0, serial_1.stringToBytes)(v.toString()));
        case enums_1.VarType.UUID:
          return encodeNotNull((0, uuid_1.convertUuidToBytes)(v));
        case enums_1.VarType.BYTEA:
          return encodeNotNull(v);
        default:
          throw new Error("invalid scalar value");
      }
    }
    function isDecimal(n) {
      const numStr = Math.abs(n).toString();
      const decimalIdx = numStr.indexOf(".");
      return decimalIdx !== -1;
    }
    function encodeNull() {
      return new Uint8Array([0]);
    }
    function encodeNotNull(v) {
      const bytes = new Uint8Array(v.length + 1);
      bytes[0] = 1;
      bytes.set(v, 1);
      return bytes;
    }
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/transaction/payloadTx.js
var require_payloadTx = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/transaction/payloadTx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PayloadTx = void 0;
    var intern_1 = require_intern();
    var enums_1 = require_enums();
    var signature_1 = require_signature();
    var tx_1 = require_tx();
    var base64_1 = require_base64();
    var crypto_1 = require_crypto();
    var objects_1 = require_objects();
    var serial_1 = require_serial();
    var strings_1 = require_strings();
    var kwilEncoding_1 = require_kwilEncoding();
    var PayloadTx = class _PayloadTx {
      /**
       * Initializes a new `Payload` instance.
       *
       * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
       */
      constructor(kwil, options) {
        this.kwil = objects_1.objects.requireNonNil(kwil, "Client is required for TxnBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.");
        this.payload = objects_1.objects.requireNonNil(options.payload, "Payload is required for TxnBuilder. Please pass a valid payload.");
        objects_1.objects.validateOptionalFields(options, [
          "payloadType",
          "signer",
          "identifier",
          "signatureType",
          "chainId",
          "description",
          "nonce"
        ]);
        this.payloadType = options.payloadType;
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
        this.chainId = options.chainId;
        this.description = options.description;
        this.nonce = options.nonce;
      }
      /**
       * Static factory method to create a new Payload instance.
       *
       * @param kwil - The Kwil client.
       * @param options - The options to configure the Payload instance.
       */
      static createTx(kwil, options) {
        return new _PayloadTx(kwil, options);
      }
      /**
       * Build the payload structure for a transaction.
       */
      async buildTx() {
        const { signer, payloadType, identifier, signatureType, chainId } = objects_1.objects.validateFields({
          signer: this.signer,
          payloadType: this.payloadType,
          identifier: this.identifier,
          signatureType: this.signatureType,
          chainId: this.chainId
        }, (fieldName) => `${fieldName} is required to build a transaction.`);
        const preEstTxn = tx_1.Txn.create((tx) => {
          tx.body.payload = this.encodePayload(this.payloadType, this.payload);
          tx.body.type = payloadType;
          tx.sender = (0, serial_1.bytesToHex)(identifier);
        });
        const cost = await (0, intern_1.unwrap)(this.kwil)(preEstTxn);
        let nonce = this.nonce;
        if (!this.nonce) {
          const acct = await this.kwil.getAccount(identifier);
          nonce = Number(objects_1.objects.requireNonNil(acct.data?.nonce, "something went wrong retrieving your account nonce.")) + 1;
        }
        const encodedPayload = objects_1.objects.requireNonNil(preEstTxn.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
        const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx) => {
          tx.body.payload = (0, base64_1.base64ToBytes)(encodedPayload);
          tx.body.fee = BigInt(strings_1.strings.requireNonNil(cost.data, "something went wrong estimating the cost of your transaction."));
          tx.body.nonce = objects_1.objects.requireNonNil(nonce, "something went wrong retrieving your account nonce.");
          tx.body.chain_id = chainId;
        });
        if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
          throw new Error("Signature type is invalid.");
        }
        return _PayloadTx.signTx(postEstTxn, signer, identifier, signatureType, this.description);
      }
      /**
       * Signs the payload of a transaction / request to the broadcast GRPC endpoint.
       *
       * @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
       * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
       * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
       * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
       * @param {string} description - The description to be included in the signature.
       * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
       * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
       */
      static async signTx(tx, signer, identifier, signatureType, description) {
        const digest = (0, crypto_1.sha256BytesToBytes)(tx.body.payload).subarray(0, 20);
        const signatureMessage = `${description}

PayloadType: ${tx.body.type}
PayloadDigest: ${(0, serial_1.bytesToHex)(digest)}
Fee: ${tx.body.fee}
Nonce: ${tx.body.nonce}

Kwil Chain ID: ${tx.body.chain_id}
`;
        const signedMessage = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(signatureMessage), signer, signatureType);
        const encodedPayload = objects_1.objects.requireNonNil(tx.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
        return tx_1.Txn.copy(tx, (newTx) => {
          newTx.signature = {
            // bytes must be base64 encoded for transport over GRPC
            sig: (0, base64_1.bytesToBase64)(signedMessage),
            type: signatureType.toString()
          };
          newTx.body = {
            desc: description,
            payload: (0, base64_1.bytesToBase64)(encodedPayload),
            type: newTx.body.type,
            fee: newTx.body.fee?.toString() || "",
            nonce: newTx.body.nonce,
            chain_id: newTx.body.chain_id
          };
          newTx.sender = (0, serial_1.bytesToHex)(identifier);
          newTx.serialization = enums_1.SerializationType.SIGNED_MSG_CONCAT;
        });
      }
      encodePayload(payloadType, payload) {
        switch (payloadType) {
          case enums_1.PayloadType.EXECUTE_ACTION:
            if (!("action" in payload && "arguments" in payload)) {
              throw new Error("Invalid payload type for EXECUTE_ACTION");
            }
            return (0, kwilEncoding_1.encodeActionExecution)(payload);
          case enums_1.PayloadType.TRANSFER:
            if (!("to" in payload && "amount" in payload)) {
              throw new Error("Invalid payload type for TRANSFER");
            }
            return (0, kwilEncoding_1.encodeTransfer)(payload);
          case enums_1.PayloadType.RAW_STATEMENT:
            if (!("statement" in payload && "parameters" in payload)) {
              throw new Error("Invalid payload type for RAW_STATEMENT");
            }
            return (0, kwilEncoding_1.encodeRawStatement)(payload);
          default:
            throw new Error(`Unsupported payload type: ${payloadType}`);
        }
      }
    };
    exports.PayloadTx = PayloadTx;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/funder/funder.js
var require_funder = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/funder/funder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Funder = void 0;
    var enums_1 = require_enums();
    var payloadTx_1 = require_payloadTx();
    var serial_1 = require_serial();
    var Funder = class {
      constructor(kwil, funderClient, chainId) {
        this.kwil = kwil;
        this.funderClient = funderClient;
        this.chainId = chainId;
      }
      async transfer(payload, signer, synchronous) {
        if (!payload.keyType) {
          payload.keyType = enums_1.AccountKeyType.SECP256K1;
        }
        if (payload.to instanceof Uint8Array) {
          payload.to = (0, serial_1.bytesToHex)(payload.to);
        }
        const txPayload = {
          to: {
            identifier: payload.to,
            key_type: payload.keyType
          },
          amount: payload.amount.toString()
        };
        const transaction = await payloadTx_1.PayloadTx.createTx(this.kwil, {
          chainId: this.chainId,
          description: payload.description || "",
          payload: txPayload,
          payloadType: enums_1.PayloadType.TRANSFER,
          identifier: signer.identifier,
          signer: signer.signer,
          signatureType: signer.signatureType
        }).buildTx();
        return await this.funderClient.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
      }
    };
    exports.Funder = Funder;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyAuthProperties = exports.removeTrailingSlash = exports.generateSignatureText = exports.composeAuthMsg = void 0;
    function composeAuthMsg(authParam, domain, version2, chainId) {
      let msg = "";
      msg += `${domain} wants you to sign in with your account:
`;
      msg += `
`;
      if (authParam.statement !== "") {
        msg += `${authParam.statement}
`;
      }
      msg += "\n";
      msg += `URI: ${authParam.uri}
`;
      msg += `Version: ${version2}
`;
      msg += `Chain ID: ${chainId}
`;
      msg += `Nonce: ${authParam.nonce}
`;
      msg += `Issue At: ${authParam.issue_at}
`;
      msg += `Expiration Time: ${authParam.expiration_time}
`;
      return msg;
    }
    exports.composeAuthMsg = composeAuthMsg;
    function generateSignatureText(namespace, action, digest, challenge) {
      let sigText = "Kwil view call.\n";
      sigText += "\n";
      sigText += `Namespace: ${namespace}
`;
      sigText += `Method: ${action}
`;
      sigText += `Digest: ${digest}
`;
      sigText += `Challenge: ${challenge}
`;
      return sigText;
    }
    exports.generateSignatureText = generateSignatureText;
    function removeTrailingSlash(url) {
      if (url.endsWith("/")) {
        return url.slice(0, -1);
      }
      return url;
    }
    exports.removeTrailingSlash = removeTrailingSlash;
    function verifyAuthProperties(authParm, domain, version2, chainId) {
      if (authParm.domain && authParm.domain !== domain) {
        throw new Error(`Domain mismatch: ${authParm.domain} !== ${domain}`);
      }
      if (authParm.version && authParm.version !== version2) {
        throw new Error(`Version mismatch: ${authParm.version} !== ${version2}`);
      }
      if (authParm.chain_id && authParm.chain_id !== chainId) {
        throw new Error(`Chain ID mismatch: ${authParm.chain_id} !== ${chainId}`);
      }
    }
    exports.verifyAuthProperties = verifyAuthProperties;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/parameterEncoding.js
var require_parameterEncoding = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/parameterEncoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveValueType = exports.analyzeNumber = exports.encodeValueType = exports.encodeRawStatementParameters = exports.encodeParameters = void 0;
    var enums_1 = require_enums();
    var base64_1 = require_base64();
    var kwilEncoding_1 = require_kwilEncoding();
    var uuid_1 = require_uuid();
    function encodeParameters(params) {
      const encodedParams = {};
      Object.entries(params).forEach(([key, value]) => {
        encodedParams[key] = formatEncodedValueBase64(value);
      });
      return encodedParams;
    }
    exports.encodeParameters = encodeParameters;
    function formatEncodedValueBase64(val) {
      const base2 = formatDataType(val);
      if (Array.isArray(val)) {
        const encodedValues = [];
        for (const v of val) {
          encodedValues.push((0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(v)));
        }
        return {
          type: base2.type,
          data: encodedValues
        };
      }
      return {
        type: base2.type,
        data: [(0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(base2.data))]
      };
    }
    function encodeRawStatementParameters(params) {
      return Object.entries(params).map(([key, value]) => {
        const encodedValue = formatEncodedValue(value);
        return {
          name: key,
          value: encodedValue
        };
      });
    }
    exports.encodeRawStatementParameters = encodeRawStatementParameters;
    function formatEncodedValue(val, o) {
      const base2 = formatDataType(val, o);
      if (Array.isArray(val)) {
        const encodedValues = [];
        for (const v of val) {
          encodedValues.push((0, kwilEncoding_1.encodeValue)(v, o?.name));
        }
        return {
          type: base2.type,
          data: encodedValues
        };
      }
      return {
        type: base2.type,
        data: [(0, kwilEncoding_1.encodeValue)(base2.data, o?.name)]
      };
    }
    function encodeValueType(values) {
      return values.map((val) => formatEncodedValue(val.v, val.o));
    }
    exports.encodeValueType = encodeValueType;
    function formatDataType(val, o) {
      if (o) {
        return {
          type: o,
          data: val
        };
      }
      const { metadata, varType } = resolveValueType(val);
      const dataType = {
        name: varType,
        is_array: Array.isArray(val),
        metadata
      };
      return { type: dataType, data: val };
    }
    function analyzeNumber(num) {
      const numStr = Math.abs(num).toString();
      const decimalIndex = numStr.indexOf(".");
      const hasDecimal = decimalIndex !== -1;
      const precision = hasDecimal ? numStr.length - 1 : numStr.length;
      const scale = hasDecimal ? numStr.length - decimalIndex - 1 : 0;
      return {
        hasDecimal,
        precision,
        scale
      };
    }
    exports.analyzeNumber = analyzeNumber;
    function resolveValueType(value) {
      if (Array.isArray(value)) {
        return resolveValueType(value[0]);
      }
      let metadata = [0, 0];
      let varType = enums_1.VarType.TEXT;
      switch (typeof value) {
        case "string":
          if ((0, uuid_1.isUuid)(value)) {
            varType = enums_1.VarType.UUID;
          }
          break;
        case "number":
          const numAnalysis = analyzeNumber(value);
          return {
            metadata: [numAnalysis.precision, numAnalysis.scale],
            varType: numAnalysis.hasDecimal ? enums_1.VarType.NUMERIC : enums_1.VarType.INT8
          };
        case "boolean":
          varType = enums_1.VarType.BOOL;
          break;
        case "object":
          if (value instanceof Uint8Array) {
            varType = enums_1.VarType.BYTEA;
            break;
          }
          if (value === null) {
            varType = enums_1.VarType.NULL;
            break;
          }
        case "undefined":
          varType = enums_1.VarType.NULL;
          break;
        default:
          throw new Error(`Unsupported type: ${typeof value}. If using a uuid, blob, or uint256, please convert to a JavaScript string.`);
      }
      return {
        metadata,
        varType
      };
    }
    exports.resolveValueType = resolveValueType;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/auth/auth.js
var require_auth2 = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/auth/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = void 0;
    var auth_1 = require_auth();
    var objects_1 = require_objects();
    var signature_1 = require_signature();
    var serial_1 = require_serial();
    var base64_1 = require_base64();
    var action_1 = require_action();
    var crypto_1 = require_crypto();
    var kwilEncoding_1 = require_kwilEncoding();
    var parameterEncoding_1 = require_parameterEncoding();
    var Auth = class {
      constructor(authClient, kwilProvider, chainId) {
        this.authClient = authClient;
        this.kwilProvider = kwilProvider;
        this.chainId = chainId;
      }
      /**
       * Authenticates a user with the Kwil Gateway (KGW). This is required to execute view actions with the `@kgw(authn='true')` annotation.
       *
       * This method should only be used if your Kwil Network is using the Kwil Gateway.
       *
       * @param {KwilSigner} signer - The signer for the authentication.
       * @returns A promise that resolves to the authentication success or failure.
       */
      async authenticateKGW(signer) {
        const authParam = await this.authClient.getAuthenticateClient();
        const authProperties = objects_1.objects.requireNonNil(authParam.data, "something went wrong retrieving auth info from KGW");
        const domain = (0, auth_1.removeTrailingSlash)(this.kwilProvider);
        const version2 = "1";
        (0, auth_1.verifyAuthProperties)(authProperties, domain, version2, this.chainId);
        const msg = (0, auth_1.composeAuthMsg)(authProperties, domain, version2, this.chainId);
        const signature = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(msg), signer.signer, signer.signatureType);
        const authBody = {
          nonce: authProperties.nonce,
          sender: (0, serial_1.bytesToHex)(signer.identifier),
          signature: {
            sig: (0, base64_1.bytesToBase64)(signature),
            type: signer.signatureType
          }
        };
        const res = await this.authClient.postAuthenticateClient(authBody);
        return res;
      }
      /**
       * Authenticates a user in private mode.
       *
       * This method should only be used if your Kwil Network is in private mode.
       *
       * @param {KwilSigner} signer - The signer for the authentication.
       * @param {CallBody} callBody - The body of the action to send. This should use the `ActionBody` interface.
       * @returns A promise that resolves a privateSignature => privateSignature = {sig: string (Base64), type: AnySignatureType}
       */
      async authenticatePrivateMode(callBody, signer) {
        const challenge = await this.authClient.challengeClient();
        let msgChallenge = challenge.data;
        if (!msgChallenge) {
          throw new Error("Challenge data is undefined. Something went wrong.");
        }
        let inputs = {};
        if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
          inputs = action_1.transformActionInput.toSingleEntry(callBody.inputs);
        } else if (callBody.inputs && action_1.transformPositionalParam.isPositionalParam(callBody.inputs)) {
          inputs = action_1.transformPositionalParam.toNamedParam(callBody.inputs);
        } else if (callBody.inputs) {
          inputs = callBody.inputs;
        }
        const actionValues = callBody?.inputs ? Object.values(inputs) : [];
        const value = (0, action_1.resolveParamTypes)(actionValues, callBody?.types);
        const payload = {
          dbid: callBody.namespace,
          action: callBody.name,
          arguments: (0, parameterEncoding_1.encodeValueType)(value)
        };
        const encodedPayload = (0, kwilEncoding_1.encodeActionCall)(payload);
        const uInt8ArrayPayload = (0, base64_1.base64ToBytes)(encodedPayload);
        const digest = (0, crypto_1.sha256BytesToBytes)(uInt8ArrayPayload).subarray(0, 20);
        const msg = (0, auth_1.generateSignatureText)(callBody.namespace, callBody.name, (0, serial_1.bytesToHex)(digest), msgChallenge);
        const signature = await (0, signature_1.executeSign)((0, serial_1.stringToBytes)(msg), signer.signer, signer.signatureType);
        const sig = (0, base64_1.bytesToBase64)(signature);
        const byteChallenge = (0, serial_1.hexToBytes)(msgChallenge);
        const base64Challenge = (0, base64_1.bytesToBase64)(byteChallenge);
        const res = {
          signature: sig,
          challenge: base64Challenge
        };
        return res;
      }
      async logoutKGW(signer) {
        const identifier = signer?.identifier || void 0;
        return await this.authClient.logoutClient(identifier);
      }
    };
    exports.Auth = Auth;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/message.js
var require_message = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Msg = exports.BaseMessage = void 0;
    var signature_1 = require_signature();
    var BaseMessage = class {
      constructor(data) {
        this.data = data || {
          body: {
            payload: null,
            challenge: ""
          },
          auth_type: signature_1.SignatureType.SECP256K1_PERSONAL,
          sender: null,
          signature: null
        };
      }
      get body() {
        return this.data.body;
      }
      get auth_type() {
        return this.data.auth_type;
      }
      get sender() {
        return this.data.sender;
      }
      get signature() {
        return this.data.signature;
      }
    };
    exports.BaseMessage = BaseMessage;
    var Msg;
    (function(Msg2) {
      function create(configure) {
        const msg = {
          body: {
            payload: null,
            challenge: ""
          },
          auth_type: signature_1.SignatureType.SECP256K1_PERSONAL,
          sender: null,
          signature: null
        };
        configure(msg);
        return new BaseMessage(msg);
      }
      Msg2.create = create;
      function copy(source, configure) {
        return Msg2.create((msg) => {
          msg.body = source.body;
          msg.auth_type = source.auth_type;
          msg.sender = source.sender;
          msg.signature = source.signature;
          configure(msg);
        });
      }
      Msg2.copy = copy;
    })(Msg = exports.Msg || (exports.Msg = {}));
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/message/payloadMsg.js
var require_payloadMsg = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/message/payloadMsg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PayloadMsg = void 0;
    var message_1 = require_message();
    var objects_1 = require_objects();
    var serial_1 = require_serial();
    var kwilEncoding_1 = require_kwilEncoding();
    var PayloadMsg = class _PayloadMsg {
      /**
       * Initializes a new `PayloadMsg` instance.
       *
       * @param {PayloadMsgOptions} options - Parameters interface to build a payload message.
       */
      constructor(payload, options) {
        this.payload = objects_1.objects.requireNonNil(payload, "Payload is required for Payload Msg Builder. Please pass a valid payload.");
        objects_1.objects.validateOptionalFields(options, [
          "signature",
          "challenge",
          "signer",
          "identifier",
          "signatureType"
        ]);
        this.signature = options.signature;
        this.challenge = options.challenge;
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
      }
      /**
       * Static factory method to create a new Payload instance.
       *
       * @param kwil - The Kwil client.
       * @param options - The options to configure the Payload instance.
       */
      static createMsg(payload, options) {
        return new _PayloadMsg(payload, options);
      }
      /**
       * Build the payload structure for a message.
       */
      async buildMsg() {
        let msg = message_1.Msg.create((msg2) => {
          msg2.body.payload = this.payload;
          msg2.body.challenge = this.challenge;
          msg2.signature = this.signature;
        });
        if (this.signer) {
          const { identifier, signatureType } = objects_1.objects.validateFields({
            identifier: this.identifier,
            signatureType: this.signatureType
          }, (fieldName) => `${fieldName} required to build a message.`);
          if (identifier) {
            return await _PayloadMsg.authMsg(msg, identifier, signatureType);
          }
        }
        return message_1.Msg.copy(msg, (msg2) => {
          msg2.body.payload = (0, kwilEncoding_1.encodeActionCall)(this.payload);
        });
      }
      /**
       * Adds the caller's sender address to the message.
       *
       * @param {Message} msg - The message to sign. See {@link Message} for more information.
       * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
       * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
       * @param {string} description - The description to be included in the signature.
       * @returns Message - A promise that resolves to the signed message.
       * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
       */
      static async authMsg(msg, identifier, signatureType) {
        const unencodedPayload = objects_1.objects.requireNonNil(msg.body.payload, "Payload is required to sign a message. This is likely an internal error. Please create an issue.");
        return message_1.Msg.copy(msg, (msg2) => {
          msg2.body.payload = (0, kwilEncoding_1.encodeActionCall)(unencodedPayload);
          msg2.auth_type = signatureType;
          msg2.sender = (0, serial_1.bytesToHex)(identifier);
        });
      }
    };
    exports.PayloadMsg = PayloadMsg;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/transaction/action.js
var require_action2 = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/transaction/action.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    var action_1 = require_action();
    var enums_1 = require_enums();
    var payloadTx_1 = require_payloadTx();
    var payloadMsg_1 = require_payloadMsg();
    var objects_1 = require_objects();
    var parameterEncoding_1 = require_parameterEncoding();
    var TXN_BUILD_IN_PROGRESS = [];
    var Action = class _Action {
      /**
       * Initializes a new `Action` instance.
       * It helps in building transactions to execute database actions on the Kwil network.
       *
       * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
       */
      constructor(kwil, options) {
        this.kwil = objects_1.objects.requireNonNil(kwil, "Client is required for Action Builder. Please pass a valid Kwil Client.");
        objects_1.objects.validateRequiredFields(options, [
          "actionName",
          "namespace",
          "chainId",
          "description",
          "actionInputs"
        ]);
        this.actionName = options.actionName;
        this.namespace = options.namespace;
        this.chainId = options.chainId;
        this.description = options.description;
        this.actionInputs = options.actionInputs;
        objects_1.objects.validateOptionalFields(options, [
          "signer",
          "identifier",
          "actionInputs",
          "signatureType",
          "nonce",
          "types"
        ]);
        this.signer = options.signer;
        this.identifier = options.identifier;
        this.signatureType = options.signatureType;
        this.nonce = options.nonce;
        this.challenge = options.challenge;
        this.signature = options.signature;
        this.types = options.types;
      }
      /**
       * Static factory method to create a new Action instance.
       *
       * @param kwil - The Kwil client.
       * @param options - The options to configure the Action instance.
       */
      static createTx(kwil, options) {
        return new _Action(kwil, options);
      }
      /**
       * Build the action structure for a transaction.
       */
      async buildTx(privateMode) {
        this.assertNotBuilding();
        const cachedActionInputs = this.actionInputs;
        this.actionInputs = TXN_BUILD_IN_PROGRESS;
        const payload = await this.buildTxPayload(privateMode, cachedActionInputs);
        const { signer, identifier, signatureType } = objects_1.objects.validateFields({
          signer: this.signer,
          identifier: this.identifier,
          signatureType: this.signatureType
        }, (fieldName) => `${fieldName} is required to build a transaction.`);
        return await payloadTx_1.PayloadTx.createTx(this.kwil, {
          payloadType: enums_1.PayloadType.EXECUTE_ACTION,
          payload,
          signer,
          signatureType,
          description: this.description,
          chainId: this.chainId,
          identifier,
          nonce: this.nonce
        }).buildTx().finally(() => this.actionInputs = cachedActionInputs);
      }
      /**
       * Builds the message structure for view actions. This can be provided to the `kwil.call()` api.
       */
      async buildMsg(privateMode) {
        this.assertNotBuilding();
        const cachedActionInputs = this.actionInputs;
        this.actionInputs = TXN_BUILD_IN_PROGRESS;
        const payload = await this.buildMsgPayload(privateMode, cachedActionInputs);
        let msg = payloadMsg_1.PayloadMsg.createMsg(payload, {
          challenge: this.challenge,
          signature: this.signature
        });
        if (this.signer) {
          msg.signer = this.signer;
          msg.signatureType = this.signatureType;
          msg.identifier = this.identifier;
        }
        return await msg.buildMsg().finally(() => this.actionInputs = cachedActionInputs);
      }
      /**
       * Builds the payload for the execute action.
       *
       * @param {boolean} privateMode - Whether the action is being executed in private mode.
       * @param {ActionInput[]} actionInputs - The inputs for the action.
       * @returns {UnencodedActionPayload<PayloadType.EXECUTE_ACTION>} - The payload for the execute action.
       */
      async buildTxPayload(privateMode, actionInputs) {
        const payload = {
          dbid: this.namespace,
          action: this.actionName,
          arguments: []
        };
        if (privateMode) {
          for (const actionInput of actionInputs) {
            const value = (0, action_1.resolveParamTypes)(actionInput, this.types);
            payload.arguments.push((0, parameterEncoding_1.encodeValueType)(value));
          }
          return payload;
        }
        const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
        if (modifiers.length > 0 && modifiers.includes(enums_1.AccessModifier.VIEW)) {
          throw new Error(`Action / Procedure ${actionName} is a 'view' action. Please use kwil.call().`);
        }
        payload.arguments = encodedActionInputs;
        return payload;
      }
      /**
       * Builds the payload for the call action.
       *
       * @param {boolean} privateMode - Whether the action is being executed in private mode.
       * @param {ActionInput[]} actionInputs - The inputs for the action.
       * @returns {UnencodedActionPayload<PayloadType.CALL_ACTION>} - The payload for the call action.
       */
      async buildMsgPayload(privateMode, actionInputs) {
        const payload = {
          dbid: this.namespace,
          action: this.actionName,
          arguments: []
        };
        if (privateMode) {
          const actionValues = actionInputs.length > 0 ? Object.values(actionInputs[0]) : [];
          const value = (0, action_1.resolveParamTypes)(actionValues, this.types);
          payload.arguments = (0, parameterEncoding_1.encodeValueType)(value);
          return payload;
        }
        const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
        if (encodedActionInputs && encodedActionInputs.length > 1) {
          throw new Error("Cannot pass more than one input to the call endpoint. Please pass only one input and try again.");
        }
        if (modifiers.length > 0 && modifiers.includes(enums_1.AccessModifier.VIEW) === false) {
          throw new Error(`Action ${actionName} is not a view only action. Please use kwil.execute().`);
        }
        payload.arguments = encodedActionInputs[0];
        return payload;
      }
      /**
       * Checks the action definition and validates the action inputs
       *
       * @param {ActionInput[]} actionInputs - An array of action inputs to be executed.
       * @returns {ValidatedAction} - An object containing the database namespace, action name, modifiers, and encoded action inputs.
       */
      async validatedActionRequest(actionInputs) {
        if ((0, action_1.isNamedParams)(actionInputs)) {
          const namespaceRequest = await this.kwil.getActions(this.namespace);
          if (namespaceRequest.status !== 200) {
            throw new Error(`Failed to retrieve actions for namespace ${this.namespace}. Status: ${namespaceRequest.status}`);
          }
          if (!namespaceRequest.data || namespaceRequest.data.length === 0) {
            throw new Error(`No actions found for the namespace '${this.namespace}'. Please verify the namespace exists and contains the '${this.actionName}' action.`);
          }
          const namespaceActions = namespaceRequest.data;
          const selectedAction = namespaceActions.find((a) => a.name === this.actionName);
          if (!selectedAction) {
            throw new Error(`Action '${this.actionName}' not found in namespace '${this.namespace}'.`);
          }
          if (!selectedAction.access_modifiers.includes(enums_1.AccessModifier.PUBLIC)) {
            throw new Error(`Action '${this.actionName}' is not a public action.`);
          }
          if (actionInputs) {
            for (const actionInput of actionInputs) {
              if (!this.validateActionInputs(selectedAction, actionInput)) {
                throw new Error(`Action inputs are invalid for action: ${selectedAction.name}.`);
              }
            }
          }
          const encodedActionInputs = [];
          for (const actionInput of actionInputs) {
            const value = (0, action_1.resolveParamTypes)(actionInput, this.types);
            encodedActionInputs.push((0, parameterEncoding_1.encodeValueType)(value));
          }
          return {
            actionName: selectedAction.name,
            modifiers: selectedAction.access_modifiers,
            encodedActionInputs
          };
        }
        let encValue = [];
        if (actionInputs.length > 0) {
          for (const a of actionInputs) {
            const value = (0, action_1.resolveParamTypes)(a, this.types);
            encValue.push((0, parameterEncoding_1.encodeValueType)(value));
          }
        }
        return {
          actionName: this.actionName,
          modifiers: [],
          encodedActionInputs: encValue
        };
      }
      /**
       * Validates that the action is not missing any inputs.
       *
       * @param {NamespaceAction} selectedAction - The schema of the action to be executed.
       * @param {ActionInput} actionInput - The values of the actions to be executed.
       * @returns {boolean} - True if the action inputs are valid, false otherwise.
       */
      validateActionInputs(selectedAction, actionInputEntries) {
        const actionInputKeys = Object.keys(actionInputEntries);
        if (!selectedAction.parameter_names || selectedAction.parameter_names.length === 0) {
          if (actionInputKeys.length !== 0) {
            throw new Error(`No parameters found for action: ${this.actionName}.`);
          }
          return true;
        }
        if (actionInputKeys.every((key) => key.startsWith("$pstn_"))) {
          return true;
        }
        const incorrectParameters = actionInputKeys.filter((key) => !selectedAction.parameter_names.includes(key));
        if (incorrectParameters.length > 0) {
          throw new Error(`Incorrect parameters: ${incorrectParameters.join(", ")} for action '${selectedAction.name}'`);
        }
        return true;
      }
      assertNotBuilding() {
        if (this.actionInputs === TXN_BUILD_IN_PROGRESS) {
          throw new Error("Cannot modify the builder while a transaction is being built.");
        }
      }
    };
    exports.Action = Action;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/dbid.js
var require_dbid = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/dbid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateDBID = void 0;
    var bytes_1 = require_bytes();
    var crypto_1 = require_crypto();
    var serial_1 = require_serial();
    function generateDBID(owner, name) {
      if (typeof owner === "string") {
        owner = (0, serial_1.hexToBytes)(owner);
      }
      return "x" + (0, crypto_1.sha224BytesToString)((0, bytes_1.concatBytes)((0, serial_1.stringToBytes)(name.toLowerCase()), owner));
    }
    exports.generateDBID = generateDBID;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/namespace.js
var require_namespace = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/namespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveNamespace = exports.validateNamespace = void 0;
    var validateNamespace = (namespace) => {
      if (!namespace || typeof namespace !== "string") {
        return false;
      }
      if (/[';{}\\]/.test(namespace)) {
        return false;
      }
      if (!/^[a-zA-Z0-9_]+$/.test(namespace)) {
        return false;
      }
      return true;
    };
    exports.validateNamespace = validateNamespace;
    var resolveNamespace = (actionBody) => {
      if (actionBody.namespace) {
        return actionBody.namespace;
      }
      if (actionBody.dbid) {
        console.warn('Warning: The "dbid" field is deprecated. Please use "namespace" instead.');
        return actionBody.dbid;
      }
      throw new Error('Either "namespace" or "dbid" must be provided');
    };
    exports.resolveNamespace = resolveNamespace;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/utils/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inferKeyType = void 0;
    var serial_1 = require_serial();
    var enums_1 = require_enums();
    function inferKeyType(owner) {
      if (typeof owner === "string") {
        owner = (0, serial_1.hexToBytes)(owner);
      }
      if (owner.length === 32 || isXrplKey(owner) || isStellarAddress(owner)) {
        return enums_1.AccountKeyType.ED25519;
      }
      if (owner.length === 20) {
        return enums_1.AccountKeyType.SECP256K1;
      }
      throw new Error("Cannot determine key type from owner.");
    }
    exports.inferKeyType = inferKeyType;
    function isXrplKey(key) {
      return key.length === 33 && (0, serial_1.bytesToHex)(key).slice(0, 2) === "ed";
    }
    function isStellarAddress(addr) {
      const address = new TextDecoder("utf-8").decode(new Uint8Array(addr));
      return /^G[A-Z0-9]{55}$/.test(address);
    }
  }
});

// node_modules/.pnpm/lru-cache@11.1.0/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/.pnpm/lru-cache@11.1.0/node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class _Stack {
      constructor(max, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s = new _Stack(max, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    _constructing = new WeakMap();
    // private constructor
    __privateAdd(_Stack, _constructing, false);
    var Stack = _Stack;
    var _a4, _b, _max, _maxSize2, _dispose, _onInsert, _disposeAfter, _fetchMethod, _memoMethod, _size2, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _hasOnInsert, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
    var _LRUCache = class _LRUCache {
      constructor(options) {
        __privateAdd(this, _LRUCache_instances);
        // options that cannot be changed without disaster
        __privateAdd(this, _max);
        __privateAdd(this, _maxSize2);
        __privateAdd(this, _dispose);
        __privateAdd(this, _onInsert);
        __privateAdd(this, _disposeAfter);
        __privateAdd(this, _fetchMethod);
        __privateAdd(this, _memoMethod);
        /**
         * {@link LRUCache.OptionsBase.ttl}
         */
        __publicField(this, "ttl");
        /**
         * {@link LRUCache.OptionsBase.ttlResolution}
         */
        __publicField(this, "ttlResolution");
        /**
         * {@link LRUCache.OptionsBase.ttlAutopurge}
         */
        __publicField(this, "ttlAutopurge");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnGet}
         */
        __publicField(this, "updateAgeOnGet");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnHas}
         */
        __publicField(this, "updateAgeOnHas");
        /**
         * {@link LRUCache.OptionsBase.allowStale}
         */
        __publicField(this, "allowStale");
        /**
         * {@link LRUCache.OptionsBase.noDisposeOnSet}
         */
        __publicField(this, "noDisposeOnSet");
        /**
         * {@link LRUCache.OptionsBase.noUpdateTTL}
         */
        __publicField(this, "noUpdateTTL");
        /**
         * {@link LRUCache.OptionsBase.maxEntrySize}
         */
        __publicField(this, "maxEntrySize");
        /**
         * {@link LRUCache.OptionsBase.sizeCalculation}
         */
        __publicField(this, "sizeCalculation");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
         */
        __publicField(this, "noDeleteOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
         */
        __publicField(this, "noDeleteOnStaleGet");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
         */
        __publicField(this, "allowStaleOnFetchAbort");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
         */
        __publicField(this, "allowStaleOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.ignoreFetchAbort}
         */
        __publicField(this, "ignoreFetchAbort");
        // computed properties
        __privateAdd(this, _size2);
        __privateAdd(this, _calculatedSize);
        __privateAdd(this, _keyMap);
        __privateAdd(this, _keyList);
        __privateAdd(this, _valList);
        __privateAdd(this, _next);
        __privateAdd(this, _prev);
        __privateAdd(this, _head);
        __privateAdd(this, _tail);
        __privateAdd(this, _free);
        __privateAdd(this, _disposed);
        __privateAdd(this, _sizes);
        __privateAdd(this, _starts);
        __privateAdd(this, _ttls);
        __privateAdd(this, _hasDispose);
        __privateAdd(this, _hasFetchMethod);
        __privateAdd(this, _hasDisposeAfter);
        __privateAdd(this, _hasOnInsert);
        // conditionally set private methods related to TTL
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        /* c8 ignore stop */
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        /**
         * A String value that is used in the creation of the default string
         * description of an object. Called by the built-in method
         * `Object.prototype.toString`.
         */
        __publicField(this, _a4, "LRUCache");
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        __privateSet(this, _max, max);
        __privateSet(this, _maxSize2, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize2);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize2) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        __privateSet(this, _memoMethod, memoMethod);
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max).fill(void 0));
        __privateSet(this, _valList, new Array(max).fill(void 0));
        __privateSet(this, _next, new UintArray(max));
        __privateSet(this, _prev, new UintArray(max));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max));
        __privateSet(this, _size2, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof onInsert === "function") {
          __privateSet(this, _onInsert, onInsert);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasOnInsert, !!__privateGet(this, _onInsert));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize2) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize2))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize2) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize2)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: __privateGet(c, _starts),
          ttls: __privateGet(c, _ttls),
          sizes: __privateGet(c, _sizes),
          keyMap: __privateGet(c, _keyMap),
          keyList: __privateGet(c, _keyList),
          valList: __privateGet(c, _valList),
          next: __privateGet(c, _next),
          prev: __privateGet(c, _prev),
          get head() {
            return __privateGet(c, _head);
          },
          get tail() {
            return __privateGet(c, _tail);
          },
          free: __privateGet(c, _free),
          // methods
          isBackgroundFetch: (p) => {
            var _a5;
            return __privateMethod(_a5 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a5, p);
          },
          backgroundFetch: (k, index, options, context) => {
            var _a5;
            return __privateMethod(_a5 = c, _LRUCache_instances, backgroundFetch_fn).call(_a5, k, index, options, context);
          },
          moveToTail: (index) => {
            var _a5;
            return __privateMethod(_a5 = c, _LRUCache_instances, moveToTail_fn).call(_a5, index);
          },
          indexes: (options) => {
            var _a5;
            return __privateMethod(_a5 = c, _LRUCache_instances, indexes_fn).call(_a5, options);
          },
          rindexes: (options) => {
            var _a5;
            return __privateMethod(_a5 = c, _LRUCache_instances, rindexes_fn).call(_a5, options);
          },
          isStale: (index) => {
            var _a5;
            return __privateGet(_a5 = c, _isStale).call(_a5, index);
          }
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return __privateGet(this, _max);
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return __privateGet(this, _maxSize2);
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return __privateGet(this, _size2);
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      get memoMethod() {
        return __privateGet(this, _memoMethod);
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return __privateGet(this, _dispose);
      }
      /**
       * {@link LRUCache.OptionsBase.onInsert} (read-only)
       */
      get onInsert() {
        return __privateGet(this, _onInsert);
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [(_b = Symbol.iterator, _a4 = Symbol.toStringTag, _b)]() {
        return this.entries();
      }
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, __privateGet(this, _keyList)[i], this)) {
            return this.get(__privateGet(this, _keyList)[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i)) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = __privateGet(this, _keyMap).get(key);
        if (i === void 0)
          return void 0;
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          const ttl = __privateGet(this, _ttls)[i];
          const start = __privateGet(this, _starts)[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
          const key = __privateGet(this, _keyList)[i];
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i];
            const age = perf.now() - __privateGet(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        var _a5, _b2, _c, _d;
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
          return this;
        }
        let index = __privateGet(this, _size2) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          index = __privateGet(this, _size2) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size2) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size2);
          __privateGet(this, _keyList)[index] = k;
          __privateGet(this, _valList)[index] = v;
          __privateGet(this, _keyMap).set(k, index);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index;
          __privateGet(this, _prev)[index] = __privateGet(this, _tail);
          __privateSet(this, _tail, index);
          __privateWrapper(this, _size2)._++;
          __privateGet(this, _addItemSize).call(this, index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
          if (__privateGet(this, _hasOnInsert)) {
            (_a5 = __privateGet(this, _onInsert)) == null ? void 0 : _a5.call(this, v, k, "add");
          }
        } else {
          __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          const oldVal = __privateGet(this, _valList)[index];
          if (v !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (__privateGet(this, _hasDispose)) {
                  (_b2 = __privateGet(this, _dispose)) == null ? void 0 : _b2.call(this, s, k, "set");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  __privateGet(this, _disposed)?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([oldVal, k, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index);
            __privateGet(this, _addItemSize).call(this, index, size, status);
            __privateGet(this, _valList)[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
          if (__privateGet(this, _hasOnInsert)) {
            this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        var _a5;
        try {
          while (__privateGet(this, _size2)) {
            const val = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt?.shift()) {
              (_a5 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a5.call(this, ...task);
            }
          }
        }
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
          return;
        }
        const v = __privateGet(this, _valList)[index];
        return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          return p.__returned = p;
        } else {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = __privateGet(this, _isStale).call(this, index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index);
            return v;
          }
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = __privateGet(this, _memoMethod);
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const value = __privateGet(this, _valList)[index];
          const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
          if (__privateGet(this, _isStale).call(this, index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
      }
    };
    _max = new WeakMap();
    _maxSize2 = new WeakMap();
    _dispose = new WeakMap();
    _onInsert = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _memoMethod = new WeakMap();
    _size2 = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _hasOnInsert = new WeakMap();
    _LRUCache_instances = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index)) {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = __privateGet(this, _keyMap).get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      __privateSet(this, _isStale, (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
      });
      __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      __privateSet(this, _addItemSize, (index, size, status) => {
        sizes[index] = size;
        if (__privateGet(this, _maxSize2)) {
          const maxSize = __privateGet(this, _maxSize2) - sizes[index];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size2)) {
        for (let i = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _head)) {
            break;
          } else {
            i = __privateGet(this, _prev)[i];
          }
        }
      }
    };
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size2)) {
        for (let i = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _tail)) {
            break;
          } else {
            i = __privateGet(this, _next)[i];
          }
        }
      }
    };
    isValidIndex_fn = function(index) {
      return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
    };
    evict_fn = function(free) {
      var _a5;
      const head = __privateGet(this, _head);
      const k = __privateGet(this, _keyList)[head];
      const v = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v, k, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size2) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k);
      __privateWrapper(this, _size2)._--;
      return head;
    };
    backgroundFetch_fn = function(k, index, options, context) {
      const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted: aborted2 } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted2 && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted2 && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
            } else {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted: aborted2 } = ac.signal;
        const allowStaleAborted = aborted2 && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a5;
        const fmp = (_a5 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a5.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = __privateGet(this, _keyMap).get(k);
      } else {
        __privateGet(this, _valList)[index] = bf;
      }
      return bf;
    };
    isBackgroundFetch_fn = function(p) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    connect_fn = function(p, n) {
      __privateGet(this, _prev)[n] = p;
      __privateGet(this, _next)[p] = n;
    };
    moveToTail_fn = function(index) {
      if (index !== __privateGet(this, _tail)) {
        if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
        }
        __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
        __privateSet(this, _tail, index);
      }
    };
    delete_fn = function(k, reason) {
      var _a5, _b2;
      let deleted = false;
      if (__privateGet(this, _size2) !== 0) {
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          deleted = true;
          if (__privateGet(this, _size2) === 1) {
            __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
          } else {
            __privateGet(this, _removeItemSize).call(this, index);
            const v = __privateGet(this, _valList)[index];
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
              if (__privateGet(this, _hasDispose)) {
                (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, reason);
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([v, k, reason]);
              }
            }
            __privateGet(this, _keyMap).delete(k);
            __privateGet(this, _keyList)[index] = void 0;
            __privateGet(this, _valList)[index] = void 0;
            if (index === __privateGet(this, _tail)) {
              __privateSet(this, _tail, __privateGet(this, _prev)[index]);
            } else if (index === __privateGet(this, _head)) {
              __privateSet(this, _head, __privateGet(this, _next)[index]);
            } else {
              const pi = __privateGet(this, _prev)[index];
              __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
              const ni = __privateGet(this, _next)[index];
              __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
            }
            __privateWrapper(this, _size2)._--;
            __privateGet(this, _free).push(index);
          }
        }
      }
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
        }
      }
      return deleted;
    };
    clear_fn = function(reason) {
      var _a5, _b2;
      for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = __privateGet(this, _keyList)[index];
          if (__privateGet(this, _hasDispose)) {
            (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            __privateGet(this, _disposed)?.push([v, k, reason]);
          }
        }
      }
      __privateGet(this, _keyMap).clear();
      __privateGet(this, _valList).fill(void 0);
      __privateGet(this, _keyList).fill(void 0);
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        __privateGet(this, _ttls).fill(0);
        __privateGet(this, _starts).fill(0);
      }
      if (__privateGet(this, _sizes)) {
        __privateGet(this, _sizes).fill(0);
      }
      __privateSet(this, _head, 0);
      __privateSet(this, _tail, 0);
      __privateGet(this, _free).length = 0;
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _size2, 0);
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt?.shift()) {
          (_b2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _b2.call(this, ...task);
        }
      }
    };
    var LRUCache = _LRUCache;
    exports.LRUCache = LRUCache;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/kwil.js
var require_kwil = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/kwil.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Kwil = void 0;
    var client_1 = __importDefault(require_client());
    var enums_1 = require_enums();
    var action_1 = require_action();
    var intern_1 = require_intern();
    var funder_1 = require_funder();
    var auth_1 = require_auth2();
    var action_2 = require_action2();
    var parameterEncoding_1 = require_parameterEncoding();
    var dbid_1 = require_dbid();
    var payloadTx_1 = require_payloadTx();
    var namespace_1 = require_namespace();
    var keys_1 = require_keys();
    var serial_1 = require_serial();
    var lru_cache_1 = require_commonjs();
    var Kwil = class extends client_1.default {
      constructor(opts) {
        super(opts);
        this.chainId = opts.chainId;
        this.autoAuthenticate = opts.autoAuthenticate ?? true;
        this.actionsCache = new lru_cache_1.LRUCache({
          max: 500,
          ttl: 24 * 1e3 * 60 * 60
          // 1 day TTL
        });
        this.funder = new funder_1.Funder(this, {
          broadcastClient: this.broadcastClient.bind(this)
        }, this.chainId);
        this.auth = new auth_1.Auth({
          getAuthenticateClient: this.getAuthenticateClient.bind(this),
          postAuthenticateClient: this.postAuthenticateClient.bind(this),
          challengeClient: this.challengeClient.bind(this),
          logoutClient: this.logoutClient.bind(this)
        }, this.config.kwilProvider, this.chainId);
        (0, intern_1.wrap)(this, this.estimateCostClient.bind(this));
      }
      /**
       * Retrieves the actions in a database given its namespace.
       *
       * @param namespace - The namespace of the actions to retrieve.
       * @returns A promise that resolves to the actions in the database.
       */
      async getActions(namespace) {
        if (!(0, namespace_1.validateNamespace)(namespace)) {
          throw new Error("Please provide a valid namespace");
        }
        const cached2 = this.actionsCache.get(namespace);
        if (cached2 !== void 0) {
          return {
            status: 200,
            data: cached2
          };
        }
        const response = await this.selectQuery("SELECT * FROM info.actions WHERE namespace = $namespace", { $namespace: namespace });
        if (response.data) {
          this.actionsCache.set(namespace, response.data);
        }
        return response;
      }
      /**
       * Retrieves an account using the owner's Ethereum wallet address.
       *
       * @param owner - The owner's identifier (e.g. Ethereum wallet address or ED25119 keys). Ethereum addresses and ED25519 public keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
       * @returns A promise that resolves to an Account object. The account object includes the account's id, balance, and nonce.
       */
      async getAccount(owner, keyType) {
        if (!keyType) {
          keyType = (0, keys_1.inferKeyType)(owner);
        }
        if (owner instanceof Uint8Array) {
          owner = (0, serial_1.bytesToHex)(owner);
        }
        return await this.getAccountClient({
          identifier: owner,
          key_type: keyType
        });
      }
      /**
       * Executes a transaction on a Kwil network. These are mutative actions that must be mined on the Kwil network's blockchain.
       *
       * @param actionBody - The body of the action to send. This should use the `ActionBody` interface.
       * @param kwilSigner - The signer for the action transactions.
       * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
       * @returns A promise that resolves to the receipt of the transaction.
       */
      async execute(actionBody, kwilSigner, synchronous) {
        if (!actionBody.name) {
          throw new Error("name is required in actionBody");
        }
        await this.ensureAuthenticationMode();
        const namespace = (0, namespace_1.resolveNamespace)(actionBody);
        let inputs = [];
        if (actionBody.inputs && action_1.transformActionInput.isActionInputArray(actionBody.inputs)) {
          inputs = action_1.transformActionInput.toNamedParams(actionBody.inputs);
        } else {
          inputs = actionBody.inputs || [];
        }
        let tx = action_2.Action.createTx(this, {
          namespace,
          actionName: actionBody.name.toLowerCase(),
          description: actionBody.description || "",
          identifier: kwilSigner.identifier,
          chainId: this.chainId,
          signer: kwilSigner.signer,
          signatureType: kwilSigner.signatureType,
          nonce: actionBody.nonce,
          actionInputs: inputs,
          types: actionBody.types
        });
        const transaction = await tx.buildTx(this.authMode === enums_1.AuthenticationMode.PRIVATE);
        return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
      }
      async selectQuery(query, params) {
        if (typeof params === "string") {
          return this.legacySelectQuery(query, params);
        }
        const encodedParams = (0, parameterEncoding_1.encodeParameters)(params || {});
        const q = {
          query,
          params: encodedParams
        };
        return await this.selectQueryClient(q);
      }
      async legacySelectQuery(dbid, query) {
        console.warn("WARNING: selectQuery(dbid, query) is deprecated and will be removed in the next major version. Use selectQuery(query, params?) instead.");
        const q = {
          query: `{${dbid}}${query}`,
          params: {}
        };
        return await this.selectQueryClient(q);
      }
      /**
       * Executes a mutative SQL query (INSERT, UPDATE, DELETE) on a database.
       *
       * @param query - The SQL query to execute, including the database identifier in curly braces.
       *               Use parameterized queries with @paramName placeholders for better security (recommended):
       *               '{dbname}INSERT INTO users (name) VALUES (@name)'
       *
       *               Raw queries are possible but discouraged:
       *               '{dbname}INSERT INTO users (name) VALUES ('john')'
       *
       * @param params - Object containing named parameters to bind to the query. Parameters are referenced
       *                using @paramName syntax in the query.
       * @param kwilSigner - Required signer for executing mutative queries
       * @param synchronous - (optional) If true, waits for transaction to be mined
       *
       * @example
       * // Insert with parameters
       * await kwil.execSql(
       *   '{mydb}INSERT INTO users (name, email) VALUES ($name, $email)',
       *   { $name: 'John', $email: 'john@example.com' },
       *   signer
       * );
       *
       * // Update with parameters
       * await kwil.execSql(
       *   '{mydb}UPDATE users SET status = $status WHERE id = $id',
       *   { $status: 'active', $id: 123 },
       *   signer
       * );
       *
       * // Delete with parameters
       * await kwil.execSql(
       *   '{mydb}DELETE FROM users WHERE id = $id',
       *   { $id: 123 },
       *   signer
       * );
       *
       * @returns Promise resolving to transaction receipt
       */
      async execSql(query, params, signer, synchronous) {
        const encodedParams = (0, parameterEncoding_1.encodeRawStatementParameters)(params);
        const rawStatementPayload = {
          statement: query,
          parameters: encodedParams
        };
        const transaction = await payloadTx_1.PayloadTx.createTx(this, {
          chainId: this.chainId,
          description: `Performing a mutative query`,
          payload: rawStatementPayload,
          payloadType: enums_1.PayloadType.RAW_STATEMENT,
          identifier: signer.identifier,
          signer: signer.signer,
          signatureType: signer.signatureType
        }).buildTx();
        return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
      }
      /**
       * Retrieves information about a transaction given its hash.
       *
       * @param hash - The `tx_hash` of the transaction.
       * @returns A promise that resolves to the transaction info receipt.
       */
      async txInfo(hash2) {
        return await this.txInfoClient(hash2);
      }
      /**
       * Retrieves the chain id, block height, and latest block hash of the configured network.
       *
       * Will log a warning if the returned chain id does not match the configured chain id.
       *
       * @param {ChainInfoOpts} opts - Options for the chain info request.
       * @returns {ChainInfo} - A promise that resolves to the chain info.
       */
      async chainInfo(opts) {
        const info = await this.chainInfoClient();
        if (!opts?.disableWarning && info.data?.chain_id !== this.chainId) {
          console.warn(`WARNING: Chain ID mismatch. Expected ${info.data?.chain_id}, got ${this.chainId}`);
        }
        return info;
      }
      /**
       * Pings the server and gets a response.
       *
       * @returns A promise that resolves to a string indicating the server's response.
       */
      async ping() {
        return await this.pingClient();
      }
      // DEPRECATED APIS BELOW
      /**
       * Generates a unique database identifier (DBID) from the provided owner's identifier (e.g. wallet address, public key, etc.) and a database name.
       *
       * @param owner - The owner's identifier (e.g wallet address, public key, etc.). Ethereum addresses can be passed as a hex string (0x123...) or as bytes (Uint8Array). NEAR protocol public keys can be passed as the base58 encoded public key (with "ed25519:" prefix), a hex string, or bytes (Uint8Array).
       * @param name - The name of the database. This should be a unique name to identify the database.
       * @deprecated DBID's are no longer in use.  This method will be removed in the next major version.
       * @returns A string that represents the unique identifier for the database.
       */
      getDBID(owner, name) {
        console.warn("WARNING: `getDBID()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
        return (0, dbid_1.generateDBID)(owner, name);
      }
      /**
       * Retrieves the schema of a database given its unique identifier (DBID).
       *
       * @param dbid - The unique identifier of the database. The DBID can be generated using the kwil.getDBID method.
       * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
       * @returns A promise that resolves to the schema of the database.
       */
      async getSchema(dbid) {
        console.warn("WARNING: `getSchema()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery()` instead.");
        throw new Error("The `getSchema()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
      }
      /**
       * Deploys a database to the Kwil network.
       *
       * @param deployBody - The body of the database to deploy. This should use the `DeployBody` interface.
       * @param kwilSigner - The signer for the database deployment.
       * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
       * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
       * @returns A promise that resolves to the receipt of the transaction.
       */
      async deploy(deployBody, kwilSigner, synchronous) {
        console.warn("WARNING: `deploy()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
        throw new Error("The `deploy()` method is no longer supported. Please use `kwil.execSql()` instead.");
      }
      /**
       * Drops a database from the Kwil network.
       *
       * @param dropBody - The body of the database to drop. This should use the `DropBody` interface.
       * @param kwilSigner - The signer for the database drop.
       * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
       * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
       * @returns A promise that resolves to the receipt of the transaction.
       */
      async drop(dropBody, kwilSigner, synchronous) {
        console.warn("WARNING: `drop()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
        throw new Error("The `drop()` method is no longer supported. Please use `kwil.execSql()` instead.");
      }
      /**
       * Lists all databases owned by a particular owner.
       *
       * @param owner (optional) - Lists the databases on a network. Can pass and owner identifier to see all the databases deployed by a specific account, or leave empty to see al the databases deployed on the network. The owner's public key (Ethereum or NEAR Protocol). Ethereum keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
       * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
       * @returns A promise that resolves to a list of database names.
       */
      async listDatabases(owner) {
        console.warn("WARNING: `listDatabases()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
        throw new Error("The `listDatabases()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
      }
      /**
       * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
       *
       * @param {CallBody} callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
       * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @param {(...args: any) => void} cookieHandlerCallback (optional) - the callback to handle the cookie if in the NODE environment
       * @returns A promise that resolves to the receipt of the message.
       */
      async baseCall(callBody, kwilSigner, cookieHandlerCallback) {
        await this.ensureAuthenticationMode();
        if (this.authMode === enums_1.AuthenticationMode.OPEN) {
          if (cookieHandlerCallback) {
            cookieHandlerCallback.setCookie();
          }
          const message = await this.buildMessage(callBody, kwilSigner);
          const response = await this.callClient(message);
          if (cookieHandlerCallback) {
            cookieHandlerCallback.resetCookie();
          }
          if (response.authCode === enums_1.AuthErrorCodes.KGW_MODE && this.autoAuthenticate) {
            if (!kwilSigner) {
              throw new Error("KGW authentication requires a KwilSigner");
            }
            const res = await this.auth.authenticateKGW(kwilSigner);
            if (res.data && "cookie" in res.data) {
              this.cookie = res.data.cookie;
            }
            return await this.callClient(message);
          }
          return response;
        }
        if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
          const authBody = await this.handleAuthenticatePrivate(callBody, kwilSigner);
          const message = await this.buildMessage(callBody, kwilSigner, authBody.challenge, authBody.signature);
          return await this.callClient(message);
        }
        throw new Error("Unexpected authentication mode. If you hit this error, please report it to the Kwil team.");
      }
      /**
       * Check if authMode is already set, if not call healthModeCheckClient()
       * healthModeCheckClient => RPC call to retrieve health of blockchain and kwild mode (PRIVATE or OPEN (PUBLIC))
       *
       */
      async ensureAuthenticationMode() {
        if (!this.authMode) {
          const health = await this.healthModeCheckClient();
          this.authMode = health.data?.mode;
        }
      }
      /**
       * Builds a message with a chainId, namespace, name, and description of the action.
       * NOT INCLUDED => challenge, sender, signature
       *
       * @param callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
       * @param kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @param challenge (optional) - To ensure a challenge is passed into the message before the signer in PRIVATE mode
       * @param signature (optional) - To ensure a signature is passed into the message before the signer in PRIVATE mode
       * @returns A message object that can be sent to the Kwil network.
       * @throws  Will throw an error if the action is being built or if there's an issue with the schema or account retrieval.
       * @throws  Will throw an error if the action is not a view action.
       */
      async buildMessage(callBody, kwilSigner, challenge, signature) {
        if (!callBody.name) {
          throw new Error("name is required in actionBody");
        }
        const namespace = (0, namespace_1.resolveNamespace)(callBody);
        let inputs = [];
        if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
          inputs = [action_1.transformActionInput.toSingleEntry(callBody.inputs)];
        } else if (callBody.inputs && (0, action_1.isNamedParam)(callBody.inputs)) {
          inputs = [callBody.inputs];
        } else {
          inputs = callBody.inputs ? [callBody.inputs] : [];
        }
        let msg = action_2.Action.createTx(this, {
          chainId: this.chainId,
          namespace,
          actionName: callBody.name,
          description: "",
          actionInputs: inputs,
          types: callBody.types
        });
        if (kwilSigner && this.authMode === enums_1.AuthenticationMode.OPEN) {
          this.addSignerToMessage(msg, kwilSigner);
        }
        if (kwilSigner && this.authMode === enums_1.AuthenticationMode.PRIVATE) {
          if (challenge && signature) {
            msg.challenge = challenge;
            msg.signature = signature;
            this.addSignerToMessage(msg, kwilSigner);
          }
        }
        return await msg.buildMsg(this.authMode === enums_1.AuthenticationMode.PRIVATE);
      }
      /**
       * Adds a signer to the message
       *
       * @param msgBuilder - The Action class that handles the building of the message
       * @param kwilSigner - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @returns the Action class responsible for building the view action message with the sender attached
       *
       */
      addSignerToMessage(msg, kwilSigner) {
        msg.signer = kwilSigner.signer;
        msg.signatureType = kwilSigner.signatureType;
        msg.identifier = kwilSigner.identifier;
        return msg;
      }
      /**
       * Checks authentication errors for PRIVATE mode
       * Signs message and then retries request for successful response
       *
       * @param {CallBodyNode} actionBody - The message to send. The message can be built using the buildMsg() method in the Action class.
       * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @returns the authentication body that consists of the challenge and signature required for PRIVATE mode
       */
      async handleAuthenticatePrivate(actionBody, kwilSigner) {
        if (this.autoAuthenticate) {
          try {
            if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
              if (!kwilSigner) {
                throw new Error("Private mode authentication requires a KwilSigner.");
              }
              return await this.auth.authenticatePrivateMode(actionBody, kwilSigner);
            }
          } catch (error) {
            throw new Error(`Authentication failed: ${error}`);
          }
        }
        throw new Error("Authentication process did not complete successfully");
      }
    };
    exports.Kwil = Kwil;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/node/nodeKwil.js
var require_nodeKwil = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/node/nodeKwil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeKwil = void 0;
    var kwil_1 = require_kwil();
    var NodeKwil2 = class extends kwil_1.Kwil {
      constructor(opts) {
        super(opts);
      }
      /**
       * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
       * If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
       *
       * @param {CallBodyNode} actionBody - The body of the action to send. This should use the `CallBody` interface.
       * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @returns An Object[] with the result of the action
       */
      async call(actionBody, kwilSigner) {
        const setCookie = () => {
          if (actionBody.cookie) {
            this.setTemporaryCookie(actionBody.cookie);
          }
        };
        const resetCookie = () => {
          if (this.tempCookie) {
            this.resetTempCookie(this.tempCookie);
          }
        };
        const cookieHandler = {
          setCookie,
          resetCookie
        };
        return await this.baseCall(actionBody, kwilSigner, cookieHandler);
      }
      /**
       * set the temp cookie to reset it after the call
       *
       * @param {string} cookie - The temporary cookie
       * @returns the temporary cookie to handle for Node
       */
      setTemporaryCookie(cookie) {
        this.tempCookie = this.cookie;
        this.cookie = cookie;
      }
      /**
       * Resets the temporary cookie
       *
       * @param {string} tempCookie - the temporary cookie to be reset
       */
      resetTempCookie(tempCookie) {
        this.cookie = tempCookie;
      }
    };
    exports.NodeKwil = NodeKwil2;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/web/webKwil.js
var require_webKwil = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/client/web/webKwil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebKwil = void 0;
    var kwil_1 = require_kwil();
    var WebKwil2 = class extends kwil_1.Kwil {
      constructor(opts) {
        super(opts);
      }
      /**
       * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
       * If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
       *
       * @param {CallBody} actionBody - The body of the action to send. This should use the `CallBody` interface.
       * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
       * @returns An Object[] with the result of the action or a MsgReceipt
       */
      async call(actionBody, kwilSigner) {
        return await this.baseCall(actionBody, kwilSigner);
      }
    };
    exports.WebKwil = WebKwil2;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/database.js
var require_database = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/database.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataType = void 0;
    var enums_1 = require_enums();
    var DataType2;
    (function(DataType3) {
      DataType3.Uuid = {
        name: enums_1.VarType.UUID,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.UuidArray = {
        name: enums_1.VarType.UUID,
        is_array: true,
        metadata: [0, 0]
      };
      DataType3.Text = {
        name: enums_1.VarType.TEXT,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.TextArray = {
        name: enums_1.VarType.TEXT,
        is_array: true,
        metadata: [0, 0]
      };
      DataType3.Int = {
        name: enums_1.VarType.INT8,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.IntArray = {
        name: enums_1.VarType.INT8,
        is_array: true,
        metadata: [0, 0]
      };
      DataType3.Boolean = {
        name: enums_1.VarType.BOOL,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.BooleanArray = {
        name: enums_1.VarType.BOOL,
        is_array: true,
        metadata: [0, 0]
      };
      DataType3.Numeric = (precision, scale) => ({
        name: enums_1.VarType.NUMERIC,
        is_array: false,
        metadata: [precision, scale]
      });
      DataType3.NumericArray = (precision, scale) => ({
        name: enums_1.VarType.NUMERIC,
        is_array: true,
        metadata: [precision, scale]
      });
      DataType3.Null = {
        name: enums_1.VarType.NULL,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.NullArray = {
        name: enums_1.VarType.NULL,
        is_array: true,
        metadata: [0, 0]
      };
      DataType3.Bytea = {
        name: enums_1.VarType.BYTEA,
        is_array: false,
        metadata: [0, 0]
      };
      DataType3.ByteaArray = {
        name: enums_1.VarType.BYTEA,
        is_array: true,
        metadata: [0, 0]
      };
    })(DataType2 = exports.DataType || (exports.DataType = {}));
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/kwilSigner.js
var require_kwilSigner = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/core/kwilSigner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KwilSigner = void 0;
    var serial_1 = require_serial();
    var signature_1 = require_signature();
    var KwilSigner2 = class {
      /**
       * Actual implementation of the KwilSigner constructor.
       *
       * @param {SignerSupplier} signer - Either an instance of EthSigner or CustomSigner.
       * @param {HexString | Uint8Array} identifier - The identifier associated with the signer (e.g. wallet address, public key, etc). Can be a hex string or bytes (Uint8Array).
       * @param {AnySignatureType} signatureType - (Optional) The type of the signature. If not provided,
       *                        the signature type is determined from the signer.
       */
      constructor(signer, identifier, signatureType) {
        this.signer = signer;
        if (typeof identifier === "string") {
          this.identifier = (0, serial_1.hexToBytes)(identifier);
        } else {
          this.identifier = identifier;
        }
        if (signatureType) {
          this.signatureType = signatureType;
        } else {
          this.signatureType = (0, signature_1.getSignatureType)(signer);
          if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
            throw new Error("Could not determine signature type from signer. Please pass a signature type to the KwilSigner constructor.");
          }
        }
      }
    };
    exports.KwilSigner = KwilSigner2;
  }
});

// node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@idos-network+kwil-js@0.1.3_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@idos-network/kwil-js/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.Utils = exports.KwilSigner = exports.WebKwil = exports.NodeKwil = void 0;
    var nodeKwil_1 = require_nodeKwil();
    Object.defineProperty(exports, "NodeKwil", { enumerable: true, get: function() {
      return nodeKwil_1.NodeKwil;
    } });
    var webKwil_1 = require_webKwil();
    Object.defineProperty(exports, "WebKwil", { enumerable: true, get: function() {
      return webKwil_1.WebKwil;
    } });
    var dbid_1 = require_dbid();
    var action_1 = require_action();
    var database_1 = require_database();
    var kwilSigner_1 = require_kwilSigner();
    Object.defineProperty(exports, "KwilSigner", { enumerable: true, get: function() {
      return kwilSigner_1.KwilSigner;
    } });
    var client_1 = __importDefault(require_client());
    exports.Client = client_1.default;
    var Utils2;
    (function(Utils3) {
      Utils3.ActionInput = action_1.ActionInput;
      Utils3.generateDBID = dbid_1.generateDBID;
      Utils3.DataType = database_1.DataType;
    })(Utils2 || (Utils2 = {}));
    exports.Utils = Utils2;
  }
});

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix2;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XRPLFaucetError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.RippledNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.RippledError = exports.ConnectionError = exports.UnexpectedError = exports.XrplError = void 0;
    var XrplError = class extends Error {
      constructor(message = "", data) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace != null) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      toString() {
        let result = `[${this.name}(${this.message}`;
        if (this.data) {
          result += `, ${JSON.stringify(this.data)}`;
        }
        result += ")]";
        return result;
      }
      inspect() {
        return this.toString();
      }
    };
    exports.XrplError = XrplError;
    var RippledError = class extends XrplError {
    };
    exports.RippledError = RippledError;
    var UnexpectedError = class extends XrplError {
    };
    exports.UnexpectedError = UnexpectedError;
    var ConnectionError = class extends XrplError {
    };
    exports.ConnectionError = ConnectionError;
    var NotConnectedError = class extends ConnectionError {
    };
    exports.NotConnectedError = NotConnectedError;
    var DisconnectedError = class extends ConnectionError {
    };
    exports.DisconnectedError = DisconnectedError;
    var RippledNotInitializedError = class extends ConnectionError {
    };
    exports.RippledNotInitializedError = RippledNotInitializedError;
    var TimeoutError = class extends ConnectionError {
    };
    exports.TimeoutError = TimeoutError;
    var ResponseFormatError = class extends ConnectionError {
    };
    exports.ResponseFormatError = ResponseFormatError;
    var ValidationError = class extends XrplError {
    };
    exports.ValidationError = ValidationError;
    var XRPLFaucetError = class extends XrplError {
    };
    exports.XRPLFaucetError = XRPLFaucetError;
    var NotFoundError = class extends XrplError {
      constructor(message = "Not found") {
        super(message);
      }
    };
    exports.NotFoundError = NotFoundError;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/common/index.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/common/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2 = exports.RIPPLED_API_V1 = void 0;
    exports.RIPPLED_API_V1 = 1;
    exports.RIPPLED_API_V2 = 2;
    exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js
var require_AccountRoot = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountRootFlags = void 0;
    var AccountRootFlags;
    (function(AccountRootFlags2) {
      AccountRootFlags2[AccountRootFlags2["lsfPasswordSpent"] = 65536] = "lsfPasswordSpent";
      AccountRootFlags2[AccountRootFlags2["lsfRequireDestTag"] = 131072] = "lsfRequireDestTag";
      AccountRootFlags2[AccountRootFlags2["lsfRequireAuth"] = 262144] = "lsfRequireAuth";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowXRP"] = 524288] = "lsfDisallowXRP";
      AccountRootFlags2[AccountRootFlags2["lsfDisableMaster"] = 1048576] = "lsfDisableMaster";
      AccountRootFlags2[AccountRootFlags2["lsfNoFreeze"] = 2097152] = "lsfNoFreeze";
      AccountRootFlags2[AccountRootFlags2["lsfGlobalFreeze"] = 4194304] = "lsfGlobalFreeze";
      AccountRootFlags2[AccountRootFlags2["lsfDefaultRipple"] = 8388608] = "lsfDefaultRipple";
      AccountRootFlags2[AccountRootFlags2["lsfDepositAuth"] = 16777216] = "lsfDepositAuth";
      AccountRootFlags2[AccountRootFlags2["lsfAMM"] = 33554432] = "lsfAMM";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingNFTokenOffer"] = 67108864] = "lsfDisallowIncomingNFTokenOffer";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingCheck"] = 134217728] = "lsfDisallowIncomingCheck";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingPayChan"] = 268435456] = "lsfDisallowIncomingPayChan";
      AccountRootFlags2[AccountRootFlags2["lsfDisallowIncomingTrustline"] = 536870912] = "lsfDisallowIncomingTrustline";
      AccountRootFlags2[AccountRootFlags2["lsfAllowTrustLineClawback"] = 2147483648] = "lsfAllowTrustLineClawback";
      AccountRootFlags2[AccountRootFlags2["lsfAllowTrustLineLocking"] = 1073741824] = "lsfAllowTrustLineLocking";
    })(AccountRootFlags || (exports.AccountRootFlags = AccountRootFlags = {}));
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex2;
    exports.hexToBytes = hexToBytes2;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes2;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto2();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes2[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n2;
      }
      return array2;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/shared.js
var require_shared = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.equal = exports.concat = exports.HEX_REGEX = void 0;
    var utils_1 = require_utils();
    exports.HEX_REGEX = /^[A-F0-9]*$/iu;
    function concat2(views) {
      return (0, utils_1.concatBytes)(...views);
    }
    exports.concat = concat2;
    function equal(buf1, buf2) {
      if (buf1.byteLength !== buf2.byteLength) {
        return false;
      }
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i !== buf1.byteLength; i++) {
        if (dv1[i] !== dv2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.equal = equal;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/browser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.stringToHex = exports.hexToString = exports.hexToBytes = exports.bytesToHex = void 0;
    var utils_1 = require_utils();
    var shared_1 = require_shared();
    var bytesToHex2 = (bytes) => {
      const hex = (0, utils_1.bytesToHex)(bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes));
      return hex.toUpperCase();
    };
    exports.bytesToHex = bytesToHex2;
    var hexToBytes2 = (hex) => {
      const len = hex.length;
      const array2 = new Uint8Array(len / 2);
      if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error("Invalid hex string");
      }
      for (let i = 0; i < array2.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) {
          throw new Error("Invalid byte sequence");
        }
        array2[i] = byte;
      }
      return array2;
    };
    exports.hexToBytes = hexToBytes2;
    var hexToString = (hex, encoding = "utf8") => {
      return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));
    };
    exports.hexToString = hexToString;
    var stringToHex = (string3) => {
      return (0, exports.bytesToHex)(new TextEncoder().encode(string3));
    };
    exports.stringToHex = stringToHex;
    exports.randomBytes = utils_1.randomBytes;
    __exportStar(require_shared(), exports);
  }
});

// node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function isArrayOf(isString, arr) {
      if (!Array.isArray(arr))
        return false;
      if (arr.length === 0)
        return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function afn(input) {
      if (typeof input !== "function")
        throw new Error("function expected");
      return true;
    }
    function astr(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
    }
    function aArr(input) {
      if (!Array.isArray(input))
        throw new Error("array expected");
    }
    function astrArr(label, input) {
      if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr(label, input) {
      if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function chain(...args) {
      const id = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode9 = args.map((x) => x.encode).reduceRight(wrap, id);
      const decode10 = args.map((x) => x.decode).reduce(wrap, id);
      return { encode: encode9, decode: decode10 };
    }
    // @__NO_SIDE_EFFECTS__
    function alphabet2(letters) {
      const lettersA = typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l, i) => [l, i]));
      return {
        encode: (digits) => {
          aArr(digits);
          return digits.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= len)
              throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
            return lettersA[i];
          });
        },
        decode: (input) => {
          aArr(input);
          return input.map((letter) => {
            astr("alphabet.decode", letter);
            const i = indexes.get(letter);
            if (i === void 0)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
            return i;
          });
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function join(separator = "") {
      astr("join", separator);
      return {
        encode: (from) => {
          astrArr("join.decode", from);
          return from.join(separator);
        },
        decode: (to) => {
          astr("join.decode", to);
          return to.split(separator);
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function padding(bits, chr = "=") {
      anumber(bits);
      astr("padding", chr);
      return {
        encode(data) {
          astrArr("padding.encode", data);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          astrArr("padding.decode", input);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("padding: invalid, string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            const last = end - 1;
            const byte = last * bits;
            if (byte % 8 === 0)
              throw new Error("padding: invalid, string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function normalize(fn) {
      afn(fn);
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
      aArr(data);
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
          throw new Error(`invalid integer: ${d}`);
        return d;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
          const digit = digits[i];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit;
          if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to;
          carry = digitBase % to;
          const rounded = Math.floor(div);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
    var powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i = 0; i < 40; i++)
        res.push(2 ** i);
      return res;
    })();
    function convertRadix2(data, from, to, padding2) {
      aArr(data);
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (/* @__PURE__ */ radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const max = powers[from];
      const mask = powers[to] - 1;
      const res = [];
      for (const n of data) {
        anumber(n);
        if (n >= max)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === void 0)
          throw new Error("invalid carry");
        carry &= pow - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    // @__NO_SIDE_EFFECTS__
    function radix(num) {
      anumber(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
          anumArr("radix.decode", digits);
          return Uint8Array.from(convertRadix(digits, num, _256));
        }
      };
    }
    // @__NO_SIDE_EFFECTS__
    function radix2(bits, revPadding = false) {
      anumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          anumArr("radix2.decode", digits);
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      afn(fn);
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      anumber(len);
      afn(fn);
      return {
        encode(data) {
          if (!isBytes(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const sum = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(sum, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const oldChecksum = data.slice(-len);
          const newChecksum = fn(payload).slice(0, len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = {
      alphabet: alphabet2,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    exports.base16 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet2("0123456789ABCDEF"), /* @__PURE__ */ join(""));
    exports.base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
    exports.base32nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ join(""));
    exports.base32hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
    exports.base32hexnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ join(""));
    exports.base32crockford = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    var hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    var decodeBase64Builtin = (s, isUrl) => {
      astr("base64", s);
      const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet3 = isUrl ? "base64url" : "base64";
      if (s.length > 0 && !re.test(s))
        throw new Error("invalid base64");
      return Uint8Array.fromBase64(s, { alphabet: alphabet3, lastChunkHandling: "strict" });
    };
    exports.base64 = hasBase64Builtin ? {
      encode(b) {
        abytes(b);
        return b.toBase64();
      },
      decode(s) {
        return decodeBase64Builtin(s, false);
      }
    } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
    exports.base64nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ join(""));
    exports.base64url = hasBase64Builtin ? {
      encode(b) {
        abytes(b);
        return b.toBase64({ alphabet: "base64url" });
      },
      decode(s) {
        return decodeBase64Builtin(s, true);
      }
    } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
    exports.base64urlnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ join(""));
    var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet2(abc), /* @__PURE__ */ join(""));
    exports.base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = /* @__PURE__ */ genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = /* @__PURE__ */ genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check = (sha256) => /* @__PURE__ */ chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
    exports.createBase58check = createBase58check;
    exports.base58check = exports.createBase58check;
    var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if ((b >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix2, words, encodingConst = 1) {
      const len = prefix2.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix2.charCodeAt(i);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix2})`);
        chk = bech32Polymod(chk) ^ c >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ prefix2.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
    }
    // @__NO_SIDE_EFFECTS__
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = /* @__PURE__ */ radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode9(prefix2, words, limit = 90) {
        astr("bech32.encode prefix", prefix2);
        if (isBytes(words))
          words = Array.from(words);
        anumArr("bech32.encode", words);
        const plen = prefix2.length;
        if (plen === 0)
          throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix2.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode10(str, limit = 90) {
        astr("bech32.decode input", str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit)
          throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix2 = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix2, words, ENCODING_CONST);
        if (!data.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix: prefix2, words };
      }
      const decodeUnsafe = unsafeWrapper(decode10);
      function decodeToBytes(str) {
        const { prefix: prefix2, words } = decode10(str, false);
        return { prefix: prefix2, words, bytes: fromWords(words) };
      }
      function encodeFromBytes(prefix2, bytes) {
        return encode9(prefix2, toWords(bytes));
      }
      return {
        encode: encode9,
        decode: decode10,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
      };
    }
    exports.bech32 = /* @__PURE__ */ genBech32("bech32");
    exports.bech32m = /* @__PURE__ */ genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    var hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
    var hexBuiltin = {
      encode(data) {
        abytes(data);
        return data.toHex();
      },
      decode(s) {
        astr("hex", s);
        return Uint8Array.fromHex(s);
      }
    };
    exports.hex = hasHexBuiltin ? hexBuiltin : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet2("0123456789abcdef"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => {
      if (typeof s !== "string" || s.length % 2 !== 0)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes(bytes))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports.HashMD = HashMD;
    exports.SHA256_IV = Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    exports.SHA224_IV = Uint32Array.from([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
    exports.SHA384_IV = Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    exports.SHA512_IV = Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
    exports.add = add;
    exports.fromBig = fromBig;
    exports.split = split;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA2562 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA256 = SHA2562;
    var SHA224 = class extends SHA2562 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports.SHA224 = SHA224;
    var K512 = /* @__PURE__ */ (() => u64.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
          const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
          const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
          const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
          const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports.SHA384 = SHA384;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216,
      424955298,
      1944164710,
      2312950998,
      502970286,
      855612546,
      1738396948,
      1479516111,
      258812777,
      2077511080,
      2011393907,
      79989058,
      1067287976,
      1780299464,
      286451373,
      2446758561
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204,
      4230739756,
      2673172387,
      3360449730,
      596883563,
      1867755857,
      2520282905,
      1497426621,
      2519219938,
      2827943907,
      3193839141,
      1401305490,
      721525244,
      746961066,
      246885852,
      2177182882
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports.SHA512_256 = SHA512_256;
    exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA2562());
    exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
    var sha2_ts_1 = require_sha2();
    exports.SHA256 = sha2_ts_1.SHA256;
    exports.sha256 = sha2_ts_1.sha256;
    exports.SHA224 = sha2_ts_1.SHA224;
    exports.sha224 = sha2_ts_1.sha224;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js
var require_normalizeInput = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeInput(input) {
      return Array.isArray(input) ? new Uint8Array(input) : input;
    }
    exports.default = normalizeInput;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/wrapNoble.js
var require_wrapNoble = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/wrapNoble.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var normalizeInput_1 = __importDefault(require_normalizeInput());
    function wrapNoble(chash) {
      function wrapped(input) {
        return chash((0, normalizeInput_1.default)(input));
      }
      wrapped.create = () => {
        const hash2 = chash.create();
        return {
          update(input) {
            hash2.update((0, normalizeInput_1.default)(input));
            return this;
          },
          digest() {
            return hash2.digest();
          }
        };
      };
      return wrapped;
    }
    exports.default = wrapNoble;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha256/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha256/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var sha256_1 = require_sha256();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.sha256 = (0, wrapNoble_1.default)(sha256_1.sha256);
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatArgs = exports.arrayEqual = void 0;
    function arrayEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      return arr1.every((value, index) => value === arr2[index]);
    }
    exports.arrayEqual = arrayEqual;
    function isScalar(val) {
      return typeof val === "number";
    }
    function concatArgs(...args) {
      return args.flatMap((arg) => {
        return isScalar(arg) ? [arg] : Array.from(arg);
      });
    }
    exports.concatArgs = concatArgs;
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/xrp-codec.js
var require_xrp_codec = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/xrp-codec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var base_1 = require_lib();
    var sha256_1 = require_browser2();
    var utils_1 = require_utils2();
    var Codec = class {
      constructor(options) {
        this._sha256 = options.sha256;
        this._codec = base_1.base58xrp;
      }
      /**
       * Encoder.
       *
       * @param bytes - Uint8Array of data to encode.
       * @param opts - Options object including the version bytes and the expected length of the data to encode.
       */
      encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
      }
      /**
       * Decoder.
       *
       * @param base58string - Base58Check-encoded string to decode.
       * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
       */
      /* eslint-disable max-lines-per-function --
       * TODO refactor */
      decode(base58string, opts) {
        var _a4;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
          throw new Error("expectedLength is required because there are >= 2 possible versions");
        }
        const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
        const payloadLength = (_a4 = opts.expectedLength) !== null && _a4 !== void 0 ? _a4 : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
          const version2 = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
          if ((0, utils_1.arrayEqual)(versionBytes, version2)) {
            return {
              version: version2,
              bytes: payload,
              type: types ? types[i] : null
            };
          }
        }
        throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
      }
      encodeChecked(bytes) {
        const check = this._sha256(this._sha256(bytes)).slice(0, 4);
        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));
      }
      decodeChecked(base58string) {
        const intArray = this._decodeRaw(base58string);
        if (intArray.byteLength < 5) {
          throw new Error("invalid_input_size: decoded data must have length >= 5");
        }
        if (!this._verifyCheckSum(intArray)) {
          throw new Error("checksum_invalid");
        }
        return intArray.slice(0, -4);
      }
      _encodeVersioned(bytes, versions, expectedLength) {
        if (!checkByteLength(bytes, expectedLength)) {
          throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Uint8Array.");
        }
        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));
      }
      _encodeRaw(bytes) {
        return this._codec.encode(Uint8Array.from(bytes));
      }
      /* eslint-enable max-lines-per-function */
      _decodeRaw(base58string) {
        return this._codec.decode(base58string);
      }
      _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.arrayEqual)(computed, checksum);
      }
    };
    var ACCOUNT_ID = 0;
    var ACCOUNT_PUBLIC_KEY = 35;
    var FAMILY_SEED = 33;
    var NODE_PUBLIC = 28;
    var ED25519_SEED = [1, 225, 75];
    var codecOptions = {
      sha256: sha256_1.sha256
    };
    var codecWithXrpAlphabet = new Codec(codecOptions);
    exports.codec = codecWithXrpAlphabet;
    function encodeSeed(entropy, type) {
      if (!checkByteLength(entropy, 16)) {
        throw new Error("entropy must have length 16");
      }
      const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
      };
      return codecWithXrpAlphabet.encode(entropy, opts);
    }
    exports.encodeSeed = encodeSeed;
    function decodeSeed(seed, opts = {
      versionTypes: ["ed25519", "secp256k1"],
      versions: [ED25519_SEED, FAMILY_SEED],
      expectedLength: 16
    }) {
      return codecWithXrpAlphabet.decode(seed, opts);
    }
    exports.decodeSeed = decodeSeed;
    function encodeAccountID(bytes) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountID = encodeAccountID;
    exports.encodeAddress = encodeAccountID;
    function decodeAccountID(accountId) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.decode(accountId, opts).bytes;
    }
    exports.decodeAccountID = decodeAccountID;
    exports.decodeAddress = decodeAccountID;
    function decodeNodePublic(base58string) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeNodePublic = decodeNodePublic;
    function encodeNodePublic(bytes) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeNodePublic = encodeNodePublic;
    function encodeAccountPublic(bytes) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountPublic = encodeAccountPublic;
    function decodeAccountPublic(base58string) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeAccountPublic = decodeAccountPublic;
    function isValidClassicAddress(address) {
      try {
        decodeAccountID(address);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidClassicAddress = isValidClassicAddress;
    function checkByteLength(bytes, expectedLength) {
      return "byteLength" in bytes ? bytes.byteLength === expectedLength : bytes.length === expectedLength;
    }
  }
});

// node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var utils_1 = require_browser();
    var xrp_codec_1 = require_xrp_codec();
    Object.defineProperty(exports, "codec", { enumerable: true, get: function() {
      return xrp_codec_1.codec;
    } });
    Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.encodeSeed;
    } });
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.decodeSeed;
    } });
    Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountID;
    } });
    Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountID;
    } });
    Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeNodePublic;
    } });
    Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeNodePublic;
    } });
    Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountPublic;
    } });
    Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountPublic;
    } });
    Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
      return xrp_codec_1.isValidClassicAddress;
    } });
    var PREFIX_BYTES = {
      // 5, 68
      main: Uint8Array.from([5, 68]),
      // 4, 147
      test: Uint8Array.from([4, 147])
    };
    var MAX_32_BIT_UNSIGNED_INT = 4294967295;
    function classicAddressToXAddress(classicAddress, tag, test) {
      const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
      return encodeXAddress(accountId, tag, test);
    }
    exports.classicAddressToXAddress = classicAddressToXAddress;
    function encodeXAddress(accountId, tag, test) {
      if (accountId.length !== 20) {
        throw new Error("Account ID must be 20 bytes");
      }
      if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error("Invalid tag");
      }
      const theTag = tag || 0;
      const flag = tag === false || tag == null ? 0 : 1;
      const bytes = (0, utils_1.concat)([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Uint8Array.from([
          // 0x00 if no tag, 0x01 if 32-bit tag
          flag,
          // first byte
          theTag & 255,
          // second byte
          theTag >> 8 & 255,
          // third byte
          theTag >> 16 & 255,
          // fourth byte
          theTag >> 24 & 255,
          0,
          0,
          0,
          // four zero bytes (reserved for 64-bit tags)
          0
        ])
      ]);
      return xrp_codec_1.codec.encodeChecked(bytes);
    }
    exports.encodeXAddress = encodeXAddress;
    function xAddressToClassicAddress(xAddress) {
      const { accountId, tag, test } = decodeXAddress(xAddress);
      const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
      return {
        classicAddress,
        tag,
        test
      };
    }
    exports.xAddressToClassicAddress = xAddressToClassicAddress;
    function decodeXAddress(xAddress) {
      const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
      const test = isUint8ArrayForTestAddress(decoded);
      const accountId = decoded.slice(2, 22);
      const tag = tagFromUint8Array(decoded);
      return {
        accountId,
        tag,
        test
      };
    }
    exports.decodeXAddress = decodeXAddress;
    function isUint8ArrayForTestAddress(buf) {
      const decodedPrefix = buf.slice(0, 2);
      if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {
        return false;
      }
      if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {
        return true;
      }
      throw new Error("Invalid X-address: bad prefix");
    }
    function tagFromUint8Array(buf) {
      const flag = buf[22];
      if (flag >= 2) {
        throw new Error("Unsupported X-address");
      }
      if (flag === 1) {
        return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
      }
      if (flag !== 0) {
        throw new Error("flag must be zero to indicate no tag");
      }
      if (!(0, utils_1.equal)((0, utils_1.hexToBytes)("0000000000000000"), buf.slice(23, 23 + 8))) {
        throw new Error("remaining bytes must be zero");
      }
      return false;
    }
    function isValidXAddress(xAddress) {
      try {
        decodeXAddress(xAddress);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidXAddress = isValidXAddress;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/definitions.json
var require_definitions = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/definitions.json"(exports, module) {
    module.exports = {
      FIELDS: [
        [
          "Generic",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 0,
            type: "Unknown"
          }
        ],
        [
          "Invalid",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: -1,
            type: "Unknown"
          }
        ],
        [
          "ObjectEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STObject"
          }
        ],
        [
          "ArrayEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STArray"
          }
        ],
        [
          "taker_gets_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Amount"
          }
        ],
        [
          "taker_pays_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 259,
            type: "Amount"
          }
        ],
        [
          "LedgerEntryType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt16"
          }
        ],
        [
          "TransactionType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt16"
          }
        ],
        [
          "SignerWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt16"
          }
        ],
        [
          "TransferFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt16"
          }
        ],
        [
          "TradingFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt16"
          }
        ],
        [
          "DiscountedFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt16"
          }
        ],
        [
          "Version",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt16"
          }
        ],
        [
          "HookStateChangeCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt16"
          }
        ],
        [
          "HookEmitCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt16"
          }
        ],
        [
          "HookExecutionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt16"
          }
        ],
        [
          "HookApiVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt16"
          }
        ],
        [
          "LedgerFixType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt16"
          }
        ],
        [
          "ManagementFeeRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt16"
          }
        ],
        [
          "NetworkID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt32"
          }
        ],
        [
          "Flags",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt32"
          }
        ],
        [
          "SourceTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt32"
          }
        ],
        [
          "Sequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt32"
          }
        ],
        [
          "PreviousTxnLgrSeq",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt32"
          }
        ],
        [
          "LedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt32"
          }
        ],
        [
          "CloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt32"
          }
        ],
        [
          "ParentCloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt32"
          }
        ],
        [
          "SigningTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt32"
          }
        ],
        [
          "Expiration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt32"
          }
        ],
        [
          "TransferRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt32"
          }
        ],
        [
          "WalletSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt32"
          }
        ],
        [
          "OwnerCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt32"
          }
        ],
        [
          "DestinationTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "UInt32"
          }
        ],
        [
          "LastUpdateTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "UInt32"
          }
        ],
        [
          "HighQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt32"
          }
        ],
        [
          "HighQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt32"
          }
        ],
        [
          "LowQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt32"
          }
        ],
        [
          "LowQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt32"
          }
        ],
        [
          "QualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt32"
          }
        ],
        [
          "QualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt32"
          }
        ],
        [
          "StampEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt32"
          }
        ],
        [
          "BondAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt32"
          }
        ],
        [
          "LoadFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt32"
          }
        ],
        [
          "OfferSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt32"
          }
        ],
        [
          "FirstLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt32"
          }
        ],
        [
          "LastLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "UInt32"
          }
        ],
        [
          "TransactionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "UInt32"
          }
        ],
        [
          "OperationLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "UInt32"
          }
        ],
        [
          "ReferenceFeeUnits",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "UInt32"
          }
        ],
        [
          "ReserveBase",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "UInt32"
          }
        ],
        [
          "ReserveIncrement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "UInt32"
          }
        ],
        [
          "SetFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "UInt32"
          }
        ],
        [
          "ClearFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "UInt32"
          }
        ],
        [
          "SignerQuorum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "UInt32"
          }
        ],
        [
          "CancelAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "UInt32"
          }
        ],
        [
          "FinishAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 37,
            type: "UInt32"
          }
        ],
        [
          "SignerListID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 38,
            type: "UInt32"
          }
        ],
        [
          "SettleDelay",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 39,
            type: "UInt32"
          }
        ],
        [
          "TicketCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 40,
            type: "UInt32"
          }
        ],
        [
          "TicketSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 41,
            type: "UInt32"
          }
        ],
        [
          "NFTokenTaxon",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 42,
            type: "UInt32"
          }
        ],
        [
          "MintedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 43,
            type: "UInt32"
          }
        ],
        [
          "BurnedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 44,
            type: "UInt32"
          }
        ],
        [
          "HookStateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 45,
            type: "UInt32"
          }
        ],
        [
          "EmitGeneration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 46,
            type: "UInt32"
          }
        ],
        [
          "VoteWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 48,
            type: "UInt32"
          }
        ],
        [
          "FirstNFTokenSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 50,
            type: "UInt32"
          }
        ],
        [
          "OracleDocumentID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 51,
            type: "UInt32"
          }
        ],
        [
          "PermissionValue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 52,
            type: "UInt32"
          }
        ],
        [
          "MutableFlags",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 53,
            type: "UInt32"
          }
        ],
        [
          "StartDate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 54,
            type: "UInt32"
          }
        ],
        [
          "PaymentInterval",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 55,
            type: "UInt32"
          }
        ],
        [
          "GracePeriod",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 56,
            type: "UInt32"
          }
        ],
        [
          "PreviousPaymentDate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 57,
            type: "UInt32"
          }
        ],
        [
          "NextPaymentDueDate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 58,
            type: "UInt32"
          }
        ],
        [
          "PaymentRemaining",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 59,
            type: "UInt32"
          }
        ],
        [
          "PaymentTotal",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 60,
            type: "UInt32"
          }
        ],
        [
          "LoanSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 61,
            type: "UInt32"
          }
        ],
        [
          "CoverRateMinimum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 62,
            type: "UInt32"
          }
        ],
        [
          "CoverRateLiquidation",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 63,
            type: "UInt32"
          }
        ],
        [
          "OverpaymentFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 64,
            type: "UInt32"
          }
        ],
        [
          "InterestRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 65,
            type: "UInt32"
          }
        ],
        [
          "LateInterestRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 66,
            type: "UInt32"
          }
        ],
        [
          "CloseInterestRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 67,
            type: "UInt32"
          }
        ],
        [
          "OverpaymentInterestRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 68,
            type: "UInt32"
          }
        ],
        [
          "IndexNext",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt64"
          }
        ],
        [
          "IndexPrevious",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt64"
          }
        ],
        [
          "BookNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt64"
          }
        ],
        [
          "OwnerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt64"
          }
        ],
        [
          "BaseFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt64"
          }
        ],
        [
          "ExchangeRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt64"
          }
        ],
        [
          "LowNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt64"
          }
        ],
        [
          "HighNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt64"
          }
        ],
        [
          "DestinationNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt64"
          }
        ],
        [
          "Cookie",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt64"
          }
        ],
        [
          "ServerVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt64"
          }
        ],
        [
          "NFTokenOfferNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt64"
          }
        ],
        [
          "EmitBurden",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt64"
          }
        ],
        [
          "HookOn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt64"
          }
        ],
        [
          "HookInstructionCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt64"
          }
        ],
        [
          "HookReturnCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt64"
          }
        ],
        [
          "ReferenceCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt64"
          }
        ],
        [
          "XChainClaimID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountCreateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountClaimCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt64"
          }
        ],
        [
          "AssetPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt64"
          }
        ],
        [
          "MaximumAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt64"
          }
        ],
        [
          "OutstandingAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt64"
          }
        ],
        [
          "MPTAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt64"
          }
        ],
        [
          "IssuerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "UInt64"
          }
        ],
        [
          "SubjectNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "UInt64"
          }
        ],
        [
          "LockedAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "UInt64"
          }
        ],
        [
          "VaultNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "UInt64"
          }
        ],
        [
          "LoanBrokerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "UInt64"
          }
        ],
        [
          "EmailHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash128"
          }
        ],
        [
          "LedgerHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash256"
          }
        ],
        [
          "ParentHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash256"
          }
        ],
        [
          "TransactionHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash256"
          }
        ],
        [
          "AccountHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash256"
          }
        ],
        [
          "PreviousTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Hash256"
          }
        ],
        [
          "LedgerIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Hash256"
          }
        ],
        [
          "WalletLocator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Hash256"
          }
        ],
        [
          "RootIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Hash256"
          }
        ],
        [
          "AccountTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Hash256"
          }
        ],
        [
          "NFTokenID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Hash256"
          }
        ],
        [
          "EmitParentTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Hash256"
          }
        ],
        [
          "EmitNonce",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Hash256"
          }
        ],
        [
          "EmitHookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Hash256"
          }
        ],
        [
          "AMMID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "Hash256"
          }
        ],
        [
          "BookDirectory",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Hash256"
          }
        ],
        [
          "InvoiceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Hash256"
          }
        ],
        [
          "Nickname",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Hash256"
          }
        ],
        [
          "Amendment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Hash256"
          }
        ],
        [
          "Digest",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "Hash256"
          }
        ],
        [
          "Channel",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Hash256"
          }
        ],
        [
          "ConsensusHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Hash256"
          }
        ],
        [
          "CheckID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Hash256"
          }
        ],
        [
          "ValidatedHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Hash256"
          }
        ],
        [
          "PreviousPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Hash256"
          }
        ],
        [
          "NextPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Hash256"
          }
        ],
        [
          "NFTokenBuyOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Hash256"
          }
        ],
        [
          "NFTokenSellOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Hash256"
          }
        ],
        [
          "HookStateKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Hash256"
          }
        ],
        [
          "HookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Hash256"
          }
        ],
        [
          "HookNamespace",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "Hash256"
          }
        ],
        [
          "HookSetTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "Hash256"
          }
        ],
        [
          "DomainID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "Hash256"
          }
        ],
        [
          "VaultID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "Hash256"
          }
        ],
        [
          "ParentBatchID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "Hash256"
          }
        ],
        [
          "LoanBrokerID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 37,
            type: "Hash256"
          }
        ],
        [
          "LoanID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 38,
            type: "Hash256"
          }
        ],
        [
          "hash",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Hash256"
          }
        ],
        [
          "index",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Hash256"
          }
        ],
        [
          "Amount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Amount"
          }
        ],
        [
          "Balance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Amount"
          }
        ],
        [
          "LimitAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Amount"
          }
        ],
        [
          "TakerPays",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Amount"
          }
        ],
        [
          "TakerGets",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Amount"
          }
        ],
        [
          "LowLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Amount"
          }
        ],
        [
          "HighLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Amount"
          }
        ],
        [
          "Fee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Amount"
          }
        ],
        [
          "SendMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Amount"
          }
        ],
        [
          "DeliverMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Amount"
          }
        ],
        [
          "Amount2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Amount"
          }
        ],
        [
          "BidMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Amount"
          }
        ],
        [
          "BidMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Amount"
          }
        ],
        [
          "MinimumOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Amount"
          }
        ],
        [
          "RippleEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Amount"
          }
        ],
        [
          "DeliveredAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Amount"
          }
        ],
        [
          "NFTokenBrokerFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Amount"
          }
        ],
        [
          "BaseFeeDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Amount"
          }
        ],
        [
          "ReserveBaseDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Amount"
          }
        ],
        [
          "ReserveIncrementDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Amount"
          }
        ],
        [
          "LPTokenOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Amount"
          }
        ],
        [
          "LPTokenIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Amount"
          }
        ],
        [
          "EPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Amount"
          }
        ],
        [
          "Price",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Amount"
          }
        ],
        [
          "SignatureReward",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Amount"
          }
        ],
        [
          "MinAccountCreateAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Amount"
          }
        ],
        [
          "LPTokenBalance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Amount"
          }
        ],
        [
          "PublicKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Blob"
          }
        ],
        [
          "MessageKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Blob"
          }
        ],
        [
          "SigningPubKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Blob"
          }
        ],
        [
          "TxnSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 4,
            type: "Blob"
          }
        ],
        [
          "URI",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "Blob"
          }
        ],
        [
          "Signature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 6,
            type: "Blob"
          }
        ],
        [
          "Domain",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 7,
            type: "Blob"
          }
        ],
        [
          "FundCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "Blob"
          }
        ],
        [
          "RemoveCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "Blob"
          }
        ],
        [
          "ExpireCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "Blob"
          }
        ],
        [
          "CreateCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "Blob"
          }
        ],
        [
          "MemoType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 12,
            type: "Blob"
          }
        ],
        [
          "MemoData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 13,
            type: "Blob"
          }
        ],
        [
          "MemoFormat",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 14,
            type: "Blob"
          }
        ],
        [
          "Fulfillment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "Blob"
          }
        ],
        [
          "Condition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 17,
            type: "Blob"
          }
        ],
        [
          "MasterSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 18,
            type: "Blob"
          }
        ],
        [
          "UNLModifyValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "Blob"
          }
        ],
        [
          "ValidatorToDisable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "Blob"
          }
        ],
        [
          "ValidatorToReEnable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "Blob"
          }
        ],
        [
          "HookStateData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "Blob"
          }
        ],
        [
          "HookReturnString",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "Blob"
          }
        ],
        [
          "HookParameterName",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 24,
            type: "Blob"
          }
        ],
        [
          "HookParameterValue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 25,
            type: "Blob"
          }
        ],
        [
          "DIDDocument",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 26,
            type: "Blob"
          }
        ],
        [
          "Data",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 27,
            type: "Blob"
          }
        ],
        [
          "AssetClass",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 28,
            type: "Blob"
          }
        ],
        [
          "Provider",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 29,
            type: "Blob"
          }
        ],
        [
          "MPTokenMetadata",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 30,
            type: "Blob"
          }
        ],
        [
          "CredentialType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 31,
            type: "Blob"
          }
        ],
        [
          "Account",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "AccountID"
          }
        ],
        [
          "Owner",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "AccountID"
          }
        ],
        [
          "Destination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "AccountID"
          }
        ],
        [
          "Issuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "AccountID"
          }
        ],
        [
          "Authorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "AccountID"
          }
        ],
        [
          "Unauthorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 6,
            type: "AccountID"
          }
        ],
        [
          "RegularKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "AccountID"
          }
        ],
        [
          "NFTokenMinter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "AccountID"
          }
        ],
        [
          "EmitCallback",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "AccountID"
          }
        ],
        [
          "Holder",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "AccountID"
          }
        ],
        [
          "Delegate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 12,
            type: "AccountID"
          }
        ],
        [
          "HookAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "AccountID"
          }
        ],
        [
          "OtherChainSource",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 18,
            type: "AccountID"
          }
        ],
        [
          "OtherChainDestination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "AccountID"
          }
        ],
        [
          "AttestationSignerAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "AccountID"
          }
        ],
        [
          "AttestationRewardAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "AccountID"
          }
        ],
        [
          "LockingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "AccountID"
          }
        ],
        [
          "IssuingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "AccountID"
          }
        ],
        [
          "Subject",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 24,
            type: "AccountID"
          }
        ],
        [
          "Borrower",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 25,
            type: "AccountID"
          }
        ],
        [
          "Counterparty",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 26,
            type: "AccountID"
          }
        ],
        [
          "Number",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Number"
          }
        ],
        [
          "AssetsAvailable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Number"
          }
        ],
        [
          "AssetsMaximum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Number"
          }
        ],
        [
          "AssetsTotal",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Number"
          }
        ],
        [
          "LossUnrealized",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Number"
          }
        ],
        [
          "DebtTotal",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Number"
          }
        ],
        [
          "DebtMaximum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Number"
          }
        ],
        [
          "CoverAvailable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Number"
          }
        ],
        [
          "LoanOriginationFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Number"
          }
        ],
        [
          "LoanServiceFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Number"
          }
        ],
        [
          "LatePaymentFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Number"
          }
        ],
        [
          "ClosePaymentFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Number"
          }
        ],
        [
          "PrincipalOutstanding",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Number"
          }
        ],
        [
          "PrincipalRequested",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "Number"
          }
        ],
        [
          "TotalValueOutstanding",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "Number"
          }
        ],
        [
          "PeriodicPayment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Number"
          }
        ],
        [
          "ManagementFeeOutstanding",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Number"
          }
        ],
        [
          "LoanScale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Int32"
          }
        ],
        [
          "TransactionMetaData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "STObject"
          }
        ],
        [
          "CreatedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "STObject"
          }
        ],
        [
          "DeletedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STObject"
          }
        ],
        [
          "ModifiedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STObject"
          }
        ],
        [
          "PreviousFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STObject"
          }
        ],
        [
          "FinalFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STObject"
          }
        ],
        [
          "NewFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STObject"
          }
        ],
        [
          "TemplateEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STObject"
          }
        ],
        [
          "Memo",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STObject"
          }
        ],
        [
          "SignerEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STObject"
          }
        ],
        [
          "NFToken",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STObject"
          }
        ],
        [
          "EmitDetails",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "STObject"
          }
        ],
        [
          "Hook",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "STObject"
          }
        ],
        [
          "Permission",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "STObject"
          }
        ],
        [
          "Signer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STObject"
          }
        ],
        [
          "Majority",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STObject"
          }
        ],
        [
          "DisabledValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STObject"
          }
        ],
        [
          "EmittedTxn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STObject"
          }
        ],
        [
          "HookExecution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STObject"
          }
        ],
        [
          "HookDefinition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STObject"
          }
        ],
        [
          "HookParameter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "STObject"
          }
        ],
        [
          "HookGrant",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STObject"
          }
        ],
        [
          "VoteEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STObject"
          }
        ],
        [
          "AuctionSlot",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "STObject"
          }
        ],
        [
          "AuthAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "STObject"
          }
        ],
        [
          "XChainClaimProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "STObject"
          }
        ],
        [
          "XChainClaimAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "STObject"
          }
        ],
        [
          "PriceData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "STObject"
          }
        ],
        [
          "Credential",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "STObject"
          }
        ],
        [
          "RawTransaction",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "STObject"
          }
        ],
        [
          "BatchSigner",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "STObject"
          }
        ],
        [
          "Book",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "STObject"
          }
        ],
        [
          "CounterpartySignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 37,
            type: "STObject"
          }
        ],
        [
          "Signers",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 3,
            type: "STArray"
          }
        ],
        [
          "SignerEntries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STArray"
          }
        ],
        [
          "Template",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STArray"
          }
        ],
        [
          "Necessary",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STArray"
          }
        ],
        [
          "Sufficient",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STArray"
          }
        ],
        [
          "AffectedNodes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STArray"
          }
        ],
        [
          "Memos",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STArray"
          }
        ],
        [
          "NFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STArray"
          }
        ],
        [
          "Hooks",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STArray"
          }
        ],
        [
          "VoteSlots",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STArray"
          }
        ],
        [
          "AdditionalBooks",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "STArray"
          }
        ],
        [
          "Majorities",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STArray"
          }
        ],
        [
          "DisabledValidators",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "STArray"
          }
        ],
        [
          "HookExecutions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STArray"
          }
        ],
        [
          "HookParameters",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STArray"
          }
        ],
        [
          "HookGrants",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STArray"
          }
        ],
        [
          "XChainClaimAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STArray"
          }
        ],
        [
          "XChainCreateAccountAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STArray"
          }
        ],
        [
          "PriceDataSeries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STArray"
          }
        ],
        [
          "AuthAccounts",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STArray"
          }
        ],
        [
          "AuthorizeCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "STArray"
          }
        ],
        [
          "UnauthorizeCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "STArray"
          }
        ],
        [
          "AcceptedCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "STArray"
          }
        ],
        [
          "Permissions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "STArray"
          }
        ],
        [
          "RawTransactions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "STArray"
          }
        ],
        [
          "BatchSigners",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 31,
            type: "STArray"
          }
        ],
        [
          "CloseResolution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt8"
          }
        ],
        [
          "Method",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt8"
          }
        ],
        [
          "TransactionResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt8"
          }
        ],
        [
          "Scale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt8"
          }
        ],
        [
          "AssetScale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt8"
          }
        ],
        [
          "TickSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt8"
          }
        ],
        [
          "UNLModifyDisabling",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt8"
          }
        ],
        [
          "HookResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt8"
          }
        ],
        [
          "WasLockingChainSend",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt8"
          }
        ],
        [
          "WithdrawalPolicy",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt8"
          }
        ],
        [
          "TakerPaysCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash160"
          }
        ],
        [
          "TakerPaysIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash160"
          }
        ],
        [
          "Paths",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "PathSet"
          }
        ],
        [
          "Indexes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Vector256"
          }
        ],
        [
          "Hashes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Vector256"
          }
        ],
        [
          "Amendments",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Vector256"
          }
        ],
        [
          "NFTokenOffers",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "Vector256"
          }
        ],
        [
          "CredentialIDs",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "Vector256"
          }
        ],
        [
          "MPTokenIssuanceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash192"
          }
        ],
        [
          "ShareMPTID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash192"
          }
        ],
        [
          "LockingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Issue"
          }
        ],
        [
          "IssuingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Issue"
          }
        ],
        [
          "Asset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Issue"
          }
        ],
        [
          "Asset2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Issue"
          }
        ],
        [
          "XChainBridge",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "XChainBridge"
          }
        ],
        [
          "BaseAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Currency"
          }
        ],
        [
          "QuoteAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Currency"
          }
        ],
        [
          "Transaction",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Transaction"
          }
        ],
        [
          "LedgerEntry",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "LedgerEntry"
          }
        ],
        [
          "Validation",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Validation"
          }
        ],
        [
          "Metadata",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Metadata"
          }
        ]
      ],
      LEDGER_ENTRY_TYPES: {
        AMM: 121,
        AccountRoot: 97,
        Amendments: 102,
        Bridge: 105,
        Check: 67,
        Credential: 129,
        DID: 73,
        Delegate: 131,
        DepositPreauth: 112,
        DirectoryNode: 100,
        Escrow: 117,
        FeeSettings: 115,
        Invalid: -1,
        LedgerHashes: 104,
        Loan: 137,
        LoanBroker: 136,
        MPToken: 127,
        MPTokenIssuance: 126,
        NFTokenOffer: 55,
        NFTokenPage: 80,
        NegativeUNL: 78,
        Offer: 111,
        Oracle: 128,
        PayChannel: 120,
        PermissionedDomain: 130,
        RippleState: 114,
        SignerList: 83,
        Ticket: 84,
        Vault: 132,
        XChainOwnedClaimID: 113,
        XChainOwnedCreateAccountClaimID: 116
      },
      TRANSACTION_RESULTS: {
        tecAMM_ACCOUNT: 168,
        tecAMM_BALANCE: 163,
        tecAMM_EMPTY: 166,
        tecAMM_FAILED: 164,
        tecAMM_INVALID_TOKENS: 165,
        tecAMM_NOT_EMPTY: 167,
        tecARRAY_EMPTY: 190,
        tecARRAY_TOO_LARGE: 191,
        tecBAD_CREDENTIALS: 193,
        tecCANT_ACCEPT_OWN_NFTOKEN_OFFER: 158,
        tecCLAIM: 100,
        tecCRYPTOCONDITION_ERROR: 146,
        tecDIR_FULL: 121,
        tecDST_TAG_NEEDED: 143,
        tecDUPLICATE: 149,
        tecEMPTY_DID: 187,
        tecEXPIRED: 148,
        tecFAILED_PROCESSING: 105,
        tecFROZEN: 137,
        tecHAS_OBLIGATIONS: 151,
        tecHOOK_REJECTED: 153,
        tecINCOMPLETE: 169,
        tecINSUFFICIENT_FUNDS: 159,
        tecINSUFFICIENT_PAYMENT: 161,
        tecINSUFFICIENT_RESERVE: 141,
        tecINSUFF_FEE: 136,
        tecINSUF_RESERVE_LINE: 122,
        tecINSUF_RESERVE_OFFER: 123,
        tecINTERNAL: 144,
        tecINVALID_UPDATE_TIME: 188,
        tecINVARIANT_FAILED: 147,
        tecKILLED: 150,
        tecLIMIT_EXCEEDED: 195,
        tecLOCKED: 192,
        tecMAX_SEQUENCE_REACHED: 154,
        tecNEED_MASTER_KEY: 142,
        tecNFTOKEN_BUY_SELL_MISMATCH: 156,
        tecNFTOKEN_OFFER_TYPE_MISMATCH: 157,
        tecNO_ALTERNATIVE_KEY: 130,
        tecNO_AUTH: 134,
        tecNO_DELEGATE_PERMISSION: 198,
        tecNO_DST: 124,
        tecNO_DST_INSUF_XRP: 125,
        tecNO_ENTRY: 140,
        tecNO_ISSUER: 133,
        tecNO_LINE: 135,
        tecNO_LINE_INSUF_RESERVE: 126,
        tecNO_LINE_REDUNDANT: 127,
        tecNO_PERMISSION: 139,
        tecNO_REGULAR_KEY: 131,
        tecNO_SUITABLE_NFTOKEN_PAGE: 155,
        tecNO_TARGET: 138,
        tecOBJECT_NOT_FOUND: 160,
        tecOVERSIZE: 145,
        tecOWNERS: 132,
        tecPATH_DRY: 128,
        tecPATH_PARTIAL: 101,
        tecPRECISION_LOSS: 197,
        tecPSEUDO_ACCOUNT: 196,
        tecTOKEN_PAIR_NOT_FOUND: 189,
        tecTOO_SOON: 152,
        tecUNFUNDED: 129,
        tecUNFUNDED_ADD: 102,
        tecUNFUNDED_AMM: 162,
        tecUNFUNDED_OFFER: 103,
        tecUNFUNDED_PAYMENT: 104,
        tecWRONG_ASSET: 194,
        tecXCHAIN_ACCOUNT_CREATE_PAST: 181,
        tecXCHAIN_ACCOUNT_CREATE_TOO_MANY: 182,
        tecXCHAIN_BAD_CLAIM_ID: 172,
        tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR: 185,
        tecXCHAIN_BAD_TRANSFER_ISSUE: 170,
        tecXCHAIN_CLAIM_NO_QUORUM: 173,
        tecXCHAIN_CREATE_ACCOUNT_DISABLED: 186,
        tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE: 175,
        tecXCHAIN_INSUFF_CREATE_AMOUNT: 180,
        tecXCHAIN_NO_CLAIM_ID: 171,
        tecXCHAIN_NO_SIGNERS_LIST: 178,
        tecXCHAIN_PAYMENT_FAILED: 183,
        tecXCHAIN_PROOF_UNKNOWN_KEY: 174,
        tecXCHAIN_REWARD_MISMATCH: 177,
        tecXCHAIN_SELF_COMMIT: 184,
        tecXCHAIN_SENDING_ACCOUNT_MISMATCH: 179,
        tecXCHAIN_WRONG_CHAIN: 176,
        tefALREADY: -198,
        tefBAD_ADD_AUTH: -197,
        tefBAD_AUTH: -196,
        tefBAD_AUTH_MASTER: -183,
        tefBAD_LEDGER: -195,
        tefBAD_QUORUM: -185,
        tefBAD_SIGNATURE: -186,
        tefCREATED: -194,
        tefEXCEPTION: -193,
        tefFAILURE: -199,
        tefINTERNAL: -192,
        tefINVALID_LEDGER_FIX_TYPE: -178,
        tefINVARIANT_FAILED: -182,
        tefMASTER_DISABLED: -188,
        tefMAX_LEDGER: -187,
        tefNFTOKEN_IS_NOT_TRANSFERABLE: -179,
        tefNOT_MULTI_SIGNING: -184,
        tefNO_AUTH_REQUIRED: -191,
        tefNO_TICKET: -180,
        tefPAST_SEQ: -190,
        tefTOO_BIG: -181,
        tefWRONG_PRIOR: -189,
        telBAD_DOMAIN: -398,
        telBAD_PATH_COUNT: -397,
        telBAD_PUBLIC_KEY: -396,
        telCAN_NOT_QUEUE: -392,
        telCAN_NOT_QUEUE_BALANCE: -391,
        telCAN_NOT_QUEUE_BLOCKED: -389,
        telCAN_NOT_QUEUE_BLOCKS: -390,
        telCAN_NOT_QUEUE_FEE: -388,
        telCAN_NOT_QUEUE_FULL: -387,
        telENV_RPC_FAILED: -383,
        telFAILED_PROCESSING: -395,
        telINSUF_FEE_P: -394,
        telLOCAL_ERROR: -399,
        telNETWORK_ID_MAKES_TX_NON_CANONICAL: -384,
        telNO_DST_PARTIAL: -393,
        telREQUIRES_NETWORK_ID: -385,
        telWRONG_NETWORK: -386,
        temARRAY_EMPTY: -253,
        temARRAY_TOO_LARGE: -252,
        temBAD_AMM_TOKENS: -261,
        temBAD_AMOUNT: -298,
        temBAD_CURRENCY: -297,
        temBAD_EXPIRATION: -296,
        temBAD_FEE: -295,
        temBAD_ISSUER: -294,
        temBAD_LIMIT: -293,
        temBAD_NFTOKEN_TRANSFER_FEE: -262,
        temBAD_OFFER: -292,
        temBAD_PATH: -291,
        temBAD_PATH_LOOP: -290,
        temBAD_QUORUM: -271,
        temBAD_REGKEY: -289,
        temBAD_SEND_XRP_LIMIT: -288,
        temBAD_SEND_XRP_MAX: -287,
        temBAD_SEND_XRP_NO_DIRECT: -286,
        temBAD_SEND_XRP_PARTIAL: -285,
        temBAD_SEND_XRP_PATHS: -284,
        temBAD_SEQUENCE: -283,
        temBAD_SIGNATURE: -282,
        temBAD_SIGNER: -272,
        temBAD_SRC_ACCOUNT: -281,
        temBAD_TICK_SIZE: -269,
        temBAD_TRANSFER_FEE: -251,
        temBAD_TRANSFER_RATE: -280,
        temBAD_WEIGHT: -270,
        temCANNOT_PREAUTH_SELF: -267,
        temDISABLED: -273,
        temDST_IS_SRC: -279,
        temDST_NEEDED: -278,
        temEMPTY_DID: -254,
        temINVALID: -277,
        temINVALID_ACCOUNT_ID: -268,
        temINVALID_COUNT: -266,
        temINVALID_FLAG: -276,
        temINVALID_INNER_BATCH: -250,
        temMALFORMED: -299,
        temREDUNDANT: -275,
        temRIPPLE_EMPTY: -274,
        temSEQ_AND_TICKET: -263,
        temUNCERTAIN: -265,
        temUNKNOWN: -264,
        temXCHAIN_BAD_PROOF: -259,
        temXCHAIN_BRIDGE_BAD_ISSUES: -258,
        temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT: -256,
        temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT: -255,
        temXCHAIN_BRIDGE_NONDOOR_OWNER: -257,
        temXCHAIN_EQUAL_DOOR_ACCOUNTS: -260,
        terADDRESS_COLLISION: -86,
        terFUNDS_SPENT: -98,
        terINSUF_FEE_B: -97,
        terLAST: -91,
        terNO_ACCOUNT: -96,
        terNO_AMM: -87,
        terNO_AUTH: -95,
        terNO_DELEGATE_PERMISSION: -85,
        terNO_LINE: -94,
        terNO_RIPPLE: -90,
        terOWNERS: -93,
        terPRE_SEQ: -92,
        terPRE_TICKET: -88,
        terQUEUED: -89,
        terRETRY: -99,
        tesSUCCESS: 0
      },
      TRANSACTION_TYPES: {
        AMMBid: 39,
        AMMClawback: 31,
        AMMCreate: 35,
        AMMDelete: 40,
        AMMDeposit: 36,
        AMMVote: 38,
        AMMWithdraw: 37,
        AccountDelete: 21,
        AccountSet: 3,
        Batch: 71,
        CheckCancel: 18,
        CheckCash: 17,
        CheckCreate: 16,
        Clawback: 30,
        CredentialAccept: 59,
        CredentialCreate: 58,
        CredentialDelete: 60,
        DIDDelete: 50,
        DIDSet: 49,
        DelegateSet: 64,
        DepositPreauth: 19,
        EnableAmendment: 100,
        EscrowCancel: 4,
        EscrowCreate: 1,
        EscrowFinish: 2,
        Invalid: -1,
        LedgerStateFix: 53,
        LoanBrokerCoverClawback: 78,
        LoanBrokerCoverDeposit: 76,
        LoanBrokerCoverWithdraw: 77,
        LoanBrokerDelete: 75,
        LoanBrokerSet: 74,
        LoanDelete: 81,
        LoanManage: 82,
        LoanPay: 84,
        LoanSet: 80,
        MPTokenAuthorize: 57,
        MPTokenIssuanceCreate: 54,
        MPTokenIssuanceDestroy: 55,
        MPTokenIssuanceSet: 56,
        NFTokenAcceptOffer: 29,
        NFTokenBurn: 26,
        NFTokenCancelOffer: 28,
        NFTokenCreateOffer: 27,
        NFTokenMint: 25,
        NFTokenModify: 61,
        OfferCancel: 8,
        OfferCreate: 7,
        OracleDelete: 52,
        OracleSet: 51,
        Payment: 0,
        PaymentChannelClaim: 15,
        PaymentChannelCreate: 13,
        PaymentChannelFund: 14,
        PermissionedDomainDelete: 63,
        PermissionedDomainSet: 62,
        SetFee: 101,
        SetRegularKey: 5,
        SignerListSet: 12,
        TicketCreate: 10,
        TrustSet: 20,
        UNLModify: 102,
        VaultClawback: 70,
        VaultCreate: 65,
        VaultDelete: 67,
        VaultDeposit: 68,
        VaultSet: 66,
        VaultWithdraw: 69,
        XChainAccountCreateCommit: 44,
        XChainAddAccountCreateAttestation: 46,
        XChainAddClaimAttestation: 45,
        XChainClaim: 43,
        XChainCommit: 42,
        XChainCreateBridge: 48,
        XChainCreateClaimID: 41,
        XChainModifyBridge: 47
      },
      TYPES: {
        AccountID: 8,
        Amount: 6,
        Blob: 7,
        Currency: 26,
        Done: -1,
        Hash128: 4,
        Hash160: 17,
        Hash192: 21,
        Hash256: 5,
        Int32: 10,
        Int64: 11,
        Issue: 24,
        LedgerEntry: 10002,
        Metadata: 10004,
        NotPresent: 0,
        Number: 9,
        PathSet: 18,
        STArray: 15,
        STObject: 14,
        Transaction: 10001,
        UInt16: 1,
        UInt32: 2,
        UInt384: 22,
        UInt512: 23,
        UInt64: 3,
        UInt8: 16,
        UInt96: 20,
        Unknown: -2,
        Validation: 10003,
        Vector256: 19,
        XChainBridge: 25
      }
    };
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = void 0;
    var Bytes = class {
      constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = new Uint8Array(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
          this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 255;
        }
      }
      toJSON() {
        return this.name;
      }
      toBytesSink(sink) {
        sink.put(this.bytes);
      }
      toBytes() {
        return this.bytes;
      }
    };
    exports.Bytes = Bytes;
    var BytesLookup = class {
      constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
          this.add(k, v);
        });
      }
      /**
       * Add a new name value pair to the BytesLookup.
       *
       * @param name - A human readable name for the field.
       * @param value - The numeric value for the field.
       * @throws if the name or value already exist in the lookup because it's unclear how to decode.
       */
      add(name, value) {
        if (this[name]) {
          throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
          throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
      }
      from(value) {
        return value instanceof Bytes ? value : this[value];
      }
      fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
      }
    };
    exports.BytesLookup = BytesLookup;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js
var require_binary_serializer = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinarySerializer = exports.BytesList = void 0;
    var utils_1 = require_browser();
    var BytesList = class {
      constructor() {
        this.bytesArray = [];
      }
      /**
       * Get the total number of bytes in the BytesList
       *
       * @return the number of bytes
       */
      getLength() {
        return (0, utils_1.concat)(this.bytesArray).byteLength;
      }
      /**
       * Put bytes in the BytesList
       *
       * @param bytesArg A Uint8Array
       * @return this BytesList
       */
      put(bytesArg) {
        const bytes = Uint8Array.from(bytesArg);
        this.bytesArray.push(bytes);
        return this;
      }
      /**
       * Write this BytesList to the back of another bytes list
       *
       *  @param list The BytesList to write to
       */
      toBytesSink(list) {
        list.put(this.toBytes());
      }
      toBytes() {
        return (0, utils_1.concat)(this.bytesArray);
      }
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
    };
    exports.BytesList = BytesList;
    var BinarySerializer = class {
      constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
      }
      /**
       * Write a value to this BinarySerializer
       *
       * @param value a SerializedType value
       */
      write(value) {
        value.toBytesSink(this.sink);
      }
      /**
       * Write bytes to this BinarySerializer
       *
       * @param bytes the bytes to write
       */
      put(bytes) {
        this.sink.put(bytes);
      }
      /**
       * Write a value of a given type to this BinarySerializer
       *
       * @param type the type to write
       * @param value a value of that type
       */
      writeType(type, value) {
        this.write(type.from(value));
      }
      /**
       * Write BytesList to this BinarySerializer
       *
       * @param bl BytesList to write to BinarySerializer
       */
      writeBytesList(bl) {
        bl.toBytesSink(this.sink);
      }
      /**
       * Calculate the header of Variable Length encoded bytes
       *
       * @param length the length of the bytes
       */
      encodeVariableLength(length) {
        const lenBytes = new Uint8Array(3);
        if (length <= 192) {
          lenBytes[0] = length;
          return lenBytes.slice(0, 1);
        } else if (length <= 12480) {
          length -= 193;
          lenBytes[0] = 193 + (length >>> 8);
          lenBytes[1] = length & 255;
          return lenBytes.slice(0, 2);
        } else if (length <= 918744) {
          length -= 12481;
          lenBytes[0] = 241 + (length >>> 16);
          lenBytes[1] = length >> 8 & 255;
          lenBytes[2] = length & 255;
          return lenBytes.slice(0, 3);
        }
        throw new Error("Overflow error");
      }
      /**
       * Write field and value to BinarySerializer
       *
       * @param field field to write to BinarySerializer
       * @param value value to write to BinarySerializer
       */
      writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        if (associatedValue.toBytesSink === void 0 || field.name === void 0) {
          throw new Error();
        }
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
          this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        } else {
          associatedValue.toBytesSink(this.sink);
        }
      }
      /**
       * Write a variable length encoded value to the BinarySerializer
       *
       * @param value length encoded value to write to BytesList
       */
      writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
          value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
      }
    };
    exports.BinarySerializer = BinarySerializer;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/serialized-type.js
var require_serialized_type = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/serialized-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comparable = exports.SerializedType = void 0;
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_browser();
    var SerializedType = class {
      constructor(bytes) {
        this.bytes = new Uint8Array(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);
      }
      static fromParser(parser, hint) {
        throw new Error("fromParser not implemented");
        return this.fromParser(parser, hint);
      }
      static from(value) {
        throw new Error("from not implemented");
        return this.from(value);
      }
      /**
       * Write the bytes representation of a SerializedType to a BytesList
       *
       * @param list The BytesList to write SerializedType bytes to
       */
      toBytesSink(list) {
        list.put(this.bytes);
      }
      /**
       * Get the hex representation of a SerializedType's bytes
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
      /**
       * Get the bytes representation of a SerializedType
       *
       * @returns A Uint8Array of the bytes
       */
      toBytes() {
        if (this.bytes) {
          return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
      }
      /**
       * Return the JSON representation of a SerializedType
       *
       * @param _definitions rippled definitions used to parse the values of transaction types and such.
       *                          Unused in default, but used in STObject, STArray
       *                          Can be customized for sidechains and amendments.
       * @returns any type, if not overloaded returns hexString representation of bytes
       */
      toJSON(_definitions, _fieldName) {
        return this.toHex();
      }
      /**
       * @returns hexString representation of this.bytes
       */
      toString() {
        return this.toHex();
      }
    };
    exports.SerializedType = SerializedType;
    var Comparable = class extends SerializedType {
      lt(other) {
        return this.compareTo(other) < 0;
      }
      eq(other) {
        return this.compareTo(other) === 0;
      }
      gt(other) {
        return this.compareTo(other) > 0;
      }
      gte(other) {
        return this.compareTo(other) > -1;
      }
      lte(other) {
        return this.compareTo(other) < 1;
      }
      /**
       * Overload this method to define how two Comparable SerializedTypes are compared
       *
       * @param other The comparable object to compare this to
       * @returns A number denoting the relationship of this and other
       */
      compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
      }
    };
    exports.Comparable = Comparable;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DELEGATABLE_PERMISSIONS_WIDTH = exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
    exports.TYPE_WIDTH = 2;
    exports.LEDGER_ENTRY_WIDTH = 2;
    exports.TRANSACTION_TYPE_WIDTH = 2;
    exports.TRANSACTION_RESULT_WIDTH = 1;
    exports.DELEGATABLE_PERMISSIONS_WIDTH = 4;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/field.js
var require_field = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/field.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldLookup = void 0;
    var bytes_1 = require_bytes2();
    var serialized_type_1 = require_serialized_type();
    var constants_1 = require_constants3();
    function fieldHeader(type, nth) {
      const header = [];
      if (type < 16) {
        if (nth < 16) {
          header.push(type << 4 | nth);
        } else {
          header.push(type << 4, nth);
        }
      } else if (nth < 16) {
        header.push(nth, type);
      } else {
        header.push(0, type, nth);
      }
      return Uint8Array.from(header);
    }
    function buildField([name, info], typeOrdinal) {
      const field = fieldHeader(typeOrdinal, info.nth);
      return {
        name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: typeOrdinal << 16 | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType
        // For later assignment in ./types/index.js or Definitions.updateAll(...)
      };
    }
    var FieldLookup = class {
      constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
          const typeOrdinal = types[field_info.type];
          this[name] = buildField([name, field_info], typeOrdinal);
          this[this[name].ordinal.toString()] = this[name];
        });
      }
      fromString(value) {
        return this[value];
      }
    };
    exports.FieldLookup = FieldLookup;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js
var require_xrpl_definitions_base = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
    var bytes_1 = require_bytes2();
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return bytes_1.Bytes;
    } });
    Object.defineProperty(exports, "BytesLookup", { enumerable: true, get: function() {
      return bytes_1.BytesLookup;
    } });
    var field_1 = require_field();
    Object.defineProperty(exports, "FieldLookup", { enumerable: true, get: function() {
      return field_1.FieldLookup;
    } });
    var constants_1 = require_constants3();
    var XrplDefinitionsBase = class {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`.
       * To generate a new definitions file from rippled source code, use the tool at
       * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param types - A list of type objects with the same name as the fields defined.
       *              You can use the coreTypes object if you are not adding new types.
       */
      constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES).filter(([_key, value]) => value >= 0).map(([key, _value]) => key);
        this.dataTypes = {};
        this.associateTypes(types);
        this.granularPermissions = {
          TrustlineAuthorize: 65537,
          TrustlineFreeze: 65538,
          TrustlineUnfreeze: 65539,
          AccountDomainSet: 65540,
          AccountEmailHashSet: 65541,
          AccountMessageKeySet: 65542,
          AccountTransferRateSet: 65543,
          AccountTickSizeSet: 65544,
          PaymentMint: 65545,
          PaymentBurn: 65546,
          MPTokenIssuanceLock: 65547,
          MPTokenIssuanceUnlock: 65548
        };
        const incrementedTransactionTypes = Object.fromEntries(Object.entries(enums.TRANSACTION_TYPES).map(([key, value]) => [
          key,
          value + 1
        ]));
        const combinedPermissions = Object.assign(Object.assign({}, this.granularPermissions), incrementedTransactionTypes);
        this.delegatablePermissions = new bytes_1.BytesLookup(combinedPermissions, constants_1.DELEGATABLE_PERMISSIONS_WIDTH);
      }
      /**
       * Associates each Field to a corresponding class that TypeScript can recognize.
       *
       * @param types a list of type objects with the same name as the fields defined.
       *              Defaults to xrpl.js's core type definitions.
       */
      associateTypes(types) {
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
          field.associatedType = this.dataTypes[field.type.name];
        });
        this.field["TransactionType"].associatedType = this.transactionType;
        this.field["TransactionResult"].associatedType = this.transactionResult;
        this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
        if (this.field["PermissionValue"]) {
          this.field["PermissionValue"].associatedType = this.delegatablePermissions;
        }
      }
      getAssociatedTypes() {
        return this.dataTypes;
      }
    };
    exports.XrplDefinitionsBase = XrplDefinitionsBase;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/index.js
var require_enums2 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
    var definitions_json_1 = __importDefault(require_definitions());
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.Bytes;
    } });
    var DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(definitions_json_1.default, {});
    exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
    var Type = DEFAULT_DEFINITIONS.type;
    exports.Type = Type;
    var LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
    exports.LedgerEntryType = LedgerEntryType;
    var TransactionType = DEFAULT_DEFINITIONS.transactionType;
    exports.TransactionType = TransactionType;
    var TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
    exports.TransactionResult = TransactionResult;
    var Field = DEFAULT_DEFINITIONS.field;
    exports.Field = Field;
    var TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
    exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compare = exports.equal = exports.readInt64BE = exports.readInt32BE = exports.readUInt32BE = exports.readUInt16BE = exports.writeInt64BE = exports.writeInt32BE = exports.writeUInt32BE = exports.writeUInt16BE = exports.writeUInt8 = void 0;
    function writeUInt8(array2, value, offset) {
      value = Number(value);
      array2[offset] = value;
    }
    exports.writeUInt8 = writeUInt8;
    function writeUInt16BE(array2, value, offset) {
      value = Number(value);
      array2[offset] = value >>> 8;
      array2[offset + 1] = value;
    }
    exports.writeUInt16BE = writeUInt16BE;
    function writeUInt32BE(array2, value, offset) {
      array2[offset] = value >>> 24 & 255;
      array2[offset + 1] = value >>> 16 & 255;
      array2[offset + 2] = value >>> 8 & 255;
      array2[offset + 3] = value & 255;
    }
    exports.writeUInt32BE = writeUInt32BE;
    function writeInt32BE(array2, value, offset) {
      new DataView(array2.buffer, array2.byteOffset, array2.byteLength).setInt32(offset, value, false);
    }
    exports.writeInt32BE = writeInt32BE;
    function writeInt64BE(array2, value, offset) {
      new DataView(array2.buffer, array2.byteOffset, array2.byteLength).setBigInt64(offset, value, false);
    }
    exports.writeInt64BE = writeInt64BE;
    function readUInt16BE(array2, offset) {
      return new DataView(array2.buffer).getUint16(offset, false).toString(10);
    }
    exports.readUInt16BE = readUInt16BE;
    function readUInt32BE(array2, offset) {
      return new DataView(array2.buffer).getUint32(offset, false).toString(10);
    }
    exports.readUInt32BE = readUInt32BE;
    function readInt32BE(array2, offset) {
      return new DataView(array2.buffer, array2.byteOffset, array2.byteLength).getInt32(offset, false);
    }
    exports.readInt32BE = readInt32BE;
    function readInt64BE(array2, offset) {
      return new DataView(array2.buffer, array2.byteOffset, array2.byteLength).getBigInt64(offset, false);
    }
    exports.readInt64BE = readInt64BE;
    function equal(a, b) {
      const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
      const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
      if (aUInt.byteLength != bUInt.byteLength)
        return false;
      if (aligned32(aUInt) && aligned32(bUInt))
        return compare32(aUInt, bUInt) === 0;
      if (aligned16(aUInt) && aligned16(bUInt))
        return compare16(aUInt, bUInt) === 0;
      return compare8(aUInt, bUInt) === 0;
    }
    exports.equal = equal;
    function compare8(a, b) {
      const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
      return compare(ua, ub);
    }
    function compare16(a, b) {
      const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
      return compare(ua, ub);
    }
    function compare32(a, b) {
      const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
      const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
      return compare(ua, ub);
    }
    function compare(a, b) {
      if (a.byteLength !== b.byteLength) {
        throw new Error("Cannot compare arrays of different length");
      }
      for (let i = 0; i < a.length - 1; i += 1) {
        if (a[i] > b[i])
          return 1;
        if (a[i] < b[i])
          return -1;
      }
      return 0;
    }
    exports.compare = compare;
    function aligned16(array2) {
      return array2.byteOffset % 2 === 0 && array2.byteLength % 2 === 0;
    }
    function aligned32(array2) {
      return array2.byteOffset % 4 === 0 && array2.byteLength % 4 === 0;
    }
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var Hash = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
        if (this.bytes.length !== this.constructor.width) {
          throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
      }
      /**
       * Construct a Hash object from an existing Hash object or a hex-string
       *
       * @param value A hash object or hex-string of a hash
       */
      static from(value) {
        if (value instanceof this) {
          return value;
        }
        if (typeof value === "string") {
          if (!utils_1.HEX_REGEX.test(value)) {
            throw new Error(`Invalid hash string ${value}`);
          }
          return new this((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Hash from given value");
      }
      /**
       * Read a Hash object from a BinaryParser
       *
       * @param parser BinaryParser to read the hash from
       * @param hint length of the bytes to read, optional
       */
      static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
      }
      /**
       * Overloaded operator for comparing two hash objects
       *
       * @param other The Hash to compare this to
       */
      compareTo(other) {
        return (0, utils_2.compare)(this.bytes, this.constructor.from(other).bytes);
      }
      /**
       * @returns the hex-string representation of this Hash
       */
      toString() {
        return this.toHex();
      }
      /**
       * Returns four bits at the specified depth within a hash
       *
       * @param depth The depth of the four bits
       * @returns The number represented by the four bits
       */
      nibblet(depth) {
        const byteIx = depth > 0 ? depth / 2 | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
          b = (b & 240) >>> 4;
        } else {
          b = b & 15;
        }
        return b;
      }
    };
    exports.Hash = Hash;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-160.js
var require_hash_160 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash160 = void 0;
    var hash_1 = require_hash();
    var Hash160 = class _Hash160 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash160.ZERO_160.bytes);
      }
    };
    exports.Hash160 = Hash160;
    Hash160.width = 20;
    Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/account-id.js
var require_account_id = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/account-id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountID = void 0;
    var ripple_address_codec_1 = require_dist2();
    var hash_160_1 = require_hash_160();
    var utils_1 = require_browser();
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var AccountID = class _AccountID extends hash_160_1.Hash160 {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _AccountID.defaultAccountID.bytes);
      }
      /**
       * Defines how to construct an AccountID
       *
       * @param value either an existing AccountID, a hex-string, or a base58 r-Address
       * @returns an AccountID object
       */
      static from(value) {
        if (value instanceof _AccountID) {
          return value;
        }
        if (typeof value === "string") {
          if (value === "") {
            return new _AccountID();
          }
          return HEX_REGEX.test(value) ? new _AccountID((0, utils_1.hexToBytes)(value)) : this.fromBase58(value);
        }
        throw new Error("Cannot construct AccountID from value given");
      }
      /**
       * Defines how to build an AccountID from a base58 r-Address
       *
       * @param value a base58 r-Address
       * @returns an AccountID object
       */
      static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
          const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
          if (classic.tag !== false)
            throw new Error("Only allowed to have tag on Account or Destination");
          value = classic.classicAddress;
        }
        return new _AccountID(Uint8Array.from((0, ripple_address_codec_1.decodeAccountID)(value)));
      }
      /**
       * Overload of toJSON
       *
       * @returns the base58 string for this AccountID
       */
      toJSON() {
        return this.toBase58();
      }
      /**
       * Defines how to encode AccountID into a base58 address
       *
       * @returns the base58 string defined by this.bytes
       */
      toBase58() {
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
      }
    };
    exports.AccountID = AccountID;
    AccountID.defaultAccountID = new AccountID(new Uint8Array(20));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js
var require_binary_parser = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryParser = void 0;
    var enums_1 = require_enums2();
    var utils_1 = require_browser();
    var BinaryParser = class {
      /**
       * Initialize bytes to a hex string
       *
       * @param hexBytes a hex string
       * @param definitions Rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       */
      constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = (0, utils_1.hexToBytes)(hexBytes);
        this.definitions = definitions;
      }
      /**
       * Peek the first byte of the BinaryParser
       *
       * @returns The first byte of the BinaryParser
       */
      peek() {
        if (this.bytes.byteLength === 0) {
          throw new Error();
        }
        return this.bytes[0];
      }
      /**
       * Consume the first n bytes of the BinaryParser
       *
       * @param n the number of bytes to skip
       */
      skip(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        this.bytes = this.bytes.slice(n);
      }
      /**
       * read the first n bytes from the BinaryParser
       *
       * @param n The number of bytes to read
       * @return The bytes
       */
      read(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
      }
      /**
       * Read an integer of given size
       *
       * @param n The number of bytes to read
       * @return The number represented by those bytes
       */
      readUIntN(n) {
        if (0 >= n || n > 4) {
          throw new Error("invalid n");
        }
        return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;
      }
      readUInt8() {
        return this.readUIntN(1);
      }
      readUInt16() {
        return this.readUIntN(2);
      }
      readUInt32() {
        return this.readUIntN(4);
      }
      size() {
        return this.bytes.byteLength;
      }
      end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || customEnd !== void 0 && length <= customEnd;
      }
      /**
       * Reads variable length encoded bytes
       *
       * @return The variable length bytes
       */
      readVariableLength() {
        return this.read(this.readVariableLengthLength());
      }
      /**
       * Reads the length of the variable length encoded bytes
       *
       * @return The length of the variable length encoded bytes
       */
      readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
          return b1;
        } else if (b1 <= 240) {
          const b2 = this.readUInt8();
          return 193 + (b1 - 193) * 256 + b2;
        } else if (b1 <= 254) {
          const b2 = this.readUInt8();
          const b3 = this.readUInt8();
          return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error("Invalid variable length indicator");
      }
      /**
       * Reads the field ordinal from the BinaryParser
       *
       * @return Field ordinal
       */
      readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
          type = this.readUInt8();
          if (type === 0 || type < 16) {
            throw new Error(`Cannot read FieldOrdinal, type_code ${type} out of range`);
          }
        }
        if (nth === 0) {
          nth = this.readUInt8();
          if (nth === 0 || nth < 16) {
            throw new Error(`Cannot read FieldOrdinal, field_code ${nth} out of range`);
          }
        }
        return type << 16 | nth;
      }
      /**
       * Read the field from the BinaryParser
       *
       * @return The field represented by the bytes at the head of the BinaryParser
       */
      readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
      }
      /**
       * Read a given type from the BinaryParser
       *
       * @param type The type that you want to read from the BinaryParser
       * @return The instance of that type read from the BinaryParser
       */
      readType(type) {
        return type.fromParser(this);
      }
      /**
       * Get the type associated with a given field
       *
       * @param field The field that you wan to get the type of
       * @return The type associated with the given field
       */
      typeForField(field) {
        return field.associatedType;
      }
      /**
       * Read value of the type specified by field from the BinaryParser
       *
       * @param field The field that you want to get the associated value for
       * @return The value associated with the given field
       */
      readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
          throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : void 0;
        const value = type.fromParser(this, sizeHint);
        if (value === void 0) {
          throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
      }
      /**
       * Get the next field and value from the BinaryParser
       *
       * @return The field and value
       */
      readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
      }
    };
    exports.BinaryParser = BinaryParser;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/currency.js
var require_currency = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/currency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Currency = void 0;
    var hash_160_1 = require_hash_160();
    var utils_1 = require_browser();
    var XRP_HEX_REGEX = /^0{40}$/;
    var ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
    function isoToBytes(iso) {
      const bytes = new Uint8Array(20);
      if (iso !== "XRP") {
        const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
      }
      return bytes;
    }
    function isIsoCode(iso) {
      return ISO_REGEX.test(iso);
    }
    function isoCodeFromHex(code) {
      const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));
      if (iso === "XRP") {
        return null;
      }
      if (isIsoCode(iso)) {
        return iso;
      }
      return null;
    }
    function isHex(hex) {
      return HEX_REGEX.test(hex);
    }
    function isStringRepresentation(input) {
      return input.length === 3 || isHex(input);
    }
    function isBytesArray(bytes) {
      return bytes.byteLength === 20;
    }
    function isValidRepresentation(input) {
      return input instanceof Uint8Array ? isBytesArray(input) : isStringRepresentation(input);
    }
    function bytesFromRepresentation(input) {
      if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
      }
      return input.length === 3 ? isoToBytes(input) : (0, utils_1.hexToBytes)(input);
    }
    var Currency = class _Currency extends hash_160_1.Hash160 {
      constructor(byteBuf) {
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : _Currency.XRP.bytes);
        const hex = (0, utils_1.bytesToHex)(this.bytes);
        if (XRP_HEX_REGEX.test(hex)) {
          this._iso = "XRP";
        } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
          this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        } else {
          this._iso = null;
        }
      }
      /**
       * Return the ISO code of this currency
       *
       * @returns ISO code if it exists, else null
       */
      iso() {
        return this._iso;
      }
      /**
       * Constructs a Currency object
       *
       * @param val Currency object or a string representation of a currency
       */
      static from(value) {
        if (value instanceof _Currency) {
          return value;
        }
        if (typeof value === "string") {
          return new _Currency(bytesFromRepresentation(value));
        }
        throw new Error("Cannot construct Currency from value given");
      }
      /**
       * Gets the JSON representation of a currency
       *
       * @returns JSON representation
       */
      toJSON() {
        const iso = this.iso();
        if (iso !== null) {
          return iso;
        }
        return (0, utils_1.bytesToHex)(this.bytes);
      }
    };
    exports.Currency = Currency;
    Currency.XRP = new Currency(new Uint8Array(20));
  }
});

// node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet2, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET2.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET2.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet2.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER2 || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET2 = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET: ALPHABET2
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = (function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        })();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ (function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet2.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet2, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet2.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet2.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet2.charAt(0));
            }
            return str;
          };
        })();
        div = /* @__PURE__ */ (function() {
          function multiply(x, k, base2) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base2 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base2;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base2) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base2 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base2) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base2) {
              base2 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base2 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base2);
                xc = multiply(xc, n, base2);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base2 / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base2) n = base2 - 1;
                    prod = multiply(yc, n, base2);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base2);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base2);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base2);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base2 == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        })();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ (function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base2, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base2 ? p1 : m;
                });
                if (b) {
                  base2 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base2);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        })();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base2, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base2 = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base2 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base2;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET2.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-192.js
var require_hash_192 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-192.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash192 = void 0;
    var hash_1 = require_hash();
    var Hash192 = class _Hash192 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash192.ZERO_192.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash192.ZERO_192.bytes);
      }
    };
    exports.Hash192 = Hash192;
    Hash192.width = 24;
    Hash192.ZERO_192 = new Hash192(new Uint8Array(Hash192.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/amount.js
var require_amount = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/amount.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Amount = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var hash_192_1 = require_hash_192();
    var MIN_IOU_EXPONENT = -96;
    var MAX_IOU_EXPONENT = 80;
    var MAX_IOU_PRECISION = 16;
    var MAX_DROPS = new bignumber_js_1.default("1e17");
    var MIN_XRP = new bignumber_js_1.default("1e-6");
    var mask = BigInt(4294967295);
    var mptMask = BigInt(9223372036854776e3);
    bignumber_js_1.default.config({
      EXPONENTIAL_AT: [
        MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
        MAX_IOU_EXPONENT + MAX_IOU_PRECISION
      ]
    });
    function isAmountObjectIOU(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 3 && keys[0] === "currency" && keys[1] === "issuer" && keys[2] === "value";
    }
    function isAmountObjectMPT(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 2 && keys[0] === "mpt_issuance_id" && keys[1] === "value";
    }
    var Amount = class _Amount extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Amount.defaultAmount.bytes);
      }
      /**
       * Construct an amount from an IOU, MPT or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Amount) {
          return value;
        }
        let amount = new Uint8Array(8);
        if (typeof value === "string") {
          _Amount.assertXrpIsValid(value);
          const number3 = BigInt(value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(number3 >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(number3 & BigInt(mask)), 0);
          amount = (0, utils_1.concat)(intBuf);
          amount[0] |= 64;
          return new _Amount(amount);
        }
        if (isAmountObjectIOU(value)) {
          const number3 = new bignumber_js_1.default(value.value);
          _Amount.assertIouIsValid(number3);
          if (number3.isZero()) {
            amount[0] |= 128;
          } else {
            const integerNumberString = number3.times(`1e${-((number3.e || 0) - 15)}`).abs().toString();
            const num = BigInt(integerNumberString);
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
            amount = (0, utils_1.concat)(intBuf);
            amount[0] |= 128;
            if (number3.gt(new bignumber_js_1.default(0))) {
              amount[0] |= 64;
            }
            const exponent = (number3.e || 0) - 15;
            const exponentByte = 97 + exponent;
            amount[0] |= exponentByte >>> 2;
            amount[1] |= (exponentByte & 3) << 6;
          }
          const currency = currency_1.Currency.from(value.currency).toBytes();
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Amount((0, utils_1.concat)([amount, currency, issuer]));
        }
        if (isAmountObjectMPT(value)) {
          _Amount.assertMptIsValid(value.value);
          let leadingByte = new Uint8Array(1);
          leadingByte[0] |= 96;
          const num = BigInt(value.value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
          amount = (0, utils_1.concat)(intBuf);
          const mptIssuanceID = hash_192_1.Hash192.from(value.mpt_issuance_id).toBytes();
          return new _Amount((0, utils_1.concat)([leadingByte, amount, mptIssuanceID]));
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const isIOU = parser.peek() & 128;
        if (isIOU)
          return new _Amount(parser.read(48));
        const isMPT = parser.peek() & 32;
        const numBytes = isMPT ? 33 : 8;
        return new _Amount(parser.read(numBytes));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.isNative()) {
          const bytes = this.bytes;
          const isPositive = bytes[0] & 64;
          const sign2 = isPositive ? "" : "-";
          bytes[0] &= 63;
          const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));
          const num = msb << BigInt(32) | lsb;
          return `${sign2}${num.toString()}`;
        }
        if (this.isIOU()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const mantissa = parser.read(8);
          const currency = currency_1.Currency.fromParser(parser);
          const issuer = account_id_1.AccountID.fromParser(parser);
          const b1 = mantissa[0];
          const b2 = mantissa[1];
          const isPositive = b1 & 64;
          const sign2 = isPositive ? "" : "-";
          const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
          mantissa[0] = 0;
          mantissa[1] &= 63;
          const value = new bignumber_js_1.default(`${sign2}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);
          _Amount.assertIouIsValid(value);
          return {
            value: value.toString(),
            currency: currency.toJSON(),
            issuer: issuer.toJSON()
          };
        }
        if (this.isMPT()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const leadingByte = parser.read(1);
          const amount = parser.read(8);
          const mptID = hash_192_1.Hash192.fromParser(parser);
          const isPositive = leadingByte[0] & 64;
          const sign2 = isPositive ? "" : "-";
          const msb = BigInt((0, utils_2.readUInt32BE)(amount.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(amount.slice(4), 0));
          const num = msb << BigInt(32) | lsb;
          return {
            value: `${sign2}${num.toString()}`,
            mpt_issuance_id: mptID.toString()
          };
        }
        throw new Error("Invalid amount to construct JSON");
      }
      /**
       * Validate XRP amount
       *
       * @param amount String representing XRP amount
       * @returns void, but will throw if invalid amount
       */
      static assertXrpIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Validate IOU.value amount
       *
       * @param decimal BigNumber object representing IOU.value
       * @returns void, but will throw if invalid amount
       */
      static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
          const p = decimal.precision();
          const e = (decimal.e || 0) - 15;
          if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {
            throw new Error("Decimal precision out of range");
          }
          this.verifyNoDecimal(decimal);
        }
      }
      /**
       * Validate MPT.value amount
       *
       * @param decimal BigNumber object representing MPT.value
       * @returns void, but will throw if invalid amount
       */
      static assertMptIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal < (0, bignumber_js_1.default)(0)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
          if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Ensure that the value after being multiplied by the exponent does not
       * contain a decimal.
       *
       * @param decimal a Decimal object
       * @returns a string of the object without a decimal
       */
      static verifyNoDecimal(decimal) {
        const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();
        if (integerNumberString.indexOf(".") !== -1) {
          throw new Error("Decimal place found in integerNumberString");
        }
      }
      /**
       * Test if this amount is in units of Native Currency(XRP)
       *
       * @returns true if Native (XRP)
       */
      isNative() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) === 0;
      }
      /**
       * Test if this amount is in units of MPT
       *
       * @returns true if MPT
       */
      isMPT() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) !== 0;
      }
      /**
       * Test if this amount is in units of IOU
       *
       * @returns true if IOU
       */
      isIOU() {
        return (this.bytes[0] & 128) !== 0;
      }
    };
    exports.Amount = Amount;
    Amount.defaultAmount = new Amount((0, utils_1.hexToBytes)("4000000000000000"));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/blob.js
var require_blob = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/blob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Blob = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var Blob2 = class _Blob extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Defines how to read a Blob from a BinaryParser
       *
       * @param parser The binary parser to read the Blob from
       * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
       * @returns A Blob object
       */
      static fromParser(parser, hint) {
        return new _Blob(parser.read(hint));
      }
      /**
       * Create a Blob object from a hex-string
       *
       * @param value existing Blob object or a hex-string
       * @returns A Blob object
       */
      static from(value) {
        if (value instanceof _Blob) {
          return value;
        }
        if (typeof value === "string") {
          if (!/^[A-F0-9]*$/iu.test(value)) {
            throw new Error("Cannot construct Blob from a non-hex string");
          }
          return new _Blob((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Blob from value given");
      }
    };
    exports.Blob = Blob2;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-128.js
var require_hash_128 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-128.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash128 = void 0;
    var hash_1 = require_hash();
    var utils_1 = require_browser();
    var Hash128 = class _Hash128 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash128.ZERO_128.bytes);
      }
      /**
       * Get the hex representation of a hash-128 bytes, allowing unset
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        const hex = (0, utils_1.bytesToHex)(this.toBytes());
        if (/^0+$/.exec(hex)) {
          return "";
        }
        return hex;
      }
    };
    exports.Hash128 = Hash128;
    Hash128.width = 16;
    Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-256.js
var require_hash_256 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash256 = void 0;
    var hash_1 = require_hash();
    var Hash256 = class _Hash256 extends hash_1.Hash {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash256.ZERO_256.bytes);
      }
    };
    exports.Hash256 = Hash256;
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/issue.js
var require_issue = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/issue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Issue = void 0;
    var utils_1 = require_browser();
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    var hash_192_1 = require_hash_192();
    var utils_2 = require_utils3();
    function isIssueObject(arg) {
      const keys = Object.keys(arg).sort();
      const isXRP = keys.length === 1 && keys[0] === "currency";
      const isIOU = keys.length === 2 && keys[0] === "currency" && keys[1] === "issuer";
      const isMPT = keys.length === 1 && keys[0] === "mpt_issuance_id";
      return isXRP || isIOU || isMPT;
    }
    var MPT_WIDTH = 44;
    var NO_ACCOUNT = account_id_1.AccountID.from("0000000000000000000000000000000000000001");
    var Issue = class _Issue extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Issue.XRP_ISSUE.bytes);
      }
      /**
       * Construct Issue from XRPIssue, IOUIssue or MPTIssue
       *
       * @param value An object representing an XRPIssue, IOUIssue or MPTIssue
       * @returns An Issue object
       */
      static from(value) {
        if (value instanceof _Issue) {
          return value;
        }
        if (isIssueObject(value)) {
          if (value.currency) {
            const currency = currency_1.Currency.from(value.currency.toString()).toBytes();
            if (value.issuer) {
              const issuer = account_id_1.AccountID.from(value.issuer.toString()).toBytes();
              return new _Issue((0, utils_1.concat)([currency, issuer]));
            }
            return new _Issue(currency);
          }
          if (value.mpt_issuance_id) {
            const mptIssuanceIdBytes = hash_192_1.Hash192.from(value.mpt_issuance_id.toString()).toBytes();
            const issuerAccount = mptIssuanceIdBytes.slice(4);
            const sequence = Number((0, utils_2.readUInt32BE)(mptIssuanceIdBytes.slice(0, 4), 0));
            const sequenceBuffer = new Uint8Array(4);
            new DataView(sequenceBuffer.buffer).setUint32(0, sequence, true);
            return new _Issue((0, utils_1.concat)([issuerAccount, NO_ACCOUNT.toBytes(), sequenceBuffer]));
          }
        }
        throw new Error("Invalid type to construct an Issue");
      }
      /**
       * Read Issue from a BinaryParser
       *
       * @param parser BinaryParser to read the Issue from
       *
       * @returns An Issue object
       */
      static fromParser(parser) {
        const currencyOrAccount = parser.read(20);
        if (new currency_1.Currency(currencyOrAccount).toJSON() === "XRP") {
          return new _Issue(currencyOrAccount);
        }
        const issuerAccountId = new account_id_1.AccountID(parser.read(20));
        if (NO_ACCOUNT.toHex() === issuerAccountId.toHex()) {
          const sequence = parser.read(4);
          return new _Issue((0, utils_1.concat)([currencyOrAccount, NO_ACCOUNT.toBytes(), sequence]));
        }
        return new _Issue((0, utils_1.concat)([currencyOrAccount, issuerAccountId.toBytes()]));
      }
      /**
       * Get the JSON representation of this IssueObject
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.toBytes().length === MPT_WIDTH) {
          const issuerAccount = this.toBytes().slice(0, 20);
          const sequence = new DataView(this.toBytes().slice(40).buffer).getUint32(0, true);
          const sequenceBuffer = new Uint8Array(4);
          (0, utils_2.writeUInt32BE)(sequenceBuffer, sequence, 0);
          return {
            mpt_issuance_id: (0, utils_1.bytesToHex)((0, utils_1.concat)([sequenceBuffer, issuerAccount]))
          };
        }
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === "XRP") {
          return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
          currency: currency.toJSON(),
          issuer: issuer.toJSON()
        };
      }
    };
    exports.Issue = Issue;
    Issue.XRP_ISSUE = new Issue(new Uint8Array(20));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-number.js
var require_st_number = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STNumber = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_utils3();
    var MIN_MANTISSA = BigInt("1000000000000000");
    var MAX_MANTISSA = BigInt("9999999999999999");
    var MIN_EXPONENT = -32768;
    var MAX_EXPONENT = 32768;
    var DEFAULT_VALUE_EXPONENT = -2147483648;
    function extractNumberPartsFromString(val) {
      const regex = /^([-+]?)([0-9]+)(?:\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/;
      const match = regex.exec(val);
      if (!match)
        throw new Error(`Unable to parse number from string: ${val}`);
      const [, sign2, intPart, fracPart, expPart] = match;
      const cleanIntPart = intPart.replace(/^0+(?=\d)/, "") || "0";
      let mantissaStr = cleanIntPart;
      let exponent = 0;
      if (fracPart) {
        mantissaStr += fracPart;
        exponent -= fracPart.length;
      }
      if (expPart)
        exponent += parseInt(expPart, 10);
      let mantissa = BigInt(mantissaStr);
      if (sign2 === "-")
        mantissa = -mantissa;
      const isNegative = mantissa < BigInt(0);
      return { mantissa, exponent, isNegative };
    }
    function normalize(mantissa, exponent) {
      let m = mantissa < BigInt(0) ? -mantissa : mantissa;
      const isNegative = mantissa < BigInt(0);
      while (m !== BigInt(0) && m < MIN_MANTISSA && exponent > MIN_EXPONENT) {
        exponent -= 1;
        m *= BigInt(10);
      }
      while (m > MAX_MANTISSA) {
        if (exponent >= MAX_EXPONENT)
          throw new Error("Mantissa and exponent are too large");
        exponent += 1;
        m /= BigInt(10);
      }
      if (isNegative)
        m = -m;
      return { mantissa: m, exponent };
    }
    var STNumber = class _STNumber extends serialized_type_1.SerializedType {
      /**
       * Construct a STNumber from 12 bytes (8 for mantissa, 4 for exponent).
       * @param bytes - 12-byte Uint8Array
       * @throws Error if input is not a Uint8Array of length 12.
       */
      constructor(bytes) {
        const used = bytes !== null && bytes !== void 0 ? bytes : _STNumber.defaultBytes;
        if (!(used instanceof Uint8Array) || used.length !== 12) {
          throw new Error(`STNumber must be constructed from a 12-byte Uint8Array, got ${used === null || used === void 0 ? void 0 : used.length}`);
        }
        super(used);
      }
      /**
       * Construct from a number string (or another STNumber).
       *
       * @param value - A string, or STNumber instance.
       * @returns STNumber instance.
       * @throws Error if not a string or STNumber.
       */
      static from(value) {
        if (value instanceof _STNumber) {
          return value;
        }
        if (typeof value === "string") {
          return _STNumber.fromValue(value);
        }
        throw new Error("STNumber.from: Only string or STNumber instance is supported");
      }
      /**
       * Construct from a number string (integer, decimal, or scientific notation).
       * Handles normalization to XRPL Number constraints.
       *
       * @param val - The number as a string (e.g. '1.23', '-123e5').
       * @returns STNumber instance
       * @throws Error if val is not a valid number string.
       */
      static fromValue(val) {
        const { mantissa, exponent, isNegative } = extractNumberPartsFromString(val);
        let normalizedMantissa;
        let normalizedExponent;
        if (mantissa === BigInt(0) && exponent === 0 && !isNegative) {
          normalizedMantissa = BigInt(0);
          normalizedExponent = DEFAULT_VALUE_EXPONENT;
        } else {
          ;
          ({ mantissa: normalizedMantissa, exponent: normalizedExponent } = normalize(mantissa, exponent));
        }
        const bytes = new Uint8Array(12);
        (0, utils_1.writeInt64BE)(bytes, normalizedMantissa, 0);
        (0, utils_1.writeInt32BE)(bytes, normalizedExponent, 8);
        return new _STNumber(bytes);
      }
      /**
       * Read a STNumber from a BinaryParser stream (12 bytes).
       * @param parser - BinaryParser positioned at the start of a number
       * @returns STNumber instance
       */
      static fromParser(parser) {
        return new _STNumber(parser.read(12));
      }
      /**
       * Convert this STNumber to a normalized string representation.
       * The output is decimal or scientific notation, depending on exponent range.
       * Follows XRPL convention: zero is "0", other values are normalized to a canonical string.
       *
       * @returns String representation of the value
       */
      // eslint-disable-next-line complexity -- required
      toJSON() {
        const b = this.bytes;
        if (!b || b.length !== 12)
          throw new Error("STNumber internal bytes not set or wrong length");
        const mantissa = (0, utils_1.readInt64BE)(b, 0);
        const exponent = (0, utils_1.readInt32BE)(b, 8);
        if (mantissa === BigInt(0) && exponent === DEFAULT_VALUE_EXPONENT) {
          return "0";
        }
        if (exponent === 0)
          return mantissa.toString();
        if (exponent < -25 || exponent > -5) {
          return `${mantissa}e${exponent}`;
        }
        const isNegative = mantissa < BigInt(0);
        const mantissaAbs = mantissa < BigInt(0) ? -mantissa : mantissa;
        const padPrefix = 27;
        const padSuffix = 23;
        const mantissaStr = mantissaAbs.toString();
        const rawValue = "0".repeat(padPrefix) + mantissaStr + "0".repeat(padSuffix);
        const OFFSET = exponent + 43;
        const integerPart = rawValue.slice(0, OFFSET).replace(/^0+/, "") || "0";
        const fractionPart = rawValue.slice(OFFSET).replace(/0+$/, "");
        return `${isNegative ? "-" : ""}${integerPart}${fractionPart ? "." + fractionPart : ""}`;
      }
    };
    exports.STNumber = STNumber;
    STNumber.defaultBytes = new Uint8Array(12);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/path-set.js
var require_path_set = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/path-set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathSet = void 0;
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var binary_parser_1 = require_binary_parser();
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_browser();
    var PATHSET_END_BYTE = 0;
    var PATH_SEPARATOR_BYTE = 255;
    var TYPE_ACCOUNT = 1;
    var TYPE_CURRENCY = 16;
    var TYPE_ISSUER = 32;
    function isHopObject(arg) {
      return arg.issuer !== void 0 || arg.account !== void 0 || arg.currency !== void 0;
    }
    function isPathSet(arg) {
      return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
    }
    var Hop = class _Hop extends serialized_type_1.SerializedType {
      /**
       * Create a Hop from a HopObject
       *
       * @param value Either a hop or HopObject to create a hop with
       * @returns a Hop
       */
      static from(value) {
        if (value instanceof _Hop) {
          return value;
        }
        const bytes = [Uint8Array.from([0])];
        if (value.account) {
          bytes.push(account_id_1.AccountID.from(value.account).toBytes());
          bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
          bytes.push(currency_1.Currency.from(value.currency).toBytes());
          bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
          bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
          bytes[0][0] |= TYPE_ISSUER;
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Construct a Hop from a BinaryParser
       *
       * @param parser BinaryParser to read the Hop from
       * @returns a Hop
       */
      static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [Uint8Array.from([type])];
        if (type & TYPE_ACCOUNT) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
          bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON interpretation of this hop
       *
       * @returns a HopObject, an JS object with optional account, issuer, and currency
       */
      toJSON() {
        const hopParser = new binary_parser_1.BinaryParser((0, utils_1.bytesToHex)(this.bytes));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
          account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
          currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
          issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
          result.account = account;
        }
        if (issuer) {
          result.issuer = issuer;
        }
        if (currency) {
          result.currency = currency;
        }
        return result;
      }
      /**
       * get a number representing the type of this hop
       *
       * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
       */
      type() {
        return this.bytes[0];
      }
    };
    var Path = class _Path extends serialized_type_1.SerializedType {
      /**
       * construct a Path from an array of Hops
       *
       * @param value Path or array of HopObjects to construct a Path
       * @returns the Path
       */
      static from(value) {
        if (value instanceof _Path) {
          return value;
        }
        const bytes = [];
        value.forEach((hop) => {
          bytes.push(Hop.from(hop).toBytes());
        });
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Read a Path from a BinaryParser
       *
       * @param parser BinaryParser to read Path from
       * @returns the Path represented by the bytes read from the BinaryParser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Hop.fromParser(parser).toBytes());
          if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {
            break;
          }
        }
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this Path
       *
       * @returns an Array of HopObject constructed from this.bytes
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
      }
    };
    var PathSet = class _PathSet extends serialized_type_1.SerializedType {
      /**
       * Construct a PathSet from an Array of Arrays representing paths
       *
       * @param value A PathSet or Array of Array of HopObjects
       * @returns the PathSet constructed from value
       */
      static from(value) {
        if (value instanceof _PathSet) {
          return value;
        }
        if (isPathSet(value)) {
          const bytes = [];
          value.forEach((path) => {
            bytes.push(Path.from(path).toBytes());
            bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));
          });
          bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);
          return new _PathSet((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct PathSet from given value");
      }
      /**
       * Construct a PathSet from a BinaryParser
       *
       * @param parser A BinaryParser to read PathSet from
       * @returns the PathSet read from parser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Path.fromParser(parser).toBytes());
          bytes.push(parser.read(1));
          if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
            break;
          }
        }
        return new _PathSet((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this PathSet
       *
       * @returns an Array of Array of HopObjects, representing this PathSet
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Path.fromParser(pathParser).toJSON());
          pathParser.skip(1);
        }
        return json;
      }
    };
    exports.PathSet = PathSet;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint.js
var require_uint = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt = void 0;
    var serialized_type_1 = require_serialized_type();
    function compare(n1, n2) {
      return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
    }
    var UInt = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Overload of compareTo for Comparable
       *
       * @param other other UInt to compare this to
       * @returns -1, 0, or 1 depending on how the objects relate to each other
       */
      compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
      }
      /**
       * Convert a UInt object to JSON
       *
       * @returns number or string represented by this.bytes
       */
      toJSON() {
        const val = this.valueOf();
        return typeof val === "number" ? val : val.toString();
      }
      static checkUintRange(val, min, max) {
        if (val < min || val > max) {
          throw new Error(`Invalid ${this.constructor.name}: ${val} must be >= ${min} and <= ${max}`);
        }
      }
    };
    exports.UInt = UInt;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-64.js
var require_uint_64 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt64 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var enums_1 = require_enums2();
    var HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
    var BASE10_REGEX = /^[0-9]{1,20}$/;
    var mask = BigInt(4294967295);
    var BASE10_AMOUNT_FIELDS = /* @__PURE__ */ new Set([
      "MaximumAmount",
      "OutstandingAmount",
      "MPTAmount",
      "LockedAmount"
    ]);
    function isBase10(fieldName) {
      return BASE10_AMOUNT_FIELDS.has(fieldName);
    }
    var UInt64 = class _UInt64 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt64.defaultUInt64.bytes);
      }
      static fromParser(parser) {
        return new _UInt64(parser.read(_UInt64.width));
      }
      /**
       * Construct a UInt64 object
       *
       * @param val A UInt64, hex-string, bigInt, or number
       * @returns A UInt64 object
       */
      // eslint-disable-next-line complexity
      static from(val, fieldName = "") {
        if (val instanceof _UInt64) {
          return val;
        }
        let buf = new Uint8Array(_UInt64.width);
        if (typeof val === "number") {
          if (val < 0) {
            throw new Error("value must be an unsigned integer");
          }
          const number3 = BigInt(val);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(number3 >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(number3 & BigInt(mask)), 0);
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        if (typeof val === "string") {
          if (isBase10(fieldName)) {
            if (!BASE10_REGEX.test(val)) {
              throw new Error(`${fieldName} ${val} is not a valid base 10 string`);
            }
            val = BigInt(val).toString(16);
          }
          if (typeof val === "string" && !HEX_REGEX.test(val)) {
            throw new Error(`${val} is not a valid hex-string`);
          }
          const strBuf = val.padStart(16, "0");
          buf = (0, utils_1.hexToBytes)(strBuf);
          return new _UInt64(buf);
        }
        if (typeof val === "bigint") {
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        throw new Error("Cannot construct UInt64 from given value");
      }
      /**
       * The JSON representation of a UInt64 object
       *
       * @returns a hex-string
       */
      toJSON(_definitions = enums_1.DEFAULT_DEFINITIONS, fieldName = "") {
        const hexString = (0, utils_1.bytesToHex)(this.bytes);
        if (isBase10(fieldName)) {
          return BigInt("0x" + hexString).toString(10);
        }
        return hexString;
      }
      /**
       * Get the value of the UInt64
       *
       * @returns the number represented buy this.bytes
       */
      valueOf() {
        const msb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));
        return msb << BigInt(32) | lsb;
      }
      /**
       * Get the bytes representation of the UInt64 object
       *
       * @returns 8 bytes representing the UInt64
       */
      toBytes() {
        return this.bytes;
      }
    };
    exports.UInt64 = UInt64;
    UInt64.width = 64 / 8;
    UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-object.js
var require_st_object = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STObject = void 0;
    var enums_1 = require_enums2();
    var serialized_type_1 = require_serialized_type();
    var ripple_address_codec_1 = require_dist2();
    var binary_parser_1 = require_binary_parser();
    var binary_serializer_1 = require_binary_serializer();
    var st_array_1 = require_st_array();
    var uint_64_1 = require_uint_64();
    var OBJECT_END_MARKER_BYTE = Uint8Array.from([225]);
    var OBJECT_END_MARKER = "ObjectEndMarker";
    var ST_OBJECT = "STObject";
    var DESTINATION = "Destination";
    var ACCOUNT = "Account";
    var SOURCE_TAG = "SourceTag";
    var DEST_TAG = "DestinationTag";
    function handleXAddress(field, xAddress) {
      const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
      let tagName;
      if (field === DESTINATION)
        tagName = DEST_TAG;
      else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
      else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
      return decoded.tag !== false ? { [field]: decoded.classicAddress, [tagName]: decoded.tag } : { [field]: decoded.classicAddress };
    }
    function checkForDuplicateTags(obj1, obj2) {
      if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0))
        throw new Error("Cannot have Account X-Address and SourceTag");
      if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0))
        throw new Error("Cannot have Destination X-Address and DestinationTag");
    }
    var STObject = class _STObject extends serialized_type_1.SerializedType {
      /**
       * Construct a STObject from a BinaryParser
       *
       * @param parser BinaryParser to read STObject from
       * @returns A STObject object
       */
      static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          const associatedValue = parser.readFieldValue(field);
          bytes.writeFieldAndValue(field, associatedValue);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        }
        return new _STObject(list.toBytes());
      }
      /**
       * Construct a STObject from a JSON object
       *
       * @param value An object to include
       * @param filter optional, denote which field to include in serialized object
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns a STObject object
       */
      static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STObject) {
          return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
          let handled = void 0;
          if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
            handled = handleXAddress(key, val.toString());
            checkForDuplicateTags(handled, value);
          }
          return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
        }, {});
        function isValidFieldInstance(f) {
          return f !== void 0 && xAddressDecoded[f.name] !== void 0 && f.isSerialized;
        }
        let sorted = Object.keys(xAddressDecoded).map((f) => {
          if (!(f in definitions.field)) {
            if (f[0] === f[0].toLowerCase())
              return void 0;
            throw new Error(`Field ${f} is not defined in the definitions`);
          }
          return definitions.field[f];
        }).filter(isValidFieldInstance).sort((a, b) => {
          return a.ordinal - b.ordinal;
        });
        if (filter !== void 0) {
          sorted = sorted.filter(filter);
        }
        sorted.forEach((field) => {
          const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], void 0, definitions) : field.type.name === "STArray" ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions) : field.type.name === "UInt64" ? uint_64_1.UInt64.from(xAddressDecoded[field.name], field.name) : field.associatedType.from(xAddressDecoded[field.name]);
          if (associatedValue == void 0) {
            throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
          }
          if (associatedValue.name === "UNLModify") {
            isUnlModify = true;
          }
          const isUnlModifyWorkaround = field.name == "Account" && isUnlModify;
          bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        });
        return new _STObject(list.toBytes());
      }
      /**
       * Get the JSON interpretation of this.bytes
       * @param definitions rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       * @returns a JSON object
       */
      toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while (!objectParser.end()) {
          const field = objectParser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions, field.name);
        }
        return accumulator;
      }
    };
    exports.STObject = STObject;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-array.js
var require_st_array = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STArray = void 0;
    var enums_1 = require_enums2();
    var serialized_type_1 = require_serialized_type();
    var st_object_1 = require_st_object();
    var binary_parser_1 = require_binary_parser();
    var utils_1 = require_browser();
    var ARRAY_END_MARKER = Uint8Array.from([241]);
    var ARRAY_END_MARKER_NAME = "ArrayEndMarker";
    var OBJECT_END_MARKER = Uint8Array.from([225]);
    function isObjects(args) {
      return Array.isArray(args) && args.every((arg) => typeof arg === "object" && Object.keys(arg).length === 1 && typeof Object.values(arg)[0] === "object");
    }
    var STArray = class _STArray extends serialized_type_1.SerializedType {
      /**
       * Construct an STArray from a BinaryParser
       *
       * @param parser BinaryParser to parse an STArray from
       * @returns An STArray Object
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new _STArray((0, utils_1.concat)(bytes));
      }
      /**
       * Construct an STArray from an Array of JSON Objects
       *
       * @param value STArray or Array of Objects to parse into an STArray
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An STArray object
       */
      static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STArray) {
          return value;
        }
        if (isObjects(value)) {
          const bytes = [];
          value.forEach((obj) => {
            bytes.push(st_object_1.STObject.from(obj, void 0, definitions).toBytes());
          });
          bytes.push(ARRAY_END_MARKER);
          return new _STArray((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct STArray from value given");
      }
      /**
       * Return the JSON representation of this.bytes
       *
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An Array of JSON objects
       */
      toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while (!arrayParser.end()) {
          const field = arrayParser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          const outer = {};
          outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
          result.push(outer);
        }
        return result;
      }
    };
    exports.STArray = STArray;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-16.js
var require_uint_16 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt16 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils3();
    var UInt16 = class _UInt16 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt16.defaultUInt16.bytes);
      }
      static fromParser(parser) {
        return new _UInt16(parser.read(_UInt16.width));
      }
      /**
       * Construct a UInt16 object from a number
       *
       * @param val UInt16 object or number
       */
      static from(val) {
        if (val instanceof _UInt16) {
          return val;
        }
        if (typeof val === "number") {
          _UInt16.checkUintRange(val, 0, 65535);
          const buf = new Uint8Array(_UInt16.width);
          (0, utils_1.writeUInt16BE)(buf, val, 0);
          return new _UInt16(buf);
        }
        throw new Error("Can not construct UInt16 with given value");
      }
      /**
       * get the value of a UInt16 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt16BE)(this.bytes, 0));
      }
    };
    exports.UInt16 = UInt16;
    UInt16.width = 16 / 8;
    UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-32.js
var require_uint_32 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt32 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils3();
    var UInt32 = class _UInt32 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt32.defaultUInt32.bytes);
      }
      static fromParser(parser) {
        return new _UInt32(parser.read(_UInt32.width));
      }
      /**
       * Construct a UInt32 object from a number
       *
       * @param val UInt32 object or number
       */
      static from(val) {
        if (val instanceof _UInt32) {
          return val;
        }
        const buf = new Uint8Array(_UInt32.width);
        if (typeof val === "string") {
          const num = Number.parseInt(val);
          (0, utils_1.writeUInt32BE)(buf, num, 0);
          return new _UInt32(buf);
        }
        if (typeof val === "number") {
          _UInt32.checkUintRange(val, 0, 4294967295);
          (0, utils_1.writeUInt32BE)(buf, val, 0);
          return new _UInt32(buf);
        }
        throw new Error("Cannot construct UInt32 from given value");
      }
      /**
       * get the value of a UInt32 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt32BE)(this.bytes, 0), 10);
      }
    };
    exports.UInt32 = UInt32;
    UInt32.width = 32 / 8;
    UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-8.js
var require_uint_8 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt8 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_browser();
    var utils_2 = require_utils3();
    var UInt8 = class _UInt8 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt8.defaultUInt8.bytes);
      }
      static fromParser(parser) {
        return new _UInt8(parser.read(_UInt8.width));
      }
      /**
       * Construct a UInt8 object from a number
       *
       * @param val UInt8 object or number
       */
      static from(val) {
        if (val instanceof _UInt8) {
          return val;
        }
        if (typeof val === "number") {
          _UInt8.checkUintRange(val, 0, 255);
          const buf = new Uint8Array(_UInt8.width);
          (0, utils_2.writeUInt8)(buf, val, 0);
          return new _UInt8(buf);
        }
        throw new Error("Cannot construct UInt8 from given value");
      }
      /**
       * get the value of a UInt8 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.bytesToHex)(this.bytes), 16);
      }
    };
    exports.UInt8 = UInt8;
    UInt8.width = 8 / 8;
    UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width));
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/vector-256.js
var require_vector_256 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/vector-256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = void 0;
    var serialized_type_1 = require_serialized_type();
    var hash_256_1 = require_hash_256();
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_browser();
    function isStrings(arg) {
      return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string");
    }
    var Vector256 = class _Vector256 extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Construct a Vector256 from a BinaryParser
       *
       * @param parser BinaryParser to
       * @param hint length of the vector, in bytes, optional
       * @returns a Vector256 object
       */
      static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
          hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new _Vector256(bytesList.toBytes());
      }
      /**
       * Construct a Vector256 object from an array of hashes
       *
       * @param value A Vector256 object or array of hex-strings representing Hash256's
       * @returns a Vector256 object
       */
      static from(value) {
        if (value instanceof _Vector256) {
          return value;
        }
        if (isStrings(value)) {
          const bytesList = new binary_serializer_1.BytesList();
          value.forEach((hash2) => {
            hash_256_1.Hash256.from(hash2).toBytesSink(bytesList);
          });
          return new _Vector256(bytesList.toBytes());
        }
        throw new Error("Cannot construct Vector256 from given value");
      }
      /**
       * Return an Array of hex-strings represented by this.bytes
       *
       * @returns An Array of strings representing the Hash256 objects
       */
      toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
          throw new Error("Invalid bytes for Vector256");
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
          result.push((0, utils_1.bytesToHex)(this.bytes.slice(i, i + 32)));
        }
        return result;
      }
    };
    exports.Vector256 = Vector256;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js
var require_xchain_bridge = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XChainBridge = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var serialized_type_1 = require_serialized_type();
    var issue_1 = require_issue();
    var utils_1 = require_browser();
    function isXChainBridgeObject(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 4 && keys[0] === "IssuingChainDoor" && keys[1] === "IssuingChainIssue" && keys[2] === "LockingChainDoor" && keys[3] === "LockingChainIssue";
    }
    var XChainBridge = class _XChainBridge extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
      }
      /**
       * Construct a cross-chain bridge from a JSON
       *
       * @param value XChainBridge or JSON to parse into an XChainBridge
       * @returns An XChainBridge object
       */
      static from(value) {
        if (value instanceof _XChainBridge) {
          return value;
        }
        if (!isXChainBridgeObject(value)) {
          throw new Error("Invalid type to construct an XChainBridge");
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            bytes.push(Uint8Array.from([20]));
          }
          const object2 = type.from(value[name]);
          bytes.push(object2.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Read an XChainBridge from a BinaryParser
       *
       * @param parser BinaryParser to read the XChainBridge from
       * @returns An XChainBridge object
       */
      static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
            bytes.push(Uint8Array.from([20]));
          }
          const object2 = type.fromParser(parser);
          bytes.push(object2.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this XChainBridge
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        _XChainBridge.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
          }
          const object2 = type.fromParser(parser).toJSON();
          json[name] = object2;
        });
        return json;
      }
    };
    exports.XChainBridge = XChainBridge;
    XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1.concat)([
      Uint8Array.from([20]),
      new Uint8Array(40),
      Uint8Array.from([20]),
      new Uint8Array(40)
    ]));
    XChainBridge.TYPE_ORDER = [
      { name: "LockingChainDoor", type: account_id_1.AccountID },
      { name: "LockingChainIssue", type: issue_1.Issue },
      { name: "IssuingChainDoor", type: account_id_1.AccountID },
      { name: "IssuingChainIssue", type: issue_1.Issue }
    ];
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/index.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash192 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
    var account_id_1 = require_account_id();
    Object.defineProperty(exports, "AccountID", { enumerable: true, get: function() {
      return account_id_1.AccountID;
    } });
    var amount_1 = require_amount();
    Object.defineProperty(exports, "Amount", { enumerable: true, get: function() {
      return amount_1.Amount;
    } });
    var blob_1 = require_blob();
    Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
      return blob_1.Blob;
    } });
    var currency_1 = require_currency();
    Object.defineProperty(exports, "Currency", { enumerable: true, get: function() {
      return currency_1.Currency;
    } });
    var hash_128_1 = require_hash_128();
    Object.defineProperty(exports, "Hash128", { enumerable: true, get: function() {
      return hash_128_1.Hash128;
    } });
    var hash_160_1 = require_hash_160();
    Object.defineProperty(exports, "Hash160", { enumerable: true, get: function() {
      return hash_160_1.Hash160;
    } });
    var hash_192_1 = require_hash_192();
    Object.defineProperty(exports, "Hash192", { enumerable: true, get: function() {
      return hash_192_1.Hash192;
    } });
    var hash_256_1 = require_hash_256();
    Object.defineProperty(exports, "Hash256", { enumerable: true, get: function() {
      return hash_256_1.Hash256;
    } });
    var issue_1 = require_issue();
    var st_number_1 = require_st_number();
    var path_set_1 = require_path_set();
    Object.defineProperty(exports, "PathSet", { enumerable: true, get: function() {
      return path_set_1.PathSet;
    } });
    var st_array_1 = require_st_array();
    Object.defineProperty(exports, "STArray", { enumerable: true, get: function() {
      return st_array_1.STArray;
    } });
    var st_object_1 = require_st_object();
    Object.defineProperty(exports, "STObject", { enumerable: true, get: function() {
      return st_object_1.STObject;
    } });
    var uint_16_1 = require_uint_16();
    Object.defineProperty(exports, "UInt16", { enumerable: true, get: function() {
      return uint_16_1.UInt16;
    } });
    var uint_32_1 = require_uint_32();
    Object.defineProperty(exports, "UInt32", { enumerable: true, get: function() {
      return uint_32_1.UInt32;
    } });
    var uint_64_1 = require_uint_64();
    Object.defineProperty(exports, "UInt64", { enumerable: true, get: function() {
      return uint_64_1.UInt64;
    } });
    var uint_8_1 = require_uint_8();
    Object.defineProperty(exports, "UInt8", { enumerable: true, get: function() {
      return uint_8_1.UInt8;
    } });
    var vector_256_1 = require_vector_256();
    Object.defineProperty(exports, "Vector256", { enumerable: true, get: function() {
      return vector_256_1.Vector256;
    } });
    var xchain_bridge_1 = require_xchain_bridge();
    var enums_1 = require_enums2();
    var coreTypes = {
      AccountID: account_id_1.AccountID,
      Amount: amount_1.Amount,
      Blob: blob_1.Blob,
      Currency: currency_1.Currency,
      Hash128: hash_128_1.Hash128,
      Hash160: hash_160_1.Hash160,
      Hash192: hash_192_1.Hash192,
      Hash256: hash_256_1.Hash256,
      Issue: issue_1.Issue,
      Number: st_number_1.STNumber,
      PathSet: path_set_1.PathSet,
      STArray: st_array_1.STArray,
      STObject: st_object_1.STObject,
      UInt8: uint_8_1.UInt8,
      UInt16: uint_16_1.UInt16,
      UInt32: uint_32_1.UInt32,
      UInt64: uint_64_1.UInt64,
      Vector256: vector_256_1.Vector256,
      XChainBridge: xchain_bridge_1.XChainBridge
    };
    exports.coreTypes = coreTypes;
    enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hash-prefixes.js
var require_hash_prefixes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hash-prefixes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashPrefix = void 0;
    var utils_1 = require_utils3();
    function bytes(uint32) {
      const result = new Uint8Array(4);
      (0, utils_1.writeUInt32BE)(result, uint32, 0);
      return result;
    }
    var HashPrefix = {
      transactionID: bytes(1415073280),
      // transaction plus metadata
      transaction: bytes(1397638144),
      // account state
      accountStateEntry: bytes(1296846336),
      // inner node in tree
      innerNode: bytes(1296649728),
      // ledger master data for signing
      ledgerHeader: bytes(1280791040),
      // inner transaction to sign
      transactionSig: bytes(1398036480),
      // inner transaction to sign
      transactionMultiSig: bytes(1397576704),
      // validation for signing
      validation: bytes(1447119872),
      // proposal for signing
      proposal: bytes(1347571712),
      // payment channel claim
      paymentChannelClaim: bytes(1129073920),
      // batch
      batch: bytes(1111705600)
    };
    exports.HashPrefix = HashPrefix;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
    var sha2_ts_1 = require_sha2();
    exports.SHA512 = sha2_ts_1.SHA512;
    exports.sha512 = sha2_ts_1.sha512;
    exports.SHA384 = sha2_ts_1.SHA384;
    exports.sha384 = sha2_ts_1.sha384;
    exports.SHA512_224 = sha2_ts_1.SHA512_224;
    exports.sha512_224 = sha2_ts_1.sha512_224;
    exports.SHA512_256 = sha2_ts_1.SHA512_256;
    exports.sha512_256 = sha2_ts_1.sha512_256;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha512/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha512/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = void 0;
    var sha512_1 = require_sha512();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.sha512 = (0, wrapNoble_1.default)(sha512_1.sha512);
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hashes.js
var require_hashes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
    var hash_prefixes_1 = require_hash_prefixes();
    var types_1 = require_types2();
    var binary_serializer_1 = require_binary_serializer();
    var sha512_1 = require_browser3();
    var Sha512Half = class _Sha512Half extends binary_serializer_1.BytesList {
      constructor() {
        super(...arguments);
        this.hash = sha512_1.sha512.create();
      }
      /**
       * Construct a new Sha512Hash and write bytes this.hash
       *
       * @param bytes bytes to write to this.hash
       * @returns the new Sha512Hash object
       */
      static put(bytes) {
        return new _Sha512Half().put(bytes);
      }
      /**
       * Write bytes to an existing Sha512Hash
       *
       * @param bytes bytes to write to object
       * @returns the Sha512 object
       */
      put(bytes) {
        this.hash.update(bytes);
        return this;
      }
      /**
       * Compute SHA512 hash and slice in half
       *
       * @returns half of a SHA512 hash
       */
      finish256() {
        return Uint8Array.from(this.hash.digest().slice(0, 32));
      }
      /**
       * Constructs a Hash256 from the Sha512Half object
       *
       * @returns a Hash256 object
       */
      finish() {
        return new types_1.Hash256(this.finish256());
      }
    };
    exports.Sha512Half = Sha512Half;
    function sha512Half(...args) {
      const hash2 = new Sha512Half();
      args.forEach((a) => hash2.put(a));
      return hash2.finish256();
    }
    exports.sha512Half = sha512Half;
    function transactionID(serialized) {
      return new types_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
    }
    exports.transactionID = transactionID;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signingBatchData = exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
    var utils_1 = require_browser();
    var types_1 = require_types2();
    var binary_parser_1 = require_binary_parser();
    Object.defineProperty(exports, "BinaryParser", { enumerable: true, get: function() {
      return binary_parser_1.BinaryParser;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    var binary_serializer_1 = require_binary_serializer();
    Object.defineProperty(exports, "BinarySerializer", { enumerable: true, get: function() {
      return binary_serializer_1.BinarySerializer;
    } });
    Object.defineProperty(exports, "BytesList", { enumerable: true, get: function() {
      return binary_serializer_1.BytesList;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "sha512Half", { enumerable: true, get: function() {
      return hashes_1.sha512Half;
    } });
    Object.defineProperty(exports, "transactionID", { enumerable: true, get: function() {
      return hashes_1.transactionID;
    } });
    var enums_1 = require_enums2();
    var makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes, definitions);
    exports.makeParser = makeParser;
    var readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
    exports.readJSON = readJSON;
    var binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);
    exports.binaryToJSON = binaryToJSON;
    function serializeObject(object2, opts = {}) {
      const { prefix: prefix2, suffix, signingFieldsOnly = false, definitions } = opts;
      const bytesList = new binary_serializer_1.BytesList();
      if (prefix2) {
        bytesList.put(prefix2);
      }
      const filter = signingFieldsOnly ? (f) => f.isSigningField : void 0;
      types_1.coreTypes.STObject.from(object2, filter, definitions).toBytesSink(bytesList);
      if (suffix) {
        bytesList.put(suffix);
      }
      return bytesList.toBytes();
    }
    exports.serializeObject = serializeObject;
    function signingData(transaction, prefix2 = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
      return serializeObject(transaction, {
        prefix: prefix2,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.signingData = signingData;
    function signingClaimData(claim) {
      const num = BigInt(String(claim.amount));
      const prefix2 = hash_prefixes_1.HashPrefix.paymentChannelClaim;
      const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
      const amount = types_1.coreTypes.UInt64.from(num).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix2);
      bytesList.put(channel);
      bytesList.put(amount);
      return bytesList.toBytes();
    }
    exports.signingClaimData = signingClaimData;
    function multiSigningData(transaction, signingAccount, opts = {
      definitions: enums_1.DEFAULT_DEFINITIONS
    }) {
      const prefix2 = hash_prefixes_1.HashPrefix.transactionMultiSig;
      const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
      return serializeObject(transaction, {
        prefix: prefix2,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.multiSigningData = multiSigningData;
    function signingBatchData(batch) {
      if (batch.flags == null) {
        throw Error("No field `flags'");
      }
      if (batch.txIDs == null) {
        throw Error("No field `txIDs`");
      }
      const prefix2 = hash_prefixes_1.HashPrefix.batch;
      const flags = types_1.coreTypes.UInt32.from(batch.flags).toBytes();
      const txIDsLength = types_1.coreTypes.UInt32.from(batch.txIDs.length).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix2);
      bytesList.put(flags);
      bytesList.put(txIDsLength);
      batch.txIDs.forEach((txID) => {
        bytesList.put(types_1.coreTypes.Hash256.from(txID).toBytes());
      });
      return bytesList.toBytes();
    }
    exports.signingBatchData = signingBatchData;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/shamap.js
var require_shamap = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/shamap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
    var types_1 = require_types2();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var ShaMapNode = class {
    };
    exports.ShaMapNode = ShaMapNode;
    var ShaMapLeaf = class extends ShaMapNode {
      constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
      }
      /**
       * @returns true as ShaMapLeaf is a leaf node
       */
      isLeaf() {
        return true;
      }
      /**
       * @returns false as ShaMapLeaf is not an inner node
       */
      isInner() {
        return false;
      }
      /**
       * Get the prefix of the this.item
       *
       * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
       */
      hashPrefix() {
        return this.item === void 0 ? new Uint8Array(0) : this.item.hashPrefix();
      }
      /**
       * Hash the bytes representation of this
       *
       * @returns hash of this.item concatenated with this.index
       */
      hash() {
        const hash2 = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash2);
        return hash2.finish();
      }
      /**
       * Write the bytes representation of this to a BytesList
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        if (this.item !== void 0) {
          this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
      }
    };
    exports.ShaMapLeaf = ShaMapLeaf;
    var ShaMapInner = class _ShaMapInner extends ShaMapNode {
      constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
      }
      /**
       * @returns true as ShaMapInner is an inner node
       */
      isInner() {
        return true;
      }
      /**
       * @returns false as ShaMapInner is not a leaf node
       */
      isLeaf() {
        return false;
      }
      /**
       * Get the hash prefix for this node
       *
       * @returns hash prefix describing an inner node
       */
      hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
      }
      /**
       * Set a branch of this node to be another node
       *
       * @param slot Slot to add branch to this.branches
       * @param branch Branch to add
       */
      setBranch(slot, branch) {
        this.slotBits = this.slotBits | 1 << slot;
        this.branches[slot] = branch;
      }
      /**
       * @returns true if node is empty
       */
      empty() {
        return this.slotBits === 0;
      }
      /**
       * Compute the hash of this node
       *
       * @returns The hash of this node
       */
      hash() {
        if (this.empty()) {
          return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash2 = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash2);
        return hash2.finish();
      }
      /**
       * Writes the bytes representation of this node to a BytesList
       *
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
          const branch = this.branches[i];
          const hash2 = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;
          hash2.toBytesSink(list);
        }
      }
      /**
       * Add item to the SHAMap
       *
       * @param index Hash of the index of the item being inserted
       * @param item Item to insert in the map
       * @param leaf Leaf node to insert when branch doesn't exist
       */
      addItem(index, item, leaf) {
        if (index === void 0) {
          throw new Error();
        }
        if (index !== void 0) {
          const nibble = index.nibblet(this.depth);
          const existing = this.branches[nibble];
          if (existing === void 0) {
            this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
          } else if (existing instanceof ShaMapLeaf) {
            const newInner = new _ShaMapInner(this.depth + 1);
            newInner.addItem(existing.index, void 0, existing);
            newInner.addItem(index, item, leaf);
            this.setBranch(nibble, newInner);
          } else if (existing instanceof _ShaMapInner) {
            existing.addItem(index, item, leaf);
          } else {
            throw new Error("invalid ShaMap.addItem call");
          }
        }
      }
    };
    var ShaMap = class extends ShaMapInner {
    };
    exports.ShaMap = ShaMap;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/ledger-hashes.js
var require_ledger_hashes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/ledger-hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
    var shamap_1 = require_shamap();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var binary_1 = require_binary();
    var hash_256_1 = require_hash_256();
    var st_object_1 = require_st_object();
    var uint_64_1 = require_uint_64();
    var uint_32_1 = require_uint_32();
    var uint_8_1 = require_uint_8();
    var binary_parser_1 = require_binary_parser();
    function computeHash(itemizer, itemsJson) {
      const map = new shamap_1.ShaMap();
      itemsJson.forEach((item) => map.addItem(...itemizer(item)));
      return map.hash();
    }
    function transactionItemizer(json) {
      if (!json.hash) {
        throw new Error();
      }
      const index = hash_256_1.Hash256.from(json.hash);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
          const serializer = new binary_1.BinarySerializer(sink);
          serializer.writeLengthEncoded(st_object_1.STObject.from(json));
          serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        }
      };
      return [index, item, void 0];
    }
    function entryItemizer(json) {
      const index = hash_256_1.Hash256.from(json.index);
      const bytes = (0, binary_1.serializeObject)(json);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
          sink.put(bytes);
        }
      };
      return [index, item, void 0];
    }
    function transactionTreeHash(param) {
      const itemizer = transactionItemizer;
      return computeHash(itemizer, param);
    }
    exports.transactionTreeHash = transactionTreeHash;
    function accountStateHash(param) {
      const itemizer = entryItemizer;
      return computeHash(itemizer, param);
    }
    exports.accountStateHash = accountStateHash;
    function ledgerHash(header) {
      const hash2 = new hashes_1.Sha512Half();
      hash2.put(hash_prefixes_1.HashPrefix.ledgerHeader);
      if (header.parent_close_time === void 0 || header.close_flags === void 0) {
        throw new Error();
      }
      uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash2);
      uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash2);
      hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash2);
      hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash2);
      hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash2);
      uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash2);
      uint_32_1.UInt32.from(header.close_time).toBytesSink(hash2);
      uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash2);
      uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash2);
      return hash2.finish();
    }
    exports.ledgerHash = ledgerHash;
    function decodeLedgerData(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      const parser = new binary_parser_1.BinaryParser(binary, definitions);
      return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8()
      };
    }
    exports.decodeLedgerData = decodeLedgerData;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/quality.js
var require_quality = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/quality.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.quality = void 0;
    var types_1 = require_types2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_browser();
    var quality = class {
      /**
       * Encode quality amount
       *
       * @param arg string representation of an amount
       * @returns Serialized quality
       */
      static encode(quality2) {
        const decimal = (0, bignumber_js_1.default)(quality2);
        const exponent = ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(BigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
      }
      /**
       * Decode quality amount
       *
       * @param arg hex-string denoting serialized quality
       * @returns deserialized quality
       */
      static decode(quality2) {
        const bytes = (0, utils_1.hexToBytes)(quality2).slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new bignumber_js_1.default(`0x${(0, utils_1.bytesToHex)(bytes.slice(1))}`);
        return mantissa.times(`1e${exponent}`);
      }
    };
    exports.quality = quality;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/coretypes.js
var require_coretypes = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/coretypes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
    var enums_1 = require_enums2();
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return enums_1.Field;
    } });
    Object.defineProperty(exports, "TransactionType", { enumerable: true, get: function() {
      return enums_1.TransactionType;
    } });
    Object.defineProperty(exports, "LedgerEntryType", { enumerable: true, get: function() {
      return enums_1.LedgerEntryType;
    } });
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return enums_1.Type;
    } });
    Object.defineProperty(exports, "TransactionResult", { enumerable: true, get: function() {
      return enums_1.TransactionResult;
    } });
    var types = __importStar(require_types2());
    exports.types = types;
    var binary = __importStar(require_binary());
    exports.binary = binary;
    var shamap_1 = require_shamap();
    Object.defineProperty(exports, "ShaMap", { enumerable: true, get: function() {
      return shamap_1.ShaMap;
    } });
    var ledgerHashes = __importStar(require_ledger_hashes());
    exports.ledgerHashes = ledgerHashes;
    var hashes = __importStar(require_hashes());
    exports.hashes = hashes;
    var quality_1 = require_quality();
    Object.defineProperty(exports, "quality", { enumerable: true, get: function() {
      return quality_1.quality;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    Object.defineProperty(exports, "HashPrefix", { enumerable: true, get: function() {
      return hash_prefixes_1.HashPrefix;
    } });
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js
var require_xrpl_definitions = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XrplDefinitions = void 0;
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    var types_1 = require_types2();
    var XrplDefinitions = class extends xrpl_definitions_base_1.XrplDefinitionsBase {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use the tool at
       * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
       *              These types will be included in addition to the coreTypes used on mainnet.
       */
      constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
      }
    };
    exports.XrplDefinitions = XrplDefinitions;
  }
});

// node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/ripple-binary-codec@2.6.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForSigningBatch = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
    var coretypes_1 = require_coretypes();
    var ledger_hashes_1 = require_ledger_hashes();
    Object.defineProperty(exports, "decodeLedgerData", { enumerable: true, get: function() {
      return ledger_hashes_1.decodeLedgerData;
    } });
    var enums_1 = require_enums2();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return enums_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "TRANSACTION_TYPES", { enumerable: true, get: function() {
      return enums_1.TRANSACTION_TYPES;
    } });
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    var xrpl_definitions_1 = require_xrpl_definitions();
    Object.defineProperty(exports, "XrplDefinitions", { enumerable: true, get: function() {
      return xrpl_definitions_1.XrplDefinitions;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "coreTypes", { enumerable: true, get: function() {
      return types_1.coreTypes;
    } });
    var utils_1 = require_browser();
    var { signingData, signingClaimData, multiSigningData, signingBatchData, binaryToJSON, serializeObject } = coretypes_1.binary;
    function decode10(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      return binaryToJSON(binary, definitions);
    }
    exports.decode = decode10;
    function encode9(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(serializeObject(json, { definitions }));
    }
    exports.encode = encode9;
    function encodeForSigning(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions
      }));
    }
    exports.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(json) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(signingClaimData(json));
    }
    exports.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultisigning(json, signer, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      const definitionsOpt = definitions ? { definitions } : void 0;
      return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));
    }
    exports.encodeForMultisigning = encodeForMultisigning;
    function encodeForSigningBatch(json) {
      if (typeof json !== "object") {
        throw new Error("Need an object to encode a Batch transaction");
      }
      return (0, utils_1.bytesToHex)(signingBatchData(json));
    }
    exports.encodeForSigningBatch = encodeForSigningBatch;
    function encodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));
    }
    exports.encodeQuality = encodeQuality;
    function decodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return coretypes_1.quality.decode(value).toString();
    }
    exports.decodeQuality = decodeQuality;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHex = exports.hasFlag = exports.isFlagEnabled = exports.onlyHasFields = exports.INTEGER_SANITY_CHECK = void 0;
    var HEX_REGEX = /^[0-9A-Fa-f]+$/u;
    exports.INTEGER_SANITY_CHECK = /^[0-9]+$/u;
    function onlyHasFields(obj, fields) {
      return Object.keys(obj).every((key) => fields.includes(key));
    }
    exports.onlyHasFields = onlyHasFields;
    function isFlagEnabled(Flags, checkFlag) {
      return (BigInt(checkFlag) & BigInt(Flags)) === BigInt(checkFlag);
    }
    exports.isFlagEnabled = isFlagEnabled;
    function hasFlag(tx, flag, flagName) {
      if (tx.Flags == null) {
        return false;
      }
      if (typeof tx.Flags === "number") {
        return isFlagEnabled(tx.Flags, flag);
      }
      return tx.Flags[flagName] === true;
    }
    exports.hasFlag = hasFlag;
    function isHex(str) {
      return HEX_REGEX.test(str);
    }
    exports.isHex = isHex;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/common.js
var require_common3 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDomainID = exports.containsDuplicates = exports.validateCredentialsList = exports.validateCredentialType = exports.parseAmountValue = exports.validateBaseTransaction = exports.GlobalFlags = exports.validateOptionalField = exports.validateRequiredField = exports.validateHexMetadata = exports.isLedgerEntryId = exports.isArray = exports.isXChainBridge = exports.isTokenAmount = exports.isAmount = exports.isAccount = exports.isClawbackAmount = exports.isMPTAmount = exports.isAuthorizeCredential = exports.isIssuedCurrencyAmount = exports.isIssuedCurrency = exports.isCurrency = exports.isXRPLNumber = exports.isValue = exports.isNull = exports.isNumber = exports.isString = exports.isRecord = exports.VAULT_DATA_MAX_BYTE_LENGTH = exports.MAX_AUTHORIZED_CREDENTIALS = void 0;
    var utils_1 = require_browser();
    var ripple_address_codec_1 = require_dist2();
    var ripple_binary_codec_1 = require_dist3();
    var errors_1 = require_errors();
    var utils_2 = require_utils4();
    var MEMO_SIZE = 3;
    exports.MAX_AUTHORIZED_CREDENTIALS = 8;
    var MAX_CREDENTIAL_BYTE_LENGTH = 64;
    var MAX_CREDENTIAL_TYPE_LENGTH = MAX_CREDENTIAL_BYTE_LENGTH * 2;
    var SHA_512_HALF_LENGTH = 64;
    exports.VAULT_DATA_MAX_BYTE_LENGTH = 256;
    function isMemo(obj) {
      if (!isRecord(obj)) {
        return false;
      }
      const memo = obj.Memo;
      if (!isRecord(memo)) {
        return false;
      }
      const size = Object.keys(memo).length;
      const validData = memo.MemoData == null || isString(memo.MemoData) && (0, utils_2.isHex)(memo.MemoData);
      const validFormat = memo.MemoFormat == null || isString(memo.MemoFormat) && (0, utils_2.isHex)(memo.MemoFormat);
      const validType = memo.MemoType == null || isString(memo.MemoType) && (0, utils_2.isHex)(memo.MemoType);
      return size >= 1 && size <= MEMO_SIZE && validData && validFormat && validType && (0, utils_2.onlyHasFields)(memo, ["MemoFormat", "MemoData", "MemoType"]);
    }
    var SIGNER_SIZE = 3;
    function isSigner(obj) {
      if (!isRecord(obj)) {
        return false;
      }
      const signer = obj.Signer;
      if (!isRecord(signer)) {
        return false;
      }
      return Object.keys(signer).length === SIGNER_SIZE && isString(signer.Account) && isString(signer.TxnSignature) && isString(signer.SigningPubKey);
    }
    var XRP_CURRENCY_SIZE = 1;
    var MPT_CURRENCY_SIZE = 1;
    var ISSUE_CURRENCY_SIZE = 2;
    var MPT_CURRENCY_AMOUNT_SIZE = 2;
    var ISSUED_CURRENCY_AMOUNT_SIZE = 3;
    var XCHAIN_BRIDGE_SIZE = 4;
    var AUTHORIZE_CREDENTIAL_SIZE = 1;
    function isRecord(value) {
      return value !== null && typeof value === "object" && !Array.isArray(value);
    }
    exports.isRecord = isRecord;
    function isString(str) {
      return typeof str === "string";
    }
    exports.isString = isString;
    function isNumber(num) {
      return typeof num === "number";
    }
    exports.isNumber = isNumber;
    function isNull(inp) {
      return inp == null;
    }
    exports.isNull = isNull;
    function isValue(value) {
      const isValueInternal = (inp) => inp === value;
      return isValueInternal;
    }
    exports.isValue = isValue;
    function isXRPLNumber(value) {
      return typeof value === "string" && /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/u.test(value.trim());
    }
    exports.isXRPLNumber = isXRPLNumber;
    function isCurrency(input) {
      return isRecord(input) && (Object.keys(input).length === ISSUE_CURRENCY_SIZE && isString(input.issuer) && isString(input.currency) || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === "XRP" || Object.keys(input).length === MPT_CURRENCY_SIZE && isString(input.mpt_issuance_id));
    }
    exports.isCurrency = isCurrency;
    function isIssuedCurrency(input) {
      return isRecord(input) && (Object.keys(input).length === ISSUE_CURRENCY_SIZE && isString(input.issuer) && isString(input.currency) || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === "XRP");
    }
    exports.isIssuedCurrency = isIssuedCurrency;
    function isIssuedCurrencyAmount(input) {
      return isRecord(input) && Object.keys(input).length === ISSUED_CURRENCY_AMOUNT_SIZE && isString(input.value) && isString(input.issuer) && isString(input.currency);
    }
    exports.isIssuedCurrencyAmount = isIssuedCurrencyAmount;
    function isAuthorizeCredential(input) {
      return isRecord(input) && isRecord(input.Credential) && Object.keys(input).length === AUTHORIZE_CREDENTIAL_SIZE && typeof input.Credential.CredentialType === "string" && typeof input.Credential.Issuer === "string";
    }
    exports.isAuthorizeCredential = isAuthorizeCredential;
    function isMPTAmount(input) {
      return isRecord(input) && Object.keys(input).length === MPT_CURRENCY_AMOUNT_SIZE && typeof input.value === "string" && typeof input.mpt_issuance_id === "string";
    }
    exports.isMPTAmount = isMPTAmount;
    function isClawbackAmount(input) {
      return isIssuedCurrencyAmount(input) || isMPTAmount(input);
    }
    exports.isClawbackAmount = isClawbackAmount;
    function isAccount(account) {
      return typeof account === "string" && ((0, ripple_address_codec_1.isValidClassicAddress)(account) || (0, ripple_address_codec_1.isValidXAddress)(account));
    }
    exports.isAccount = isAccount;
    function isAmount(amount) {
      return typeof amount === "string" || isIssuedCurrencyAmount(amount) || isMPTAmount(amount);
    }
    exports.isAmount = isAmount;
    function isTokenAmount(amount) {
      return isIssuedCurrencyAmount(amount) || isMPTAmount(amount);
    }
    exports.isTokenAmount = isTokenAmount;
    function isXChainBridge(input) {
      return isRecord(input) && Object.keys(input).length === XCHAIN_BRIDGE_SIZE && typeof input.LockingChainDoor === "string" && isIssuedCurrency(input.LockingChainIssue) && typeof input.IssuingChainDoor === "string" && isIssuedCurrency(input.IssuingChainIssue);
    }
    exports.isXChainBridge = isXChainBridge;
    function isArray(input) {
      return input != null && Array.isArray(input);
    }
    exports.isArray = isArray;
    function isLedgerEntryId(input) {
      return isString(input) && (0, utils_2.isHex)(input) && input.length === SHA_512_HALF_LENGTH;
    }
    exports.isLedgerEntryId = isLedgerEntryId;
    function validateHexMetadata(input, lengthUpto) {
      return isString(input) && (0, utils_2.isHex)(input) && input.length > 0 && input.length <= lengthUpto;
    }
    exports.validateHexMetadata = validateHexMetadata;
    function validateRequiredField(tx, param, checkValidity, errorOpts = {}) {
      var _a4, _b;
      const paramNameStr = (_a4 = errorOpts.paramName) !== null && _a4 !== void 0 ? _a4 : param;
      const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx.TransactionType;
      if (tx[param] == null) {
        throw new errors_1.ValidationError(`${txType}: missing field ${String(paramNameStr)}`);
      }
      if (!checkValidity(tx[param])) {
        throw new errors_1.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);
      }
    }
    exports.validateRequiredField = validateRequiredField;
    function validateOptionalField(tx, param, checkValidity, errorOpts = {}) {
      var _a4, _b;
      const paramNameStr = (_a4 = errorOpts.paramName) !== null && _a4 !== void 0 ? _a4 : param;
      const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx.TransactionType;
      if (tx[param] !== void 0 && !checkValidity(tx[param])) {
        throw new errors_1.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);
      }
    }
    exports.validateOptionalField = validateOptionalField;
    var GlobalFlags;
    (function(GlobalFlags2) {
      GlobalFlags2[GlobalFlags2["tfInnerBatchTxn"] = 1073741824] = "tfInnerBatchTxn";
    })(GlobalFlags || (exports.GlobalFlags = GlobalFlags = {}));
    function validateBaseTransaction(common) {
      if (!isRecord(common)) {
        throw new errors_1.ValidationError("BaseTransaction: invalid, expected a valid object");
      }
      if (common.TransactionType === void 0) {
        throw new errors_1.ValidationError("BaseTransaction: missing field TransactionType");
      }
      if (typeof common.TransactionType !== "string") {
        throw new errors_1.ValidationError("BaseTransaction: TransactionType not string");
      }
      if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {
        throw new errors_1.ValidationError(`BaseTransaction: Unknown TransactionType ${common.TransactionType}`);
      }
      validateRequiredField(common, "Account", isString);
      validateOptionalField(common, "Fee", isString);
      validateOptionalField(common, "Sequence", isNumber);
      validateOptionalField(common, "AccountTxnID", isString);
      validateOptionalField(common, "LastLedgerSequence", isNumber);
      const memos = common.Memos;
      if (memos != null && (!isArray(memos) || !memos.every(isMemo))) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Memos");
      }
      const signers = common.Signers;
      if (signers != null && (!isArray(signers) || signers.length === 0 || !signers.every(isSigner))) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Signers");
      }
      validateOptionalField(common, "SourceTag", isNumber);
      validateOptionalField(common, "SigningPubKey", isString);
      validateOptionalField(common, "TicketSequence", isNumber);
      validateOptionalField(common, "TxnSignature", isString);
      validateOptionalField(common, "NetworkID", isNumber);
      validateOptionalField(common, "Delegate", isAccount);
      const delegate = common.Delegate;
      if (delegate != null && delegate === common.Account) {
        throw new errors_1.ValidationError("BaseTransaction: Account and Delegate addresses cannot be the same");
      }
    }
    exports.validateBaseTransaction = validateBaseTransaction;
    function parseAmountValue(amount) {
      if (!isAmount(amount)) {
        return NaN;
      }
      if (typeof amount === "string") {
        return parseFloat(amount);
      }
      return parseFloat(amount.value);
    }
    exports.parseAmountValue = parseAmountValue;
    function validateCredentialType(tx) {
      if (typeof tx.TransactionType !== "string") {
        throw new errors_1.ValidationError("Invalid TransactionType");
      }
      if (tx.CredentialType === void 0) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: missing field CredentialType`);
      }
      if (!isString(tx.CredentialType)) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be a string`);
      }
      if (tx.CredentialType.length === 0) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType cannot be an empty string`);
      } else if (tx.CredentialType.length > MAX_CREDENTIAL_TYPE_LENGTH) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType length cannot be > ${MAX_CREDENTIAL_TYPE_LENGTH}`);
      }
      if (!utils_1.HEX_REGEX.test(tx.CredentialType)) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be encoded in hex`);
      }
    }
    exports.validateCredentialType = validateCredentialType;
    function validateCredentialsList(credentials, transactionType, isStringID, maxCredentials) {
      if (credentials == null) {
        return;
      }
      if (!isArray(credentials)) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials must be an array`);
      }
      if (credentials.length > maxCredentials) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials length cannot exceed ${maxCredentials} elements`);
      } else if (credentials.length === 0) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials cannot be an empty array`);
      }
      credentials.forEach((credential) => {
        if (isStringID) {
          if (!isString(credential)) {
            throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials ID list format`);
          }
        } else if (!isAuthorizeCredential(credential)) {
          throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials format`);
        }
      });
      if (containsDuplicates(credentials)) {
        throw new errors_1.ValidationError(`${transactionType}: Credentials cannot contain duplicate elements`);
      }
    }
    exports.validateCredentialsList = validateCredentialsList;
    function isAuthorizeCredentialArray(list) {
      return typeof list[0] !== "string";
    }
    function containsDuplicates(objectList) {
      if (typeof objectList[0] === "string") {
        const objSet = new Set(objectList.map((obj) => JSON.stringify(obj)));
        return objSet.size !== objectList.length;
      }
      const seen = /* @__PURE__ */ new Set();
      if (isAuthorizeCredentialArray(objectList)) {
        for (const item of objectList) {
          const key = `${item.Credential.Issuer}-${item.Credential.CredentialType}`;
          if (seen.has(key)) {
            return true;
          }
          seen.add(key);
        }
      }
      return false;
    }
    exports.containsDuplicates = containsDuplicates;
    var _DOMAIN_ID_LENGTH = 64;
    function isDomainID(domainID) {
      return isString(domainID) && domainID.length === _DOMAIN_ID_LENGTH && (0, utils_2.isHex)(domainID);
    }
    exports.isDomainID = isDomainID;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountSet.js
var require_accountSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAccountSet = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var AccountSetAsfFlags;
    (function(AccountSetAsfFlags2) {
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfRequireDest"] = 1] = "asfRequireDest";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfRequireAuth"] = 2] = "asfRequireAuth";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowXRP"] = 3] = "asfDisallowXRP";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisableMaster"] = 4] = "asfDisableMaster";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAccountTxnID"] = 5] = "asfAccountTxnID";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfNoFreeze"] = 6] = "asfNoFreeze";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfGlobalFreeze"] = 7] = "asfGlobalFreeze";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDefaultRipple"] = 8] = "asfDefaultRipple";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDepositAuth"] = 9] = "asfDepositAuth";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAuthorizedNFTokenMinter"] = 10] = "asfAuthorizedNFTokenMinter";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingNFTokenOffer"] = 12] = "asfDisallowIncomingNFTokenOffer";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingCheck"] = 13] = "asfDisallowIncomingCheck";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingPayChan"] = 14] = "asfDisallowIncomingPayChan";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfDisallowIncomingTrustline"] = 15] = "asfDisallowIncomingTrustline";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAllowTrustLineClawback"] = 16] = "asfAllowTrustLineClawback";
      AccountSetAsfFlags2[AccountSetAsfFlags2["asfAllowTrustLineLocking"] = 17] = "asfAllowTrustLineLocking";
    })(AccountSetAsfFlags || (exports.AccountSetAsfFlags = AccountSetAsfFlags = {}));
    var AccountSetTfFlags;
    (function(AccountSetTfFlags2) {
      AccountSetTfFlags2[AccountSetTfFlags2["tfRequireDestTag"] = 65536] = "tfRequireDestTag";
      AccountSetTfFlags2[AccountSetTfFlags2["tfOptionalDestTag"] = 131072] = "tfOptionalDestTag";
      AccountSetTfFlags2[AccountSetTfFlags2["tfRequireAuth"] = 262144] = "tfRequireAuth";
      AccountSetTfFlags2[AccountSetTfFlags2["tfOptionalAuth"] = 524288] = "tfOptionalAuth";
      AccountSetTfFlags2[AccountSetTfFlags2["tfDisallowXRP"] = 1048576] = "tfDisallowXRP";
      AccountSetTfFlags2[AccountSetTfFlags2["tfAllowXRP"] = 2097152] = "tfAllowXRP";
    })(AccountSetTfFlags || (exports.AccountSetTfFlags = AccountSetTfFlags = {}));
    var MIN_TICK_SIZE = 3;
    var MAX_TICK_SIZE = 15;
    function validateAccountSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "NFTokenMinter", common_1.isAccount);
      if (tx.ClearFlag !== void 0) {
        if (typeof tx.ClearFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.ClearFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
      }
      if (tx.Domain !== void 0 && typeof tx.Domain !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid Domain");
      }
      if (tx.EmailHash !== void 0 && typeof tx.EmailHash !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid EmailHash");
      }
      if (tx.MessageKey !== void 0 && typeof tx.MessageKey !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid MessageKey");
      }
      if (tx.SetFlag !== void 0) {
        if (typeof tx.SetFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.SetFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
      }
      if (tx.TransferRate !== void 0 && typeof tx.TransferRate !== "number") {
        throw new errors_1.ValidationError("AccountSet: invalid TransferRate");
      }
      if (tx.TickSize !== void 0) {
        if (typeof tx.TickSize !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
        if (tx.TickSize !== 0 && (tx.TickSize < MIN_TICK_SIZE || tx.TickSize > MAX_TICK_SIZE)) {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
      }
    }
    exports.validateAccountSet = validateAccountSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMClawback.js
var require_AMMClawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMClawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMClawback = exports.AMMClawbackFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var AMMClawbackFlags;
    (function(AMMClawbackFlags2) {
      AMMClawbackFlags2[AMMClawbackFlags2["tfClawTwoAssets"] = 1] = "tfClawTwoAssets";
    })(AMMClawbackFlags || (exports.AMMClawbackFlags = AMMClawbackFlags = {}));
    function validateAMMClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Holder", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Asset", common_1.isIssuedCurrency);
      const asset = tx.Asset;
      if (tx.Holder === asset.issuer) {
        throw new errors_1.ValidationError("AMMClawback: Holder and Asset.issuer must be distinct");
      }
      if (tx.Account !== asset.issuer) {
        throw new errors_1.ValidationError("AMMClawback: Account must be the same as Asset.issuer");
      }
      (0, common_1.validateRequiredField)(tx, "Asset2", common_1.isIssuedCurrency);
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isIssuedCurrencyAmount);
      if (tx.Amount != null) {
        if (tx.Amount.currency !== asset.currency) {
          throw new errors_1.ValidationError("AMMClawback: Amount.currency must match Asset.currency");
        }
        if (tx.Amount.issuer !== asset.issuer) {
          throw new errors_1.ValidationError("AMMClawback: Amount.issuer must match Amount.issuer");
        }
      }
    }
    exports.validateAMMClawback = validateAMMClawback;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js
var require_AMMDeposit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMDeposit = exports.AMMDepositFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var AMMDepositFlags;
    (function(AMMDepositFlags2) {
      AMMDepositFlags2[AMMDepositFlags2["tfLPToken"] = 65536] = "tfLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfSingleAsset"] = 524288] = "tfSingleAsset";
      AMMDepositFlags2[AMMDepositFlags2["tfTwoAsset"] = 1048576] = "tfTwoAsset";
      AMMDepositFlags2[AMMDepositFlags2["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
      AMMDepositFlags2[AMMDepositFlags2["tfTwoAssetIfEmpty"] = 8388608] = "tfTwoAssetIfEmpty";
    })(AMMDepositFlags || (exports.AMMDepositFlags = AMMDepositFlags = {}));
    function validateAMMDeposit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMDeposit: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset2");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMDeposit: Asset2 must be a Currency");
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set Amount with Amount2");
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set Amount with EPrice");
      } else if (tx.LPTokenOut == null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMDeposit: must set at least LPTokenOut or Amount");
      }
      if (tx.LPTokenOut != null && !(0, common_1.isIssuedCurrencyAmount)(tx.LPTokenOut)) {
        throw new errors_1.ValidationError("AMMDeposit: LPTokenOut must be an IssuedCurrencyAmount");
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMDeposit: Amount must be an Amount");
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMDeposit: Amount2 must be an Amount");
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError("AMMDeposit: EPrice must be an Amount");
      }
    }
    exports.validateAMMDeposit = validateAMMDeposit;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js
var require_AMMWithdraw = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMWithdraw = exports.AMMWithdrawFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var AMMWithdrawFlags;
    (function(AMMWithdrawFlags2) {
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfLPToken"] = 65536] = "tfLPToken";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfWithdrawAll"] = 131072] = "tfWithdrawAll";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfOneAssetWithdrawAll"] = 262144] = "tfOneAssetWithdrawAll";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfSingleAsset"] = 524288] = "tfSingleAsset";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfTwoAsset"] = 1048576] = "tfTwoAsset";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
      AMMWithdrawFlags2[AMMWithdrawFlags2["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
    })(AMMWithdrawFlags || (exports.AMMWithdrawFlags = AMMWithdrawFlags = {}));
    function validateAMMWithdraw(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMWithdraw: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset2");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMWithdraw: Asset2 must be a Currency");
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMWithdraw: must set Amount with Amount2");
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError("AMMWithdraw: must set Amount with EPrice");
      }
      if (tx.LPTokenIn != null && !(0, common_1.isIssuedCurrencyAmount)(tx.LPTokenIn)) {
        throw new errors_1.ValidationError("AMMWithdraw: LPTokenIn must be an IssuedCurrencyAmount");
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMWithdraw: Amount must be an Amount");
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMWithdraw: Amount2 must be an Amount");
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError("AMMWithdraw: EPrice must be an Amount");
      }
    }
    exports.validateAMMWithdraw = validateAMMWithdraw;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/batch.js
var require_batch = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/batch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBatch = exports.BatchFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var BatchFlags;
    (function(BatchFlags2) {
      BatchFlags2[BatchFlags2["tfAllOrNothing"] = 65536] = "tfAllOrNothing";
      BatchFlags2[BatchFlags2["tfOnlyOne"] = 131072] = "tfOnlyOne";
      BatchFlags2[BatchFlags2["tfUntilFailure"] = 262144] = "tfUntilFailure";
      BatchFlags2[BatchFlags2["tfIndependent"] = 524288] = "tfIndependent";
    })(BatchFlags || (exports.BatchFlags = BatchFlags = {}));
    function validateBatchInnerTransaction(tx, index) {
      if (tx.TransactionType === "Batch") {
        throw new errors_1.ValidationError(`Batch: RawTransactions[${index}] is a Batch transaction. Cannot nest Batch transactions.`);
      }
      if (!(0, utils_1.hasFlag)(tx, common_1.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) {
        throw new errors_1.ValidationError(`Batch: RawTransactions[${index}] must contain the \`tfInnerBatchTxn\` flag.`);
      }
      (0, common_1.validateOptionalField)(tx, "Fee", (0, common_1.isValue)("0"), {
        paramName: `RawTransactions[${index}].RawTransaction.Fee`,
        txType: "Batch"
      });
      (0, common_1.validateOptionalField)(tx, "SigningPubKey", (0, common_1.isValue)(""), {
        paramName: `RawTransactions[${index}].RawTransaction.SigningPubKey`,
        txType: "Batch"
      });
      (0, common_1.validateOptionalField)(tx, "TxnSignature", common_1.isNull, {
        paramName: `RawTransactions[${index}].RawTransaction.TxnSignature`,
        txType: "Batch"
      });
      (0, common_1.validateOptionalField)(tx, "Signers", common_1.isNull, {
        paramName: `RawTransactions[${index}].RawTransaction.Signers`,
        txType: "Batch"
      });
      (0, common_1.validateOptionalField)(tx, "LastLedgerSequence", common_1.isNull, {
        paramName: `RawTransactions[${index}].RawTransaction.LastLedgerSequence`,
        txType: "Batch"
      });
    }
    function validateBatch(tx) {
      var _a4;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "RawTransactions", common_1.isArray);
      tx.RawTransactions.forEach((rawTxObj, index) => {
        if (!(0, common_1.isRecord)(rawTxObj)) {
          throw new errors_1.ValidationError(`Batch: RawTransactions[${index}] is not object.`);
        }
        (0, common_1.validateRequiredField)(rawTxObj, "RawTransaction", common_1.isRecord, {
          paramName: `RawTransactions[${index}].RawTransaction`,
          txType: "Batch"
        });
        const rawTx = rawTxObj.RawTransaction;
        validateBatchInnerTransaction(rawTx, index);
      });
      (0, common_1.validateOptionalField)(tx, "BatchSigners", common_1.isArray);
      (_a4 = tx.BatchSigners) === null || _a4 === void 0 ? void 0 : _a4.forEach((signerObj, index) => {
        if (!(0, common_1.isRecord)(signerObj)) {
          throw new errors_1.ValidationError(`Batch: BatchSigners[${index}] is not object.`);
        }
        const signerRecord = signerObj;
        (0, common_1.validateRequiredField)(signerRecord, "BatchSigner", common_1.isRecord, {
          paramName: `BatchSigners[${index}].BatchSigner`,
          txType: "Batch"
        });
        const signer = signerRecord.BatchSigner;
        (0, common_1.validateRequiredField)(signer, "Account", common_1.isString, {
          paramName: `BatchSigners[${index}].BatchSigner.Account`,
          txType: "Batch"
        });
        (0, common_1.validateOptionalField)(signer, "SigningPubKey", common_1.isString, {
          paramName: `BatchSigners[${index}].BatchSigner.SigningPubKey`,
          txType: "Batch"
        });
        (0, common_1.validateOptionalField)(signer, "TxnSignature", common_1.isString, {
          paramName: `BatchSigners[${index}].BatchSigner.TxnSignature`,
          txType: "Batch"
        });
        (0, common_1.validateOptionalField)(signer, "Signers", common_1.isArray, {
          paramName: `BatchSigners[${index}].BatchSigner.Signers`,
          txType: "Batch"
        });
      });
    }
    exports.validateBatch = validateBatch;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanManage.js
var require_loanManage = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanManage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanManage = exports.LoanManageFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var LoanManageFlags;
    (function(LoanManageFlags2) {
      LoanManageFlags2[LoanManageFlags2["tfLoanDefault"] = 65536] = "tfLoanDefault";
      LoanManageFlags2[LoanManageFlags2["tfLoanImpair"] = 131072] = "tfLoanImpair";
      LoanManageFlags2[LoanManageFlags2["tfLoanUnimpair"] = 262144] = "tfLoanUnimpair";
    })(LoanManageFlags || (exports.LoanManageFlags = LoanManageFlags = {}));
    function validateLoanManage(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanID", common_1.isString);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanID)) {
        throw new errors_1.ValidationError(`LoanManage: LoanID must be 64 characters hexadecimal string`);
      }
      const txFlags = tx.Flags;
      if (txFlags == null) {
        return;
      }
      let flags = 0;
      if (typeof txFlags === "number") {
        flags = txFlags;
      } else {
        if (txFlags.tfLoanImpair) {
          flags |= LoanManageFlags.tfLoanImpair;
        }
        if (txFlags.tfLoanUnimpair) {
          flags |= LoanManageFlags.tfLoanUnimpair;
        }
      }
      if ((flags & LoanManageFlags.tfLoanImpair) === LoanManageFlags.tfLoanImpair && (flags & LoanManageFlags.tfLoanUnimpair) === LoanManageFlags.tfLoanUnimpair) {
        throw new errors_1.ValidationError("LoanManage: tfLoanImpair and tfLoanUnimpair cannot both be present");
      }
    }
    exports.validateLoanManage = validateLoanManage;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenAuthorize.js
var require_MPTokenAuthorize = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenAuthorize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenAuthorize = exports.MPTokenAuthorizeFlags = void 0;
    var common_1 = require_common3();
    var MPTokenAuthorizeFlags;
    (function(MPTokenAuthorizeFlags2) {
      MPTokenAuthorizeFlags2[MPTokenAuthorizeFlags2["tfMPTUnauthorize"] = 1] = "tfMPTUnauthorize";
    })(MPTokenAuthorizeFlags || (exports.MPTokenAuthorizeFlags = MPTokenAuthorizeFlags = {}));
    function validateMPTokenAuthorize(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
    }
    exports.validateMPTokenAuthorize = validateMPTokenAuthorize;
  }
});

// node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ (function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      })(opts.cmp);
      var seen = [];
      return (function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i) out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      })(data);
    };
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/mptokenMetadata.js
var require_mptokenMetadata = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/mptokenMetadata.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenMetadata = exports.decodeMPTokenMetadata = exports.encodeMPTokenMetadata = exports.MPT_META_WARNING_HEADER = exports.MAX_MPT_META_BYTE_LENGTH = void 0;
    var utils_1 = require_browser();
    var fast_json_stable_stringify_1 = __importDefault(require_fast_json_stable_stringify());
    var common_1 = require_common3();
    var _1 = require_utils4();
    exports.MAX_MPT_META_BYTE_LENGTH = 1024;
    exports.MPT_META_WARNING_HEADER = "MPTokenMetadata is not properly formatted as JSON as per the XLS-89 standard. While adherence to this standard is not mandatory, such non-compliant MPToken's might not be discoverable by Explorers and Indexers in the XRPL ecosystem.";
    var MPT_META_URI_FIELDS = [
      {
        long: "uri",
        compact: "u"
      },
      {
        long: "category",
        compact: "c"
      },
      {
        long: "title",
        compact: "t"
      }
    ];
    var MPT_META_ALL_FIELDS = [
      {
        long: "ticker",
        compact: "t",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) || !/^[A-Z0-9]{1,6}$/u.test(value)) {
            return [
              `${this.long}/${this.compact}: should have uppercase letters (A-Z) and digits (0-9) only. Max 6 characters recommended.`
            ];
          }
          return [];
        }
      },
      {
        long: "name",
        compact: "n",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) || value.length === 0) {
            return [`${this.long}/${this.compact}: should be a non-empty string.`];
          }
          return [];
        }
      },
      {
        long: "icon",
        compact: "i",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) || value.length === 0) {
            return [`${this.long}/${this.compact}: should be a non-empty string.`];
          }
          return [];
        }
      },
      {
        long: "asset_class",
        compact: "ac",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          const MPT_META_ASSET_CLASSES = [
            "rwa",
            "memes",
            "wrapped",
            "gaming",
            "defi",
            "other"
          ];
          if (!(0, common_1.isString)(value) || !MPT_META_ASSET_CLASSES.includes(value)) {
            return [
              `${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_CLASSES.join(", ")}.`
            ];
          }
          return [];
        }
      },
      {
        long: "issuer_name",
        compact: "in",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) || value.length === 0) {
            return [`${this.long}/${this.compact}: should be a non-empty string.`];
          }
          return [];
        }
      },
      {
        long: "desc",
        compact: "d",
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          if (obj[this.long] === void 0 && obj[this.compact] === void 0) {
            return [];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) || value.length === 0) {
            return [`${this.long}/${this.compact}: should be a non-empty string.`];
          }
          return [];
        }
      },
      {
        long: "asset_subclass",
        compact: "as",
        required: false,
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if ((obj.asset_class === "rwa" || obj.ac === "rwa") && value === void 0) {
            return [
              `${this.long}/${this.compact}: required when asset_class is rwa.`
            ];
          }
          if (obj[this.long] === void 0 && obj[this.compact] === void 0) {
            return [];
          }
          const MPT_META_ASSET_SUB_CLASSES = [
            "stablecoin",
            "commodity",
            "real_estate",
            "private_credit",
            "equity",
            "treasury",
            "other"
          ];
          if (!(0, common_1.isString)(value) || !MPT_META_ASSET_SUB_CLASSES.includes(value)) {
            return [
              `${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_SUB_CLASSES.join(", ")}.`
            ];
          }
          return [];
        }
      },
      {
        long: "uris",
        compact: "us",
        required: false,
        validate(obj) {
          var _a4, _b, _c, _d;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          if (obj[this.long] === void 0 && obj[this.compact] === void 0) {
            return [];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!Array.isArray(value) || value.length === 0) {
            return [`${this.long}/${this.compact}: should be a non-empty array.`];
          }
          const messages = [];
          for (const uriObj of value) {
            if (!(0, common_1.isRecord)(uriObj) || Object.keys(uriObj).length !== MPT_META_URI_FIELDS.length) {
              messages.push(`${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`);
              continue;
            }
            for (const uriField of MPT_META_URI_FIELDS) {
              if (uriObj[uriField.long] != null && uriObj[uriField.compact] != null) {
                messages.push(`${this.long}/${this.compact}: should not have both ${uriField.long} and ${uriField.compact} fields.`);
                break;
              }
            }
            const uri = (_b = uriObj.uri) !== null && _b !== void 0 ? _b : uriObj.u;
            const category = (_c = uriObj.category) !== null && _c !== void 0 ? _c : uriObj.c;
            const title = (_d = uriObj.title) !== null && _d !== void 0 ? _d : uriObj.t;
            if (!(0, common_1.isString)(uri) || !(0, common_1.isString)(category) || !(0, common_1.isString)(title)) {
              messages.push(`${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`);
            }
          }
          return messages;
        }
      },
      {
        long: "additional_info",
        compact: "ai",
        required: false,
        validate(obj) {
          var _a4;
          if (obj[this.long] != null && obj[this.compact] != null) {
            return [
              `${this.long}/${this.compact}: both long and compact forms present. expected only one.`
            ];
          }
          if (obj[this.long] === void 0 && obj[this.compact] === void 0) {
            return [];
          }
          const value = (_a4 = obj[this.long]) !== null && _a4 !== void 0 ? _a4 : obj[this.compact];
          if (!(0, common_1.isString)(value) && !(0, common_1.isRecord)(value)) {
            return [
              `${this.long}/${this.compact}: should be a string or JSON object.`
            ];
          }
          return [];
        }
      }
    ];
    function shortenKeys(input, mappings) {
      const output = {};
      for (const [key, value] of Object.entries(input)) {
        const mapping = mappings.find(({ long, compact }) => long === key || compact === key);
        if (mapping === void 0) {
          output[key] = value;
          continue;
        }
        if (input[mapping.long] !== void 0 && input[mapping.compact] !== void 0) {
          output[key] = value;
          continue;
        }
        output[mapping.compact] = value;
      }
      return output;
    }
    function encodeMPTokenMetadata(mptokenMetadata) {
      let input = mptokenMetadata;
      if (!(0, common_1.isRecord)(input)) {
        throw new Error("MPTokenMetadata must be JSON object.");
      }
      input = shortenKeys(input, MPT_META_ALL_FIELDS);
      if (Array.isArray(input.uris)) {
        input.uris = input.uris.map((uri) => {
          if ((0, common_1.isRecord)(uri)) {
            return shortenKeys(uri, MPT_META_URI_FIELDS);
          }
          return uri;
        });
      }
      if (Array.isArray(input.us)) {
        input.us = input.us.map((uri) => {
          if ((0, common_1.isRecord)(uri)) {
            return shortenKeys(uri, MPT_META_URI_FIELDS);
          }
          return uri;
        });
      }
      return (0, utils_1.stringToHex)((0, fast_json_stable_stringify_1.default)(input)).toUpperCase();
    }
    exports.encodeMPTokenMetadata = encodeMPTokenMetadata;
    function expandKeys(input, mappings) {
      const output = {};
      for (const [key, value] of Object.entries(input)) {
        const mapping = mappings.find(({ long, compact }) => long === key || compact === key);
        if (mapping === void 0) {
          output[key] = value;
          continue;
        }
        if (input[mapping.long] !== void 0 && input[mapping.compact] !== void 0) {
          output[key] = value;
          continue;
        }
        output[mapping.long] = value;
      }
      return output;
    }
    function decodeMPTokenMetadata(input) {
      if (!(0, _1.isHex)(input)) {
        throw new Error("MPTokenMetadata must be in hex format.");
      }
      let jsonMetaData;
      try {
        jsonMetaData = JSON.parse((0, utils_1.hexToString)(input));
      } catch (err) {
        throw new Error(`MPTokenMetadata is not properly formatted as JSON - ${String(err)}`);
      }
      if (!(0, common_1.isRecord)(jsonMetaData)) {
        throw new Error("MPTokenMetadata must be a JSON object.");
      }
      let output = jsonMetaData;
      output = expandKeys(output, MPT_META_ALL_FIELDS);
      if (Array.isArray(output.uris)) {
        output.uris = output.uris.map((uri) => {
          if ((0, common_1.isRecord)(uri)) {
            return expandKeys(uri, MPT_META_URI_FIELDS);
          }
          return uri;
        });
      }
      if (Array.isArray(output.us)) {
        output.us = output.us.map((uri) => {
          if ((0, common_1.isRecord)(uri)) {
            return expandKeys(uri, MPT_META_URI_FIELDS);
          }
          return uri;
        });
      }
      return output;
    }
    exports.decodeMPTokenMetadata = decodeMPTokenMetadata;
    function validateMPTokenMetadata(input) {
      const validationMessages = [];
      if (!(0, _1.isHex)(input)) {
        validationMessages.push(`MPTokenMetadata must be in hex format.`);
        return validationMessages;
      }
      if (input.length / 2 > exports.MAX_MPT_META_BYTE_LENGTH) {
        validationMessages.push(`MPTokenMetadata must be max ${exports.MAX_MPT_META_BYTE_LENGTH} bytes.`);
        return validationMessages;
      }
      let jsonMetaData;
      try {
        jsonMetaData = JSON.parse((0, utils_1.hexToString)(input));
      } catch (err) {
        validationMessages.push(`MPTokenMetadata is not properly formatted as JSON - ${String(err)}`);
        return validationMessages;
      }
      if (!(0, common_1.isRecord)(jsonMetaData)) {
        validationMessages.push("MPTokenMetadata is not properly formatted JSON object as per XLS-89.");
        return validationMessages;
      }
      if (Object.keys(jsonMetaData).length > MPT_META_ALL_FIELDS.length) {
        validationMessages.push(`MPTokenMetadata must not contain more than ${MPT_META_ALL_FIELDS.length} top-level fields (found ${Object.keys(jsonMetaData).length}).`);
      }
      const obj = jsonMetaData;
      for (const property2 of MPT_META_ALL_FIELDS) {
        validationMessages.push(...property2.validate(obj));
      }
      return validationMessages;
    }
    exports.validateMPTokenMetadata = validateMPTokenMetadata;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceCreate.js
var require_MPTokenIssuanceCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceCreate = exports.MPTokenIssuanceCreateFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var mptokenMetadata_1 = require_mptokenMetadata();
    var common_1 = require_common3();
    var MAX_AMT = "9223372036854775807";
    var MAX_TRANSFER_FEE = 5e4;
    var MPTokenIssuanceCreateFlags;
    (function(MPTokenIssuanceCreateFlags2) {
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanLock"] = 2] = "tfMPTCanLock";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTRequireAuth"] = 4] = "tfMPTRequireAuth";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanEscrow"] = 8] = "tfMPTCanEscrow";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanTrade"] = 16] = "tfMPTCanTrade";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanTransfer"] = 32] = "tfMPTCanTransfer";
      MPTokenIssuanceCreateFlags2[MPTokenIssuanceCreateFlags2["tfMPTCanClawback"] = 64] = "tfMPTCanClawback";
    })(MPTokenIssuanceCreateFlags || (exports.MPTokenIssuanceCreateFlags = MPTokenIssuanceCreateFlags = {}));
    function validateMPTokenIssuanceCreate(tx) {
      var _a4, _b;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "MaximumAmount", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "MPTokenMetadata", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "TransferFee", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "AssetScale", common_1.isNumber);
      if (typeof tx.MPTokenMetadata === "string" && (!(0, utils_1.isHex)(tx.MPTokenMetadata) || tx.MPTokenMetadata.length / 2 > mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH)) {
        throw new errors_1.ValidationError(`MPTokenIssuanceCreate: MPTokenMetadata (hex format) must be non-empty and no more than ${mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH} bytes.`);
      }
      if (typeof tx.MaximumAmount === "string") {
        if (!utils_1.INTEGER_SANITY_CHECK.exec(tx.MaximumAmount)) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: Invalid MaximumAmount");
        } else if (BigInt(tx.MaximumAmount) > BigInt(MAX_AMT) || BigInt(tx.MaximumAmount) < BigInt(`0`)) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: MaximumAmount out of range");
        }
      }
      if (typeof tx.TransferFee === "number") {
        const flags = (_a4 = tx.Flags) !== null && _a4 !== void 0 ? _a4 : 0;
        const isTfMPTCanTransfer = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceCreateFlags.tfMPTCanTransfer) : (_b = flags.tfMPTCanTransfer) !== null && _b !== void 0 ? _b : false;
        if (tx.TransferFee < 0 || tx.TransferFee > MAX_TRANSFER_FEE) {
          throw new errors_1.ValidationError(`MPTokenIssuanceCreate: TransferFee must be between 0 and ${MAX_TRANSFER_FEE}`);
        }
        if (tx.TransferFee && !isTfMPTCanTransfer) {
          throw new errors_1.ValidationError("MPTokenIssuanceCreate: TransferFee cannot be provided without enabling tfMPTCanTransfer flag");
        }
      }
      if (tx.MPTokenMetadata != null) {
        const validationMessages = (0, mptokenMetadata_1.validateMPTokenMetadata)(tx.MPTokenMetadata);
        if (validationMessages.length > 0) {
          const message = [
            mptokenMetadata_1.MPT_META_WARNING_HEADER,
            ...validationMessages.map((msg) => `- ${msg}`)
          ].join("\n");
          console.warn(message);
        }
      }
    }
    exports.validateMPTokenIssuanceCreate = validateMPTokenIssuanceCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceSet.js
var require_MPTokenIssuanceSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceSet = exports.MPTokenIssuanceSetFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var MPTokenIssuanceSetFlags;
    (function(MPTokenIssuanceSetFlags2) {
      MPTokenIssuanceSetFlags2[MPTokenIssuanceSetFlags2["tfMPTLock"] = 1] = "tfMPTLock";
      MPTokenIssuanceSetFlags2[MPTokenIssuanceSetFlags2["tfMPTUnlock"] = 2] = "tfMPTUnlock";
    })(MPTokenIssuanceSetFlags || (exports.MPTokenIssuanceSetFlags = MPTokenIssuanceSetFlags = {}));
    function validateMPTokenIssuanceSet(tx) {
      var _a4, _b, _c;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
      const flags = (_a4 = tx.Flags) !== null && _a4 !== void 0 ? _a4 : 0;
      const isTfMPTLock = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTLock) : (_b = flags.tfMPTLock) !== null && _b !== void 0 ? _b : false;
      const isTfMPTUnlock = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTUnlock) : (_c = flags.tfMPTUnlock) !== null && _c !== void 0 ? _c : false;
      if (isTfMPTLock && isTfMPTUnlock) {
        throw new errors_1.ValidationError("MPTokenIssuanceSet: flag conflict");
      }
    }
    exports.validateMPTokenIssuanceSet = validateMPTokenIssuanceSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js
var require_NFTokenCreateOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenCreateOffer = exports.NFTokenCreateOfferFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var NFTokenCreateOfferFlags;
    (function(NFTokenCreateOfferFlags2) {
      NFTokenCreateOfferFlags2[NFTokenCreateOfferFlags2["tfSellNFToken"] = 1] = "tfSellNFToken";
    })(NFTokenCreateOfferFlags || (exports.NFTokenCreateOfferFlags = NFTokenCreateOfferFlags = {}));
    function validateNFTokenSellOfferCases(tx) {
      if (tx.Owner != null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner must not be present for sell offers");
      }
    }
    function validateNFTokenBuyOfferCases(tx) {
      if (tx.Owner == null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner must be present for buy offers");
      }
      if ((0, common_1.parseAmountValue)(tx.Amount) <= 0) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Amount must be greater than 0 for buy offers");
      }
    }
    function validateNFTokenCreateOffer(tx) {
      var _a4, _b;
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Owner) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Owner and Account must not be equal");
      }
      if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: Destination and Account must not be equal");
      }
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
      if (tx.NFTokenID == null) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: missing field NFTokenID");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("NFTokenCreateOffer: invalid Amount");
      }
      const flags = (_a4 = tx.Flags) !== null && _a4 !== void 0 ? _a4 : 0;
      const isTfSellNFToken = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, NFTokenCreateOfferFlags.tfSellNFToken) : (_b = flags.tfSellNFToken) !== null && _b !== void 0 ? _b : false;
      if (isTfSellNFToken) {
        validateNFTokenSellOfferCases(tx);
      } else {
        validateNFTokenBuyOfferCases(tx);
      }
    }
    exports.validateNFTokenCreateOffer = validateNFTokenCreateOffer;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js
var require_NFTokenMint = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenMint = exports.NFTokenMintFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var NFTokenMintFlags;
    (function(NFTokenMintFlags2) {
      NFTokenMintFlags2[NFTokenMintFlags2["tfBurnable"] = 1] = "tfBurnable";
      NFTokenMintFlags2[NFTokenMintFlags2["tfOnlyXRP"] = 2] = "tfOnlyXRP";
      NFTokenMintFlags2[NFTokenMintFlags2["tfTrustLine"] = 4] = "tfTrustLine";
      NFTokenMintFlags2[NFTokenMintFlags2["tfTransferable"] = 8] = "tfTransferable";
      NFTokenMintFlags2[NFTokenMintFlags2["tfMutable"] = 16] = "tfMutable";
    })(NFTokenMintFlags || (exports.NFTokenMintFlags = NFTokenMintFlags = {}));
    function validateNFTokenMint(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Issuer) {
        throw new errors_1.ValidationError("NFTokenMint: Issuer must not be equal to Account");
      }
      (0, common_1.validateOptionalField)(tx, "Issuer", common_1.isAccount);
      if (typeof tx.URI === "string" && tx.URI === "") {
        throw new errors_1.ValidationError("NFTokenMint: URI must not be empty string");
      }
      if (typeof tx.URI === "string" && !(0, utils_1.isHex)(tx.URI)) {
        throw new errors_1.ValidationError("NFTokenMint: URI must be in hex format");
      }
      if (tx.NFTokenTaxon == null) {
        throw new errors_1.ValidationError("NFTokenMint: missing field NFTokenTaxon");
      }
      if (tx.Amount == null) {
        if (tx.Expiration != null || tx.Destination != null) {
          throw new errors_1.ValidationError("NFTokenMint: Amount is required when Expiration or Destination is present");
        }
      }
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "Expiration", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
    }
    exports.validateNFTokenMint = validateNFTokenMint;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCreate.js
var require_offerCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOfferCreate = exports.OfferCreateFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var OfferCreateFlags;
    (function(OfferCreateFlags2) {
      OfferCreateFlags2[OfferCreateFlags2["tfPassive"] = 65536] = "tfPassive";
      OfferCreateFlags2[OfferCreateFlags2["tfImmediateOrCancel"] = 131072] = "tfImmediateOrCancel";
      OfferCreateFlags2[OfferCreateFlags2["tfFillOrKill"] = 262144] = "tfFillOrKill";
      OfferCreateFlags2[OfferCreateFlags2["tfSell"] = 524288] = "tfSell";
      OfferCreateFlags2[OfferCreateFlags2["tfHybrid"] = 1048576] = "tfHybrid";
    })(OfferCreateFlags || (exports.OfferCreateFlags = OfferCreateFlags = {}));
    function validateOfferCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.TakerGets === void 0) {
        throw new errors_1.ValidationError("OfferCreate: missing field TakerGets");
      }
      if (tx.TakerPays === void 0) {
        throw new errors_1.ValidationError("OfferCreate: missing field TakerPays");
      }
      if (typeof tx.TakerGets !== "string" && !(0, common_1.isAmount)(tx.TakerGets)) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerGets");
      }
      if (typeof tx.TakerPays !== "string" && !(0, common_1.isAmount)(tx.TakerPays)) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerPays");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("OfferCreate: invalid Expiration");
      }
      if (tx.OfferSequence !== void 0 && typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError("OfferCreate: invalid OfferSequence");
      }
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isDomainID, {
        txType: "OfferCreate",
        paramName: "DomainID"
      });
      if (tx.DomainID == null && (0, utils_1.hasFlag)(tx, OfferCreateFlags.tfHybrid, "tfHybrid")) {
        throw new errors_1.ValidationError("OfferCreate: tfHybrid flag cannot be set if DomainID is not present");
      }
    }
    exports.validateOfferCreate = validateOfferCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/payment.js
var require_payment = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/payment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePayment = exports.PaymentFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var PaymentFlags;
    (function(PaymentFlags2) {
      PaymentFlags2[PaymentFlags2["tfNoRippleDirect"] = 65536] = "tfNoRippleDirect";
      PaymentFlags2[PaymentFlags2["tfPartialPayment"] = 131072] = "tfPartialPayment";
      PaymentFlags2[PaymentFlags2["tfLimitQuality"] = 262144] = "tfLimitQuality";
    })(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));
    function validatePayment(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentTransaction: missing field Amount");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid Amount");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError("PaymentTransaction: InvoiceID must be a string");
      }
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isDomainID, {
        txType: "PaymentTransaction",
        paramName: "DomainID"
      });
      if (tx.Paths !== void 0 && !isPaths(tx.Paths)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid Paths");
      }
      if (tx.SendMax !== void 0 && !(0, common_1.isAmount)(tx.SendMax)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid SendMax");
      }
      checkPartialPayment(tx);
    }
    exports.validatePayment = validatePayment;
    function checkPartialPayment(tx) {
      var _a4;
      if (tx.DeliverMin != null) {
        if (tx.Flags == null) {
          throw new errors_1.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
        }
        const flags = tx.Flags;
        const isTfPartialPayment = typeof flags === "number" ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment) : (_a4 = flags.tfPartialPayment) !== null && _a4 !== void 0 ? _a4 : false;
        if (!isTfPartialPayment) {
          throw new errors_1.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
        }
        if (!(0, common_1.isAmount)(tx.DeliverMin)) {
          throw new errors_1.ValidationError("PaymentTransaction: invalid DeliverMin");
        }
      }
    }
    function isPathStep(pathStep) {
      if (pathStep.account !== void 0 && typeof pathStep.account !== "string") {
        return false;
      }
      if (pathStep.currency !== void 0 && typeof pathStep.currency !== "string") {
        return false;
      }
      if (pathStep.issuer !== void 0 && typeof pathStep.issuer !== "string") {
        return false;
      }
      if (pathStep.account !== void 0 && pathStep.currency === void 0 && pathStep.issuer === void 0) {
        return true;
      }
      if (pathStep.currency !== void 0 || pathStep.issuer !== void 0) {
        return true;
      }
      return false;
    }
    function isPath(path) {
      if (!Array.isArray(path) || path.length === 0) {
        return false;
      }
      for (const pathStep of path) {
        if (!isPathStep(pathStep)) {
          return false;
        }
      }
      return true;
    }
    function isPaths(paths) {
      if (!(0, common_1.isArray)(paths) || paths.length === 0) {
        return false;
      }
      for (const path of paths) {
        if (!(0, common_1.isArray)(path) || path.length === 0) {
          return false;
        }
        if (!isPath(path)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js
var require_paymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelClaim = exports.PaymentChannelClaimFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var PaymentChannelClaimFlags;
    (function(PaymentChannelClaimFlags2) {
      PaymentChannelClaimFlags2[PaymentChannelClaimFlags2["tfRenew"] = 65536] = "tfRenew";
      PaymentChannelClaimFlags2[PaymentChannelClaimFlags2["tfClose"] = 131072] = "tfClose";
    })(PaymentChannelClaimFlags || (exports.PaymentChannelClaimFlags = PaymentChannelClaimFlags = {}));
    function validatePaymentChannelClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError("PaymentChannelClaim: missing Channel");
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Channel must be a string");
      }
      if (tx.Balance !== void 0 && typeof tx.Balance !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Balance must be a string");
      }
      if (tx.Amount !== void 0 && typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Amount must be a string");
      }
      if (tx.Signature !== void 0 && typeof tx.Signature !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: Signature must be a string");
      }
      if (tx.PublicKey !== void 0 && typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError("PaymentChannelClaim: PublicKey must be a string");
      }
    }
    exports.validatePaymentChannelClaim = validatePaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/trustSet.js
var require_trustSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/trustSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTrustSet = exports.TrustSetFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var TrustSetFlags;
    (function(TrustSetFlags2) {
      TrustSetFlags2[TrustSetFlags2["tfSetfAuth"] = 65536] = "tfSetfAuth";
      TrustSetFlags2[TrustSetFlags2["tfSetNoRipple"] = 131072] = "tfSetNoRipple";
      TrustSetFlags2[TrustSetFlags2["tfClearNoRipple"] = 262144] = "tfClearNoRipple";
      TrustSetFlags2[TrustSetFlags2["tfSetFreeze"] = 1048576] = "tfSetFreeze";
      TrustSetFlags2[TrustSetFlags2["tfClearFreeze"] = 2097152] = "tfClearFreeze";
      TrustSetFlags2[TrustSetFlags2["tfSetDeepFreeze"] = 4194304] = "tfSetDeepFreeze";
      TrustSetFlags2[TrustSetFlags2["tfClearDeepFreeze"] = 8388608] = "tfClearDeepFreeze";
    })(TrustSetFlags || (exports.TrustSetFlags = TrustSetFlags = {}));
    function validateTrustSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { LimitAmount, QualityIn, QualityOut } = tx;
      if (LimitAmount === void 0) {
        throw new errors_1.ValidationError("TrustSet: missing field LimitAmount");
      }
      if (!(0, common_1.isAmount)(LimitAmount)) {
        throw new errors_1.ValidationError("TrustSet: invalid LimitAmount");
      }
      if (QualityIn !== void 0 && typeof QualityIn !== "number") {
        throw new errors_1.ValidationError("TrustSet: QualityIn must be a number");
      }
      if (QualityOut !== void 0 && typeof QualityOut !== "number") {
        throw new errors_1.ValidationError("TrustSet: QualityOut must be a number");
      }
    }
    exports.validateTrustSet = validateTrustSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultCreate.js
var require_vaultCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultCreate = exports.VaultCreateFlags = exports.VaultWithdrawalPolicy = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var mptokenMetadata_1 = require_mptokenMetadata();
    var common_1 = require_common3();
    var VaultWithdrawalPolicy;
    (function(VaultWithdrawalPolicy2) {
      VaultWithdrawalPolicy2[VaultWithdrawalPolicy2["vaultStrategyFirstComeFirstServe"] = 1] = "vaultStrategyFirstComeFirstServe";
    })(VaultWithdrawalPolicy || (exports.VaultWithdrawalPolicy = VaultWithdrawalPolicy = {}));
    var VaultCreateFlags;
    (function(VaultCreateFlags2) {
      VaultCreateFlags2[VaultCreateFlags2["tfVaultPrivate"] = 65536] = "tfVaultPrivate";
      VaultCreateFlags2[VaultCreateFlags2["tfVaultShareNonTransferable"] = 131072] = "tfVaultShareNonTransferable";
    })(VaultCreateFlags || (exports.VaultCreateFlags = VaultCreateFlags = {}));
    function validateVaultCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Asset", common_1.isCurrency);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "AssetsMaximum", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "MPTokenMetadata", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "WithdrawalPolicy", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isString);
      if (tx.Data !== void 0) {
        const dataHex = tx.Data;
        if (!(0, utils_1.isHex)(dataHex)) {
          throw new errors_1.ValidationError("VaultCreate: Data must be a valid hex string");
        }
        const dataByteLength = dataHex.length / 2;
        if (dataByteLength > common_1.VAULT_DATA_MAX_BYTE_LENGTH) {
          throw new errors_1.ValidationError(`VaultCreate: Data exceeds ${common_1.VAULT_DATA_MAX_BYTE_LENGTH} bytes (actual: ${dataByteLength})`);
        }
      }
      if (tx.MPTokenMetadata !== void 0) {
        const metaHex = tx.MPTokenMetadata;
        if (!(0, utils_1.isHex)(metaHex)) {
          throw new errors_1.ValidationError("VaultCreate: MPTokenMetadata must be a valid non-empty hex string");
        }
        const metaByteLength = metaHex.length / 2;
        if (metaByteLength > mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH) {
          throw new errors_1.ValidationError(`VaultCreate: MPTokenMetadata exceeds ${mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH} bytes (actual: ${metaByteLength})`);
        }
      }
      if (tx.DomainID !== void 0 && !(0, utils_1.hasFlag)(tx, VaultCreateFlags.tfVaultPrivate, "tfVaultPrivate")) {
        throw new errors_1.ValidationError("VaultCreate: Cannot set DomainID unless tfVaultPrivate flag is set.");
      }
      if (tx.MPTokenMetadata != null) {
        const validationMessages = (0, mptokenMetadata_1.validateMPTokenMetadata)(tx.MPTokenMetadata);
        if (validationMessages.length > 0) {
          const message = [
            mptokenMetadata_1.MPT_META_WARNING_HEADER,
            ...validationMessages.map((msg) => `- ${msg}`)
          ].join("\n");
          console.warn(message);
        }
      }
    }
    exports.validateVaultCreate = validateVaultCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js
var require_XChainModifyBridge = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainModifyBridge = exports.XChainModifyBridgeFlags = void 0;
    var common_1 = require_common3();
    var XChainModifyBridgeFlags;
    (function(XChainModifyBridgeFlags2) {
      XChainModifyBridgeFlags2[XChainModifyBridgeFlags2["tfClearAccountCreateAmount"] = 65536] = "tfClearAccountCreateAmount";
    })(XChainModifyBridgeFlags || (exports.XChainModifyBridgeFlags = XChainModifyBridgeFlags = {}));
    function validateXChainModifyBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateOptionalField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "MinAccountCreateAmount", common_1.isAmount);
    }
    exports.validateXChainModifyBridge = validateXChainModifyBridge;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/flags.js
var require_flags = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = void 0;
    var errors_1 = require_errors();
    var AccountRoot_1 = require_AccountRoot();
    var accountSet_1 = require_accountSet();
    var AMMClawback_1 = require_AMMClawback();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var batch_1 = require_batch();
    var common_1 = require_common3();
    var loanManage_1 = require_loanManage();
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var offerCreate_1 = require_offerCreate();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var trustSet_1 = require_trustSet();
    var vaultCreate_1 = require_vaultCreate();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    var _1 = require_utils4();
    function parseAccountRootFlags(flags) {
      const flagsInterface = {};
      Object.values(AccountRoot_1.AccountRootFlags).forEach((flag) => {
        if (typeof flag === "string" && (0, _1.isFlagEnabled)(flags, AccountRoot_1.AccountRootFlags[flag])) {
          flagsInterface[flag] = true;
        }
      });
      return flagsInterface;
    }
    exports.parseAccountRootFlags = parseAccountRootFlags;
    var txToFlag = {
      AccountSet: accountSet_1.AccountSetTfFlags,
      AMMClawback: AMMClawback_1.AMMClawbackFlags,
      AMMDeposit: AMMDeposit_1.AMMDepositFlags,
      AMMWithdraw: AMMWithdraw_1.AMMWithdrawFlags,
      Batch: batch_1.BatchFlags,
      LoanManage: loanManage_1.LoanManageFlags,
      MPTokenAuthorize: MPTokenAuthorize_1.MPTokenAuthorizeFlags,
      MPTokenIssuanceCreate: MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags,
      MPTokenIssuanceSet: MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags,
      NFTokenCreateOffer: NFTokenCreateOffer_1.NFTokenCreateOfferFlags,
      NFTokenMint: NFTokenMint_1.NFTokenMintFlags,
      OfferCreate: offerCreate_1.OfferCreateFlags,
      PaymentChannelClaim: paymentChannelClaim_1.PaymentChannelClaimFlags,
      Payment: payment_1.PaymentFlags,
      TrustSet: trustSet_1.TrustSetFlags,
      VaultCreate: vaultCreate_1.VaultCreateFlags,
      XChainModifyBridge: XChainModifyBridge_1.XChainModifyBridgeFlags
    };
    function isTxToFlagKey(transactionType) {
      return transactionType in txToFlag;
    }
    function setTransactionFlagsToNumber(tx) {
      console.warn("This function is deprecated. Use convertTxFlagsToNumber() instead and use the returned value to modify the Transaction.Flags from the caller.");
      if (tx.Flags) {
        tx.Flags = convertTxFlagsToNumber(tx);
      }
    }
    exports.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
    function convertTxFlagsToNumber(tx) {
      const txFlags = tx.Flags;
      if (txFlags == null) {
        return 0;
      }
      if (typeof txFlags === "number") {
        return txFlags;
      }
      if (isTxToFlagKey(tx.TransactionType)) {
        const flagEnum = txToFlag[tx.TransactionType];
        return Object.keys(txFlags).reduce((resultFlags, flag) => {
          var _a4;
          if (flagEnum[flag] == null && common_1.GlobalFlags[flag] == null) {
            throw new errors_1.ValidationError(`Invalid flag ${flag}.`);
          }
          return txFlags[flag] ? resultFlags | ((_a4 = flagEnum[flag]) !== null && _a4 !== void 0 ? _a4 : common_1.GlobalFlags[flag]) : resultFlags;
        }, 0);
      }
      return Object.keys(txFlags).reduce((resultFlags, flag) => {
        if (common_1.GlobalFlags[flag] == null) {
          throw new errors_1.ValidationError(`Invalid flag ${flag}. Valid flags are ${JSON.stringify(common_1.GlobalFlags)}`);
        }
        return txFlags[flag] ? resultFlags | common_1.GlobalFlags[flag] : resultFlags;
      }, 0);
    }
    exports.convertTxFlagsToNumber = convertTxFlagsToNumber;
    function parseTransactionFlags(tx) {
      const flags = convertTxFlagsToNumber(tx);
      if (flags === 0) {
        return {};
      }
      const booleanFlagMap = {};
      if (isTxToFlagKey(tx.TransactionType)) {
        const transactionTypeFlags = txToFlag[tx.TransactionType];
        Object.values(transactionTypeFlags).forEach((flag) => {
          if (typeof flag === "string" && (0, _1.isFlagEnabled)(flags, transactionTypeFlags[flag])) {
            booleanFlagMap[flag] = true;
          }
        });
      }
      Object.values(common_1.GlobalFlags).forEach((flag) => {
        if (typeof flag === "string" && (0, _1.isFlagEnabled)(flags, common_1.GlobalFlags[flag])) {
          booleanFlagMap[flag] = true;
        }
      });
      return booleanFlagMap;
    }
    exports.parseTransactionFlags = parseTransactionFlags;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K3;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K3 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K3 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K3 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K3 = 3395469782;
          }
          const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K3 + SHA1_W[i] | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.SHA1 = SHA1;
    exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = /* @__PURE__ */ Math.pow(2, 32);
    var K2 = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
    var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
    var MD5_W = /* @__PURE__ */ new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = 7 * i % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K2[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports.MD5 = MD5;
    exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = /* @__PURE__ */ Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
    var idxLR = /* @__PURE__ */ (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res)
          j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    var idxL = /* @__PURE__ */ (() => idxLR[0])();
    var idxR = /* @__PURE__ */ (() => idxLR[1])();
    var shifts160 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => Uint8Array.from(i));
    var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
    var Kl160 = /* @__PURE__ */ Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr160 = /* @__PURE__ */ Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function ripemd_f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      if (group === 1)
        return x & y | ~x & z;
      if (group === 2)
        return (x | ~y) ^ z;
      if (group === 3)
        return x & z | y & ~z;
      return x ^ (y | ~z);
    }
    var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var legacy_ts_1 = require_legacy();
    exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
    exports.ripemd160 = legacy_ts_1.ripemd160;
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ripemd160/browser.js
var require_browser4 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ripemd160/browser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var wrapNoble_1 = __importDefault(require_wrapNoble());
    exports.ripemd160 = (0, wrapNoble_1.default)(ripemd160_1.ripemd160);
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash2);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    exports.abool = abool;
    exports._abool2 = _abool2;
    exports._abytes2 = _abytes2;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE2;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes2;
    exports.equalBytes = equalBytes2;
    exports.copyBytes = copyBytes;
    exports.asciiToBytes = asciiToBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.isHash = isHash;
    exports._validateObject = _validateObject;
    exports.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n2 = /* @__PURE__ */ BigInt(0);
    var _1n2 = /* @__PURE__ */ BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function _abool2(value, title = "") {
      if (typeof value !== "boolean") {
        const prefix2 = title && `"${title}"`;
        throw new Error(prefix2 + "expected boolean, got type=" + typeof value);
      }
      return value;
    }
    function _abytes2(value, length, title = "") {
      const bytes = (0, utils_js_1.isBytes)(value);
      const len = value?.length;
      const needsLen = length !== void 0;
      if (!bytes || needsLen && len !== length) {
        const prefix2 = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix2 + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n2 : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE2(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes2(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes2(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    function asciiToBytes(ascii) {
      return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
          throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
      });
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n2 <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n2; n >>= _1n2, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n2;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n2 : _0n2) << BigInt(pos);
    }
    var bitMask = (n) => (_1n2 << BigInt(n)) - _1n2;
    exports.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object2) => object2.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object2, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object2[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object2)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object2;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object2, fields, optFields = {}) {
      if (!object2 || typeof object2 !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object2[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod2;
    exports.pow = pow;
    exports.pow2 = pow22;
    exports.invert = invert2;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils5();
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = /* @__PURE__ */ BigInt(2);
    var _3n = /* @__PURE__ */ BigInt(3);
    var _4n = /* @__PURE__ */ BigInt(4);
    var _5n = /* @__PURE__ */ BigInt(5);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _8n2 = /* @__PURE__ */ BigInt(8);
    var _9n = /* @__PURE__ */ BigInt(9);
    var _16n = /* @__PURE__ */ BigInt(16);
    function mod2(a, b) {
      const result = a % b;
      return result >= _0n2 ? result : b + result;
    }
    function pow(num, power, modulo) {
      return FpPow(Field(modulo), num, power);
    }
    function pow22(x, power, modulo) {
      let res = x;
      while (power-- > _0n2) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert2(number3, modulo) {
      if (number3 === _0n2)
        throw new Error("invert: expected non-zero number");
      if (modulo <= _0n2)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod2(number3, modulo);
      let b = modulo;
      let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
      while (a !== _0n2) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n2)
        throw new Error("invert: does not exist");
      return mod2(x, modulo);
    }
    function assertIsSquare(Fp, root, n) {
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n2) / _4n;
      const root = Fp.pow(n, p1div4);
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n2;
      const n2 = Fp.mul(n, _2n2);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n2), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp, n) => {
        let tv1 = Fp.pow(n, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c2);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n);
        const e2 = Fp.eql(Fp.sqr(tv3), n);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n)
        throw new Error("sqrt is not defined for small field");
      let Q = P - _1n2;
      let S = 0;
      while (Q % _2n2 === _0n2) {
        Q /= _2n2;
        S++;
      }
      let Z = _2n2;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1)
        return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n2) / _2n2;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
          return n;
        if (FpLegendre(Fp, n) !== 1)
          throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n2 << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n)
        return sqrt3mod4;
      if (P % _8n2 === _5n)
        return sqrt5mod8;
      if (P % _16n === _9n)
        return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod2(num, modulo) & _1n2) === _1n2;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n2)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n2)
        return Fp.ONE;
      if (power === _1n2)
        return num;
      let p = Fp.ONE;
      let d = num;
      while (power > _0n2) {
        if (power & _1n2)
          p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n2;
      }
      return p;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
          return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert2(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n2) / _2n2;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n2)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modFromBytes = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === "boolean")
          modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n2,
        ONE: _1n2,
        allowedLengths,
        create: (num) => mod2(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n2 <= num && num < ORDER;
        },
        is0: (num) => num === _0n2,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n2) === _1n2,
        neg: (num) => mod2(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod2(num * num, ORDER),
        add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert2(num, ORDER),
        sqrt: _sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
          if (modFromBytes)
            scalar = mod2(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => c ? b : a
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
      return mod2(num, groupOrder - _1n2) + _1n2;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod2(num, fieldOrder - _1n2) + _1n2;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = void 0;
    exports.negateCt = negateCt;
    exports.normalizeZ = normalizeZ;
    exports.mulEndoUnsafe = mulEndoUnsafe;
    exports.pippenger = pippenger;
    exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports.validateBasic = validateBasic;
    exports._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
      return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n2;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n2)
        throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point2, bits) {
        this.BASE = Point2.BASE;
        this.ZERO = Point2.ZERO;
        this.Fn = Point2.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n2) {
          if (n & _1n2)
            p = p.add(d);
          d = d.double();
          n >>= _1n2;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base2 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n))
          throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n2)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform2) {
        let comp = pointPrecomputes2.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform2 === "function")
              comp = transform2(comp);
            pointPrecomputes2.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform2) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform2), scalar);
      }
      unsafe(point, scalar, transform2, prev) {
        const W = getW(point);
        if (W === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform2), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes2.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports.wNAF = wNAF;
    function mulEndoUnsafe(Point2, point, k1, k2) {
      let acc = point;
      let p1 = Point2.ZERO;
      let p2 = Point2.ZERO;
      while (k1 > _0n2 || k2 > _0n2) {
        if (k1 & _1n2)
          p1 = p1.add(acc);
        if (k2 & _1n2)
          p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n2;
        k2 >>= _1n2;
      }
      return { p1, p2 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field, isLE) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order, { isLE });
      }
    }
    function _createCurveFields(type, CURVE2, curveOpts = {}, FpFnLE) {
      if (FpFnLE === void 0)
        FpFnLE = type === "edwards";
      if (!CURVE2 || typeof CURVE2 !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE2[p];
        if (!(typeof val === "bigint" && val > _0n2))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp = createField(CURVE2.p, curveOpts.Fp, FpFnLE);
      const Fn = createField(CURVE2.n, curveOpts.Fn, FpFnLE);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp.isValid(CURVE2[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      CURVE2 = Object.freeze(Object.assign({}, CURVE2));
      return { CURVE: CURVE2, Fp, Fn };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = exports.DERErr = void 0;
    exports._splitEndoScalar = _splitEndoScalar;
    exports._normFnElement = _normFnElement;
    exports.weierstrassN = weierstrassN;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports.ecdh = ecdh;
    exports.ecdsa = ecdsa;
    exports.weierstrassPoints = weierstrassPoints;
    exports._legacyHelperEquat = _legacyHelperEquat;
    exports.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils5();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n2) / den;
    function _splitEndoScalar(k, basis, n) {
      const [[a1, b1], [a2, b2]] = basis;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = k - c1 * a1 - c2 * a2;
      let k2 = -c1 * b1 - c2 * b2;
      const k1neg = k1 < _0n2;
      const k2neg = k2 < _0n2;
      if (k1neg)
        k1 = -k1;
      if (k2neg)
        k2 = -k2;
      const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n2;
      if (k1 < _0n2 || k1 >= MAX_NUM || k2 < _0n2 || k2 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function validateSigFormat(format) {
      if (!["compact", "recovered", "der"].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
      return format;
    }
    function validateSigOpts(opts, def) {
      const optsn = {};
      for (let optName of Object.keys(def)) {
        optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
      }
      (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
      (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
      if (optsn.format !== void 0)
        validateSigFormat(optsn.format);
      return optsn;
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports.DERErr = DERErr;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports.DER;
          if (num < _0n2)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports.DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int2, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int2.decode(rBytes), s: int2.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int2 } = exports.DER;
        const rs = tlv.encode(2, int2.encode(sig.r));
        const ss = tlv.encode(2, int2.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _normFnElement(Fn, key) {
      const { BYTES: expected } = Fn;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
      const { Fp, Fn } = validated;
      let CURVE2 = validated.CURVE;
      const { h: cofactor, n: CURVE_ORDER } = CURVE2;
      (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = extraOpts;
      if (endo) {
        if (!Fp.is0(CURVE2.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
          throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
      }
      const lengths = getWLengths(Fp, Fn);
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === comp && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
          return { x, y };
        } else if (length === uncomp && head === 4) {
          const L = Fp.BYTES;
          const x = Fp.fromBytes(tail.subarray(0, L));
          const y = Fp.fromBytes(tail.subarray(L, L * 2));
          if (!isValidXY(x, y))
            throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
      }
      const encodePoint = extraOpts.toBytes || pointToBytes;
      const decodePoint = extraOpts.fromBytes || pointFromBytes;
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE2.a)), CURVE2.b);
      }
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE2.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE2.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || banZero && Fp.is0(n))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point2))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
          throw new Error("no endo");
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        if (Fp.eql(Z, Fp.ONE))
          return { x: X, y: Y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
          if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point2(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point2 {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y, true);
          this.Z = acoord("z", Z);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE2;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point2)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y))
            return Point2.ZERO;
          return new Point2(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
          const P = Point2.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
          P.assertValidity();
          return P;
        }
        static fromHex(hex) {
          return Point2.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point2(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE2;
          const b3 = Fp.mul(b, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point2(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE2.a;
          const b3 = Fp.mul(CURVE2.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point2(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point2.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = extraOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point2, p));
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p, f } = mul(scalar);
            point = p;
            fake = f;
          }
          return (0, curve_ts_1.normalizeZ)(Point2, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = extraOpts;
          const p = this;
          if (!Fn.isValid(sc))
            throw new Error("invalid scalar: out of range");
          if (sc === _0n2 || p.is0())
            return Point2.ZERO;
          if (sc === _1n2)
            return p;
          if (wnaf.hasCache(this))
            return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
            const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point2, p, k1, k2);
            return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = extraOpts;
          if (cofactor === _1n2)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point2, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = extraOpts;
          if (cofactor === _1n2)
            return this;
          if (clearCofactor)
            return clearCofactor(Point2, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          this.assertValidity();
          return encodePoint(Point2, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point2, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point2, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
          return Point2.BASE.multiply(_normFnElement(Fn, privateKey));
        }
      }
      Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp.ONE);
      Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point2.Fp = Fp;
      Point2.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = new curve_ts_1.wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
      Point2.BASE.precompute(8);
      return Point2;
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n2;
      for (let o = q - _1n2; o % _2n2 === _0n2; o /= _2n2)
        l += _1n2;
      const c1 = l;
      const _2n_pow_c1_1 = _2n2 << c1 - _1n2 - _1n2;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
      const c2 = (q - _1n2) / _2n_pow_c1;
      const c3 = (c2 - _1n2) / _2n2;
      const c4 = _2n_pow_c1 - _1n2;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n2) / _2n2);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n2; i--) {
          let tv52 = i - _2n2;
          tv52 = _2n2 << tv52 - _1n2;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
    function getWLengths(Fp, Fn) {
      return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES
      };
    }
    function ecdh(Point2, ecdhOpts = {}) {
      const { Fn } = Point2;
      const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
      const lengths = Object.assign(getWLengths(Point2.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
      function isValidSecretKey(secretKey) {
        try {
          return !!_normFnElement(Fn, secretKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
          const l = publicKey.length;
          if (isCompressed === true && l !== comp)
            return false;
          if (isCompressed === false && l !== publicKeyUncompressed)
            return false;
          return !!Point2.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"), Fn.ORDER);
      }
      function getPublicKey2(secretKey, isCompressed = true) {
        return Point2.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
      }
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey2(secretKey) };
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point2)
          return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
          return void 0;
        const l = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l === publicKey || l === publicKeyUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point2.fromHex(publicKeyB);
        return b.multiply(s).toBytes(isCompressed);
      }
      const utils2 = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point2.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({ getPublicKey: getPublicKey2, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
    }
    function ecdsa(Point2, hash2, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash2);
      (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point2;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      const { keygen, getPublicKey: getPublicKey2, getSharedSecret, utils: utils2, lengths } = ecdh(Point2, ecdsaOpts);
      const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: false
      };
      const defaultSigOpts_format = "compact";
      function isBiggerThanHalfOrder(number3) {
        const HALF = CURVE_ORDER >> _1n2;
        return number3 > HALF;
      }
      function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
      }
      function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
      }
      class Signature2 {
        constructor(r, s, recovery) {
          this.r = validateRS("r", r);
          this.s = validateRS("s", s);
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
          validateSigLength(bytes, format);
          let recid;
          if (format === "der") {
            const { r: r2, s: s2 } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
            return new Signature2(r2, s2);
          }
          if (format === "recovered") {
            recid = bytes[0];
            format = "compact";
            bytes = bytes.subarray(1);
          }
          const L = Fn.BYTES;
          const r = bytes.subarray(0, L);
          const s = bytes.subarray(L, L * 2);
          return new Signature2(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
          return new Signature2(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point2.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
          const ir = Fn.inv(radj);
          const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0())
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
          validateSigFormat(format);
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
          const r = Fn.toBytes(this.r);
          const s = Fn.toBytes(this.s);
          if (format === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
          }
          return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(hex) {
          return Signature2.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "compact");
        }
        static fromDER(hex) {
          return Signature2.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex), "der");
        }
        normalizeS() {
          return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
        const delta = bytes.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
        return Fn.create(bits2int(bytes));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n2, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, void 0, "message");
        return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
      }
      function prepSig(message, privateKey, opts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (extraEntropy != null && extraEntropy !== false) {
          const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k))
            return;
          const ik = Fn.inv(k);
          const q = Point2.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n2)
            return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n2)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n2);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = Fn.neg(s);
            recovery ^= 1;
          }
          return new Signature2(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      function sign2(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)("message", message);
        const { seed, k2sig } = prepSig(message, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig);
        return sig;
      }
      function tryParsingSig(sg) {
        let sig = void 0;
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (isObj) {
          sig = new Signature2(sg.r, sg.s);
        } else if (isHex) {
          try {
            sig = Signature2.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
          }
          if (!sig) {
            try {
              sig = Signature2.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
            } catch (error) {
              return false;
            }
          }
        }
        if (!sig)
          return false;
        return sig;
      }
      function verify2(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const sig = format === void 0 ? tryParsingSig(signature) : Signature2.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
        if (sig === false)
          return false;
        try {
          const P = Point2.fromBytes(publicKey);
          if (lowS && sig.hasHighS())
            return false;
          const { r, s } = sig;
          const h = bits2int_modN(message);
          const is = Fn.inv(s);
          const u1 = Fn.create(h * is);
          const u2 = Fn.create(r * is);
          const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
          if (R.is0())
            return false;
          const v = Fn.create(R.x);
          return v === r;
        } catch (e) {
          return false;
        }
      }
      function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
      }
      return Object.freeze({
        keygen,
        getPublicKey: getPublicKey2,
        getSharedSecret,
        utils: utils2,
        lengths,
        Point: Point2,
        sign: sign2,
        verify: verify2,
        recoverPublicKey,
        Signature: Signature2,
        hash: hash2
      });
    }
    function weierstrassPoints(c) {
      const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point2 = weierstrassN(CURVE2, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point2);
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE2 = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
      const Fn = (0, modular_ts_1.Field)(CURVE2.n, {
        BITS: c.nBitLength,
        allowedLengths,
        modFromBytes: c.wrapPrivateKey
      });
      const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes
      };
      return { CURVE: CURVE2, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE: CURVE2, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN
      };
      return { CURVE: CURVE2, curveOpts, hash: c.hash, ecdsaOpts };
    }
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _weierstrass_new_output_to_legacy(c, Point2) {
      const { Fp, Fn } = Point2;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n2, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      return Object.assign({}, {
        CURVE: c,
        Point: Point2,
        ProjectivePoint: Point2,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c, _ecdsa) {
      const Point2 = _ecdsa.Point;
      return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point2,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point2.Fn.ORDER, Point2.Fn.BITS))
      });
    }
    function weierstrass(c) {
      const { CURVE: CURVE2, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
      const Point2 = weierstrassN(CURVE2, curveOpts);
      const signs = ecdsa(Point2, hash2, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash2) {
      return { hash: hash2 };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
      return { ...create(defHash), create };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._DST_scalar = void 0;
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p, k, m, hash: hash2, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point2, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point2.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point2.ZERO))
          return Point2.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map(u[0]);
          const u1 = map(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u = hash_to_field(msg, 1, opts);
          const u0 = map(u[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N = Point2.Fn.ORDER;
          const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
          return hash_to_field(msg, 1, opts)[0][0];
        }
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils5();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    var _0n2 = /* @__PURE__ */ BigInt(0);
    var _1n2 = /* @__PURE__ */ BigInt(1);
    var _2n2 = /* @__PURE__ */ BigInt(2);
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n2, P) * b2 % P;
      const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n2, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
    var hasEven = (y) => y % _2n2 === _0n2;
    function schnorrGetExtPubKey(priv) {
      const { Fn, BASE } = Pointk1;
      const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
      const p = BASE.multiply(d_);
      const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      const Fp = Fpk1;
      if (!Fp.isValidNot0(x))
        throw new Error("invalid x: Fail if x \u2265 p");
      const xx = Fp.create(x * x);
      const c = Fp.create(xx * x + BigInt(7));
      let y = Fp.sqrt(c);
      if (!hasEven(y))
        y = Fp.neg(y);
      const p = Pointk1.fromAffine({ x, y });
      p.assertValidity();
      return p;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const { Fn } = Pointk1;
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const { Fn, BASE } = Pointk1;
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n2, secp256k1_CURVE.p))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n2, secp256k1_CURVE.n))
          return false;
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod
        },
        lengths: {
          secretKey: size,
          publicKey: size,
          publicKeyHasPrefix: false,
          signature: size * 2,
          seed: seedLength
        }
      };
    })();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHash = exports.validateObject = exports.memoized = exports.notImplemented = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.aInRange = exports.inRange = exports.asciiToBytes = exports.copyBytes = exports.equalBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToNumber = exports.numberToHexUnpadded = exports.abool = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    var u = require_utils5();
    exports.abytes = u.abytes;
    exports.anumber = u.anumber;
    exports.bytesToHex = u.bytesToHex;
    exports.bytesToUtf8 = u.bytesToUtf8;
    exports.concatBytes = u.concatBytes;
    exports.hexToBytes = u.hexToBytes;
    exports.isBytes = u.isBytes;
    exports.randomBytes = u.randomBytes;
    exports.utf8ToBytes = u.utf8ToBytes;
    exports.abool = u.abool;
    exports.numberToHexUnpadded = u.numberToHexUnpadded;
    exports.hexToNumber = u.hexToNumber;
    exports.bytesToNumberBE = u.bytesToNumberBE;
    exports.bytesToNumberLE = u.bytesToNumberLE;
    exports.numberToBytesBE = u.numberToBytesBE;
    exports.numberToBytesLE = u.numberToBytesLE;
    exports.numberToVarBytesBE = u.numberToVarBytesBE;
    exports.ensureBytes = u.ensureBytes;
    exports.equalBytes = u.equalBytes;
    exports.copyBytes = u.copyBytes;
    exports.asciiToBytes = u.asciiToBytes;
    exports.inRange = u.inRange;
    exports.aInRange = u.aInRange;
    exports.bitLen = u.bitLen;
    exports.bitGet = u.bitGet;
    exports.bitSet = u.bitSet;
    exports.bitMask = u.bitMask;
    exports.createHmacDrbg = u.createHmacDrbg;
    exports.notImplemented = u.notImplemented;
    exports.memoized = u.memoized;
    exports.validateObject = u.validateObject;
    exports.isHash = u.isHash;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/Sha512.js
var require_Sha512 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/Sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha512_1 = require_browser3();
    var utils_1 = require_utils6();
    var Sha512 = class _Sha512 {
      constructor() {
        this.hash = sha512_1.sha512.create();
      }
      static half(input) {
        return new _Sha512().add(input).first256();
      }
      add(bytes) {
        this.hash.update(bytes);
        return this;
      }
      addU32(i) {
        const buffer = new Uint8Array(4);
        new DataView(buffer.buffer).setUint32(0, i);
        return this.add(buffer);
      }
      finish() {
        return this.hash.digest();
      }
      first256() {
        return this.finish().slice(0, 32);
      }
      first256BigInt() {
        return (0, utils_1.bytesToNumberBE)(this.first256());
      }
    };
    exports.default = Sha512;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js
var require_utils7 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
    var secp256k1_1 = require_secp256k1();
    var Sha512_1 = __importDefault(require_Sha512());
    var ZERO = BigInt(0);
    function deriveScalar(bytes, discrim) {
      const order = secp256k1_1.secp256k1.CURVE.n;
      for (let i = 0; i <= 4294967295; i++) {
        const hasher = new Sha512_1.default().add(bytes);
        if (discrim !== void 0) {
          hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BigInt();
        if (key > ZERO && key < order) {
          return key;
        }
      }
      throw new Error("impossible unicorn ;)");
    }
    function derivePrivateKey(seed, opts = {}) {
      const root = opts.validator;
      const order = secp256k1_1.secp256k1.CURVE.n;
      const privateGen = deriveScalar(seed);
      if (root) {
        return privateGen;
      }
      const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
      const accountIndex = opts.accountIndex || 0;
      return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
    }
    exports.derivePrivateKey = derivePrivateKey;
    function accountPublicFromPublicGenerator(publicGenBytes) {
      const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
      const scalar = deriveScalar(publicGenBytes, 0);
      const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);
      const offset = rootPubPoint.add(point);
      return offset.toRawBytes(true);
    }
    exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assertHelper = {
      ok(cond, message) {
        if (!cond) {
          throw new Error(message);
        }
      }
    };
    exports.default = assertHelper;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js
var require_getAlgorithmFromKey = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
    var Prefix;
    (function(Prefix2) {
      Prefix2[Prefix2["NONE"] = -1] = "NONE";
      Prefix2[Prefix2["ED25519"] = 237] = "ED25519";
      Prefix2[Prefix2["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
      Prefix2[Prefix2["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
      Prefix2[Prefix2["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
      Prefix2[Prefix2["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
    })(Prefix || (Prefix = {}));
    var KEY_TYPES = {
      [`private_${Prefix.NONE}_32`]: "ecdsa-secp256k1",
      [`private_${Prefix.SECP256K1_PRIVATE}_33`]: "ecdsa-secp256k1",
      [`private_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.SECP256K1_PUB_X}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_XY}_65`]: "ecdsa-secp256k1"
    };
    function getKeyInfo(key) {
      return {
        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
        len: key.length / 2
      };
    }
    function prefixRepr(prefix2) {
      return prefix2 === Prefix.NONE ? "None" : `0x${prefix2.toString(16).padStart(2, "0")}`;
    }
    function getValidFormatsTable(type) {
      const padding = 2;
      const colWidth = {
        algorithm: "ecdsa-secp256k1".length + padding,
        prefix: "0x00".length + padding
      };
      return Object.entries(KEY_TYPES).filter(([key]) => key.startsWith(type)).map(([key, algorithm]) => {
        const [, prefix2, length] = key.split("_");
        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
        const paddedPrefix = prefixRepr(Number(prefix2)).padEnd(colWidth.prefix);
        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
      }).join("\n");
    }
    function keyError({ key, type, prefix: prefix2, len }) {
      const validFormats = getValidFormatsTable(type);
      return `invalid_key:

Type: ${type}
Key: ${key}
Prefix: ${prefixRepr(prefix2)} 
Length: ${len} bytes

Acceptable ${type} formats are:
${validFormats}
`;
    }
    function getAlgorithmFromKey(key, type) {
      const { prefix: prefix2, len } = getKeyInfo(key);
      const usedPrefix = type === "private" && len === 32 ? Prefix.NONE : prefix2;
      const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];
      if (!algorithm) {
        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));
      }
      return algorithm;
    }
    exports.getAlgorithmFromKey = getAlgorithmFromKey;
    function getAlgorithmFromPublicKey(key) {
      return getAlgorithmFromKey(key, "public");
    }
    exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
    function getAlgorithmFromPrivateKey(key) {
      return getAlgorithmFromKey(key, "private");
    }
    exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js
var require_secp256k12 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils6();
    var secp256k1_1 = require_secp256k1();
    var utils_2 = require_browser();
    var utils_3 = require_utils7();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var SECP256K1_PREFIX = "00";
    var secp256k1 = {
      deriveKeypair(entropy, options) {
        const derived = (0, utils_3.derivePrivateKey)(entropy, options);
        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));
        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX) || privateKey.length === 64);
        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
        return secp256k1_1.secp256k1.sign(Sha512_1.default.half(message), normedPrivateKey, {
          // "Canonical" signatures
          lowS: true,
          // Would fail tests if signatures aren't deterministic
          extraEntropy: void 0
        }).toDERHex(true).toUpperCase();
      },
      verify(message, signature, publicKey) {
        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);
        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);
      }
    };
    exports.default = secp256k1;
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimeEdwardsPoint = void 0;
    exports.edwards = edwards;
    exports.eddsa = eddsa;
    exports.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils5();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = BigInt(2);
    var _8n2 = BigInt(8);
    function isEdValidXY(Fp, CURVE2, x, y) {
      const x2 = Fp.sqr(x);
      const y2 = Fp.sqr(y);
      const left = Fp.add(Fp.mul(CURVE2.a, x2), y2);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE2.d, Fp.mul(x2, y2)));
      return Fp.eql(left, right);
    }
    function edwards(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
      const { Fp, Fn } = validated;
      let CURVE2 = validated.CURVE;
      const { h: cofactor } = CURVE2;
      (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
      const MASK = _2n2 << BigInt(Fn.BYTES * 8) - _1n2;
      const modP = (n) => Fp.create(n);
      const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
        } catch (e) {
          return { isValid: false, value: _0n2 };
        }
      });
      if (!isEdValidXY(Fp, CURVE2, CURVE2.Gx, CURVE2.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n2 : _0n2;
        (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point2))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? _8n2 : Fp.inv(Z);
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
          return { x: _0n2, y: _1n2 };
        if (zz !== _1n2)
          throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE2;
        if (p.is0())
          throw new Error("bad point: ZERO");
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point2 {
        constructor(X, Y, Z, T) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y);
          this.Z = acoord("z", Z, true);
          this.T = acoord("t", T);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE2;
        }
        static fromAffine(p) {
          if (p instanceof Point2)
            throw new Error("extended point not allowed");
          const { x, y } = p || {};
          acoord("x", x);
          acoord("y", y);
          return new Point2(x, y, _1n2, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
          const len = Fp.BYTES;
          const { a, d } = CURVE2;
          bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
          (0, utils_ts_1._abool2)(zip215, "zip215");
          const normed = (0, utils_ts_1.copyBytes)(bytes);
          const lastByte = bytes[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("point.y", y, _0n2, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n2);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio2(u, v);
          if (!isValid)
            throw new Error("bad point: invalid y coordinate");
          const isXOdd = (x & _1n2) === _1n2;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n2 && isLastByteOdd)
            throw new Error("bad point: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point2.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
          return Point2.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_2n2);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point2.ZERO);
        }
        negate() {
          return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE2;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n2 * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point2(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE2;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point2(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: expected 1 <= sc < curve.n");
          const { p, f } = wnaf.cached(this, scalar, (p2) => (0, curve_ts_1.normalizeZ)(Point2, p2));
          return (0, curve_ts_1.normalizeZ)(Point2, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point2.ZERO) {
          if (!Fn.isValid(scalar))
            throw new Error("invalid scalar: expected 0 <= sc < curve.n");
          if (scalar === _0n2)
            return Point2.ZERO;
          if (this.is0() || scalar === _1n2)
            return this;
          return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point2, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE2.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n2)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = Fp.toBytes(y);
          bytes[bytes.length - 1] |= x & _1n2 ? 128 : 0;
          return bytes;
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point2, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point2, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        toRawBytes() {
          return this.toBytes();
        }
      }
      Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n2, modP(CURVE2.Gx * CURVE2.Gy));
      Point2.ZERO = new Point2(_0n2, _1n2, _1n2, _0n2);
      Point2.Fp = Fp;
      Point2.Fn = Fn;
      const wnaf = new curve_ts_1.wNAF(Point2, Fn.BITS);
      Point2.BASE.precompute(8);
      return Point2;
    }
    var PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
      }
      static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
    exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
    function eddsa(Point2, cHash, eddsaOpts = {}) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash } = eddsaOpts;
      const { BASE, Fp, Fn } = Point2;
      const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
        (0, utils_ts_1._abool2)(phflag, "phflag");
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data;
      });
      function modN_LE(hash2) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash2));
      }
      function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix2 = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix: prefix2, scalar };
      }
      function getExtendedPublicKey2(secretKey) {
        const { head, prefix: prefix2, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix: prefix2, scalar, point, pointBytes };
      }
      function getPublicKey2(secretKey) {
        return getExtendedPublicKey2(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign2(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix: prefix2, scalar, pointBytes } = getExtendedPublicKey2(secretKey);
        const r = hashDomainToScalar(options.context, prefix2, msg);
        const R = BASE.multiply(r).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = Fn.create(r + k * scalar);
        if (!Fn.isValid(s))
          throw new Error("sign failed: invalid s");
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
      }
      const verifyOpts = { zip215: true };
      function verify2(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, lengths.publicKey);
        if (zip215 !== void 0)
          (0, utils_ts_1._abool2)(zip215, "zip215");
        if (prehash)
          msg = prehash(msg);
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
          A = Point2.fromBytes(publicKey, zip215);
          R = Point2.fromBytes(r, zip215);
          SB = BASE.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      const _size2 = Fp.BYTES;
      const lengths = {
        secretKey: _size2,
        publicKey: _size2,
        signature: 2 * _size2,
        seed: _size2
      };
      function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
      }
      function keygen(seed) {
        const secretKey = utils2.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey2(secretKey) };
      }
      function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point2.fromBytes(key, zip215);
        } catch (error) {
          return false;
        }
      }
      const utils2 = {
        getExtendedPublicKey: getExtendedPublicKey2,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
          const { y } = Point2.fromBytes(publicKey);
          const size = lengths.publicKey;
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u = is25519 ? Fp.div(_1n2 + y, _1n2 - y) : Fp.div(y - _1n2, y + _1n2);
          return Fp.toBytes(u);
        },
        toMontgomerySecret(secretKey) {
          const size = lengths.secretKey;
          (0, utils_ts_1._abytes2)(secretKey, size);
          const hashed = cHash(secretKey.subarray(0, size));
          return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point2.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({
        keygen,
        getPublicKey: getPublicKey2,
        sign: sign2,
        verify: verify2,
        utils: utils2,
        Point: Point2,
        lengths
      });
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE2 = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE2.n, c.nBitLength, true);
      const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve
      };
      return { CURVE: CURVE2, curveOpts, hash: c.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const Point2 = eddsa2.Point;
      const legacy = Object.assign({}, eddsa2, {
        ExtendedPoint: Point2,
        CURVE: c,
        nBitLength: Point2.Fn.BITS,
        nByteLength: Point2.Fn.BYTES
      });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE: CURVE2, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
      const Point2 = edwards(CURVE2, curveOpts);
      const EDDSA = eddsa(Point2, hash2, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.montgomery = montgomery;
    var utils_ts_1 = require_utils5();
    var modular_ts_1 = require_modular();
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE2 = validateOpts(curveDef);
      const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE2;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n2 ** BigInt(254) : _2n2 ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n2 ** BigInt(251) - _1n2 : BigInt(4) * _2n2 ** BigInt(445) - _1n2;
      const maxScalar = minScalar + maxAdded + _1n2;
      const modP = (n) => (0, modular_ts_1.mod)(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n2)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)("u", u, _0n2, P);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n2;
        let z_2 = _0n2;
        let x_3 = u;
        let z_3 = _1n2;
        let swap = _0n2;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n2; t--) {
          const k_t = k >> t & _1n2;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen
      };
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
      };
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const utils2 = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils: utils2,
        GuBytes: GuBytes.slice(),
        lengths
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
    exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils5();
    var _0n2 = /* @__PURE__ */ BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n2 = BigInt(8);
    var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    var ed25519_CURVE = /* @__PURE__ */ (() => ({
      p: ed25519_CURVE_p,
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n2,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    }))();
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ed25519_CURVE_p;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = (0, modular_ts_1.pow2)(b2, _2n2, P) * b2 % P;
      const b5 = (0, modular_ts_1.pow2)(b4, _1n2, P) * x % P;
      const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
      const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
      const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
      const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
      const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
      const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
      const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n2, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio2(u, v) {
      const P = ed25519_CURVE_p;
      const v3 = (0, modular_ts_1.mod)(v * v * v, P);
      const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_ts_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    var Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
    var Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
    var ed25519Defaults = /* @__PURE__ */ (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/v
      uvRatio: uvRatio2
    }))();
    exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
    }
    exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha2_js_1.sha512
    })))();
    exports.x25519 = (() => {
      const P = Fp.ORDER;
      return (0, montgomery_ts_1.montgomery)({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes
      });
    })();
    var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n2)();
    var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n2, ELL2_C1))();
    var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n2;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n2);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n2 };
    }
    var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
      return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
    }
    exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: ed25519_CURVE_p,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha512
    }))();
    var SQRT_M12 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE2 = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D2 = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ2 = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ2 = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt2 = (number3) => uvRatio2(_1n2, number3);
    var MAX_255B2 = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE2 = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B2);
    function calcElligatorRistrettoMap(r0) {
      const { d } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod2 = (n) => Fp.create(n);
      const r = mod2(SQRT_M12 * r0 * r0);
      const Ns = mod2((r + _1n2) * ONE_MINUS_D_SQ2);
      let c = BigInt(-1);
      const D = mod2((c - d * r) * mod2(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio2(Ns, D);
      let s_ = mod2(s * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod2(-s_);
      if (!Ns_D_is_sq)
        s = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod2(c * (r - _1n2) * D_MINUS_ONE_SQ2 - D);
      const s2 = s * s;
      const W0 = mod2((s + s) * D);
      const W1 = mod2(Nt * SQRT_AD_MINUS_ONE2);
      const W2 = mod2(_1n2 - s2);
      const W3 = mod2(_1n2 + s2);
      return new exports.ed25519.Point(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
    }
    function ristretto255_map(bytes) {
      (0, utils_js_1.abytes)(bytes, 64);
      const r1 = bytes255ToNumberLE2(bytes.subarray(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE2(bytes.subarray(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new _RistrettoPoint(R1.add(R2));
    }
    var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64));
      }
      static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod2 = (n) => Fp.create(n);
        const s = bytes255ToNumberLE2(bytes);
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
          throw new Error("invalid ristretto255 encoding 1");
        const s2 = mod2(s * s);
        const u1 = mod2(_1n2 + a * s2);
        const u2 = mod2(_1n2 - a * s2);
        const u1_2 = mod2(u1 * u1);
        const u2_2 = mod2(u2 * u2);
        const v = mod2(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt2(mod2(v * u2_2));
        const Dx = mod2(I * u2);
        const Dy = mod2(I * Dx * v);
        let x = mod2((s + s) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = mod2(-x);
        const y = mod2(u1 * Dy);
        const t = mod2(x * y);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n2)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new exports.ed25519.Point(x, y, _1n2, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32));
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod2 = (n) => Fp.create(n);
        const u1 = mod2(mod2(Z + Y) * mod2(Z - Y));
        const u2 = mod2(X * Y);
        const u2sq = mod2(u2 * u2);
        const { value: invsqrt } = invertSqrt2(mod2(u1 * u2sq));
        const D1 = mod2(invsqrt * u1);
        const D2 = mod2(invsqrt * u2);
        const zInv = mod2(D1 * D2 * T);
        let D;
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
          let _x = mod2(Y * SQRT_M12);
          let _y = mod2(X * SQRT_M12);
          X = _x;
          Y = _y;
          D = mod2(D1 * INVSQRT_A_MINUS_D2);
        } else {
          D = D2;
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
          Y = mod2(-Y);
        let s = mod2((Z - Y) * D);
        if ((0, modular_ts_1.isNegativeLE)(s, P))
          s = mod2(-s);
        return Fp.toBytes(s);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod2 = (n) => Fp.create(n);
        const one = mod2(X1 * Y2) === mod2(Y1 * X2);
        const two = mod2(Y1 * Y2) === mod2(X1 * X2);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
    exports.ristretto255 = { Point: _RistrettoPoint };
    exports.ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
      }
    };
    exports.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    function edwardsToMontgomeryPub(edwardsPub) {
      return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
    }
    exports.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
    }
    exports.RistrettoPoint = _RistrettoPoint;
    exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
    exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
    exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js
var require_ed255192 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ed25519_1 = require_ed25519();
    var utils_1 = require_browser();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var ED_PREFIX = "ED";
    var ed25519 = {
      deriveKeypair(entropy) {
        const rawPrivateKey = Sha512_1.default.half(entropy);
        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);
        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(message instanceof Uint8Array, "message must be array of octets");
        assert_1.default.ok(privateKey.length === 66, "private key must be 33 bytes including prefix");
        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));
      },
      verify(message, signature, publicKey) {
        assert_1.default.ok(publicKey.length === 66, "public key must be 33 bytes including prefix");
        return ed25519_1.ed25519.verify(
          signature,
          message,
          // Remove the 0xED prefix
          publicKey.slice(2),
          // By default, set zip215 to false for compatibility reasons.
          // ZIP 215 is a stricter Ed25519 signature verification scheme.
          // However, setting it to false adheres to the more commonly used
          // RFC8032 / NIST186-5 standards, making it compatible with systems
          // like the XRP Ledger.
          { zip215: false }
        );
      }
    };
    exports.default = ed25519;
  }
});

// node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
    var ripple_address_codec_1 = require_dist2();
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeSeed;
    } });
    var ripemd160_1 = require_browser4();
    var sha256_1 = require_browser2();
    var utils_1 = require_browser();
    var utils_2 = require_utils7();
    var Sha512_1 = __importDefault(require_Sha512());
    var assert_1 = __importDefault(require_assert());
    var getAlgorithmFromKey_1 = require_getAlgorithmFromKey();
    var secp256k1_1 = __importDefault(require_secp256k12());
    var ed25519_1 = __importDefault(require_ed255192());
    function getSigningScheme(algorithm) {
      const schemes = { "ecdsa-secp256k1": secp256k1_1.default, ed25519: ed25519_1.default };
      return schemes[algorithm];
    }
    function generateSeed(options = {}) {
      assert_1.default.ok(!options.entropy || options.entropy.length >= 16, "entropy too short");
      const entropy = options.entropy ? options.entropy.slice(0, 16) : (0, utils_1.randomBytes)(16);
      const type = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
      return (0, ripple_address_codec_1.encodeSeed)(entropy, type);
    }
    exports.generateSeed = generateSeed;
    function deriveKeypair(seed, options) {
      var _a4;
      const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);
      const proposedAlgorithm = (_a4 = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a4 !== void 0 ? _a4 : decoded.type;
      const algorithm = proposedAlgorithm === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
      const scheme = getSigningScheme(algorithm);
      const keypair = scheme.deriveKeypair(decoded.bytes, options);
      const messageToVerify = Sha512_1.default.half("This test message should verify.");
      const signature = scheme.sign(messageToVerify, keypair.privateKey);
      if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {
        throw new Error("derived keypair did not generate verifiable signature");
      }
      return keypair;
    }
    exports.deriveKeypair = deriveKeypair;
    function sign2(messageHex, privateKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
      return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);
    }
    exports.sign = sign2;
    function verify2(messageHex, signature, publicKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
      return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);
    }
    exports.verify = verify2;
    function computePublicKeyHash(publicKeyBytes) {
      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
    }
    function deriveAddressFromBytes(publicKeyBytes) {
      return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
    }
    function deriveAddress(publicKey) {
      return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
    }
    exports.deriveAddress = deriveAddress;
    function deriveNodeAddress(publicKey) {
      const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);
      const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);
      return deriveAddressFromBytes(accountPublicBytes);
    }
    exports.deriveNodeAddress = deriveNodeAddress;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/derive.js
var require_derive = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/derive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
    var ripple_address_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist4();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveAddress;
    } });
    function deriveXAddress(options) {
      const classicAddress = (0, ripple_keypairs_1.deriveAddress)(options.publicKey);
      return (0, ripple_address_codec_1.classicAddressToXAddress)(classicAddress, options.tag, options.test);
    }
    exports.deriveXAddress = deriveXAddress;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/collections.js
var require_collections = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitBy = exports.groupBy = void 0;
    function groupBy(array2, iteratee) {
      function predicate(acc, value, index, arrayReference) {
        const key = iteratee(value, index, arrayReference) || 0;
        const group = acc[key] || [];
        group.push(value);
        acc[key] = group;
        return acc;
      }
      return array2.reduce(predicate, {});
    }
    exports.groupBy = groupBy;
    function omitBy(obj, predicate) {
      const keys = Object.keys(obj);
      const keysToKeep = keys.filter((kb) => !predicate(obj[kb], kb));
      return keysToKeep.reduce((acc, key) => {
        acc[key] = obj[key];
        return acc;
      }, {});
    }
    exports.omitBy = omitBy;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/xrpConversion.js
var require_xrpConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/xrpConversion.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xrpToDrops = exports.dropsToXrp = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var DROPS_PER_XRP = 1e6;
    var MAX_FRACTION_LENGTH = 6;
    var BASE_TEN = 10;
    var SANITY_CHECK = /^-?[0-9.]+$/u;
    function dropsToXrp(dropsToConvert) {
      const drops = new bignumber_js_1.default(dropsToConvert).toString(BASE_TEN);
      if (typeof dropsToConvert === "string" && drops === "NaN") {
        throw new errors_1.ValidationError(`dropsToXrp: invalid value '${dropsToConvert}', should be a BigNumber or string-encoded number.`);
      }
      if (drops.includes(".")) {
        throw new errors_1.ValidationError(`dropsToXrp: value '${drops}' has too many decimal places.`);
      }
      if (!SANITY_CHECK.exec(drops)) {
        throw new errors_1.ValidationError(`dropsToXrp: failed sanity check - value '${drops}', does not match (^-?[0-9]+$).`);
      }
      return new bignumber_js_1.default(drops).dividedBy(DROPS_PER_XRP).toNumber();
    }
    exports.dropsToXrp = dropsToXrp;
    function xrpToDrops(xrpToConvert) {
      const xrp = new bignumber_js_1.default(xrpToConvert).toString(BASE_TEN);
      if (typeof xrpToConvert === "string" && xrp === "NaN") {
        throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrpToConvert}', should be a BigNumber or string-encoded number.`);
      }
      if (!SANITY_CHECK.exec(xrp)) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`);
      }
      const components = xrp.split(".");
      if (components.length > 2) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}' has too many decimal points.`);
      }
      const fraction = components[1] || "0";
      if (fraction.length > MAX_FRACTION_LENGTH) {
        throw new errors_1.ValidationError(`xrpToDrops: value '${xrp}' has too many decimal places.`);
      }
      return new bignumber_js_1.default(xrp).times(DROPS_PER_XRP).integerValue(bignumber_js_1.default.ROUND_FLOOR).toString(BASE_TEN);
    }
    exports.xrpToDrops = xrpToDrops;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getBalanceChanges.js
var require_getBalanceChanges = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getBalanceChanges.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var collections_1 = require_collections();
    var xrpConversion_1 = require_xrpConversion();
    function normalizeNode(affectedNode) {
      const diffType = Object.keys(affectedNode)[0];
      const node = affectedNode[diffType];
      return Object.assign(Object.assign({}, node), { NodeType: diffType, LedgerEntryType: node.LedgerEntryType, LedgerIndex: node.LedgerIndex, NewFields: node.NewFields, FinalFields: node.FinalFields, PreviousFields: node.PreviousFields });
    }
    function normalizeNodes(metadata) {
      if (metadata.AffectedNodes.length === 0) {
        return [];
      }
      return metadata.AffectedNodes.map(normalizeNode);
    }
    function groupByAccount(balanceChanges) {
      const grouped = (0, collections_1.groupBy)(balanceChanges, (node) => node.account);
      return Object.entries(grouped).map(([account, items]) => {
        return { account, balances: items.map((item) => item.balance) };
      });
    }
    function getValue(balance) {
      if (typeof balance === "string") {
        return new bignumber_js_1.default(balance);
      }
      return new bignumber_js_1.default(balance.value);
    }
    function computeBalanceChange(node) {
      var _a4, _b, _c;
      let value = null;
      if ((_a4 = node.NewFields) === null || _a4 === void 0 ? void 0 : _a4.Balance) {
        value = getValue(node.NewFields.Balance);
      } else if (((_b = node.PreviousFields) === null || _b === void 0 ? void 0 : _b.Balance) && ((_c = node.FinalFields) === null || _c === void 0 ? void 0 : _c.Balance)) {
        value = getValue(node.FinalFields.Balance).minus(getValue(node.PreviousFields.Balance));
      }
      if (value === null || value.isZero()) {
        return null;
      }
      return value;
    }
    function getXRPQuantity(node) {
      var _a4, _b, _c;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      return {
        account: (_b = (_a4 = node.FinalFields) === null || _a4 === void 0 ? void 0 : _a4.Account) !== null && _b !== void 0 ? _b : (_c = node.NewFields) === null || _c === void 0 ? void 0 : _c.Account,
        balance: {
          currency: "XRP",
          value: (0, xrpConversion_1.dropsToXrp)(value).toString()
        }
      };
    }
    function flipTrustlinePerspective(balanceChange) {
      const negatedBalance = new bignumber_js_1.default(balanceChange.balance.value).negated();
      return {
        account: balanceChange.balance.issuer,
        balance: {
          issuer: balanceChange.account,
          currency: balanceChange.balance.currency,
          value: negatedBalance.toString()
        }
      };
    }
    function getTrustlineQuantity(node) {
      var _a4, _b, _c;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      const fields = (_a4 = node.NewFields) !== null && _a4 !== void 0 ? _a4 : node.FinalFields;
      const result = {
        account: (_b = fields === null || fields === void 0 ? void 0 : fields.LowLimit) === null || _b === void 0 ? void 0 : _b.issuer,
        balance: {
          issuer: (_c = fields === null || fields === void 0 ? void 0 : fields.HighLimit) === null || _c === void 0 ? void 0 : _c.issuer,
          currency: (fields === null || fields === void 0 ? void 0 : fields.Balance).currency,
          value: value.toString()
        }
      };
      return [result, flipTrustlinePerspective(result)];
    }
    function getBalanceChanges(metadata) {
      const quantities = normalizeNodes(metadata).map((node) => {
        if (node.LedgerEntryType === "AccountRoot") {
          const xrpQuantity = getXRPQuantity(node);
          if (xrpQuantity == null) {
            return [];
          }
          return [xrpQuantity];
        }
        if (node.LedgerEntryType === "RippleState") {
          const trustlineQuantity = getTrustlineQuantity(node);
          if (trustlineQuantity == null) {
            return [];
          }
          return trustlineQuantity;
        }
        return [];
      });
      return groupByAccount(quantities.flat());
    }
    exports.default = getBalanceChanges;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/metadata.js
var require_metadata = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDeletedNode = exports.isModifiedNode = exports.isCreatedNode = void 0;
    function isCreatedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `CreatedNode`);
    }
    exports.isCreatedNode = isCreatedNode;
    function isModifiedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `ModifiedNode`);
    }
    exports.isModifiedNode = isModifiedNode;
    function isDeletedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `DeletedNode`);
    }
    exports.isDeletedNode = isDeletedNode;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getNFTokenID.js
var require_getNFTokenID = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getNFTokenID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist3();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta2) {
      if (typeof meta2 === "string") {
        return (0, ripple_binary_codec_1.decode)(meta2);
      }
      return meta2;
    }
    function getNFTokenID(meta2) {
      if (typeof meta2 !== "string" && (meta2 === null || meta2 === void 0 ? void 0 : meta2.AffectedNodes) === void 0) {
        throw new TypeError(`Unable to parse the parameter given to getNFTokenID.
      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta2)} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta2);
      const affectedNodes = decodedMeta.AffectedNodes.filter((node) => {
        var _a4;
        if ((0, metadata_1.isCreatedNode)(node)) {
          return node.CreatedNode.LedgerEntryType === "NFTokenPage";
        }
        if ((0, metadata_1.isModifiedNode)(node)) {
          return node.ModifiedNode.LedgerEntryType === "NFTokenPage" && Boolean((_a4 = node.ModifiedNode.PreviousFields) === null || _a4 === void 0 ? void 0 : _a4.NFTokens);
        }
        return false;
      });
      const previousTokenIDSet = new Set(affectedNodes.flatMap((node) => {
        var _a4;
        const nftokens = (0, metadata_1.isModifiedNode)(node) ? (_a4 = node.ModifiedNode.PreviousFields) === null || _a4 === void 0 ? void 0 : _a4.NFTokens : [];
        return nftokens.map((token) => token.NFToken.NFTokenID);
      }).filter((id) => Boolean(id)));
      const finalTokenIDs = affectedNodes.flatMap((node) => {
        var _a4, _b, _c, _d, _e, _f;
        return ((_f = (_c = (_b = (_a4 = node.ModifiedNode) === null || _a4 === void 0 ? void 0 : _a4.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens) !== null && _f !== void 0 ? _f : []).map((token) => token.NFToken.NFTokenID);
      }).filter((nftokenID2) => Boolean(nftokenID2));
      const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id));
      return nftokenID;
    }
    exports.default = getNFTokenID;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getXChainClaimID.js
var require_getXChainClaimID = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getXChainClaimID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist3();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta2) {
      if (typeof meta2 === "string") {
        return (0, ripple_binary_codec_1.decode)(meta2);
      }
      return meta2;
    }
    function getXChainClaimID(meta2) {
      if (typeof meta2 !== "string" && (meta2 === null || meta2 === void 0 ? void 0 : meta2.AffectedNodes) === void 0) {
        throw new TypeError(`Unable to parse the parameter given to getXChainClaimID.
      'meta' must be the metadata from an XChainCreateClaimID transaction. Received ${JSON.stringify(meta2)} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta2);
      if (!decodedMeta.TransactionResult) {
        throw new TypeError("Cannot get XChainClaimID from un-validated transaction");
      }
      if (decodedMeta.TransactionResult !== "tesSUCCESS") {
        return void 0;
      }
      const createdNode = decodedMeta.AffectedNodes.find((node) => (0, metadata_1.isCreatedNode)(node) && node.CreatedNode.LedgerEntryType === "XChainOwnedClaimID");
      return createdNode.CreatedNode.NewFields.XChainClaimID;
    }
    exports.default = getXChainClaimID;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js
var require_HashPrefix = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HashPrefix;
    (function(HashPrefix2) {
      HashPrefix2[HashPrefix2["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
      HashPrefix2[HashPrefix2["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
      HashPrefix2[HashPrefix2["INNER_NODE"] = 1296649728] = "INNER_NODE";
      HashPrefix2[HashPrefix2["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
      HashPrefix2[HashPrefix2["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
      HashPrefix2[HashPrefix2["LEDGER"] = 1280791040] = "LEDGER";
    })(HashPrefix || (HashPrefix = {}));
    exports.default = HashPrefix;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js
var require_sha512Half = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha512_1 = require_browser3();
    var utils_1 = require_browser();
    var HASH_BYTES = 32;
    function sha512Half(hex) {
      return (0, utils_1.bytesToHex)((0, sha512_1.sha512)((0, utils_1.hexToBytes)(hex)).slice(0, HASH_BYTES));
    }
    exports.default = sha512Half;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Node = exports.NodeType = void 0;
    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["INNER"] = 1] = "INNER";
      NodeType2[NodeType2["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
      NodeType2[NodeType2["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
      NodeType2[NodeType2["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
    })(NodeType || (exports.NodeType = NodeType = {}));
    var Node = class {
    };
    exports.Node = Node;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js
var require_LeafNode = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var node_1 = require_node();
    var HEX = 16;
    var LeafNode = class extends node_1.Node {
      constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
      }
      get hash() {
        switch (this.type) {
          case node_1.NodeType.ACCOUNT_STATE: {
            const leafPrefix = HashPrefix_1.default.LEAF_NODE.toString(HEX);
            return (0, sha512Half_1.default)(leafPrefix + this.data + this.tag);
          }
          case node_1.NodeType.TRANSACTION_NO_METADATA: {
            const txIDPrefix = HashPrefix_1.default.TRANSACTION_ID.toString(HEX);
            return (0, sha512Half_1.default)(txIDPrefix + this.data);
          }
          case node_1.NodeType.TRANSACTION_METADATA: {
            const txNodePrefix = HashPrefix_1.default.TRANSACTION_NODE.toString(HEX);
            return (0, sha512Half_1.default)(txNodePrefix + this.data + this.tag);
          }
          default:
            throw new errors_1.XrplError("Tried to hash a SHAMap node of unknown type.");
        }
      }
      addItem(tag, node) {
        throw new errors_1.XrplError("Cannot call addItem on a LeafNode");
        this.addItem(tag, node);
      }
    };
    exports.default = LeafNode;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js
var require_InnerNode = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var node_1 = require_node();
    var HEX_ZERO = "0000000000000000000000000000000000000000000000000000000000000000";
    var SLOT_MAX = 15;
    var HEX = 16;
    var InnerNode = class _InnerNode extends node_1.Node {
      constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = node_1.NodeType.INNER;
        this.depth = depth;
        this.empty = true;
      }
      get hash() {
        if (this.empty) {
          return HEX_ZERO;
        }
        let hex = "";
        for (let iter = 0; iter <= SLOT_MAX; iter++) {
          const child = this.leaves[iter];
          const hash2 = child == null ? HEX_ZERO : child.hash;
          hex += hash2;
        }
        const prefix2 = HashPrefix_1.default.INNER_NODE.toString(HEX);
        return (0, sha512Half_1.default)(prefix2 + hex);
      }
      addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], HEX));
        if (existingNode === void 0) {
          this.setNode(parseInt(tag[this.depth], HEX), node);
          return;
        }
        if (existingNode instanceof _InnerNode) {
          existingNode.addItem(tag, node);
        } else if (existingNode instanceof LeafNode_1.default) {
          if (existingNode.tag === tag) {
            throw new errors_1.XrplError("Tried to add a node to a SHAMap that was already in there.");
          } else {
            const newInnerNode = new _InnerNode(this.depth + 1);
            newInnerNode.addItem(existingNode.tag, existingNode);
            newInnerNode.addItem(tag, node);
            this.setNode(parseInt(tag[this.depth], HEX), newInnerNode);
          }
        }
      }
      setNode(slot, node) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError("Invalid slot: slot must be between 0-15.");
        }
        this.leaves[slot] = node;
        this.empty = false;
      }
      getNode(slot) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError("Invalid slot: slot must be between 0-15.");
        }
        return this.leaves[slot];
      }
    };
    exports.default = InnerNode;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js
var require_SHAMap = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var InnerNode_1 = __importDefault(require_InnerNode());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var SHAMap = class {
      constructor() {
        this.root = new InnerNode_1.default(0);
      }
      get hash() {
        return this.root.hash;
      }
      addItem(tag, data, type) {
        this.root.addItem(tag, new LeafNode_1.default(tag, data, type));
      }
    };
    __exportStar(require_node(), exports);
    exports.default = SHAMap;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js
var require_hashLedger = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashStateTree = exports.hashTxTree = exports.hashLedgerHeader = exports.hashSignedTx = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist3();
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var utils_2 = require_utils4();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var SHAMap_1 = __importStar(require_SHAMap());
    var HEX = 16;
    function intToHex(integer2, byteLength) {
      const foo = Number(integer2).toString(HEX).padStart(byteLength * 2, "0");
      return foo;
    }
    function bigintToHex(integerString, byteLength) {
      const hex = new bignumber_js_1.default(integerString).toString(HEX);
      return hex.padStart(byteLength * 2, "0");
    }
    function addLengthPrefix(hex) {
      const length = hex.length / 2;
      if (length <= 192) {
        return (0, utils_1.bytesToHex)([length]) + hex;
      }
      if (length <= 12480) {
        const prefix2 = length - 193;
        return (0, utils_1.bytesToHex)([193 + (prefix2 >>> 8), prefix2 & 255]) + hex;
      }
      if (length <= 918744) {
        const prefix2 = length - 12481;
        return (0, utils_1.bytesToHex)([
          241 + (prefix2 >>> 16),
          prefix2 >>> 8 & 255,
          prefix2 & 255
        ]) + hex;
      }
      throw new errors_1.XrplError("Variable integer overflow.");
    }
    function hashSignedTx(tx) {
      let txBlob;
      let txObject;
      if (typeof tx === "string") {
        txBlob = tx;
        txObject = (0, ripple_binary_codec_1.decode)(tx);
      } else {
        txBlob = (0, ripple_binary_codec_1.encode)(tx);
        txObject = tx;
      }
      if (txObject.TxnSignature === void 0 && txObject.Signers === void 0 && txObject.SigningPubKey === void 0 && !(0, utils_2.hasFlag)(txObject, common_1.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) {
        throw new errors_1.ValidationError("The transaction must be signed to hash it.");
      }
      const prefix2 = HashPrefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
      return (0, sha512Half_1.default)(prefix2.concat(txBlob));
    }
    exports.hashSignedTx = hashSignedTx;
    function hashLedgerHeader(ledgerHeader) {
      const prefix2 = HashPrefix_1.default.LEDGER.toString(HEX).toUpperCase();
      const ledger = prefix2 + intToHex(Number(ledgerHeader.ledger_index), 4) + bigintToHex(ledgerHeader.total_coins, 8) + ledgerHeader.parent_hash + ledgerHeader.transaction_hash + ledgerHeader.account_hash + intToHex(ledgerHeader.parent_close_time, 4) + intToHex(ledgerHeader.close_time, 4) + intToHex(ledgerHeader.close_time_resolution, 1) + intToHex(ledgerHeader.close_flags, 1);
      return (0, sha512Half_1.default)(ledger);
    }
    exports.hashLedgerHeader = hashLedgerHeader;
    function hashTxTree(transactions) {
      var _a4;
      const shamap = new SHAMap_1.default();
      for (const txJSON of transactions) {
        const txBlobHex = (0, ripple_binary_codec_1.encode)(txJSON);
        const metaHex = (0, ripple_binary_codec_1.encode)((_a4 = txJSON.metaData) !== null && _a4 !== void 0 ? _a4 : {});
        const txHash = hashSignedTx(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, SHAMap_1.NodeType.TRANSACTION_METADATA);
      }
      return shamap.hash;
    }
    exports.hashTxTree = hashTxTree;
    function hashStateTree(entries) {
      const shamap = new SHAMap_1.default();
      entries.forEach((ledgerEntry) => {
        const data = (0, ripple_binary_codec_1.encode)(ledgerEntry);
        shamap.addItem(ledgerEntry.index, data, SHAMap_1.NodeType.ACCOUNT_STATE);
      });
      return shamap.hash;
    }
    exports.hashStateTree = hashStateTree;
    function computeTransactionHash(ledger, options) {
      const { transaction_hash } = ledger;
      if (!options.computeTreeHashes) {
        return transaction_hash;
      }
      if (ledger.transactions == null) {
        throw new errors_1.ValidationError("transactions is missing from the ledger");
      }
      const transactionHash = hashTxTree(ledger.transactions);
      if (transaction_hash !== transactionHash) {
        throw new errors_1.ValidationError("transactionHash in header does not match computed hash of transactions", {
          transactionHashInHeader: transaction_hash,
          computedHashOfTransactions: transactionHash
        });
      }
      return transactionHash;
    }
    function computeStateHash(ledger, options) {
      const { account_hash } = ledger;
      if (!options.computeTreeHashes) {
        return account_hash;
      }
      if (ledger.accountState == null) {
        throw new errors_1.ValidationError("accountState is missing from the ledger");
      }
      const stateHash = hashStateTree(ledger.accountState);
      if (account_hash !== stateHash) {
        throw new errors_1.ValidationError("stateHash in header does not match computed hash of state");
      }
      return stateHash;
    }
    function hashLedger(ledger, options = {}) {
      const subhashes = {
        transaction_hash: computeTransactionHash(ledger, options),
        account_hash: computeStateHash(ledger, options)
      };
      return hashLedgerHeader(Object.assign(Object.assign({}, ledger), subhashes));
    }
    exports.default = hashLedger;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js
var require_ledgerSpaces = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ledgerSpaces = {
      account: "a",
      dirNode: "d",
      generatorMap: "g",
      rippleState: "r",
      offer: "o",
      ownerDir: "O",
      bookDir: "B",
      contract: "c",
      skipList: "s",
      escrow: "u",
      amendment: "f",
      feeSettings: "e",
      ticket: "T",
      signerList: "S",
      paychan: "x",
      check: "C",
      depositPreauth: "p",
      vault: "V",
      loanBroker: "l",
      loan: "L"
    };
    exports.default = ledgerSpaces;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/index.js
var require_hashes2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTxTree = exports.hashStateTree = exports.hashLedger = exports.hashSignedTx = exports.hashLedgerHeader = exports.hashLoan = exports.hashLoanBroker = exports.hashVault = exports.hashPaymentChannel = exports.hashEscrow = exports.hashTrustline = exports.hashOfferId = exports.hashSignerListId = exports.hashAccountRoot = exports.hashTx = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist2();
    var hashLedger_1 = __importStar(require_hashLedger());
    exports.hashLedger = hashLedger_1.default;
    Object.defineProperty(exports, "hashLedgerHeader", { enumerable: true, get: function() {
      return hashLedger_1.hashLedgerHeader;
    } });
    Object.defineProperty(exports, "hashSignedTx", { enumerable: true, get: function() {
      return hashLedger_1.hashSignedTx;
    } });
    Object.defineProperty(exports, "hashTxTree", { enumerable: true, get: function() {
      return hashLedger_1.hashTxTree;
    } });
    Object.defineProperty(exports, "hashStateTree", { enumerable: true, get: function() {
      return hashLedger_1.hashStateTree;
    } });
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var ledgerSpaces_1 = __importDefault(require_ledgerSpaces());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var HEX = 16;
    var BYTE_LENGTH = 4;
    function addressToHex(address) {
      return (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));
    }
    function ledgerSpaceHex(name) {
      return ledgerSpaces_1.default[name].charCodeAt(0).toString(HEX).padStart(4, "0");
    }
    var MASK = 255;
    function currencyToHex(currency) {
      if (currency.length !== 3) {
        return currency;
      }
      const bytes = Array(20).fill(0);
      bytes[12] = currency.charCodeAt(0) & MASK;
      bytes[13] = currency.charCodeAt(1) & MASK;
      bytes[14] = currency.charCodeAt(2) & MASK;
      return (0, utils_1.bytesToHex)(Uint8Array.from(bytes));
    }
    function hashTx(txBlobHex) {
      const prefix2 = HashPrefix_1.default.TRANSACTION_SIGN.toString(HEX).toUpperCase();
      return (0, sha512Half_1.default)(prefix2 + txBlobHex);
    }
    exports.hashTx = hashTx;
    function hashAccountRoot(address) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("account") + addressToHex(address));
    }
    exports.hashAccountRoot = hashAccountRoot;
    function hashSignerListId(address) {
      return (0, sha512Half_1.default)(`${ledgerSpaceHex("signerList") + addressToHex(address)}00000000`);
    }
    exports.hashSignerListId = hashSignerListId;
    function hashOfferId(address, sequence) {
      const hexPrefix = ledgerSpaces_1.default.offer.charCodeAt(0).toString(HEX).padStart(2, "0");
      const hexSequence = sequence.toString(HEX).padStart(8, "0");
      const prefix2 = `00${hexPrefix}`;
      return (0, sha512Half_1.default)(prefix2 + addressToHex(address) + hexSequence);
    }
    exports.hashOfferId = hashOfferId;
    function hashTrustline(address1, address2, currency) {
      const address1Hex = addressToHex(address1);
      const address2Hex = addressToHex(address2);
      const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(new bignumber_js_1.default(address2Hex, 16));
      const lowAddressHex = swap ? address2Hex : address1Hex;
      const highAddressHex = swap ? address1Hex : address2Hex;
      const prefix2 = ledgerSpaceHex("rippleState");
      return (0, sha512Half_1.default)(prefix2 + lowAddressHex + highAddressHex + currencyToHex(currency));
    }
    exports.hashTrustline = hashTrustline;
    function hashEscrow(address, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("escrow") + addressToHex(address) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashEscrow = hashEscrow;
    function hashPaymentChannel(address, dstAddress, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("paychan") + addressToHex(address) + addressToHex(dstAddress) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashPaymentChannel = hashPaymentChannel;
    function hashVault(address, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("vault") + addressToHex(address) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashVault = hashVault;
    function hashLoanBroker(address, sequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("loanBroker") + addressToHex(address) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashLoanBroker = hashLoanBroker;
    function hashLoan(loanBrokerId, loanSequence) {
      return (0, sha512Half_1.default)(ledgerSpaceHex("loan") + loanBrokerId + loanSequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
    }
    exports.hashLoan = hashLoan;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/parseNFTokenID.js
var require_parseNFTokenID = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/parseNFTokenID.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist2();
    var errors_1 = require_errors();
    function unscrambleTaxon(taxon, tokenSeq) {
      const seed = 384160001;
      const increment = 2459;
      const max = 4294967296;
      const scramble = new bignumber_js_1.default(seed).multipliedBy(tokenSeq).modulo(max).plus(increment).modulo(max).toNumber();
      return (taxon ^ scramble) >>> 0;
    }
    function parseNFTokenID(nftokenID) {
      const expectedLength = 64;
      if (nftokenID.length !== expectedLength) {
        throw new errors_1.XrplError(`Attempting to parse a nftokenID with length ${nftokenID.length}
    , but expected a token with length ${expectedLength}`);
      }
      const scrambledTaxon = new bignumber_js_1.default(nftokenID.substring(48, 56), 16).toNumber();
      const sequence = new bignumber_js_1.default(nftokenID.substring(56, 64), 16).toNumber();
      const NFTokenIDData = {
        NFTokenID: nftokenID,
        Flags: new bignumber_js_1.default(nftokenID.substring(0, 4), 16).toNumber(),
        TransferFee: new bignumber_js_1.default(nftokenID.substring(4, 8), 16).toNumber(),
        Issuer: (0, ripple_address_codec_1.encodeAccountID)((0, utils_1.hexToBytes)(nftokenID.substring(8, 48))),
        Taxon: unscrambleTaxon(scrambledTaxon, sequence),
        Sequence: sequence
      };
      return NFTokenIDData;
    }
    exports.default = parseNFTokenID;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/quality.js
var require_quality2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/quality.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.percentToQuality = exports.transferRateToDecimal = exports.qualityToDecimal = exports.decimalToQuality = exports.percentToTransferRate = exports.decimalToTransferRate = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var BASE_TEN = 10;
    var ONE_BILLION = "1000000000";
    var TWO_BILLION = "2000000000";
    function percentToDecimal(percent) {
      if (!percent.endsWith("%")) {
        throw new errors_1.ValidationError(`Value ${percent} must end with %`);
      }
      const split = percent.split("%").filter((str) => str !== "");
      if (split.length !== 1) {
        throw new errors_1.ValidationError(`Value ${percent} contains too many % signs`);
      }
      return new bignumber_js_1.default(split[0]).dividedBy("100").toString(BASE_TEN);
    }
    function decimalToTransferRate(decimal) {
      const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION).plus(ONE_BILLION);
      if (rate.isLessThan(ONE_BILLION) || rate.isGreaterThan(TWO_BILLION)) {
        throw new errors_1.ValidationError(`Decimal value must be between 0 and 1.00.`);
      }
      const billionths = rate.toString(BASE_TEN);
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
      }
      return Number(billionths);
    }
    exports.decimalToTransferRate = decimalToTransferRate;
    function percentToTransferRate(percent) {
      return decimalToTransferRate(percentToDecimal(percent));
    }
    exports.percentToTransferRate = percentToTransferRate;
    function decimalToQuality(decimal) {
      const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION);
      const billionths = rate.toString(BASE_TEN);
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes("-")) {
        throw new errors_1.ValidationError("Cannot have negative Quality");
      }
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(`Decimal exceeds maximum precision.`);
      }
      return Number(billionths);
    }
    exports.decimalToQuality = decimalToQuality;
    function qualityToDecimal(quality) {
      if (!Number.isInteger(quality)) {
        throw new errors_1.ValidationError("Quality must be an integer");
      }
      if (quality < 0) {
        throw new errors_1.ValidationError("Negative quality not allowed");
      }
      if (quality === 0) {
        return "1";
      }
      const decimal = new bignumber_js_1.default(quality).dividedBy(ONE_BILLION);
      return decimal.toString(BASE_TEN);
    }
    exports.qualityToDecimal = qualityToDecimal;
    function transferRateToDecimal(rate) {
      if (!Number.isInteger(rate)) {
        throw new errors_1.ValidationError("Error decoding, transfer Rate must be an integer");
      }
      if (rate === 0) {
        return "0";
      }
      const decimal = new bignumber_js_1.default(rate).minus(ONE_BILLION).dividedBy(ONE_BILLION);
      if (decimal.isLessThan(0)) {
        throw new errors_1.ValidationError("Error decoding, negative transfer rate");
      }
      return decimal.toString(BASE_TEN);
    }
    exports.transferRateToDecimal = transferRateToDecimal;
    function percentToQuality(percent) {
      return decimalToQuality(percentToDecimal(percent));
    }
    exports.percentToQuality = percentToQuality;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js
var require_signPaymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    var xrpConversion_1 = require_xrpConversion();
    function signPaymentChannelClaim(channel, xrpAmount, privateKey) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount)
      });
      return (0, ripple_keypairs_1.sign)(signingData, privateKey);
    }
    exports.default = signPaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/stringConversion.js
var require_stringConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/stringConversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertStringToHex = exports.convertHexToString = void 0;
    var utils_1 = require_browser();
    function convertStringToHex(string3) {
      return (0, utils_1.stringToHex)(string3);
    }
    exports.convertStringToHex = convertStringToHex;
    function convertHexToString(hex, encoding = "utf8") {
      return (0, utils_1.hexToString)(hex, encoding);
    }
    exports.convertHexToString = convertHexToString;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/timeConversion.js
var require_timeConversion = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/timeConversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = void 0;
    var RIPPLE_EPOCH_DIFF = 946684800;
    function rippleTimeToUnixTime(rpepoch) {
      return (rpepoch + RIPPLE_EPOCH_DIFF) * 1e3;
    }
    exports.rippleTimeToUnixTime = rippleTimeToUnixTime;
    function unixTimeToRippleTime(timestamp) {
      return Math.round(timestamp / 1e3) - RIPPLE_EPOCH_DIFF;
    }
    exports.unixTimeToRippleTime = unixTimeToRippleTime;
    function rippleTimeToISOTime(rippleTime) {
      return new Date(rippleTimeToUnixTime(rippleTime)).toISOString();
    }
    exports.rippleTimeToISOTime = rippleTimeToISOTime;
    function isoTimeToRippleTime(iso8601) {
      const isoDate = typeof iso8601 === "string" ? new Date(iso8601) : iso8601;
      return unixTimeToRippleTime(isoDate.getTime());
    }
    exports.isoTimeToRippleTime = isoTimeToRippleTime;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js
var require_verifyPaymentChannelClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    var xrpConversion_1 = require_xrpConversion();
    function verifyPaymentChannelClaim(channel, xrpAmount, signature, publicKey) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount)
      });
      return (0, ripple_keypairs_1.verify)(signingData, signature, publicKey);
    }
    exports.default = verifyPaymentChannelClaim;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/index.js
var require_utils8 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getXChainClaimID = exports.parseNFTokenID = exports.getNFTokenID = exports.encodeForSigningClaim = exports.encodeForSigningBatch = exports.encodeForSigning = exports.encodeForMultiSigning = exports.decode = exports.encode = exports.decodeXAddress = exports.encodeXAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.isValidClassicAddress = exports.isValidXAddress = exports.xAddressToClassicAddress = exports.classicAddressToXAddress = exports.convertHexToString = exports.convertStringToHex = exports.verifyPaymentChannelClaim = exports.verifyKeypairSignature = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.hashes = exports.isValidAddress = exports.isValidSecret = exports.qualityToDecimal = exports.transferRateToDecimal = exports.decimalToTransferRate = exports.percentToTransferRate = exports.decimalToQuality = exports.percentToQuality = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.hasNextPage = exports.xrpToDrops = exports.dropsToXrp = exports.getBalanceChanges = void 0;
    var ripple_address_codec_1 = require_dist2();
    Object.defineProperty(exports, "classicAddressToXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.classicAddressToXAddress;
    } });
    Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeAccountID;
    } });
    Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeAccountPublic;
    } });
    Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeNodePublic;
    } });
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeSeed;
    } });
    Object.defineProperty(exports, "decodeXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.decodeXAddress;
    } });
    Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeAccountID;
    } });
    Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeAccountPublic;
    } });
    Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeNodePublic;
    } });
    Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeSeed;
    } });
    Object.defineProperty(exports, "encodeXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.encodeXAddress;
    } });
    Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.isValidClassicAddress;
    } });
    Object.defineProperty(exports, "isValidXAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.isValidXAddress;
    } });
    Object.defineProperty(exports, "xAddressToClassicAddress", { enumerable: true, get: function() {
      return ripple_address_codec_1.xAddressToClassicAddress;
    } });
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    Object.defineProperty(exports, "verifyKeypairSignature", { enumerable: true, get: function() {
      return ripple_keypairs_1.verify;
    } });
    var derive_1 = require_derive();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return derive_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return derive_1.deriveAddress;
    } });
    Object.defineProperty(exports, "deriveXAddress", { enumerable: true, get: function() {
      return derive_1.deriveXAddress;
    } });
    var getBalanceChanges_1 = __importDefault(require_getBalanceChanges());
    exports.getBalanceChanges = getBalanceChanges_1.default;
    var getNFTokenID_1 = __importDefault(require_getNFTokenID());
    exports.getNFTokenID = getNFTokenID_1.default;
    var getXChainClaimID_1 = __importDefault(require_getXChainClaimID());
    exports.getXChainClaimID = getXChainClaimID_1.default;
    var hashes_1 = require_hashes2();
    var parseNFTokenID_1 = __importDefault(require_parseNFTokenID());
    exports.parseNFTokenID = parseNFTokenID_1.default;
    var quality_1 = require_quality2();
    Object.defineProperty(exports, "percentToTransferRate", { enumerable: true, get: function() {
      return quality_1.percentToTransferRate;
    } });
    Object.defineProperty(exports, "decimalToTransferRate", { enumerable: true, get: function() {
      return quality_1.decimalToTransferRate;
    } });
    Object.defineProperty(exports, "transferRateToDecimal", { enumerable: true, get: function() {
      return quality_1.transferRateToDecimal;
    } });
    Object.defineProperty(exports, "percentToQuality", { enumerable: true, get: function() {
      return quality_1.percentToQuality;
    } });
    Object.defineProperty(exports, "decimalToQuality", { enumerable: true, get: function() {
      return quality_1.decimalToQuality;
    } });
    Object.defineProperty(exports, "qualityToDecimal", { enumerable: true, get: function() {
      return quality_1.qualityToDecimal;
    } });
    var signPaymentChannelClaim_1 = __importDefault(require_signPaymentChannelClaim());
    exports.signPaymentChannelClaim = signPaymentChannelClaim_1.default;
    var stringConversion_1 = require_stringConversion();
    Object.defineProperty(exports, "convertHexToString", { enumerable: true, get: function() {
      return stringConversion_1.convertHexToString;
    } });
    Object.defineProperty(exports, "convertStringToHex", { enumerable: true, get: function() {
      return stringConversion_1.convertStringToHex;
    } });
    var timeConversion_1 = require_timeConversion();
    Object.defineProperty(exports, "rippleTimeToISOTime", { enumerable: true, get: function() {
      return timeConversion_1.rippleTimeToISOTime;
    } });
    Object.defineProperty(exports, "isoTimeToRippleTime", { enumerable: true, get: function() {
      return timeConversion_1.isoTimeToRippleTime;
    } });
    Object.defineProperty(exports, "rippleTimeToUnixTime", { enumerable: true, get: function() {
      return timeConversion_1.rippleTimeToUnixTime;
    } });
    Object.defineProperty(exports, "unixTimeToRippleTime", { enumerable: true, get: function() {
      return timeConversion_1.unixTimeToRippleTime;
    } });
    var verifyPaymentChannelClaim_1 = __importDefault(require_verifyPaymentChannelClaim());
    exports.verifyPaymentChannelClaim = verifyPaymentChannelClaim_1.default;
    var xrpConversion_1 = require_xrpConversion();
    Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function() {
      return xrpConversion_1.xrpToDrops;
    } });
    Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function() {
      return xrpConversion_1.dropsToXrp;
    } });
    function isValidSecret(secret) {
      try {
        (0, derive_1.deriveKeypair)(secret);
        return true;
      } catch (_err) {
        return false;
      }
    }
    exports.isValidSecret = isValidSecret;
    function encode9(object2) {
      return (0, ripple_binary_codec_1.encode)(object2);
    }
    exports.encode = encode9;
    function encodeForSigning(object2) {
      return (0, ripple_binary_codec_1.encodeForSigning)(object2);
    }
    exports.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(object2) {
      return (0, ripple_binary_codec_1.encodeForSigningClaim)(object2);
    }
    exports.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultiSigning(object2, signer) {
      return (0, ripple_binary_codec_1.encodeForMultisigning)(object2, signer);
    }
    exports.encodeForMultiSigning = encodeForMultiSigning;
    function encodeForSigningBatch(object2) {
      return (0, ripple_binary_codec_1.encodeForSigningBatch)(object2);
    }
    exports.encodeForSigningBatch = encodeForSigningBatch;
    function decode10(hex) {
      return (0, ripple_binary_codec_1.decode)(hex);
    }
    exports.decode = decode10;
    function isValidAddress(address) {
      return (0, ripple_address_codec_1.isValidXAddress)(address) || (0, ripple_address_codec_1.isValidClassicAddress)(address);
    }
    exports.isValidAddress = isValidAddress;
    function hasNextPage(response) {
      return Boolean(response.result["marker"]);
    }
    exports.hasNextPage = hasNextPage;
    var hashes = {
      hashSignedTx: hashes_1.hashSignedTx,
      hashTx: hashes_1.hashTx,
      hashAccountRoot: hashes_1.hashAccountRoot,
      hashSignerListId: hashes_1.hashSignerListId,
      hashOfferId: hashes_1.hashOfferId,
      hashTrustline: hashes_1.hashTrustline,
      hashTxTree: hashes_1.hashTxTree,
      hashStateTree: hashes_1.hashStateTree,
      hashLedger: hashes_1.hashLedger,
      hashLedgerHeader: hashes_1.hashLedgerHeader,
      hashEscrow: hashes_1.hashEscrow,
      hashPaymentChannel: hashes_1.hashPaymentChannel,
      hashVault: hashes_1.hashVault,
      hashLoanBroker: hashes_1.hashLoanBroker,
      hashLoan: hashes_1.hashLoan
    };
    exports.hashes = hashes;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/submit.js
var require_submit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/submit.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils8();
    var LEDGER_CLOSE_TIME = 1e3;
    function sleep(ms) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
          setTimeout(resolve, ms);
        });
      });
    }
    function submitRequest(client, signedTransaction, failHard = false) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!isSigned(signedTransaction)) {
          throw new errors_1.ValidationError("Transaction must be signed.");
        }
        const signedTxEncoded = typeof signedTransaction === "string" ? signedTransaction : (0, utils_1.encode)(signedTransaction);
        const request = {
          command: "submit",
          tx_blob: signedTxEncoded,
          fail_hard: isAccountDelete(signedTransaction) || failHard
        };
        return client.request(request);
      });
    }
    exports.submitRequest = submitRequest;
    function waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult) {
      return __awaiter(this, void 0, void 0, function* () {
        yield sleep(LEDGER_CLOSE_TIME);
        const latestLedger = yield client.getLedgerIndex();
        if (lastLedger < latestLedger) {
          throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).
Preliminary result: ${submissionResult}`);
        }
        const txResponse = yield client.request({
          command: "tx",
          transaction: txHash
        }).catch((error) => __awaiter(this, void 0, void 0, function* () {
          var _a4;
          const message = (_a4 = error === null || error === void 0 ? void 0 : error.data) === null || _a4 === void 0 ? void 0 : _a4.error;
          if (message === "txnNotFound") {
            return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
          }
          throw new Error(`${message} 
 Preliminary result: ${submissionResult}.
Full error details: ${String(error)}`);
        }));
        if (txResponse.result.validated) {
          return txResponse;
        }
        return waitForFinalTransactionOutcome(client, txHash, lastLedger, submissionResult);
      });
    }
    exports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;
    function isSigned(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      if (typeof tx === "string") {
        return false;
      }
      if (tx.Signers != null) {
        const signers = tx.Signers;
        for (const signer of signers) {
          if (signer.Signer.SigningPubKey == null || signer.Signer.TxnSignature == null) {
            return false;
          }
        }
        return true;
      }
      return tx.SigningPubKey != null && tx.TxnSignature != null;
    }
    function getSignedTx(client, transaction, { autofill = true, wallet } = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (isSigned(transaction)) {
          return transaction;
        }
        if (!wallet) {
          throw new errors_1.ValidationError("Wallet must be provided when submitting an unsigned transaction");
        }
        let tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
        if (autofill) {
          tx = yield client.autofill(tx);
        }
        return wallet.sign(tx).tx_blob;
      });
    }
    exports.getSignedTx = getSignedTx;
    function getLastLedgerSequence(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      return tx.LastLedgerSequence;
    }
    exports.getLastLedgerSequence = getLastLedgerSequence;
    function isAccountDelete(transaction) {
      const tx = typeof transaction === "string" ? (0, utils_1.decode)(transaction) : transaction;
      return tx.TransactionType === "AccountDelete";
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/utils.js
var require_utils9 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureClassicAddress = void 0;
    var ripple_address_codec_1 = require_dist2();
    function ensureClassicAddress(account) {
      if ((0, ripple_address_codec_1.isValidXAddress)(account)) {
        const { classicAddress, tag } = (0, ripple_address_codec_1.xAddressToClassicAddress)(account);
        if (tag !== false) {
          throw new Error("This command does not support the use of a tag. Use an address without a tag.");
        }
        return classicAddress;
      }
      return account;
    }
    exports.ensureClassicAddress = ensureClassicAddress;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/index.js
var require_sugar = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_submit(), exports);
    __exportStar(require_utils9(), exports);
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getFeeXrp.js
var require_getFeeXrp = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getFeeXrp.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var NUM_DECIMAL_PLACES = 6;
    var BASE_10 = 10;
    function getFeeXrp(client, cushion) {
      var _a4, _b;
      return __awaiter(this, void 0, void 0, function* () {
        const feeCushion = cushion !== null && cushion !== void 0 ? cushion : client.feeCushion;
        const serverInfo = (yield client.request({
          command: "server_info"
        })).result.info;
        const baseFee = (_a4 = serverInfo.validated_ledger) === null || _a4 === void 0 ? void 0 : _a4.base_fee_xrp;
        if (baseFee == null) {
          throw new errors_1.XrplError("getFeeXrp: Could not get base_fee_xrp from server_info");
        }
        const baseFeeXrp = new bignumber_js_1.default(baseFee);
        (_b = serverInfo.load_factor) !== null && _b !== void 0 ? _b : serverInfo.load_factor = 1;
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(feeCushion);
        fee = bignumber_js_1.default.min(fee, client.maxFeeXRP);
        return new bignumber_js_1.default(fee.toFixed(NUM_DECIMAL_PLACES)).toString(BASE_10);
      });
    }
    exports.default = getFeeXrp;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/autofill.js
var require_autofill = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/autofill.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autofillBatchTxn = exports.handleDeliverMax = exports.checkAccountDeleteBlockers = exports.setLatestValidatedLedgerSequence = exports.getTransactionFee = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var utils_1 = require_utils8();
    var getFeeXrp_1 = __importDefault(require_getFeeXrp());
    var LEDGER_OFFSET = 20;
    var RESTRICTED_NETWORKS = 1024;
    var REQUIRED_NETWORKID_VERSION = "1.11.0";
    function isNotLaterRippledVersion(source, target) {
      if (source === target) {
        return true;
      }
      const sourceDecomp = source.split(".");
      const targetDecomp = target.split(".");
      const sourceMajor = parseInt(sourceDecomp[0], 10);
      const sourceMinor = parseInt(sourceDecomp[1], 10);
      const targetMajor = parseInt(targetDecomp[0], 10);
      const targetMinor = parseInt(targetDecomp[1], 10);
      if (sourceMajor !== targetMajor) {
        return sourceMajor < targetMajor;
      }
      if (sourceMinor !== targetMinor) {
        return sourceMinor < targetMinor;
      }
      const sourcePatch = sourceDecomp[2].split("-");
      const targetPatch = targetDecomp[2].split("-");
      const sourcePatchVersion = parseInt(sourcePatch[0], 10);
      const targetPatchVersion = parseInt(targetPatch[0], 10);
      if (sourcePatchVersion !== targetPatchVersion) {
        return sourcePatchVersion < targetPatchVersion;
      }
      if (sourcePatch.length !== targetPatch.length) {
        return sourcePatch.length > targetPatch.length;
      }
      if (sourcePatch.length === 2) {
        if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {
          return sourcePatch[1] < targetPatch[1];
        }
        if (sourcePatch[1].startsWith("b")) {
          return parseInt(sourcePatch[1].slice(1), 10) < parseInt(targetPatch[1].slice(1), 10);
        }
        return parseInt(sourcePatch[1].slice(2), 10) < parseInt(targetPatch[1].slice(2), 10);
      }
      return false;
    }
    function txNeedsNetworkID(client) {
      if (client.networkID !== void 0 && client.networkID > RESTRICTED_NETWORKS) {
        if (client.buildVersion && isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client.buildVersion)) {
          return true;
        }
      }
      return false;
    }
    exports.txNeedsNetworkID = txNeedsNetworkID;
    function setValidAddresses(tx) {
      validateAccountAddress(tx, "Account", "SourceTag");
      if (tx["Destination"] != null) {
        validateAccountAddress(tx, "Destination", "DestinationTag");
      }
      convertToClassicAddress(tx, "Authorize");
      convertToClassicAddress(tx, "Unauthorize");
      convertToClassicAddress(tx, "Owner");
      convertToClassicAddress(tx, "RegularKey");
    }
    exports.setValidAddresses = setValidAddresses;
    function validateAccountAddress(tx, accountField, tagField) {
      const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField]);
      tx[accountField] = classicAccount;
      if (tag != null && tag !== false) {
        if (tx[tagField] && tx[tagField] !== tag) {
          throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);
        }
        tx[tagField] = tag;
      }
    }
    function getClassicAccountAndTag(account, expectedTag) {
      if ((0, ripple_address_codec_1.isValidXAddress)(account)) {
        const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(account);
        if (expectedTag != null && classic.tag !== expectedTag) {
          throw new errors_1.ValidationError("address includes a tag that does not match the tag specified in the transaction");
        }
        return {
          classicAccount: classic.classicAddress,
          tag: classic.tag
        };
      }
      return {
        classicAccount: account,
        tag: expectedTag
      };
    }
    function convertToClassicAddress(tx, fieldName) {
      const account = tx[fieldName];
      if (typeof account === "string") {
        const { classicAccount } = getClassicAccountAndTag(account);
        tx[fieldName] = classicAccount;
      }
    }
    function getNextValidSequenceNumber(client, account) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_info",
          account,
          ledger_index: "current"
        };
        const data = yield client.request(request);
        return data.result.account_data.Sequence;
      });
    }
    function setNextValidSequenceNumber(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        tx.Sequence = yield getNextValidSequenceNumber(client, tx.Account);
      });
    }
    exports.setNextValidSequenceNumber = setNextValidSequenceNumber;
    function fetchOwnerReserveFee(client) {
      var _a4;
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield client.request({ command: "server_state" });
        const fee = (_a4 = response.result.state.validated_ledger) === null || _a4 === void 0 ? void 0 : _a4.reserve_inc;
        if (fee == null) {
          return Promise.reject(new Error("Could not fetch Owner Reserve."));
        }
        return new bignumber_js_1.default(fee);
      });
    }
    function fetchCounterPartySignersCount(client, tx) {
      var _a4, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let counterParty = tx.Counterparty;
        if (counterParty == null) {
          if (tx.LoanBrokerID == null) {
            throw new errors_1.ValidationError("LoanBrokerID is required for LoanSet transaction");
          }
          const resp = (yield client.request({
            command: "ledger_entry",
            index: tx.LoanBrokerID,
            ledger_index: "validated"
          })).result.node;
          counterParty = resp.Owner;
        }
        const signerListRequest = {
          command: "account_info",
          account: counterParty,
          ledger_index: "validated",
          signer_lists: true
        };
        const signerListResponse = yield client.request(signerListRequest);
        const signerList = (_a4 = signerListResponse.result.signer_lists) === null || _a4 === void 0 ? void 0 : _a4[0];
        return (_b = signerList === null || signerList === void 0 ? void 0 : signerList.SignerEntries.length) !== null && _b !== void 0 ? _b : 1;
      });
    }
    function calculateFeePerTransactionType(client, tx, signersCount = 0) {
      return __awaiter(this, void 0, void 0, function* () {
        const netFeeXRP = yield (0, getFeeXrp_1.default)(client);
        const netFeeDrops = (0, utils_1.xrpToDrops)(netFeeXRP);
        let baseFee = new bignumber_js_1.default(netFeeDrops);
        const isSpecialTxCost = [
          "AccountDelete",
          "AMMCreate",
          "VaultCreate"
        ].includes(tx.TransactionType);
        if (tx.TransactionType === "EscrowFinish" && tx.Fulfillment != null) {
          const fulfillmentBytesSize = Math.ceil(tx.Fulfillment.length / 2);
          baseFee = new bignumber_js_1.default(scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16));
        } else if (isSpecialTxCost) {
          baseFee = yield fetchOwnerReserveFee(client);
        } else if (tx.TransactionType === "Batch") {
          const rawTxFees = yield tx.RawTransactions.reduce((acc, rawTxn) => __awaiter(this, void 0, void 0, function* () {
            const resolvedAcc = yield acc;
            const fee = yield calculateFeePerTransactionType(client, rawTxn.RawTransaction);
            return bignumber_js_1.default.sum(resolvedAcc, fee);
          }), Promise.resolve(new bignumber_js_1.default(0)));
          baseFee = bignumber_js_1.default.sum(baseFee.times(2), rawTxFees);
        }
        if (signersCount > 0) {
          baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, signersCount));
        }
        if (tx.TransactionType === "LoanSet") {
          const counterPartySignersCount = yield fetchCounterPartySignersCount(client, tx);
          baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, counterPartySignersCount));
          console.warn(`For LoanSet transaction the auto calculated Fee accounts for total number of signers the counterparty has to avoid transaction failure.`);
        }
        const maxFeeDrops = (0, utils_1.xrpToDrops)(client.maxFeeXRP);
        const totalFee = isSpecialTxCost ? baseFee : bignumber_js_1.default.min(baseFee, maxFeeDrops);
        return totalFee.dp(0, bignumber_js_1.default.ROUND_CEIL);
      });
    }
    function getTransactionFee(client, tx, signersCount = 0) {
      return __awaiter(this, void 0, void 0, function* () {
        const fee = yield calculateFeePerTransactionType(client, tx, signersCount);
        tx.Fee = fee.toString(10);
      });
    }
    exports.getTransactionFee = getTransactionFee;
    function scaleValue(value, multiplier) {
      return new bignumber_js_1.default(value).times(multiplier).toString();
    }
    function setLatestValidatedLedgerSequence(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const ledgerSequence = yield client.getLedgerIndex();
        tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
      });
    }
    exports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;
    function checkAccountDeleteBlockers(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_objects",
          account: tx.Account,
          ledger_index: "validated",
          deletion_blockers_only: true
        };
        const response = yield client.request(request);
        return new Promise((resolve, reject) => {
          if (response.result.account_objects.length > 0) {
            reject(new errors_1.XrplError(`Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));
          }
          resolve();
        });
      });
    }
    exports.checkAccountDeleteBlockers = checkAccountDeleteBlockers;
    function handleDeliverMax(tx) {
      var _a4;
      if (tx.DeliverMax != null) {
        (_a4 = tx.Amount) !== null && _a4 !== void 0 ? _a4 : tx.Amount = tx.DeliverMax;
        if (tx.Amount != null && tx.Amount !== tx.DeliverMax) {
          throw new errors_1.ValidationError("PaymentTransaction: Amount and DeliverMax fields must be identical when both are provided");
        }
        delete tx.DeliverMax;
      }
    }
    exports.handleDeliverMax = handleDeliverMax;
    function autofillBatchTxn(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountSequences = {};
        for (const rawTxn of tx.RawTransactions) {
          const txn = rawTxn.RawTransaction;
          if (txn.Sequence == null && txn.TicketSequence == null) {
            if (txn.Account in accountSequences) {
              txn.Sequence = accountSequences[txn.Account];
              accountSequences[txn.Account] += 1;
            } else {
              const nextSequence = yield getNextValidSequenceNumber(client, txn.Account);
              const sequence = txn.Account === tx.Account ? nextSequence + 1 : nextSequence;
              accountSequences[txn.Account] = sequence + 1;
              txn.Sequence = sequence;
            }
          }
          if (txn.Fee == null) {
            txn.Fee = "0";
          } else if (txn.Fee !== "0") {
            throw new errors_1.XrplError('Must have `Fee of "0" in inner Batch transaction.');
          }
          if (txn.SigningPubKey == null) {
            txn.SigningPubKey = "";
          } else if (txn.SigningPubKey !== "") {
            throw new errors_1.XrplError('Must have `SigningPubKey` of "" in inner Batch transaction.');
          }
          if (txn.TxnSignature != null) {
            throw new errors_1.XrplError("Must not have `TxnSignature` in inner Batch transaction.");
          }
          if (txn.Signers != null) {
            throw new errors_1.XrplError("Must not have `Signers` in inner Batch transaction.");
          }
          if (txn.NetworkID == null && txNeedsNetworkID(client)) {
            txn.NetworkID = client.networkID;
          }
        }
      });
    }
    exports.autofillBatchTxn = autofillBatchTxn;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/balances.js
var require_balances = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/balances.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBalances = void 0;
    function formatBalances(trustlines) {
      return trustlines.map((trustline) => ({
        value: trustline.balance,
        currency: trustline.currency,
        issuer: trustline.account
      }));
    }
    exports.formatBalances = formatBalances;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Offer.js
var require_Offer = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OfferFlags = void 0;
    var OfferFlags;
    (function(OfferFlags2) {
      OfferFlags2[OfferFlags2["lsfPassive"] = 65536] = "lsfPassive";
      OfferFlags2[OfferFlags2["lsfSell"] = 131072] = "lsfSell";
      OfferFlags2[OfferFlags2["lsfHybrid"] = 262144] = "lsfHybrid";
    })(OfferFlags || (exports.OfferFlags = OfferFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getOrderbook.js
var require_getOrderbook = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getOrderbook.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortAndLimitOffers = exports.separateBuySellOrders = exports.combineOrders = exports.extractOffers = exports.reverseRequest = exports.requestAllOffers = exports.createBookOffersRequest = exports.validateOrderbookOptions = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var Offer_1 = require_Offer();
    var DEFAULT_LIMIT = 20;
    function sortOffers(offers) {
      return offers.sort((offerA, offerB) => {
        var _a4, _b;
        const qualityA = (_a4 = offerA.quality) !== null && _a4 !== void 0 ? _a4 : 0;
        const qualityB = (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;
        return new bignumber_js_1.default(qualityA).comparedTo(qualityB);
      });
    }
    var getOrderbookOptionsSet = /* @__PURE__ */ new Set([
      "limit",
      "ledger_index",
      "ledger_hash",
      "taker"
    ]);
    function validateOrderbookOptions(options) {
      for (const key of Object.keys(options)) {
        if (!getOrderbookOptionsSet.has(key)) {
          throw new errors_1.ValidationError(`Unexpected option: ${key}`, options);
        }
      }
      if (options.limit && typeof options.limit !== "number") {
        throw new errors_1.ValidationError("limit must be a number", options.limit);
      }
      if (options.ledger_index && !(typeof options.ledger_index === "number" || typeof options.ledger_index === "string" && ["validated", "closed", "current"].includes(options.ledger_index))) {
        throw new errors_1.ValidationError('ledger_index must be a number or a string of "validated", "closed", or "current"', options.ledger_index);
      }
      if (options.ledger_hash !== void 0 && options.ledger_hash !== null && typeof options.ledger_hash !== "string") {
        throw new errors_1.ValidationError("ledger_hash must be a string", options.ledger_hash);
      }
      if (options.taker !== void 0 && typeof options.taker !== "string") {
        throw new errors_1.ValidationError("taker must be a string", options.taker);
      }
    }
    exports.validateOrderbookOptions = validateOrderbookOptions;
    function createBookOffersRequest(currency1, currency2, options) {
      var _a4, _b, _c;
      const request = {
        command: "book_offers",
        taker_pays: currency1,
        taker_gets: currency2,
        ledger_index: (_a4 = options.ledger_index) !== null && _a4 !== void 0 ? _a4 : "validated",
        ledger_hash: options.ledger_hash === null ? void 0 : options.ledger_hash,
        limit: (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,
        taker: (_c = options.taker) !== null && _c !== void 0 ? _c : void 0
      };
      return request;
    }
    exports.createBookOffersRequest = createBookOffersRequest;
    function requestAllOffers(client, request) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield client.requestAll(request);
        return results.map((result) => result.result.offers);
      });
    }
    exports.requestAllOffers = requestAllOffers;
    function reverseRequest(request) {
      return Object.assign(Object.assign({}, request), { taker_pays: request.taker_gets, taker_gets: request.taker_pays });
    }
    exports.reverseRequest = reverseRequest;
    function extractOffers(offerResults) {
      return offerResults.flatMap((offerResult) => offerResult);
    }
    exports.extractOffers = extractOffers;
    function combineOrders(directOffers, reverseOffers) {
      return [...directOffers, ...reverseOffers];
    }
    exports.combineOrders = combineOrders;
    function separateBuySellOrders(orders) {
      const buy = [];
      const sell = [];
      orders.forEach((order) => {
        if ((order.Flags & Offer_1.OfferFlags.lsfSell) === 0) {
          buy.push(order);
        } else {
          sell.push(order);
        }
      });
      return { buy, sell };
    }
    exports.separateBuySellOrders = separateBuySellOrders;
    function sortAndLimitOffers(offers, limit) {
      const sortedOffers = sortOffers(offers);
      return sortedOffers.slice(0, limit);
    }
    exports.sortAndLimitOffers = sortAndLimitOffers;
  }
});

// node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HDKey = exports.HARDENED_OFFSET = void 0;
    var modular_1 = require_modular();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac();
    var legacy_1 = require_legacy();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var Point2 = secp256k1_1.secp256k1.ProjectivePoint;
    var base58check = (0, base_1.createBase58check)(sha2_1.sha256);
    function bytesToNumber(bytes) {
      (0, utils_1.abytes)(bytes);
      const h = bytes.length === 0 ? "0" : (0, utils_1.bytesToHex)(bytes);
      return BigInt("0x" + h);
    }
    function numberToBytes(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, "0"));
    }
    var MASTER_SECRET = (0, utils_1.utf8ToBytes)("Bitcoin seed");
    var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
    exports.HARDENED_OFFSET = 2147483648;
    var hash160 = (data) => (0, legacy_1.ripemd160)((0, sha2_1.sha256)(data));
    var fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
    var toU32 = (n) => {
      if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
      }
      const buf = new Uint8Array(4);
      (0, utils_1.createView)(buf).setUint32(0, n, false);
      return buf;
    };
    var HDKey = class _HDKey {
      get fingerprint() {
        if (!this.pubHash) {
          throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
      }
      get identifier() {
        return this.pubHash;
      }
      get pubKeyHash() {
        return this.pubHash;
      }
      get privateKey() {
        return this.privKeyBytes || null;
      }
      get publicKey() {
        return this.pubKey || null;
      }
      get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("No private key");
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
      }
      get publicExtendedKey() {
        if (!this.pubKey) {
          throw new Error("No public key");
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
      }
      static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, utils_1.abytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
          throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, MASTER_SECRET, seed);
        return new _HDKey({
          versions,
          chainCode: I.slice(32),
          privateKey: I.slice(0, 32)
        });
      }
      static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version2 = keyView.getUint32(0, false);
        const opt = {
          versions,
          depth: keyBuffer[4],
          parentFingerprint: keyView.getUint32(5, false),
          index: keyView.getUint32(9, false),
          chainCode: keyBuffer.slice(13, 45)
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version2 !== versions[isPriv ? "private" : "public"]) {
          throw new Error("Version mismatch");
        }
        if (isPriv) {
          return new _HDKey({ ...opt, privateKey: key.slice(1) });
        } else {
          return new _HDKey({ ...opt, publicKey: key });
        }
      }
      static fromJSON(json) {
        return _HDKey.fromExtendedKey(json.xpriv);
      }
      constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== "object") {
          throw new Error("HDKey.constructor must not be called directly");
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
          if (this.parentFingerprint || this.index) {
            throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
          }
        }
        if (opt.publicKey && opt.privateKey) {
          throw new Error("HDKey: publicKey and privateKey at same time.");
        }
        if (opt.privateKey) {
          if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
            throw new Error("Invalid private key");
          }
          this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
          this.privKeyBytes = numberToBytes(this.privKey);
          this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        } else if (opt.publicKey) {
          this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
        } else {
          throw new Error("HDKey: no public or private key provided");
        }
        this.pubHash = hash160(this.pubKey);
      }
      derive(path) {
        if (!/^[mM]'?/.test(path)) {
          throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
          return this;
        }
        const parts = path.replace(/^[mM]'?\//, "").split("/");
        let child = this;
        for (const c of parts) {
          const m = /^(\d+)('?)$/.exec(c);
          const m1 = m && m[1];
          if (!m || m.length !== 3 || typeof m1 !== "string")
            throw new Error("invalid child index: " + c);
          let idx = +m1;
          if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
            throw new Error("Invalid index");
          }
          if (m[2] === "'") {
            idx += exports.HARDENED_OFFSET;
          }
          child = child.deriveChild(idx);
        }
        return child;
      }
      deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
          throw new Error("No publicKey or chainCode set");
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
          const priv = this.privateKey;
          if (!priv) {
            throw new Error("Could not derive hardened child key");
          }
          data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        } else {
          data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
          throw new Error("Tweak bigger than curve order");
        }
        const opt = {
          versions: this.versions,
          chainCode,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint,
          index
        };
        try {
          if (this.privateKey) {
            const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
              throw new Error("The tweak was out of range or the resulted private key is invalid");
            }
            opt.privateKey = added;
          } else {
            const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
            if (added.equals(Point2.ZERO)) {
              throw new Error("The tweak was equal to negative P, which made the result key invalid");
            }
            opt.publicKey = added.toRawBytes(true);
          }
          return new _HDKey(opt);
        } catch (err) {
          return this.deriveChild(index + 1);
        }
      }
      sign(hash2) {
        if (!this.privateKey) {
          throw new Error("No privateKey set!");
        }
        (0, utils_1.abytes)(hash2, 32);
        return secp256k1_1.secp256k1.sign(hash2, this.privKey).toCompactRawBytes();
      }
      verify(hash2, signature) {
        (0, utils_1.abytes)(hash2, 32);
        (0, utils_1.abytes)(signature, 64);
        if (!this.publicKey) {
          throw new Error("No publicKey set!");
        }
        let sig;
        try {
          sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        } catch (error) {
          return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash2, this.publicKey);
      }
      wipePrivateData() {
        this.privKey = void 0;
        if (this.privKeyBytes) {
          this.privKeyBytes.fill(0);
          this.privKeyBytes = void 0;
        }
        return this;
      }
      toJSON() {
        return {
          xpriv: this.privateExtendedKey,
          xpub: this.publicExtendedKey
        };
      }
      serialize(version2, key) {
        if (!this.chainCode) {
          throw new Error("No chainCode set");
        }
        (0, utils_1.abytes)(key, 33);
        return (0, utils_1.concatBytes)(toU32(version2), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
      }
    };
    exports.HDKey = HDKey;
  }
});

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = pbkdf2;
    exports.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash2);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf2(hash2, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMnemonic = generateMnemonic;
    exports.mnemonicToEntropy = mnemonicToEntropy;
    exports.entropyToMnemonic = entropyToMnemonic;
    exports.validateMnemonic = validateMnemonic;
    exports.mnemonicToSeed = mnemonicToSeed;
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError("invalid mnemonic type: " + typeof str);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function aentropy(ent) {
      (0, utils_1.abytes)(ent, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      (0, utils_1.anumber)(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha2_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error("wordlist: non-string element: " + i);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      aentropy(entropy);
      return entropy;
    }
    function entropyToMnemonic(entropy, wordlist) {
      aentropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "\u3000" : " ");
    }
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js
var require_english = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/ECDSA.js
var require_ECDSA = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/ECDSA.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ECDSA;
    (function(ECDSA2) {
      ECDSA2["ed25519"] = "ed25519";
      ECDSA2["secp256k1"] = "ecdsa-secp256k1";
    })(ECDSA || (ECDSA = {}));
    exports.default = ECDSA;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountDelete.js
var require_accountDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAccountDelete = void 0;
    var common_1 = require_common3();
    function validateAccountDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
    }
    exports.validateAccountDelete = validateAccountDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMBid.js
var require_AMMBid = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMBid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMBid = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_AUTH_ACCOUNTS = 4;
    function validateAMMBid(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMBid: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset2");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMBid: Asset2 must be a Currency");
      }
      if (tx.BidMin != null && !(0, common_1.isAmount)(tx.BidMin)) {
        throw new errors_1.ValidationError("AMMBid: BidMin must be an Amount");
      }
      if (tx.BidMax != null && !(0, common_1.isAmount)(tx.BidMax)) {
        throw new errors_1.ValidationError("AMMBid: BidMax must be an Amount");
      }
      if (tx.AuthAccounts != null) {
        if (!(0, common_1.isArray)(tx.AuthAccounts)) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts must be an AuthAccount array`);
        }
        if (tx.AuthAccounts.length > MAX_AUTH_ACCOUNTS) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts length must not be greater than ${MAX_AUTH_ACCOUNTS}`);
        }
        validateAuthAccounts(tx.Account, tx.AuthAccounts);
      }
    }
    exports.validateAMMBid = validateAMMBid;
    function validateAuthAccounts(senderAddress, authAccounts) {
      for (const authAccount of authAccounts) {
        if (!(0, common_1.isRecord)(authAccount)) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (!(0, common_1.isRecord)(authAccount.AuthAccount)) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account == null) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (typeof authAccount.AuthAccount.Account !== "string") {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account === senderAddress) {
          throw new errors_1.ValidationError(`AMMBid: AuthAccounts must not include sender's address`);
        }
      }
      return true;
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js
var require_AMMCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMCreate = exports.AMM_MAX_TRADING_FEE = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    exports.AMM_MAX_TRADING_FEE = 1e3;
    function validateAMMCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("AMMCreate: Amount must be an Amount");
      }
      if (tx.Amount2 == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount2");
      }
      if (!(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError("AMMCreate: Amount2 must be an Amount");
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field TradingFee");
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError("AMMCreate: TradingFee must be a number");
      }
      if (tx.TradingFee < 0 || tx.TradingFee > exports.AMM_MAX_TRADING_FEE) {
        throw new errors_1.ValidationError(`AMMCreate: TradingFee must be between 0 and ${exports.AMM_MAX_TRADING_FEE}`);
      }
    }
    exports.validateAMMCreate = validateAMMCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js
var require_AMMDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateAMMDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMDelete: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset2");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMDelete: Asset2 must be a Currency");
      }
    }
    exports.validateAMMDelete = validateAMMDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMVote.js
var require_AMMVote = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMVote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAMMVote = void 0;
    var errors_1 = require_errors();
    var AMMCreate_1 = require_AMMCreate();
    var common_1 = require_common3();
    function validateAMMVote(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMVote: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset2");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMVote: Asset2 must be a Currency");
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError("AMMVote: missing field TradingFee");
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError("AMMVote: TradingFee must be a number");
      }
      if (tx.TradingFee < 0 || tx.TradingFee > AMMCreate_1.AMM_MAX_TRADING_FEE) {
        throw new errors_1.ValidationError(`AMMVote: TradingFee must be between 0 and ${AMMCreate_1.AMM_MAX_TRADING_FEE}`);
      }
    }
    exports.validateAMMVote = validateAMMVote;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCancel.js
var require_checkCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateCheckCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCancel: invalid CheckID");
      }
    }
    exports.validateCheckCancel = validateCheckCancel;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCash.js
var require_checkCash = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCash = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateCheckCash(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null && tx.DeliverMin == null) {
        throw new errors_1.ValidationError("CheckCash: must have either Amount or DeliverMin");
      }
      if (tx.Amount != null && tx.DeliverMin != null) {
        throw new errors_1.ValidationError("CheckCash: cannot have both Amount and DeliverMin");
      }
      if (tx.Amount != null && tx.Amount !== void 0 && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("CheckCash: invalid Amount");
      }
      if (tx.DeliverMin != null && tx.DeliverMin !== void 0 && !(0, common_1.isAmount)(tx.DeliverMin)) {
        throw new errors_1.ValidationError("CheckCash: invalid DeliverMin");
      }
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCash: invalid CheckID");
      }
    }
    exports.validateCheckCash = validateCheckCash;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCreate.js
var require_checkCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCheckCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateCheckCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.SendMax === void 0) {
        throw new errors_1.ValidationError("CheckCreate: missing field SendMax");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (typeof tx.SendMax !== "string" && !(0, common_1.isIssuedCurrencyAmount)(tx.SendMax)) {
        throw new errors_1.ValidationError("CheckCreate: invalid SendMax");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("CheckCreate: invalid Expiration");
      }
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError("CheckCreate: invalid InvoiceID");
      }
    }
    exports.validateCheckCreate = validateCheckCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/clawback.js
var require_clawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/clawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateClawback = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isClawbackAmount);
      (0, common_1.validateOptionalField)(tx, "Holder", common_1.isAccount);
      if (!(0, common_1.isIssuedCurrencyAmount)(tx.Amount) && !(0, common_1.isMPTAmount)(tx.Amount)) {
        throw new errors_1.ValidationError("Clawback: invalid Amount");
      }
      if ((0, common_1.isIssuedCurrencyAmount)(tx.Amount) && tx.Account === tx.Amount.issuer) {
        throw new errors_1.ValidationError("Clawback: invalid holder Account");
      }
      if ((0, common_1.isMPTAmount)(tx.Amount) && tx.Account === tx.Holder) {
        throw new errors_1.ValidationError("Clawback: invalid holder Account");
      }
      if ((0, common_1.isIssuedCurrencyAmount)(tx.Amount) && tx.Holder) {
        throw new errors_1.ValidationError("Clawback: cannot have Holder for currency");
      }
      if ((0, common_1.isMPTAmount)(tx.Amount) && !tx.Holder) {
        throw new errors_1.ValidationError("Clawback: missing Holder");
      }
    }
    exports.validateClawback = validateClawback;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialAccept.js
var require_CredentialAccept = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialAccept.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialAccept = void 0;
    var common_1 = require_common3();
    function validateCredentialAccept(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Issuer", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
    }
    exports.validateCredentialAccept = validateCredentialAccept;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialCreate.js
var require_CredentialCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialCreate = void 0;
    var utils_1 = require_browser();
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_URI_LENGTH = 256;
    function validateCredentialCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Subject", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
      (0, common_1.validateOptionalField)(tx, "Expiration", common_1.isNumber);
      validateURI(tx.URI);
    }
    exports.validateCredentialCreate = validateCredentialCreate;
    function validateURI(URI) {
      if (URI === void 0) {
        return;
      }
      if (typeof URI !== "string") {
        throw new errors_1.ValidationError("CredentialCreate: invalid field URI");
      }
      if (URI.length === 0) {
        throw new errors_1.ValidationError("CredentialCreate: URI cannot be an empty string");
      } else if (URI.length > MAX_URI_LENGTH) {
        throw new errors_1.ValidationError(`CredentialCreate: URI length must be <= ${MAX_URI_LENGTH}`);
      }
      if (!utils_1.HEX_REGEX.test(URI)) {
        throw new errors_1.ValidationError("CredentialCreate: URI must be encoded in hex");
      }
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialDelete.js
var require_CredentialDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateCredentialDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateCredentialDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (!tx.Subject && !tx.Issuer) {
        throw new errors_1.ValidationError("CredentialDelete: either `Issuer` or `Subject` must be provided");
      }
      (0, common_1.validateRequiredField)(tx, "Account", common_1.isString);
      (0, common_1.validateCredentialType)(tx);
      (0, common_1.validateOptionalField)(tx, "Subject", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Issuer", common_1.isString);
    }
    exports.validateCredentialDelete = validateCredentialDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/delegateSet.js
var require_delegateSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/delegateSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDelegateSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var PERMISSIONS_MAX_LENGTH = 10;
    var NON_DELEGABLE_TRANSACTIONS = /* @__PURE__ */ new Set([
      "AccountSet",
      "SetRegularKey",
      "SignerListSet",
      "DelegateSet",
      "AccountDelete",
      "Batch",
      "EnableAmendment",
      "SetFee",
      "UNLModify"
    ]);
    function validateDelegateSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Authorize", common_1.isAccount);
      if (tx.Authorize === tx.Account) {
        throw new errors_1.ValidationError("DelegateSet: Authorize and Account must be different.");
      }
      (0, common_1.validateRequiredField)(tx, "Permissions", Array.isArray);
      const permissions = tx.Permissions;
      if (permissions.length > PERMISSIONS_MAX_LENGTH) {
        throw new errors_1.ValidationError(`DelegateSet: Permissions array length cannot be greater than ${PERMISSIONS_MAX_LENGTH}.`);
      }
      const permissionValueSet = /* @__PURE__ */ new Set();
      permissions.forEach((permission) => {
        if (permission == null || Object.keys(permission).length !== 1 || permission.Permission == null || Object.keys(permission.Permission).length !== 1) {
          throw new errors_1.ValidationError("DelegateSet: Permissions array element is malformed");
        }
        const permissionValue = permission.Permission.PermissionValue;
        if (permissionValue == null) {
          throw new errors_1.ValidationError("DelegateSet: PermissionValue must be defined");
        }
        if (typeof permissionValue !== "string") {
          throw new errors_1.ValidationError("DelegateSet: PermissionValue must be a string");
        }
        if (NON_DELEGABLE_TRANSACTIONS.has(permissionValue)) {
          throw new errors_1.ValidationError(`DelegateSet: PermissionValue contains a non-delegatable transaction ${permissionValue}`);
        }
        permissionValueSet.add(permissionValue);
      });
      if (permissions.length !== permissionValueSet.size) {
        throw new errors_1.ValidationError("DelegateSet: Permissions array cannot contain duplicate values");
      }
    }
    exports.validateDelegateSet = validateDelegateSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js
var require_depositPreauth = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDepositPreauth = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateDepositPreauth(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      validateSingleAuthorizationFieldProvided(tx);
      if (tx.Authorize !== void 0) {
        if (typeof tx.Authorize !== "string") {
          throw new errors_1.ValidationError("DepositPreauth: Authorize must be a string");
        }
        if (tx.Account === tx.Authorize) {
          throw new errors_1.ValidationError("DepositPreauth: Account can't preauthorize its own address");
        }
      } else if (tx.Unauthorize !== void 0) {
        if (typeof tx.Unauthorize !== "string") {
          throw new errors_1.ValidationError("DepositPreauth: Unauthorize must be a string");
        }
        if (tx.Account === tx.Unauthorize) {
          throw new errors_1.ValidationError("DepositPreauth: Account can't unauthorize its own address");
        }
      } else if (tx.AuthorizeCredentials !== void 0) {
        (0, common_1.validateCredentialsList)(tx.AuthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);
      } else if (tx.UnauthorizeCredentials !== void 0) {
        (0, common_1.validateCredentialsList)(tx.UnauthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);
      }
    }
    exports.validateDepositPreauth = validateDepositPreauth;
    function validateSingleAuthorizationFieldProvided(tx) {
      const fields = [
        "Authorize",
        "Unauthorize",
        "AuthorizeCredentials",
        "UnauthorizeCredentials"
      ];
      const countProvided = fields.filter((key) => tx[key] !== void 0).length;
      if (countProvided !== 1) {
        throw new errors_1.ValidationError("DepositPreauth: Requires exactly one field of the following: Authorize, Unauthorize, AuthorizeCredentials, UnauthorizeCredentials.");
      }
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js
var require_DIDDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDIDDelete = void 0;
    var common_1 = require_common3();
    function validateDIDDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
    }
    exports.validateDIDDelete = validateDIDDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDSet.js
var require_DIDSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateDIDSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateDIDSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "DIDDocument", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      if (tx.Data === void 0 && tx.DIDDocument === void 0 && tx.URI === void 0) {
        throw new errors_1.ValidationError("DIDSet: Must have at least one of `Data`, `DIDDocument`, and `URI`");
      }
    }
    exports.validateDIDSet = validateDIDSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js
var require_escrowCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateEscrowCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError("EscrowCancel: missing OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number" && typeof tx.OfferSequence !== "string" || Number.isNaN(Number(tx.OfferSequence))) {
        throw new errors_1.ValidationError("EscrowCancel: OfferSequence must be a number");
      }
    }
    exports.validateEscrowCancel = validateEscrowCancel;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js
var require_escrowCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateEscrowCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (tx.CancelAfter === void 0 && tx.FinishAfter === void 0) {
        throw new errors_1.ValidationError("EscrowCreate: Either CancelAfter or FinishAfter must be specified");
      }
      if (tx.FinishAfter === void 0 && tx.Condition === void 0) {
        throw new errors_1.ValidationError("EscrowCreate: Either Condition or FinishAfter must be specified");
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError("EscrowCreate: CancelAfter must be a number");
      }
      if (tx.FinishAfter !== void 0 && typeof tx.FinishAfter !== "number") {
        throw new errors_1.ValidationError("EscrowCreate: FinishAfter must be a number");
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError("EscrowCreate: Condition must be a string");
      }
    }
    exports.validateEscrowCreate = validateEscrowCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js
var require_escrowFinish = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEscrowFinish = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateEscrowFinish(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError("EscrowFinish: missing field OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number" && typeof tx.OfferSequence !== "string" || Number.isNaN(Number(tx.OfferSequence))) {
        throw new errors_1.ValidationError("EscrowFinish: OfferSequence must be a number");
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError("EscrowFinish: Condition must be a string");
      }
      if (tx.Fulfillment !== void 0 && typeof tx.Fulfillment !== "string") {
        throw new errors_1.ValidationError("EscrowFinish: Fulfillment must be a string");
      }
    }
    exports.validateEscrowFinish = validateEscrowFinish;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverClawback.js
var require_loanBrokerCoverClawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverClawback.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanBrokerCoverClawback = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanBrokerCoverClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "LoanBrokerID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isTokenAmount);
      if (tx.LoanBrokerID != null && !(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanBrokerCoverClawback: LoanBrokerID must be 64 characters hexadecimal string`);
      }
      if (tx.Amount != null && new bignumber_js_1.default(tx.Amount.value).isLessThan(0)) {
        throw new errors_1.ValidationError(`LoanBrokerCoverClawback: Amount must be >= 0`);
      }
      if (tx.LoanBrokerID == null && tx.Amount == null) {
        throw new errors_1.ValidationError(`LoanBrokerCoverClawback: Either LoanBrokerID or Amount is required`);
      }
    }
    exports.validateLoanBrokerCoverClawback = validateLoanBrokerCoverClawback;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverDeposit.js
var require_loanBrokerCoverDeposit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverDeposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanBrokerCoverDeposit = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanBrokerCoverDeposit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanBrokerID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanBrokerCoverDeposit: LoanBrokerID must be 64 characters hexadecimal string`);
      }
    }
    exports.validateLoanBrokerCoverDeposit = validateLoanBrokerCoverDeposit;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverWithdraw.js
var require_loanBrokerCoverWithdraw = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerCoverWithdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanBrokerCoverWithdraw = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanBrokerCoverWithdraw(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanBrokerID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanBrokerCoverWithdraw: LoanBrokerID must be 64 characters hexadecimal string`);
      }
    }
    exports.validateLoanBrokerCoverWithdraw = validateLoanBrokerCoverWithdraw;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerDelete.js
var require_loanBrokerDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanBrokerDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanBrokerDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanBrokerID", common_1.isString);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanBrokerDelete: LoanBrokerID must be 64 characters hexadecimal string`);
      }
    }
    exports.validateLoanBrokerDelete = validateLoanBrokerDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerSet.js
var require_loanBrokerSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanBrokerSet.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanBrokerSet = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_DATA_LENGTH = 512;
    var MAX_MANAGEMENT_FEE_RATE = 1e4;
    var MAX_COVER_RATE_MINIMUM = 1e5;
    var MAX_COVER_RATE_LIQUIDATION = 1e5;
    function validateLoanBrokerSet(tx) {
      var _a4, _b;
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "LoanBrokerID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "ManagementFeeRate", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "DebtMaximum", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "CoverRateMinimum", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "CoverRateLiquidation", common_1.isNumber);
      if (!(0, common_1.isLedgerEntryId)(tx.VaultID)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: VaultID must be 64 characters hexadecimal string`);
      }
      if (tx.LoanBrokerID != null && !(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: LoanBrokerID must be 64 characters hexadecimal string`);
      }
      if (tx.Data != null && !(0, common_1.validateHexMetadata)(tx.Data, MAX_DATA_LENGTH)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: Data must be a valid non-empty hex string up to ${MAX_DATA_LENGTH} characters`);
      }
      if (tx.ManagementFeeRate != null && (tx.ManagementFeeRate < 0 || tx.ManagementFeeRate > MAX_MANAGEMENT_FEE_RATE)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: ManagementFeeRate must be between 0 and ${MAX_MANAGEMENT_FEE_RATE} inclusive`);
      }
      if (tx.DebtMaximum != null && new bignumber_js_1.default(tx.DebtMaximum).isLessThan(0)) {
        throw new errors_1.ValidationError("LoanBrokerSet: DebtMaximum must be a non-negative value");
      }
      if (tx.CoverRateMinimum != null && (tx.CoverRateMinimum < 0 || tx.CoverRateMinimum > MAX_COVER_RATE_MINIMUM)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: CoverRateMinimum must be between 0 and ${MAX_COVER_RATE_MINIMUM} inclusive`);
      }
      if (tx.CoverRateLiquidation != null && (tx.CoverRateLiquidation < 0 || tx.CoverRateLiquidation > MAX_COVER_RATE_LIQUIDATION)) {
        throw new errors_1.ValidationError(`LoanBrokerSet: CoverRateLiquidation must be between 0 and ${MAX_COVER_RATE_LIQUIDATION} inclusive`);
      }
      const coverRateMinimumValue = (_a4 = tx.CoverRateMinimum) !== null && _a4 !== void 0 ? _a4 : 0;
      const coverRateLiquidationValue = (_b = tx.CoverRateLiquidation) !== null && _b !== void 0 ? _b : 0;
      if (coverRateMinimumValue === 0 && coverRateLiquidationValue !== 0 || coverRateMinimumValue !== 0 && coverRateLiquidationValue === 0) {
        throw new errors_1.ValidationError("LoanBrokerSet: CoverRateMinimum and CoverRateLiquidation must both be zero or both be non-zero");
      }
    }
    exports.validateLoanBrokerSet = validateLoanBrokerSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanDelete.js
var require_loanDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanID", common_1.isString);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanID)) {
        throw new errors_1.ValidationError(`LoanDelete: LoanID must be 64 characters hexadecimal string`);
      }
    }
    exports.validateLoanDelete = validateLoanDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanPay.js
var require_loanPay = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanPay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanPay = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateLoanPay(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanID)) {
        throw new errors_1.ValidationError(`LoanPay: LoanID must be 64 characters hexadecimal string`);
      }
    }
    exports.validateLoanPay = validateLoanPay;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanSet.js
var require_loanSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/loanSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateLoanSet = exports.LoanSetFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_DATA_LENGTH = 512;
    var MAX_OVER_PAYMENT_FEE_RATE = 1e5;
    var MAX_INTEREST_RATE = 1e5;
    var MAX_LATE_INTEREST_RATE = 1e5;
    var MAX_CLOSE_INTEREST_RATE = 1e5;
    var MAX_OVER_PAYMENT_INTEREST_RATE = 1e5;
    var MIN_PAYMENT_INTERVAL = 60;
    var LoanSetFlags;
    (function(LoanSetFlags2) {
      LoanSetFlags2[LoanSetFlags2["tfLoanOverpayment"] = 65536] = "tfLoanOverpayment";
    })(LoanSetFlags || (exports.LoanSetFlags = LoanSetFlags = {}));
    function validateLoanSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "LoanBrokerID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "PrincipalRequested", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "CounterpartySignature", common_1.isRecord);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Counterparty", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "LoanOriginationFee", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "LoanServiceFee", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "LatePaymentFee", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "ClosePaymentFee", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "OverpaymentFee", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "InterestRate", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "LateInterestRate", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "CloseInterestRate", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "OverpaymentInterestRate", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "PaymentTotal", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "PaymentInterval", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "GracePeriod", common_1.isNumber);
      if (!(0, common_1.isLedgerEntryId)(tx.LoanBrokerID)) {
        throw new errors_1.ValidationError(`LoanSet: LoanBrokerID must be 64 characters hexadecimal string`);
      }
      if (tx.Data != null && !(0, common_1.validateHexMetadata)(tx.Data, MAX_DATA_LENGTH)) {
        throw new errors_1.ValidationError(`LoanSet: Data must be a valid non-empty hex string up to ${MAX_DATA_LENGTH} characters`);
      }
      if (tx.OverpaymentFee != null && (tx.OverpaymentFee < 0 || tx.OverpaymentFee > MAX_OVER_PAYMENT_FEE_RATE)) {
        throw new errors_1.ValidationError(`LoanSet: OverpaymentFee must be between 0 and ${MAX_OVER_PAYMENT_FEE_RATE} inclusive`);
      }
      if (tx.InterestRate != null && (tx.InterestRate < 0 || tx.InterestRate > MAX_INTEREST_RATE)) {
        throw new errors_1.ValidationError(`LoanSet: InterestRate must be between 0 and ${MAX_INTEREST_RATE} inclusive`);
      }
      if (tx.LateInterestRate != null && (tx.LateInterestRate < 0 || tx.LateInterestRate > MAX_LATE_INTEREST_RATE)) {
        throw new errors_1.ValidationError(`LoanSet: LateInterestRate must be between 0 and ${MAX_LATE_INTEREST_RATE} inclusive`);
      }
      if (tx.CloseInterestRate != null && (tx.CloseInterestRate < 0 || tx.CloseInterestRate > MAX_CLOSE_INTEREST_RATE)) {
        throw new errors_1.ValidationError(`LoanSet: CloseInterestRate must be between 0 and ${MAX_CLOSE_INTEREST_RATE} inclusive`);
      }
      if (tx.OverpaymentInterestRate != null && (tx.OverpaymentInterestRate < 0 || tx.OverpaymentInterestRate > MAX_OVER_PAYMENT_INTEREST_RATE)) {
        throw new errors_1.ValidationError(`LoanSet: OverpaymentInterestRate must be between 0 and ${MAX_OVER_PAYMENT_INTEREST_RATE} inclusive`);
      }
      if (tx.PaymentInterval != null && tx.PaymentInterval < MIN_PAYMENT_INTERVAL) {
        throw new errors_1.ValidationError(`LoanSet: PaymentInterval must be greater than or equal to ${MIN_PAYMENT_INTERVAL}`);
      }
      if (tx.PaymentInterval != null && tx.GracePeriod != null && tx.GracePeriod > tx.PaymentInterval) {
        throw new errors_1.ValidationError(`LoanSet: GracePeriod must not be greater than PaymentInterval`);
      }
    }
    exports.validateLoanSet = validateLoanSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceDestroy.js
var require_MPTokenIssuanceDestroy = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceDestroy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMPTokenIssuanceDestroy = void 0;
    var common_1 = require_common3();
    function validateMPTokenIssuanceDestroy(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "MPTokenIssuanceID", common_1.isString);
    }
    exports.validateMPTokenIssuanceDestroy = validateMPTokenIssuanceDestroy;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js
var require_NFTokenAcceptOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenAcceptOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateNFTokenBrokerFee(tx) {
      const value = (0, common_1.parseAmountValue)(tx.NFTokenBrokerFee);
      if (Number.isNaN(value)) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: invalid NFTokenBrokerFee");
      }
      if (value <= 0) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: NFTokenBrokerFee must be greater than 0; omit if there is no fee");
      }
      if (tx.NFTokenSellOffer == null || tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: both NFTokenSellOffer and NFTokenBuyOffer must be set if using brokered mode");
      }
    }
    function validateNFTokenAcceptOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.NFTokenBrokerFee != null) {
        validateNFTokenBrokerFee(tx);
      }
      if (tx.NFTokenSellOffer == null && tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError("NFTokenAcceptOffer: must set either NFTokenSellOffer or NFTokenBuyOffer");
      }
    }
    exports.validateNFTokenAcceptOffer = validateNFTokenAcceptOffer;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js
var require_NFTokenBurn = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenBurn = void 0;
    var common_1 = require_common3();
    function validateNFTokenBurn(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "NFTokenID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
    }
    exports.validateNFTokenBurn = validateNFTokenBurn;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js
var require_NFTokenCancelOffer = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenCancelOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateNFTokenCancelOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (!(0, common_1.isArray)(tx.NFTokenOffers)) {
        throw new errors_1.ValidationError("NFTokenCancelOffer: missing field NFTokenOffers");
      }
      if (tx.NFTokenOffers.length < 1) {
        throw new errors_1.ValidationError("NFTokenCancelOffer: empty field NFTokenOffers");
      }
    }
    exports.validateNFTokenCancelOffer = validateNFTokenCancelOffer;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenModify.js
var require_NFTokenModify = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenModify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateNFTokenModify = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    function validateNFTokenModify(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "NFTokenID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      if (tx.URI !== void 0 && typeof tx.URI === "string") {
        if (tx.URI === "") {
          throw new errors_1.ValidationError("NFTokenModify: URI must not be empty string");
        }
        if (!(0, utils_1.isHex)(tx.URI)) {
          throw new errors_1.ValidationError("NFTokenModify: URI must be in hex format");
        }
      }
    }
    exports.validateNFTokenModify = validateNFTokenModify;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCancel.js
var require_offerCancel = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOfferCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateOfferCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.OfferSequence === void 0) {
        throw new errors_1.ValidationError("OfferCancel: missing field OfferSequence");
      }
      if (typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError("OfferCancel: OfferSequence must be a number");
      }
    }
    exports.validateOfferCancel = validateOfferCancel;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js
var require_oracleDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOracleDelete = void 0;
    var common_1 = require_common3();
    function validateOracleDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "OracleDocumentID", common_1.isNumber);
    }
    exports.validateOracleDelete = validateOracleDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleSet.js
var require_oracleSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOracleSet = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    var PRICE_DATA_SERIES_MAX_LENGTH = 10;
    var SCALE_MAX = 10;
    var MINIMUM_ASSET_PRICE_LENGTH = 1;
    var MAXIMUM_ASSET_PRICE_LENGTH = 16;
    function validateOracleSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "OracleDocumentID", common_1.isNumber);
      (0, common_1.validateRequiredField)(tx, "LastUpdateTime", common_1.isNumber);
      (0, common_1.validateOptionalField)(tx, "Provider", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "AssetClass", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "PriceDataSeries", (value) => {
        if (!(0, common_1.isArray)(value)) {
          throw new errors_1.ValidationError("OracleSet: PriceDataSeries must be an array");
        }
        if (value.length > PRICE_DATA_SERIES_MAX_LENGTH) {
          throw new errors_1.ValidationError(`OracleSet: PriceDataSeries must have at most ${PRICE_DATA_SERIES_MAX_LENGTH} PriceData objects`);
        }
        for (const priceData of value) {
          if (!(0, common_1.isRecord)(priceData)) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must be an array of objects");
          }
          const priceDataInner = priceData.PriceData;
          if (!(0, common_1.isRecord)(priceDataInner)) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `PriceData` object");
          }
          if (Object.keys(priceData).length !== 1) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must only have a single PriceData object");
          }
          if (priceDataInner.BaseAsset == null || typeof priceDataInner.BaseAsset !== "string") {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `BaseAsset` string");
          }
          if (typeof priceDataInner.QuoteAsset !== "string") {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have a `QuoteAsset` string");
          }
          if (priceDataInner.AssetPrice == null !== (priceDataInner.Scale == null)) {
            throw new errors_1.ValidationError("OracleSet: PriceDataSeries must have both `AssetPrice` and `Scale` if any are present");
          }
          if ("AssetPrice" in priceDataInner) {
            if (!(0, common_1.isNumber)(priceDataInner.AssetPrice)) {
              if (typeof priceDataInner.AssetPrice !== "string") {
                throw new errors_1.ValidationError("OracleSet: Field AssetPrice must be a string or a number");
              }
              if (!(0, utils_1.isHex)(priceDataInner.AssetPrice)) {
                throw new errors_1.ValidationError("OracleSet: Field AssetPrice must be a valid hex string");
              }
              if (priceDataInner.AssetPrice.length < MINIMUM_ASSET_PRICE_LENGTH || priceDataInner.AssetPrice.length > MAXIMUM_ASSET_PRICE_LENGTH) {
                throw new errors_1.ValidationError(`OracleSet: Length of AssetPrice field must be between ${MINIMUM_ASSET_PRICE_LENGTH} and ${MAXIMUM_ASSET_PRICE_LENGTH} characters long`);
              }
            }
          }
          if ("Scale" in priceDataInner) {
            if (!(0, common_1.isNumber)(priceDataInner.Scale)) {
              throw new errors_1.ValidationError("OracleSet: invalid field Scale");
            }
            if (priceDataInner.Scale < 0 || priceDataInner.Scale > SCALE_MAX) {
              throw new errors_1.ValidationError(`OracleSet: Scale must be in range 0-${SCALE_MAX}`);
            }
          }
        }
        return true;
      });
    }
    exports.validateOracleSet = validateOracleSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js
var require_paymentChannelCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validatePaymentChannelCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing Amount");
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelCreate: Amount must be a string");
      }
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      if (tx.SettleDelay === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing SettleDelay");
      }
      if (typeof tx.SettleDelay !== "number") {
        throw new errors_1.ValidationError("PaymentChannelCreate: SettleDelay must be a number");
      }
      if (tx.PublicKey === void 0) {
        throw new errors_1.ValidationError("PaymentChannelCreate: missing PublicKey");
      }
      if (typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError("PaymentChannelCreate: PublicKey must be a string");
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError("PaymentChannelCreate: CancelAfter must be a number");
      }
    }
    exports.validatePaymentChannelCreate = validatePaymentChannelCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js
var require_paymentChannelFund = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePaymentChannelFund = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validatePaymentChannelFund(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError("PaymentChannelFund: missing Channel");
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError("PaymentChannelFund: Channel must be a string");
      }
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError("PaymentChannelFund: missing Amount");
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError("PaymentChannelFund: Amount must be a string");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("PaymentChannelFund: Expiration must be a number");
      }
    }
    exports.validatePaymentChannelFund = validatePaymentChannelFund;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainDelete.js
var require_permissionedDomainDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePermissionedDomainDelete = void 0;
    var common_1 = require_common3();
    function validatePermissionedDomainDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "DomainID", common_1.isString);
    }
    exports.validatePermissionedDomainDelete = validatePermissionedDomainDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainSet.js
var require_permissionedDomainSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePermissionedDomainSet = void 0;
    var common_1 = require_common3();
    var MAX_ACCEPTED_CREDENTIALS = 10;
    function validatePermissionedDomainSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "AcceptedCredentials", common_1.isArray);
      (0, common_1.validateCredentialsList)(tx.AcceptedCredentials, tx.TransactionType, false, MAX_ACCEPTED_CREDENTIALS);
    }
    exports.validatePermissionedDomainSet = validatePermissionedDomainSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js
var require_setRegularKey = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSetRegularKey = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    function validateSetRegularKey(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.RegularKey !== void 0 && typeof tx.RegularKey !== "string") {
        throw new errors_1.ValidationError("SetRegularKey: RegularKey must be a string");
      }
    }
    exports.validateSetRegularKey = validateSetRegularKey;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/signerListSet.js
var require_signerListSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/signerListSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSignerListSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_SIGNERS = 32;
    var HEX_WALLET_LOCATOR_REGEX = /^[0-9A-Fa-f]{64}$/u;
    function validateSignerListSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "SignerQuorum", common_1.isNumber);
      if (tx.SignerQuorum === 0) {
        return;
      }
      (0, common_1.validateRequiredField)(tx, "SignerEntries", common_1.isArray);
      if (tx.SignerEntries.length === 0) {
        throw new errors_1.ValidationError("SignerListSet: need at least 1 member in SignerEntries");
      }
      if (tx.SignerEntries.length > MAX_SIGNERS) {
        throw new errors_1.ValidationError(`SignerListSet: maximum of ${MAX_SIGNERS} members allowed in SignerEntries`);
      }
      for (const entry of tx.SignerEntries) {
        if (!(0, common_1.isRecord)(entry) || !(0, common_1.isRecord)(entry.SignerEntry)) {
          throw new errors_1.ValidationError("SignerListSet: SignerEntries must be an array of SignerEntry objects");
        }
        const signerEntry = entry.SignerEntry;
        const { WalletLocator } = signerEntry;
        if (WalletLocator != null && (!(0, common_1.isString)(WalletLocator) || !HEX_WALLET_LOCATOR_REGEX.test(WalletLocator))) {
          throw new errors_1.ValidationError(`SignerListSet: WalletLocator in SignerEntry must be a 256-bit (32-byte) hexadecimal value`);
        }
      }
    }
    exports.validateSignerListSet = validateSignerListSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js
var require_ticketCreate = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTicketCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common3();
    var MAX_TICKETS = 250;
    function validateTicketCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { TicketCount } = tx;
      if (TicketCount === void 0) {
        throw new errors_1.ValidationError("TicketCreate: missing field TicketCount");
      }
      if (typeof TicketCount !== "number") {
        throw new errors_1.ValidationError("TicketCreate: TicketCount must be a number");
      }
      if (!Number.isInteger(TicketCount) || TicketCount < 1 || TicketCount > MAX_TICKETS) {
        throw new errors_1.ValidationError("TicketCreate: TicketCount must be an integer from 1 to 250");
      }
    }
    exports.validateTicketCreate = validateTicketCreate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultClawback.js
var require_vaultClawback = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultClawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultClawback = void 0;
    var common_1 = require_common3();
    function validateVaultClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Holder", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "Amount", common_1.isClawbackAmount);
    }
    exports.validateVaultClawback = validateVaultClawback;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultDelete.js
var require_vaultDelete = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultDelete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultDelete = void 0;
    var common_1 = require_common3();
    function validateVaultDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
    }
    exports.validateVaultDelete = validateVaultDelete;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultDeposit.js
var require_vaultDeposit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultDeposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultDeposit = void 0;
    var common_1 = require_common3();
    function validateVaultDeposit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateVaultDeposit = validateVaultDeposit;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultSet.js
var require_vaultSet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultSet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultSet = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils4();
    var common_1 = require_common3();
    function validateVaultSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "AssetsMaximum", common_1.isXRPLNumber);
      (0, common_1.validateOptionalField)(tx, "DomainID", common_1.isString);
      if (tx.Data !== void 0) {
        const dataHex = tx.Data;
        if (!(0, utils_1.isHex)(dataHex)) {
          throw new errors_1.ValidationError("VaultSet: Data must be a valid hex string");
        }
        const dataByteLength = dataHex.length / 2;
        if (dataByteLength > common_1.VAULT_DATA_MAX_BYTE_LENGTH) {
          throw new errors_1.ValidationError(`VaultSet: Data exceeds ${common_1.VAULT_DATA_MAX_BYTE_LENGTH} bytes (actual: ${dataByteLength})`);
        }
      }
    }
    exports.validateVaultSet = validateVaultSet;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultWithdraw.js
var require_vaultWithdraw = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/vaultWithdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVaultWithdraw = void 0;
    var common_1 = require_common3();
    function validateVaultWithdraw(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "VaultID", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
    }
    exports.validateVaultWithdraw = validateVaultWithdraw;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js
var require_XChainAccountCreateCommit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAccountCreateCommit = void 0;
    var common_1 = require_common3();
    function validateXChainAccountCreateCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainAccountCreateCommit = validateXChainAccountCreateCommit;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js
var require_XChainAddAccountCreateAttestation = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAddAccountCreateAttestation = void 0;
    var common_1 = require_common3();
    function validateXChainAddAccountCreateAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "AttestationRewardAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "AttestationSignerAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
      (0, common_1.validateRequiredField)(tx, "XChainAccountCreateCount", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
    }
    exports.validateXChainAddAccountCreateAttestation = validateXChainAddAccountCreateAttestation;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js
var require_XChainAddClaimAttestation = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainAddClaimAttestation = void 0;
    var common_1 = require_common3();
    function validateXChainAddClaimAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "AttestationRewardAccount", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "AttestationSignerAccount", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
    }
    exports.validateXChainAddClaimAttestation = validateXChainAddClaimAttestation;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js
var require_XChainClaim = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainClaim = void 0;
    var common_1 = require_common3();
    function validateXChainClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateRequiredField)(tx, "Destination", common_1.isAccount);
      (0, common_1.validateOptionalField)(tx, "DestinationTag", common_1.isNumber);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainClaim = validateXChainClaim;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js
var require_XChainCommit = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCommit = void 0;
    var common_1 = require_common3();
    function validateXChainCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "XChainClaimID", (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp));
      (0, common_1.validateOptionalField)(tx, "OtherChainDestination", common_1.isAccount);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports.validateXChainCommit = validateXChainCommit;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js
var require_XChainCreateBridge = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCreateBridge = void 0;
    var common_1 = require_common3();
    function validateXChainCreateBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateOptionalField)(tx, "MinAccountCreateAmount", common_1.isAmount);
    }
    exports.validateXChainCreateBridge = validateXChainCreateBridge;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js
var require_XChainCreateClaimID = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateXChainCreateClaimID = void 0;
    var common_1 = require_common3();
    function validateXChainCreateClaimID(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "XChainBridge", common_1.isXChainBridge);
      (0, common_1.validateRequiredField)(tx, "SignatureReward", common_1.isAmount);
      (0, common_1.validateRequiredField)(tx, "OtherChainSource", common_1.isAccount);
    }
    exports.validateXChainCreateClaimID = validateXChainCreateClaimID;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/transaction.js
var require_transaction = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validate = void 0;
    var errors_1 = require_errors();
    var flags_1 = require_flags();
    var accountDelete_1 = require_accountDelete();
    var accountSet_1 = require_accountSet();
    var AMMBid_1 = require_AMMBid();
    var AMMClawback_1 = require_AMMClawback();
    var AMMCreate_1 = require_AMMCreate();
    var AMMDelete_1 = require_AMMDelete();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMVote_1 = require_AMMVote();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var batch_1 = require_batch();
    var checkCancel_1 = require_checkCancel();
    var checkCash_1 = require_checkCash();
    var checkCreate_1 = require_checkCreate();
    var clawback_1 = require_clawback();
    var common_1 = require_common3();
    var CredentialAccept_1 = require_CredentialAccept();
    var CredentialCreate_1 = require_CredentialCreate();
    var CredentialDelete_1 = require_CredentialDelete();
    var delegateSet_1 = require_delegateSet();
    var depositPreauth_1 = require_depositPreauth();
    var DIDDelete_1 = require_DIDDelete();
    var DIDSet_1 = require_DIDSet();
    var escrowCancel_1 = require_escrowCancel();
    var escrowCreate_1 = require_escrowCreate();
    var escrowFinish_1 = require_escrowFinish();
    var loanBrokerCoverClawback_1 = require_loanBrokerCoverClawback();
    var loanBrokerCoverDeposit_1 = require_loanBrokerCoverDeposit();
    var loanBrokerCoverWithdraw_1 = require_loanBrokerCoverWithdraw();
    var loanBrokerDelete_1 = require_loanBrokerDelete();
    var loanBrokerSet_1 = require_loanBrokerSet();
    var loanDelete_1 = require_loanDelete();
    var loanManage_1 = require_loanManage();
    var loanPay_1 = require_loanPay();
    var loanSet_1 = require_loanSet();
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    var MPTokenIssuanceDestroy_1 = require_MPTokenIssuanceDestroy();
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    var NFTokenAcceptOffer_1 = require_NFTokenAcceptOffer();
    var NFTokenBurn_1 = require_NFTokenBurn();
    var NFTokenCancelOffer_1 = require_NFTokenCancelOffer();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var NFTokenModify_1 = require_NFTokenModify();
    var offerCancel_1 = require_offerCancel();
    var offerCreate_1 = require_offerCreate();
    var oracleDelete_1 = require_oracleDelete();
    var oracleSet_1 = require_oracleSet();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var paymentChannelCreate_1 = require_paymentChannelCreate();
    var paymentChannelFund_1 = require_paymentChannelFund();
    var permissionedDomainDelete_1 = require_permissionedDomainDelete();
    var permissionedDomainSet_1 = require_permissionedDomainSet();
    var setRegularKey_1 = require_setRegularKey();
    var signerListSet_1 = require_signerListSet();
    var ticketCreate_1 = require_ticketCreate();
    var trustSet_1 = require_trustSet();
    var vaultClawback_1 = require_vaultClawback();
    var vaultCreate_1 = require_vaultCreate();
    var vaultDelete_1 = require_vaultDelete();
    var vaultDeposit_1 = require_vaultDeposit();
    var vaultSet_1 = require_vaultSet();
    var vaultWithdraw_1 = require_vaultWithdraw();
    var XChainAccountCreateCommit_1 = require_XChainAccountCreateCommit();
    var XChainAddAccountCreateAttestation_1 = require_XChainAddAccountCreateAttestation();
    var XChainAddClaimAttestation_1 = require_XChainAddClaimAttestation();
    var XChainClaim_1 = require_XChainClaim();
    var XChainCommit_1 = require_XChainCommit();
    var XChainCreateBridge_1 = require_XChainCreateBridge();
    var XChainCreateClaimID_1 = require_XChainCreateClaimID();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    function validate(transaction) {
      const tx = Object.assign({}, transaction);
      (0, common_1.validateBaseTransaction)(tx);
      Object.keys(tx).forEach((key) => {
        const standard_currency_code_len = 3;
        const value = tx[key];
        if (value && (0, common_1.isIssuedCurrencyAmount)(value)) {
          const txCurrency = value.currency;
          if (txCurrency.length === standard_currency_code_len && txCurrency.toUpperCase() === "XRP") {
            throw new errors_1.ValidationError(`Cannot have an issued currency with a similar standard code to XRP (received '${txCurrency}'). XRP is not an issued currency.`);
          }
        }
      });
      tx.Flags = (0, flags_1.convertTxFlagsToNumber)(tx);
      switch (tx.TransactionType) {
        case "AMMBid":
          (0, AMMBid_1.validateAMMBid)(tx);
          break;
        case "AMMClawback":
          (0, AMMClawback_1.validateAMMClawback)(tx);
          break;
        case "AMMCreate":
          (0, AMMCreate_1.validateAMMCreate)(tx);
          break;
        case "AMMDelete":
          (0, AMMDelete_1.validateAMMDelete)(tx);
          break;
        case "AMMDeposit":
          (0, AMMDeposit_1.validateAMMDeposit)(tx);
          break;
        case "AMMVote":
          (0, AMMVote_1.validateAMMVote)(tx);
          break;
        case "AMMWithdraw":
          (0, AMMWithdraw_1.validateAMMWithdraw)(tx);
          break;
        case "AccountDelete":
          (0, accountDelete_1.validateAccountDelete)(tx);
          break;
        case "AccountSet":
          (0, accountSet_1.validateAccountSet)(tx);
          break;
        case "Batch":
          (0, batch_1.validateBatch)(tx);
          tx.RawTransactions.forEach((innerTx) => {
            validate(innerTx.RawTransaction);
          });
          break;
        case "CheckCancel":
          (0, checkCancel_1.validateCheckCancel)(tx);
          break;
        case "CheckCash":
          (0, checkCash_1.validateCheckCash)(tx);
          break;
        case "CheckCreate":
          (0, checkCreate_1.validateCheckCreate)(tx);
          break;
        case "Clawback":
          (0, clawback_1.validateClawback)(tx);
          break;
        case "CredentialAccept":
          (0, CredentialAccept_1.validateCredentialAccept)(tx);
          break;
        case "CredentialCreate":
          (0, CredentialCreate_1.validateCredentialCreate)(tx);
          break;
        case "CredentialDelete":
          (0, CredentialDelete_1.validateCredentialDelete)(tx);
          break;
        case "DIDDelete":
          (0, DIDDelete_1.validateDIDDelete)(tx);
          break;
        case "DIDSet":
          (0, DIDSet_1.validateDIDSet)(tx);
          break;
        case "DelegateSet":
          (0, delegateSet_1.validateDelegateSet)(tx);
          break;
        case "DepositPreauth":
          (0, depositPreauth_1.validateDepositPreauth)(tx);
          break;
        case "EscrowCancel":
          (0, escrowCancel_1.validateEscrowCancel)(tx);
          break;
        case "EscrowCreate":
          (0, escrowCreate_1.validateEscrowCreate)(tx);
          break;
        case "EscrowFinish":
          (0, escrowFinish_1.validateEscrowFinish)(tx);
          break;
        case "LoanBrokerCoverClawback":
          (0, loanBrokerCoverClawback_1.validateLoanBrokerCoverClawback)(tx);
          break;
        case "LoanBrokerCoverDeposit":
          (0, loanBrokerCoverDeposit_1.validateLoanBrokerCoverDeposit)(tx);
          break;
        case "LoanBrokerCoverWithdraw":
          (0, loanBrokerCoverWithdraw_1.validateLoanBrokerCoverWithdraw)(tx);
          break;
        case "LoanBrokerDelete":
          (0, loanBrokerDelete_1.validateLoanBrokerDelete)(tx);
          break;
        case "LoanBrokerSet":
          (0, loanBrokerSet_1.validateLoanBrokerSet)(tx);
          break;
        case "LoanSet":
          (0, loanSet_1.validateLoanSet)(tx);
          break;
        case "LoanManage":
          (0, loanManage_1.validateLoanManage)(tx);
          break;
        case "LoanDelete":
          (0, loanDelete_1.validateLoanDelete)(tx);
          break;
        case "LoanPay":
          (0, loanPay_1.validateLoanPay)(tx);
          break;
        case "MPTokenAuthorize":
          (0, MPTokenAuthorize_1.validateMPTokenAuthorize)(tx);
          break;
        case "MPTokenIssuanceCreate":
          (0, MPTokenIssuanceCreate_1.validateMPTokenIssuanceCreate)(tx);
          break;
        case "MPTokenIssuanceDestroy":
          (0, MPTokenIssuanceDestroy_1.validateMPTokenIssuanceDestroy)(tx);
          break;
        case "MPTokenIssuanceSet":
          (0, MPTokenIssuanceSet_1.validateMPTokenIssuanceSet)(tx);
          break;
        case "NFTokenAcceptOffer":
          (0, NFTokenAcceptOffer_1.validateNFTokenAcceptOffer)(tx);
          break;
        case "NFTokenBurn":
          (0, NFTokenBurn_1.validateNFTokenBurn)(tx);
          break;
        case "NFTokenCancelOffer":
          (0, NFTokenCancelOffer_1.validateNFTokenCancelOffer)(tx);
          break;
        case "NFTokenCreateOffer":
          (0, NFTokenCreateOffer_1.validateNFTokenCreateOffer)(tx);
          break;
        case "NFTokenMint":
          (0, NFTokenMint_1.validateNFTokenMint)(tx);
          break;
        case "NFTokenModify":
          (0, NFTokenModify_1.validateNFTokenModify)(tx);
          break;
        case "OfferCancel":
          (0, offerCancel_1.validateOfferCancel)(tx);
          break;
        case "OfferCreate":
          (0, offerCreate_1.validateOfferCreate)(tx);
          break;
        case "OracleDelete":
          (0, oracleDelete_1.validateOracleDelete)(tx);
          break;
        case "OracleSet":
          (0, oracleSet_1.validateOracleSet)(tx);
          break;
        case "Payment":
          (0, payment_1.validatePayment)(tx);
          break;
        case "PaymentChannelClaim":
          (0, paymentChannelClaim_1.validatePaymentChannelClaim)(tx);
          break;
        case "PaymentChannelCreate":
          (0, paymentChannelCreate_1.validatePaymentChannelCreate)(tx);
          break;
        case "PaymentChannelFund":
          (0, paymentChannelFund_1.validatePaymentChannelFund)(tx);
          break;
        case "PermissionedDomainSet":
          (0, permissionedDomainSet_1.validatePermissionedDomainSet)(tx);
          break;
        case "PermissionedDomainDelete":
          (0, permissionedDomainDelete_1.validatePermissionedDomainDelete)(tx);
          break;
        case "SetRegularKey":
          (0, setRegularKey_1.validateSetRegularKey)(tx);
          break;
        case "SignerListSet":
          (0, signerListSet_1.validateSignerListSet)(tx);
          break;
        case "TicketCreate":
          (0, ticketCreate_1.validateTicketCreate)(tx);
          break;
        case "TrustSet":
          (0, trustSet_1.validateTrustSet)(tx);
          break;
        case "VaultClawback":
          (0, vaultClawback_1.validateVaultClawback)(tx);
          break;
        case "VaultCreate":
          (0, vaultCreate_1.validateVaultCreate)(tx);
          break;
        case "VaultDelete":
          (0, vaultDelete_1.validateVaultDelete)(tx);
          break;
        case "VaultDeposit":
          (0, vaultDeposit_1.validateVaultDeposit)(tx);
          break;
        case "VaultSet":
          (0, vaultSet_1.validateVaultSet)(tx);
          break;
        case "VaultWithdraw":
          (0, vaultWithdraw_1.validateVaultWithdraw)(tx);
          break;
        case "XChainAccountCreateCommit":
          (0, XChainAccountCreateCommit_1.validateXChainAccountCreateCommit)(tx);
          break;
        case "XChainAddAccountCreateAttestation":
          (0, XChainAddAccountCreateAttestation_1.validateXChainAddAccountCreateAttestation)(tx);
          break;
        case "XChainAddClaimAttestation":
          (0, XChainAddClaimAttestation_1.validateXChainAddClaimAttestation)(tx);
          break;
        case "XChainClaim":
          (0, XChainClaim_1.validateXChainClaim)(tx);
          break;
        case "XChainCommit":
          (0, XChainCommit_1.validateXChainCommit)(tx);
          break;
        case "XChainCreateBridge":
          (0, XChainCreateBridge_1.validateXChainCreateBridge)(tx);
          break;
        case "XChainCreateClaimID":
          (0, XChainCreateClaimID_1.validateXChainCreateClaimID)(tx);
          break;
        case "XChainModifyBridge":
          (0, XChainModifyBridge_1.validateXChainModifyBridge)(tx);
          break;
        default:
          throw new errors_1.ValidationError(`Invalid field TransactionType: ${tx.TransactionType}`);
      }
    }
    exports.validate = validate;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js
var require_enableAmendment = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnableAmendmentFlags = void 0;
    var EnableAmendmentFlags;
    (function(EnableAmendmentFlags2) {
      EnableAmendmentFlags2[EnableAmendmentFlags2["tfGotMajority"] = 65536] = "tfGotMajority";
      EnableAmendmentFlags2[EnableAmendmentFlags2["tfLostMajority"] = 131072] = "tfLostMajority";
    })(EnableAmendmentFlags || (exports.EnableAmendmentFlags = EnableAmendmentFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XChainModifyBridgeFlags = exports.VaultWithdrawalPolicy = exports.VaultCreateFlags = exports.TrustSetFlags = exports.PaymentChannelClaimFlags = exports.PaymentFlags = exports.OfferCreateFlags = exports.validateNFTokenModify = exports.NFTokenMintFlags = exports.NFTokenCreateOfferFlags = exports.MPTokenIssuanceSetFlags = exports.MPTokenIssuanceCreateFlags = exports.MPTokenAuthorizeFlags = exports.LoanManageFlags = exports.LoanSetFlags = exports.EnableAmendmentFlags = exports.BatchFlags = exports.AMMWithdrawFlags = exports.AMMDepositFlags = exports.AMMClawbackFlags = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = exports.validate = exports.isMPTAmount = exports.GlobalFlags = void 0;
    var common_1 = require_common3();
    Object.defineProperty(exports, "GlobalFlags", { enumerable: true, get: function() {
      return common_1.GlobalFlags;
    } });
    Object.defineProperty(exports, "isMPTAmount", { enumerable: true, get: function() {
      return common_1.isMPTAmount;
    } });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return transaction_1.validate;
    } });
    __exportStar(require_metadata(), exports);
    var accountSet_1 = require_accountSet();
    Object.defineProperty(exports, "AccountSetAsfFlags", { enumerable: true, get: function() {
      return accountSet_1.AccountSetAsfFlags;
    } });
    Object.defineProperty(exports, "AccountSetTfFlags", { enumerable: true, get: function() {
      return accountSet_1.AccountSetTfFlags;
    } });
    var AMMClawback_1 = require_AMMClawback();
    Object.defineProperty(exports, "AMMClawbackFlags", { enumerable: true, get: function() {
      return AMMClawback_1.AMMClawbackFlags;
    } });
    var AMMDeposit_1 = require_AMMDeposit();
    Object.defineProperty(exports, "AMMDepositFlags", { enumerable: true, get: function() {
      return AMMDeposit_1.AMMDepositFlags;
    } });
    var AMMWithdraw_1 = require_AMMWithdraw();
    Object.defineProperty(exports, "AMMWithdrawFlags", { enumerable: true, get: function() {
      return AMMWithdraw_1.AMMWithdrawFlags;
    } });
    var batch_1 = require_batch();
    Object.defineProperty(exports, "BatchFlags", { enumerable: true, get: function() {
      return batch_1.BatchFlags;
    } });
    var enableAmendment_1 = require_enableAmendment();
    Object.defineProperty(exports, "EnableAmendmentFlags", { enumerable: true, get: function() {
      return enableAmendment_1.EnableAmendmentFlags;
    } });
    var loanSet_1 = require_loanSet();
    Object.defineProperty(exports, "LoanSetFlags", { enumerable: true, get: function() {
      return loanSet_1.LoanSetFlags;
    } });
    var loanManage_1 = require_loanManage();
    Object.defineProperty(exports, "LoanManageFlags", { enumerable: true, get: function() {
      return loanManage_1.LoanManageFlags;
    } });
    var MPTokenAuthorize_1 = require_MPTokenAuthorize();
    Object.defineProperty(exports, "MPTokenAuthorizeFlags", { enumerable: true, get: function() {
      return MPTokenAuthorize_1.MPTokenAuthorizeFlags;
    } });
    var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
    Object.defineProperty(exports, "MPTokenIssuanceCreateFlags", { enumerable: true, get: function() {
      return MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags;
    } });
    var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
    Object.defineProperty(exports, "MPTokenIssuanceSetFlags", { enumerable: true, get: function() {
      return MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags;
    } });
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    Object.defineProperty(exports, "NFTokenCreateOfferFlags", { enumerable: true, get: function() {
      return NFTokenCreateOffer_1.NFTokenCreateOfferFlags;
    } });
    var NFTokenMint_1 = require_NFTokenMint();
    Object.defineProperty(exports, "NFTokenMintFlags", { enumerable: true, get: function() {
      return NFTokenMint_1.NFTokenMintFlags;
    } });
    var NFTokenModify_1 = require_NFTokenModify();
    Object.defineProperty(exports, "validateNFTokenModify", { enumerable: true, get: function() {
      return NFTokenModify_1.validateNFTokenModify;
    } });
    var offerCreate_1 = require_offerCreate();
    Object.defineProperty(exports, "OfferCreateFlags", { enumerable: true, get: function() {
      return offerCreate_1.OfferCreateFlags;
    } });
    var payment_1 = require_payment();
    Object.defineProperty(exports, "PaymentFlags", { enumerable: true, get: function() {
      return payment_1.PaymentFlags;
    } });
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    Object.defineProperty(exports, "PaymentChannelClaimFlags", { enumerable: true, get: function() {
      return paymentChannelClaim_1.PaymentChannelClaimFlags;
    } });
    var trustSet_1 = require_trustSet();
    Object.defineProperty(exports, "TrustSetFlags", { enumerable: true, get: function() {
      return trustSet_1.TrustSetFlags;
    } });
    var vaultCreate_1 = require_vaultCreate();
    Object.defineProperty(exports, "VaultCreateFlags", { enumerable: true, get: function() {
      return vaultCreate_1.VaultCreateFlags;
    } });
    Object.defineProperty(exports, "VaultWithdrawalPolicy", { enumerable: true, get: function() {
      return vaultCreate_1.VaultWithdrawalPolicy;
    } });
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    Object.defineProperty(exports, "XChainModifyBridgeFlags", { enumerable: true, get: function() {
      return XChainModifyBridge_1.XChainModifyBridgeFlags;
    } });
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json
var require_rfc1751Words = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json"(exports, module) {
    module.exports = [
      "A",
      "ABE",
      "ACE",
      "ACT",
      "AD",
      "ADA",
      "ADD",
      "AGO",
      "AID",
      "AIM",
      "AIR",
      "ALL",
      "ALP",
      "AM",
      "AMY",
      "AN",
      "ANA",
      "AND",
      "ANN",
      "ANT",
      "ANY",
      "APE",
      "APS",
      "APT",
      "ARC",
      "ARE",
      "ARK",
      "ARM",
      "ART",
      "AS",
      "ASH",
      "ASK",
      "AT",
      "ATE",
      "AUG",
      "AUK",
      "AVE",
      "AWE",
      "AWK",
      "AWL",
      "AWN",
      "AX",
      "AYE",
      "BAD",
      "BAG",
      "BAH",
      "BAM",
      "BAN",
      "BAR",
      "BAT",
      "BAY",
      "BE",
      "BED",
      "BEE",
      "BEG",
      "BEN",
      "BET",
      "BEY",
      "BIB",
      "BID",
      "BIG",
      "BIN",
      "BIT",
      "BOB",
      "BOG",
      "BON",
      "BOO",
      "BOP",
      "BOW",
      "BOY",
      "BUB",
      "BUD",
      "BUG",
      "BUM",
      "BUN",
      "BUS",
      "BUT",
      "BUY",
      "BY",
      "BYE",
      "CAB",
      "CAL",
      "CAM",
      "CAN",
      "CAP",
      "CAR",
      "CAT",
      "CAW",
      "COD",
      "COG",
      "COL",
      "CON",
      "COO",
      "COP",
      "COT",
      "COW",
      "COY",
      "CRY",
      "CUB",
      "CUE",
      "CUP",
      "CUR",
      "CUT",
      "DAB",
      "DAD",
      "DAM",
      "DAN",
      "DAR",
      "DAY",
      "DEE",
      "DEL",
      "DEN",
      "DES",
      "DEW",
      "DID",
      "DIE",
      "DIG",
      "DIN",
      "DIP",
      "DO",
      "DOE",
      "DOG",
      "DON",
      "DOT",
      "DOW",
      "DRY",
      "DUB",
      "DUD",
      "DUE",
      "DUG",
      "DUN",
      "EAR",
      "EAT",
      "ED",
      "EEL",
      "EGG",
      "EGO",
      "ELI",
      "ELK",
      "ELM",
      "ELY",
      "EM",
      "END",
      "EST",
      "ETC",
      "EVA",
      "EVE",
      "EWE",
      "EYE",
      "FAD",
      "FAN",
      "FAR",
      "FAT",
      "FAY",
      "FED",
      "FEE",
      "FEW",
      "FIB",
      "FIG",
      "FIN",
      "FIR",
      "FIT",
      "FLO",
      "FLY",
      "FOE",
      "FOG",
      "FOR",
      "FRY",
      "FUM",
      "FUN",
      "FUR",
      "GAB",
      "GAD",
      "GAG",
      "GAL",
      "GAM",
      "GAP",
      "GAS",
      "GAY",
      "GEE",
      "GEL",
      "GEM",
      "GET",
      "GIG",
      "GIL",
      "GIN",
      "GO",
      "GOT",
      "GUM",
      "GUN",
      "GUS",
      "GUT",
      "GUY",
      "GYM",
      "GYP",
      "HA",
      "HAD",
      "HAL",
      "HAM",
      "HAN",
      "HAP",
      "HAS",
      "HAT",
      "HAW",
      "HAY",
      "HE",
      "HEM",
      "HEN",
      "HER",
      "HEW",
      "HEY",
      "HI",
      "HID",
      "HIM",
      "HIP",
      "HIS",
      "HIT",
      "HO",
      "HOB",
      "HOC",
      "HOE",
      "HOG",
      "HOP",
      "HOT",
      "HOW",
      "HUB",
      "HUE",
      "HUG",
      "HUH",
      "HUM",
      "HUT",
      "I",
      "ICY",
      "IDA",
      "IF",
      "IKE",
      "ILL",
      "INK",
      "INN",
      "IO",
      "ION",
      "IQ",
      "IRA",
      "IRE",
      "IRK",
      "IS",
      "IT",
      "ITS",
      "IVY",
      "JAB",
      "JAG",
      "JAM",
      "JAN",
      "JAR",
      "JAW",
      "JAY",
      "JET",
      "JIG",
      "JIM",
      "JO",
      "JOB",
      "JOE",
      "JOG",
      "JOT",
      "JOY",
      "JUG",
      "JUT",
      "KAY",
      "KEG",
      "KEN",
      "KEY",
      "KID",
      "KIM",
      "KIN",
      "KIT",
      "LA",
      "LAB",
      "LAC",
      "LAD",
      "LAG",
      "LAM",
      "LAP",
      "LAW",
      "LAY",
      "LEA",
      "LED",
      "LEE",
      "LEG",
      "LEN",
      "LEO",
      "LET",
      "LEW",
      "LID",
      "LIE",
      "LIN",
      "LIP",
      "LIT",
      "LO",
      "LOB",
      "LOG",
      "LOP",
      "LOS",
      "LOT",
      "LOU",
      "LOW",
      "LOY",
      "LUG",
      "LYE",
      "MA",
      "MAC",
      "MAD",
      "MAE",
      "MAN",
      "MAO",
      "MAP",
      "MAT",
      "MAW",
      "MAY",
      "ME",
      "MEG",
      "MEL",
      "MEN",
      "MET",
      "MEW",
      "MID",
      "MIN",
      "MIT",
      "MOB",
      "MOD",
      "MOE",
      "MOO",
      "MOP",
      "MOS",
      "MOT",
      "MOW",
      "MUD",
      "MUG",
      "MUM",
      "MY",
      "NAB",
      "NAG",
      "NAN",
      "NAP",
      "NAT",
      "NAY",
      "NE",
      "NED",
      "NEE",
      "NET",
      "NEW",
      "NIB",
      "NIL",
      "NIP",
      "NIT",
      "NO",
      "NOB",
      "NOD",
      "NON",
      "NOR",
      "NOT",
      "NOV",
      "NOW",
      "NU",
      "NUN",
      "NUT",
      "O",
      "OAF",
      "OAK",
      "OAR",
      "OAT",
      "ODD",
      "ODE",
      "OF",
      "OFF",
      "OFT",
      "OH",
      "OIL",
      "OK",
      "OLD",
      "ON",
      "ONE",
      "OR",
      "ORB",
      "ORE",
      "ORR",
      "OS",
      "OTT",
      "OUR",
      "OUT",
      "OVA",
      "OW",
      "OWE",
      "OWL",
      "OWN",
      "OX",
      "PA",
      "PAD",
      "PAL",
      "PAM",
      "PAN",
      "PAP",
      "PAR",
      "PAT",
      "PAW",
      "PAY",
      "PEA",
      "PEG",
      "PEN",
      "PEP",
      "PER",
      "PET",
      "PEW",
      "PHI",
      "PI",
      "PIE",
      "PIN",
      "PIT",
      "PLY",
      "PO",
      "POD",
      "POE",
      "POP",
      "POT",
      "POW",
      "PRO",
      "PRY",
      "PUB",
      "PUG",
      "PUN",
      "PUP",
      "PUT",
      "QUO",
      "RAG",
      "RAM",
      "RAN",
      "RAP",
      "RAT",
      "RAW",
      "RAY",
      "REB",
      "RED",
      "REP",
      "RET",
      "RIB",
      "RID",
      "RIG",
      "RIM",
      "RIO",
      "RIP",
      "ROB",
      "ROD",
      "ROE",
      "RON",
      "ROT",
      "ROW",
      "ROY",
      "RUB",
      "RUE",
      "RUG",
      "RUM",
      "RUN",
      "RYE",
      "SAC",
      "SAD",
      "SAG",
      "SAL",
      "SAM",
      "SAN",
      "SAP",
      "SAT",
      "SAW",
      "SAY",
      "SEA",
      "SEC",
      "SEE",
      "SEN",
      "SET",
      "SEW",
      "SHE",
      "SHY",
      "SIN",
      "SIP",
      "SIR",
      "SIS",
      "SIT",
      "SKI",
      "SKY",
      "SLY",
      "SO",
      "SOB",
      "SOD",
      "SON",
      "SOP",
      "SOW",
      "SOY",
      "SPA",
      "SPY",
      "SUB",
      "SUD",
      "SUE",
      "SUM",
      "SUN",
      "SUP",
      "TAB",
      "TAD",
      "TAG",
      "TAN",
      "TAP",
      "TAR",
      "TEA",
      "TED",
      "TEE",
      "TEN",
      "THE",
      "THY",
      "TIC",
      "TIE",
      "TIM",
      "TIN",
      "TIP",
      "TO",
      "TOE",
      "TOG",
      "TOM",
      "TON",
      "TOO",
      "TOP",
      "TOW",
      "TOY",
      "TRY",
      "TUB",
      "TUG",
      "TUM",
      "TUN",
      "TWO",
      "UN",
      "UP",
      "US",
      "USE",
      "VAN",
      "VAT",
      "VET",
      "VIE",
      "WAD",
      "WAG",
      "WAR",
      "WAS",
      "WAY",
      "WE",
      "WEB",
      "WED",
      "WEE",
      "WET",
      "WHO",
      "WHY",
      "WIN",
      "WIT",
      "WOK",
      "WON",
      "WOO",
      "WOW",
      "WRY",
      "WU",
      "YAM",
      "YAP",
      "YAW",
      "YE",
      "YEA",
      "YES",
      "YET",
      "YOU",
      "ABED",
      "ABEL",
      "ABET",
      "ABLE",
      "ABUT",
      "ACHE",
      "ACID",
      "ACME",
      "ACRE",
      "ACTA",
      "ACTS",
      "ADAM",
      "ADDS",
      "ADEN",
      "AFAR",
      "AFRO",
      "AGEE",
      "AHEM",
      "AHOY",
      "AIDA",
      "AIDE",
      "AIDS",
      "AIRY",
      "AJAR",
      "AKIN",
      "ALAN",
      "ALEC",
      "ALGA",
      "ALIA",
      "ALLY",
      "ALMA",
      "ALOE",
      "ALSO",
      "ALTO",
      "ALUM",
      "ALVA",
      "AMEN",
      "AMES",
      "AMID",
      "AMMO",
      "AMOK",
      "AMOS",
      "AMRA",
      "ANDY",
      "ANEW",
      "ANNA",
      "ANNE",
      "ANTE",
      "ANTI",
      "AQUA",
      "ARAB",
      "ARCH",
      "AREA",
      "ARGO",
      "ARID",
      "ARMY",
      "ARTS",
      "ARTY",
      "ASIA",
      "ASKS",
      "ATOM",
      "AUNT",
      "AURA",
      "AUTO",
      "AVER",
      "AVID",
      "AVIS",
      "AVON",
      "AVOW",
      "AWAY",
      "AWRY",
      "BABE",
      "BABY",
      "BACH",
      "BACK",
      "BADE",
      "BAIL",
      "BAIT",
      "BAKE",
      "BALD",
      "BALE",
      "BALI",
      "BALK",
      "BALL",
      "BALM",
      "BAND",
      "BANE",
      "BANG",
      "BANK",
      "BARB",
      "BARD",
      "BARE",
      "BARK",
      "BARN",
      "BARR",
      "BASE",
      "BASH",
      "BASK",
      "BASS",
      "BATE",
      "BATH",
      "BAWD",
      "BAWL",
      "BEAD",
      "BEAK",
      "BEAM",
      "BEAN",
      "BEAR",
      "BEAT",
      "BEAU",
      "BECK",
      "BEEF",
      "BEEN",
      "BEER",
      "BEET",
      "BELA",
      "BELL",
      "BELT",
      "BEND",
      "BENT",
      "BERG",
      "BERN",
      "BERT",
      "BESS",
      "BEST",
      "BETA",
      "BETH",
      "BHOY",
      "BIAS",
      "BIDE",
      "BIEN",
      "BILE",
      "BILK",
      "BILL",
      "BIND",
      "BING",
      "BIRD",
      "BITE",
      "BITS",
      "BLAB",
      "BLAT",
      "BLED",
      "BLEW",
      "BLOB",
      "BLOC",
      "BLOT",
      "BLOW",
      "BLUE",
      "BLUM",
      "BLUR",
      "BOAR",
      "BOAT",
      "BOCA",
      "BOCK",
      "BODE",
      "BODY",
      "BOGY",
      "BOHR",
      "BOIL",
      "BOLD",
      "BOLO",
      "BOLT",
      "BOMB",
      "BONA",
      "BOND",
      "BONE",
      "BONG",
      "BONN",
      "BONY",
      "BOOK",
      "BOOM",
      "BOON",
      "BOOT",
      "BORE",
      "BORG",
      "BORN",
      "BOSE",
      "BOSS",
      "BOTH",
      "BOUT",
      "BOWL",
      "BOYD",
      "BRAD",
      "BRAE",
      "BRAG",
      "BRAN",
      "BRAY",
      "BRED",
      "BREW",
      "BRIG",
      "BRIM",
      "BROW",
      "BUCK",
      "BUDD",
      "BUFF",
      "BULB",
      "BULK",
      "BULL",
      "BUNK",
      "BUNT",
      "BUOY",
      "BURG",
      "BURL",
      "BURN",
      "BURR",
      "BURT",
      "BURY",
      "BUSH",
      "BUSS",
      "BUST",
      "BUSY",
      "BYTE",
      "CADY",
      "CAFE",
      "CAGE",
      "CAIN",
      "CAKE",
      "CALF",
      "CALL",
      "CALM",
      "CAME",
      "CANE",
      "CANT",
      "CARD",
      "CARE",
      "CARL",
      "CARR",
      "CART",
      "CASE",
      "CASH",
      "CASK",
      "CAST",
      "CAVE",
      "CEIL",
      "CELL",
      "CENT",
      "CERN",
      "CHAD",
      "CHAR",
      "CHAT",
      "CHAW",
      "CHEF",
      "CHEN",
      "CHEW",
      "CHIC",
      "CHIN",
      "CHOU",
      "CHOW",
      "CHUB",
      "CHUG",
      "CHUM",
      "CITE",
      "CITY",
      "CLAD",
      "CLAM",
      "CLAN",
      "CLAW",
      "CLAY",
      "CLOD",
      "CLOG",
      "CLOT",
      "CLUB",
      "CLUE",
      "COAL",
      "COAT",
      "COCA",
      "COCK",
      "COCO",
      "CODA",
      "CODE",
      "CODY",
      "COED",
      "COIL",
      "COIN",
      "COKE",
      "COLA",
      "COLD",
      "COLT",
      "COMA",
      "COMB",
      "COME",
      "COOK",
      "COOL",
      "COON",
      "COOT",
      "CORD",
      "CORE",
      "CORK",
      "CORN",
      "COST",
      "COVE",
      "COWL",
      "CRAB",
      "CRAG",
      "CRAM",
      "CRAY",
      "CREW",
      "CRIB",
      "CROW",
      "CRUD",
      "CUBA",
      "CUBE",
      "CUFF",
      "CULL",
      "CULT",
      "CUNY",
      "CURB",
      "CURD",
      "CURE",
      "CURL",
      "CURT",
      "CUTS",
      "DADE",
      "DALE",
      "DAME",
      "DANA",
      "DANE",
      "DANG",
      "DANK",
      "DARE",
      "DARK",
      "DARN",
      "DART",
      "DASH",
      "DATA",
      "DATE",
      "DAVE",
      "DAVY",
      "DAWN",
      "DAYS",
      "DEAD",
      "DEAF",
      "DEAL",
      "DEAN",
      "DEAR",
      "DEBT",
      "DECK",
      "DEED",
      "DEEM",
      "DEER",
      "DEFT",
      "DEFY",
      "DELL",
      "DENT",
      "DENY",
      "DESK",
      "DIAL",
      "DICE",
      "DIED",
      "DIET",
      "DIME",
      "DINE",
      "DING",
      "DINT",
      "DIRE",
      "DIRT",
      "DISC",
      "DISH",
      "DISK",
      "DIVE",
      "DOCK",
      "DOES",
      "DOLE",
      "DOLL",
      "DOLT",
      "DOME",
      "DONE",
      "DOOM",
      "DOOR",
      "DORA",
      "DOSE",
      "DOTE",
      "DOUG",
      "DOUR",
      "DOVE",
      "DOWN",
      "DRAB",
      "DRAG",
      "DRAM",
      "DRAW",
      "DREW",
      "DRUB",
      "DRUG",
      "DRUM",
      "DUAL",
      "DUCK",
      "DUCT",
      "DUEL",
      "DUET",
      "DUKE",
      "DULL",
      "DUMB",
      "DUNE",
      "DUNK",
      "DUSK",
      "DUST",
      "DUTY",
      "EACH",
      "EARL",
      "EARN",
      "EASE",
      "EAST",
      "EASY",
      "EBEN",
      "ECHO",
      "EDDY",
      "EDEN",
      "EDGE",
      "EDGY",
      "EDIT",
      "EDNA",
      "EGAN",
      "ELAN",
      "ELBA",
      "ELLA",
      "ELSE",
      "EMIL",
      "EMIT",
      "EMMA",
      "ENDS",
      "ERIC",
      "EROS",
      "EVEN",
      "EVER",
      "EVIL",
      "EYED",
      "FACE",
      "FACT",
      "FADE",
      "FAIL",
      "FAIN",
      "FAIR",
      "FAKE",
      "FALL",
      "FAME",
      "FANG",
      "FARM",
      "FAST",
      "FATE",
      "FAWN",
      "FEAR",
      "FEAT",
      "FEED",
      "FEEL",
      "FEET",
      "FELL",
      "FELT",
      "FEND",
      "FERN",
      "FEST",
      "FEUD",
      "FIEF",
      "FIGS",
      "FILE",
      "FILL",
      "FILM",
      "FIND",
      "FINE",
      "FINK",
      "FIRE",
      "FIRM",
      "FISH",
      "FISK",
      "FIST",
      "FITS",
      "FIVE",
      "FLAG",
      "FLAK",
      "FLAM",
      "FLAT",
      "FLAW",
      "FLEA",
      "FLED",
      "FLEW",
      "FLIT",
      "FLOC",
      "FLOG",
      "FLOW",
      "FLUB",
      "FLUE",
      "FOAL",
      "FOAM",
      "FOGY",
      "FOIL",
      "FOLD",
      "FOLK",
      "FOND",
      "FONT",
      "FOOD",
      "FOOL",
      "FOOT",
      "FORD",
      "FORE",
      "FORK",
      "FORM",
      "FORT",
      "FOSS",
      "FOUL",
      "FOUR",
      "FOWL",
      "FRAU",
      "FRAY",
      "FRED",
      "FREE",
      "FRET",
      "FREY",
      "FROG",
      "FROM",
      "FUEL",
      "FULL",
      "FUME",
      "FUND",
      "FUNK",
      "FURY",
      "FUSE",
      "FUSS",
      "GAFF",
      "GAGE",
      "GAIL",
      "GAIN",
      "GAIT",
      "GALA",
      "GALE",
      "GALL",
      "GALT",
      "GAME",
      "GANG",
      "GARB",
      "GARY",
      "GASH",
      "GATE",
      "GAUL",
      "GAUR",
      "GAVE",
      "GAWK",
      "GEAR",
      "GELD",
      "GENE",
      "GENT",
      "GERM",
      "GETS",
      "GIBE",
      "GIFT",
      "GILD",
      "GILL",
      "GILT",
      "GINA",
      "GIRD",
      "GIRL",
      "GIST",
      "GIVE",
      "GLAD",
      "GLEE",
      "GLEN",
      "GLIB",
      "GLOB",
      "GLOM",
      "GLOW",
      "GLUE",
      "GLUM",
      "GLUT",
      "GOAD",
      "GOAL",
      "GOAT",
      "GOER",
      "GOES",
      "GOLD",
      "GOLF",
      "GONE",
      "GONG",
      "GOOD",
      "GOOF",
      "GORE",
      "GORY",
      "GOSH",
      "GOUT",
      "GOWN",
      "GRAB",
      "GRAD",
      "GRAY",
      "GREG",
      "GREW",
      "GREY",
      "GRID",
      "GRIM",
      "GRIN",
      "GRIT",
      "GROW",
      "GRUB",
      "GULF",
      "GULL",
      "GUNK",
      "GURU",
      "GUSH",
      "GUST",
      "GWEN",
      "GWYN",
      "HAAG",
      "HAAS",
      "HACK",
      "HAIL",
      "HAIR",
      "HALE",
      "HALF",
      "HALL",
      "HALO",
      "HALT",
      "HAND",
      "HANG",
      "HANK",
      "HANS",
      "HARD",
      "HARK",
      "HARM",
      "HART",
      "HASH",
      "HAST",
      "HATE",
      "HATH",
      "HAUL",
      "HAVE",
      "HAWK",
      "HAYS",
      "HEAD",
      "HEAL",
      "HEAR",
      "HEAT",
      "HEBE",
      "HECK",
      "HEED",
      "HEEL",
      "HEFT",
      "HELD",
      "HELL",
      "HELM",
      "HERB",
      "HERD",
      "HERE",
      "HERO",
      "HERS",
      "HESS",
      "HEWN",
      "HICK",
      "HIDE",
      "HIGH",
      "HIKE",
      "HILL",
      "HILT",
      "HIND",
      "HINT",
      "HIRE",
      "HISS",
      "HIVE",
      "HOBO",
      "HOCK",
      "HOFF",
      "HOLD",
      "HOLE",
      "HOLM",
      "HOLT",
      "HOME",
      "HONE",
      "HONK",
      "HOOD",
      "HOOF",
      "HOOK",
      "HOOT",
      "HORN",
      "HOSE",
      "HOST",
      "HOUR",
      "HOVE",
      "HOWE",
      "HOWL",
      "HOYT",
      "HUCK",
      "HUED",
      "HUFF",
      "HUGE",
      "HUGH",
      "HUGO",
      "HULK",
      "HULL",
      "HUNK",
      "HUNT",
      "HURD",
      "HURL",
      "HURT",
      "HUSH",
      "HYDE",
      "HYMN",
      "IBIS",
      "ICON",
      "IDEA",
      "IDLE",
      "IFFY",
      "INCA",
      "INCH",
      "INTO",
      "IONS",
      "IOTA",
      "IOWA",
      "IRIS",
      "IRMA",
      "IRON",
      "ISLE",
      "ITCH",
      "ITEM",
      "IVAN",
      "JACK",
      "JADE",
      "JAIL",
      "JAKE",
      "JANE",
      "JAVA",
      "JEAN",
      "JEFF",
      "JERK",
      "JESS",
      "JEST",
      "JIBE",
      "JILL",
      "JILT",
      "JIVE",
      "JOAN",
      "JOBS",
      "JOCK",
      "JOEL",
      "JOEY",
      "JOHN",
      "JOIN",
      "JOKE",
      "JOLT",
      "JOVE",
      "JUDD",
      "JUDE",
      "JUDO",
      "JUDY",
      "JUJU",
      "JUKE",
      "JULY",
      "JUNE",
      "JUNK",
      "JUNO",
      "JURY",
      "JUST",
      "JUTE",
      "KAHN",
      "KALE",
      "KANE",
      "KANT",
      "KARL",
      "KATE",
      "KEEL",
      "KEEN",
      "KENO",
      "KENT",
      "KERN",
      "KERR",
      "KEYS",
      "KICK",
      "KILL",
      "KIND",
      "KING",
      "KIRK",
      "KISS",
      "KITE",
      "KLAN",
      "KNEE",
      "KNEW",
      "KNIT",
      "KNOB",
      "KNOT",
      "KNOW",
      "KOCH",
      "KONG",
      "KUDO",
      "KURD",
      "KURT",
      "KYLE",
      "LACE",
      "LACK",
      "LACY",
      "LADY",
      "LAID",
      "LAIN",
      "LAIR",
      "LAKE",
      "LAMB",
      "LAME",
      "LAND",
      "LANE",
      "LANG",
      "LARD",
      "LARK",
      "LASS",
      "LAST",
      "LATE",
      "LAUD",
      "LAVA",
      "LAWN",
      "LAWS",
      "LAYS",
      "LEAD",
      "LEAF",
      "LEAK",
      "LEAN",
      "LEAR",
      "LEEK",
      "LEER",
      "LEFT",
      "LEND",
      "LENS",
      "LENT",
      "LEON",
      "LESK",
      "LESS",
      "LEST",
      "LETS",
      "LIAR",
      "LICE",
      "LICK",
      "LIED",
      "LIEN",
      "LIES",
      "LIEU",
      "LIFE",
      "LIFT",
      "LIKE",
      "LILA",
      "LILT",
      "LILY",
      "LIMA",
      "LIMB",
      "LIME",
      "LIND",
      "LINE",
      "LINK",
      "LINT",
      "LION",
      "LISA",
      "LIST",
      "LIVE",
      "LOAD",
      "LOAF",
      "LOAM",
      "LOAN",
      "LOCK",
      "LOFT",
      "LOGE",
      "LOIS",
      "LOLA",
      "LONE",
      "LONG",
      "LOOK",
      "LOON",
      "LOOT",
      "LORD",
      "LORE",
      "LOSE",
      "LOSS",
      "LOST",
      "LOUD",
      "LOVE",
      "LOWE",
      "LUCK",
      "LUCY",
      "LUGE",
      "LUKE",
      "LULU",
      "LUND",
      "LUNG",
      "LURA",
      "LURE",
      "LURK",
      "LUSH",
      "LUST",
      "LYLE",
      "LYNN",
      "LYON",
      "LYRA",
      "MACE",
      "MADE",
      "MAGI",
      "MAID",
      "MAIL",
      "MAIN",
      "MAKE",
      "MALE",
      "MALI",
      "MALL",
      "MALT",
      "MANA",
      "MANN",
      "MANY",
      "MARC",
      "MARE",
      "MARK",
      "MARS",
      "MART",
      "MARY",
      "MASH",
      "MASK",
      "MASS",
      "MAST",
      "MATE",
      "MATH",
      "MAUL",
      "MAYO",
      "MEAD",
      "MEAL",
      "MEAN",
      "MEAT",
      "MEEK",
      "MEET",
      "MELD",
      "MELT",
      "MEMO",
      "MEND",
      "MENU",
      "MERT",
      "MESH",
      "MESS",
      "MICE",
      "MIKE",
      "MILD",
      "MILE",
      "MILK",
      "MILL",
      "MILT",
      "MIMI",
      "MIND",
      "MINE",
      "MINI",
      "MINK",
      "MINT",
      "MIRE",
      "MISS",
      "MIST",
      "MITE",
      "MITT",
      "MOAN",
      "MOAT",
      "MOCK",
      "MODE",
      "MOLD",
      "MOLE",
      "MOLL",
      "MOLT",
      "MONA",
      "MONK",
      "MONT",
      "MOOD",
      "MOON",
      "MOOR",
      "MOOT",
      "MORE",
      "MORN",
      "MORT",
      "MOSS",
      "MOST",
      "MOTH",
      "MOVE",
      "MUCH",
      "MUCK",
      "MUDD",
      "MUFF",
      "MULE",
      "MULL",
      "MURK",
      "MUSH",
      "MUST",
      "MUTE",
      "MUTT",
      "MYRA",
      "MYTH",
      "NAGY",
      "NAIL",
      "NAIR",
      "NAME",
      "NARY",
      "NASH",
      "NAVE",
      "NAVY",
      "NEAL",
      "NEAR",
      "NEAT",
      "NECK",
      "NEED",
      "NEIL",
      "NELL",
      "NEON",
      "NERO",
      "NESS",
      "NEST",
      "NEWS",
      "NEWT",
      "NIBS",
      "NICE",
      "NICK",
      "NILE",
      "NINA",
      "NINE",
      "NOAH",
      "NODE",
      "NOEL",
      "NOLL",
      "NONE",
      "NOOK",
      "NOON",
      "NORM",
      "NOSE",
      "NOTE",
      "NOUN",
      "NOVA",
      "NUDE",
      "NULL",
      "NUMB",
      "OATH",
      "OBEY",
      "OBOE",
      "ODIN",
      "OHIO",
      "OILY",
      "OINT",
      "OKAY",
      "OLAF",
      "OLDY",
      "OLGA",
      "OLIN",
      "OMAN",
      "OMEN",
      "OMIT",
      "ONCE",
      "ONES",
      "ONLY",
      "ONTO",
      "ONUS",
      "ORAL",
      "ORGY",
      "OSLO",
      "OTIS",
      "OTTO",
      "OUCH",
      "OUST",
      "OUTS",
      "OVAL",
      "OVEN",
      "OVER",
      "OWLY",
      "OWNS",
      "QUAD",
      "QUIT",
      "QUOD",
      "RACE",
      "RACK",
      "RACY",
      "RAFT",
      "RAGE",
      "RAID",
      "RAIL",
      "RAIN",
      "RAKE",
      "RANK",
      "RANT",
      "RARE",
      "RASH",
      "RATE",
      "RAVE",
      "RAYS",
      "READ",
      "REAL",
      "REAM",
      "REAR",
      "RECK",
      "REED",
      "REEF",
      "REEK",
      "REEL",
      "REID",
      "REIN",
      "RENA",
      "REND",
      "RENT",
      "REST",
      "RICE",
      "RICH",
      "RICK",
      "RIDE",
      "RIFT",
      "RILL",
      "RIME",
      "RING",
      "RINK",
      "RISE",
      "RISK",
      "RITE",
      "ROAD",
      "ROAM",
      "ROAR",
      "ROBE",
      "ROCK",
      "RODE",
      "ROIL",
      "ROLL",
      "ROME",
      "ROOD",
      "ROOF",
      "ROOK",
      "ROOM",
      "ROOT",
      "ROSA",
      "ROSE",
      "ROSS",
      "ROSY",
      "ROTH",
      "ROUT",
      "ROVE",
      "ROWE",
      "ROWS",
      "RUBE",
      "RUBY",
      "RUDE",
      "RUDY",
      "RUIN",
      "RULE",
      "RUNG",
      "RUNS",
      "RUNT",
      "RUSE",
      "RUSH",
      "RUSK",
      "RUSS",
      "RUST",
      "RUTH",
      "SACK",
      "SAFE",
      "SAGE",
      "SAID",
      "SAIL",
      "SALE",
      "SALK",
      "SALT",
      "SAME",
      "SAND",
      "SANE",
      "SANG",
      "SANK",
      "SARA",
      "SAUL",
      "SAVE",
      "SAYS",
      "SCAN",
      "SCAR",
      "SCAT",
      "SCOT",
      "SEAL",
      "SEAM",
      "SEAR",
      "SEAT",
      "SEED",
      "SEEK",
      "SEEM",
      "SEEN",
      "SEES",
      "SELF",
      "SELL",
      "SEND",
      "SENT",
      "SETS",
      "SEWN",
      "SHAG",
      "SHAM",
      "SHAW",
      "SHAY",
      "SHED",
      "SHIM",
      "SHIN",
      "SHOD",
      "SHOE",
      "SHOT",
      "SHOW",
      "SHUN",
      "SHUT",
      "SICK",
      "SIDE",
      "SIFT",
      "SIGH",
      "SIGN",
      "SILK",
      "SILL",
      "SILO",
      "SILT",
      "SINE",
      "SING",
      "SINK",
      "SIRE",
      "SITE",
      "SITS",
      "SITU",
      "SKAT",
      "SKEW",
      "SKID",
      "SKIM",
      "SKIN",
      "SKIT",
      "SLAB",
      "SLAM",
      "SLAT",
      "SLAY",
      "SLED",
      "SLEW",
      "SLID",
      "SLIM",
      "SLIT",
      "SLOB",
      "SLOG",
      "SLOT",
      "SLOW",
      "SLUG",
      "SLUM",
      "SLUR",
      "SMOG",
      "SMUG",
      "SNAG",
      "SNOB",
      "SNOW",
      "SNUB",
      "SNUG",
      "SOAK",
      "SOAR",
      "SOCK",
      "SODA",
      "SOFA",
      "SOFT",
      "SOIL",
      "SOLD",
      "SOME",
      "SONG",
      "SOON",
      "SOOT",
      "SORE",
      "SORT",
      "SOUL",
      "SOUR",
      "SOWN",
      "STAB",
      "STAG",
      "STAN",
      "STAR",
      "STAY",
      "STEM",
      "STEW",
      "STIR",
      "STOW",
      "STUB",
      "STUN",
      "SUCH",
      "SUDS",
      "SUIT",
      "SULK",
      "SUMS",
      "SUNG",
      "SUNK",
      "SURE",
      "SURF",
      "SWAB",
      "SWAG",
      "SWAM",
      "SWAN",
      "SWAT",
      "SWAY",
      "SWIM",
      "SWUM",
      "TACK",
      "TACT",
      "TAIL",
      "TAKE",
      "TALE",
      "TALK",
      "TALL",
      "TANK",
      "TASK",
      "TATE",
      "TAUT",
      "TEAL",
      "TEAM",
      "TEAR",
      "TECH",
      "TEEM",
      "TEEN",
      "TEET",
      "TELL",
      "TEND",
      "TENT",
      "TERM",
      "TERN",
      "TESS",
      "TEST",
      "THAN",
      "THAT",
      "THEE",
      "THEM",
      "THEN",
      "THEY",
      "THIN",
      "THIS",
      "THUD",
      "THUG",
      "TICK",
      "TIDE",
      "TIDY",
      "TIED",
      "TIER",
      "TILE",
      "TILL",
      "TILT",
      "TIME",
      "TINA",
      "TINE",
      "TINT",
      "TINY",
      "TIRE",
      "TOAD",
      "TOGO",
      "TOIL",
      "TOLD",
      "TOLL",
      "TONE",
      "TONG",
      "TONY",
      "TOOK",
      "TOOL",
      "TOOT",
      "TORE",
      "TORN",
      "TOTE",
      "TOUR",
      "TOUT",
      "TOWN",
      "TRAG",
      "TRAM",
      "TRAY",
      "TREE",
      "TREK",
      "TRIG",
      "TRIM",
      "TRIO",
      "TROD",
      "TROT",
      "TROY",
      "TRUE",
      "TUBA",
      "TUBE",
      "TUCK",
      "TUFT",
      "TUNA",
      "TUNE",
      "TUNG",
      "TURF",
      "TURN",
      "TUSK",
      "TWIG",
      "TWIN",
      "TWIT",
      "ULAN",
      "UNIT",
      "URGE",
      "USED",
      "USER",
      "USES",
      "UTAH",
      "VAIL",
      "VAIN",
      "VALE",
      "VARY",
      "VASE",
      "VAST",
      "VEAL",
      "VEDA",
      "VEIL",
      "VEIN",
      "VEND",
      "VENT",
      "VERB",
      "VERY",
      "VETO",
      "VICE",
      "VIEW",
      "VINE",
      "VISE",
      "VOID",
      "VOLT",
      "VOTE",
      "WACK",
      "WADE",
      "WAGE",
      "WAIL",
      "WAIT",
      "WAKE",
      "WALE",
      "WALK",
      "WALL",
      "WALT",
      "WAND",
      "WANE",
      "WANG",
      "WANT",
      "WARD",
      "WARM",
      "WARN",
      "WART",
      "WASH",
      "WAST",
      "WATS",
      "WATT",
      "WAVE",
      "WAVY",
      "WAYS",
      "WEAK",
      "WEAL",
      "WEAN",
      "WEAR",
      "WEED",
      "WEEK",
      "WEIR",
      "WELD",
      "WELL",
      "WELT",
      "WENT",
      "WERE",
      "WERT",
      "WEST",
      "WHAM",
      "WHAT",
      "WHEE",
      "WHEN",
      "WHET",
      "WHOA",
      "WHOM",
      "WICK",
      "WIFE",
      "WILD",
      "WILL",
      "WIND",
      "WINE",
      "WING",
      "WINK",
      "WINO",
      "WIRE",
      "WISE",
      "WISH",
      "WITH",
      "WOLF",
      "WONT",
      "WOOD",
      "WOOL",
      "WORD",
      "WORE",
      "WORK",
      "WORM",
      "WORN",
      "WOVE",
      "WRIT",
      "WYNN",
      "YALE",
      "YANG",
      "YANK",
      "YARD",
      "YARN",
      "YAWL",
      "YAWN",
      "YEAH",
      "YEAR",
      "YELL",
      "YOGA",
      "YOKE"
    ];
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751.js
var require_rfc1751 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyToRFC1751Mnemonic = exports.rfc1751MnemonicToKey = void 0;
    var utils_1 = require_browser();
    var rfc1751Words_json_1 = __importDefault(require_rfc1751Words());
    var rfc1751WordList = rfc1751Words_json_1.default;
    var BINARY = [
      "0000",
      "0001",
      "0010",
      "0011",
      "0100",
      "0101",
      "0110",
      "0111",
      "1000",
      "1001",
      "1010",
      "1011",
      "1100",
      "1101",
      "1110",
      "1111"
    ];
    function keyToBinary(key) {
      let res = "";
      for (const num of key) {
        res += BINARY[num >> 4] + BINARY[num & 15];
      }
      return res;
    }
    function extract(key, start, length) {
      const subKey = key.substring(start, start + length);
      let acc = 0;
      for (let index = 0; index < subKey.length; index++) {
        acc = acc * 2 + subKey.charCodeAt(index) - 48;
      }
      return acc;
    }
    function keyToRFC1751Mnemonic(hex_key) {
      const buf = (0, utils_1.hexToBytes)(hex_key.replace(/\s+/gu, ""));
      let key = bufferToArray(swap128(buf));
      const padding = [];
      for (let index = 0; index < (8 - key.length % 8) % 8; index++) {
        padding.push(0);
      }
      key = padding.concat(key);
      const english = [];
      for (let index = 0; index < key.length; index += 8) {
        const subKey = key.slice(index, index + 8);
        let skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        subKey.push(parity << 6 & 255);
        skbin = keyToBinary(subKey);
        for (let j = 0; j < 64; j += 11) {
          english.push(rfc1751WordList[extract(skbin, j, 11)]);
        }
      }
      return english.join(" ");
    }
    exports.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;
    function rfc1751MnemonicToKey(english) {
      const words = english.split(" ");
      let key = [];
      for (let index = 0; index < words.length; index += 6) {
        const { subKey, word } = getSubKey(words, index);
        const skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        const cs0 = extract(skbin, 64, 2);
        const cs1 = parity & 3;
        if (cs0 !== cs1) {
          throw new Error(`Parity error at ${word}`);
        }
        key = key.concat(subKey.slice(0, 8));
      }
      const bufferKey = swap128(Uint8Array.from(key));
      return bufferKey;
    }
    exports.rfc1751MnemonicToKey = rfc1751MnemonicToKey;
    function getSubKey(words, index) {
      const sublist = words.slice(index, index + 6);
      let bits = 0;
      const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      let word = "";
      for (word of sublist) {
        const idx = rfc1751WordList.indexOf(word.toUpperCase());
        if (idx === -1) {
          throw new TypeError(`Expected an RFC1751 word, but received '${word}'. For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`);
        }
        const shift = (8 - (bits + 11) % 8) % 8;
        const y = idx << shift;
        const cl = y >> 16;
        const cc = y >> 8 & 255;
        const cr = y & 255;
        const t = Math.floor(bits / 8);
        if (shift > 5) {
          ch[t] |= cl;
          ch[t + 1] |= cc;
          ch[t + 2] |= cr;
        } else if (shift > -3) {
          ch[t] |= cc;
          ch[t + 1] |= cr;
        } else {
          ch[t] |= cr;
        }
        bits += 11;
      }
      const subKey = ch.slice();
      return { subKey, word };
    }
    function bufferToArray(buf) {
      return Array.prototype.slice.call(buf);
    }
    function swap(arr, n, m) {
      const i = arr[n];
      arr[n] = arr[m];
      arr[m] = i;
    }
    function swap64(arr) {
      const len = arr.length;
      for (let i = 0; i < len; i += 8) {
        swap(arr, i, i + 7);
        swap(arr, i + 1, i + 6);
        swap(arr, i + 2, i + 5);
        swap(arr, i + 3, i + 4);
      }
      return arr;
    }
    function swap128(arr) {
      const reversedBytes = swap64(arr);
      return (0, utils_1.concat)([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)]);
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/utils.js
var require_utils10 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDecodedTransaction = exports.addressToBigNumber = exports.NUM_BITS_IN_HEX = exports.compareSigners = void 0;
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist2();
    var ripple_binary_codec_1 = require_dist3();
    function compareSigners(left, right) {
      return addressToBigNumber(left.Account).comparedTo(addressToBigNumber(right.Account));
    }
    exports.compareSigners = compareSigners;
    exports.NUM_BITS_IN_HEX = 16;
    function addressToBigNumber(address) {
      const hex = (0, utils_1.bytesToHex)((0, ripple_address_codec_1.decodeAccountID)(address));
      return new bignumber_js_1.default(hex, exports.NUM_BITS_IN_HEX);
    }
    exports.addressToBigNumber = addressToBigNumber;
    function getDecodedTransaction(txOrBlob) {
      if (typeof txOrBlob === "object") {
        return (0, ripple_binary_codec_1.decode)((0, ripple_binary_codec_1.encode)(txOrBlob));
      }
      return (0, ripple_binary_codec_1.decode)(txOrBlob);
    }
    exports.getDecodedTransaction = getDecodedTransaction;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/signer.js
var require_signer = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multisign = exports.verifySignature = void 0;
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils10();
    function multisign(transactions) {
      if (transactions.length === 0) {
        throw new errors_1.ValidationError("There were 0 transactions to multisign");
      }
      const decodedTransactions = transactions.map((txOrBlob) => {
        return (0, utils_1.getDecodedTransaction)(txOrBlob);
      });
      decodedTransactions.forEach((tx) => {
        (0, transactions_1.validate)(tx);
        if (tx.Signers == null || tx.Signers.length === 0) {
          throw new errors_1.ValidationError("For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.");
        }
        if (tx.SigningPubKey !== "") {
          throw new errors_1.ValidationError("SigningPubKey must be an empty string for all transactions when multisigning.");
        }
      });
      validateTransactionEquivalence(decodedTransactions);
      return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));
    }
    exports.multisign = multisign;
    function verifySignature(tx, publicKey) {
      const decodedTx = (0, utils_1.getDecodedTransaction)(tx);
      let key = publicKey;
      if (typeof decodedTx.TxnSignature !== "string" || !decodedTx.TxnSignature) {
        throw new Error("Transaction is missing a signature, TxnSignature");
      }
      if (!key) {
        if (typeof decodedTx.SigningPubKey !== "string" || !decodedTx.SigningPubKey) {
          throw new Error("Transaction is missing a public key, SigningPubKey");
        }
        key = decodedTx.SigningPubKey;
      }
      return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);
    }
    exports.verifySignature = verifySignature;
    function validateTransactionEquivalence(transactions) {
      const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
      if (transactions.slice(1).some((tx) => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {
        throw new errors_1.ValidationError("txJSON is not the same for all signedTransactions");
      }
    }
    function getTransactionWithAllSigners(transactions) {
      const sortedSigners = transactions.flatMap((tx) => {
        var _a4;
        return (_a4 = tx.Signers) !== null && _a4 !== void 0 ? _a4 : [];
      }).sort((signer1, signer2) => (0, utils_1.compareSigners)(signer1.Signer, signer2.Signer));
      return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Amendments.js
var require_Amendments = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Amendments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AMENDMENTS_ID = void 0;
    exports.AMENDMENTS_ID = "7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4";
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js
var require_FeeSettings = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FEE_SETTINGS_ID = void 0;
    exports.FEE_SETTINGS_ID = "4BC50C9B0D8515D3EAAE1E74B29A95804346C491EE1A95BF25E4AAB854A6A651";
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Loan.js
var require_Loan = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Loan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoanFlags = void 0;
    var LoanFlags;
    (function(LoanFlags2) {
      LoanFlags2[LoanFlags2["lsfLoanDefault"] = 65536] = "lsfLoanDefault";
      LoanFlags2[LoanFlags2["lsfLoanImpaired"] = 131072] = "lsfLoanImpaired";
      LoanFlags2[LoanFlags2["lsfLoanOverpayment"] = 262144] = "lsfLoanOverpayment";
    })(LoanFlags || (exports.LoanFlags = LoanFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js
var require_NegativeUNL = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NEGATIVE_UNL_ID = void 0;
    exports.NEGATIVE_UNL_ID = "2E8A59AA9D3B5B186B0B9E0F62E6C02587CA74A4D778938E957B6357D364B244";
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/RippleState.js
var require_RippleState = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/RippleState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RippleStateFlags = void 0;
    var RippleStateFlags;
    (function(RippleStateFlags2) {
      RippleStateFlags2[RippleStateFlags2["lsfLowReserve"] = 65536] = "lsfLowReserve";
      RippleStateFlags2[RippleStateFlags2["lsfHighReserve"] = 131072] = "lsfHighReserve";
      RippleStateFlags2[RippleStateFlags2["lsfLowAuth"] = 262144] = "lsfLowAuth";
      RippleStateFlags2[RippleStateFlags2["lsfHighAuth"] = 524288] = "lsfHighAuth";
      RippleStateFlags2[RippleStateFlags2["lsfLowNoRipple"] = 1048576] = "lsfLowNoRipple";
      RippleStateFlags2[RippleStateFlags2["lsfHighNoRipple"] = 2097152] = "lsfHighNoRipple";
      RippleStateFlags2[RippleStateFlags2["lsfLowFreeze"] = 4194304] = "lsfLowFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfHighFreeze"] = 8388608] = "lsfHighFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfAMMNode"] = 16777216] = "lsfAMMNode";
      RippleStateFlags2[RippleStateFlags2["lsfLowDeepFreeze"] = 33554432] = "lsfLowDeepFreeze";
      RippleStateFlags2[RippleStateFlags2["lsfHighDeepFreeze"] = 67108864] = "lsfHighDeepFreeze";
    })(RippleStateFlags || (exports.RippleStateFlags = RippleStateFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/SignerList.js
var require_SignerList = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/SignerList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerListFlags = void 0;
    var SignerListFlags;
    (function(SignerListFlags2) {
      SignerListFlags2[SignerListFlags2["lsfOneOwnerCount"] = 65536] = "lsfOneOwnerCount";
    })(SignerListFlags || (exports.SignerListFlags = SignerListFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Vault.js
var require_Vault = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Vault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VaultFlags = void 0;
    var VaultFlags;
    (function(VaultFlags2) {
      VaultFlags2[VaultFlags2["lsfVaultPrivate"] = 65536] = "lsfVaultPrivate";
    })(VaultFlags || (exports.VaultFlags = VaultFlags = {}));
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/index.js
var require_ledger = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VaultFlags = exports.SignerListFlags = exports.RippleStateFlags = exports.OfferFlags = exports.NEGATIVE_UNL_ID = exports.LoanFlags = exports.FEE_SETTINGS_ID = exports.AMENDMENTS_ID = exports.AccountRootFlags = void 0;
    var AccountRoot_1 = require_AccountRoot();
    Object.defineProperty(exports, "AccountRootFlags", { enumerable: true, get: function() {
      return AccountRoot_1.AccountRootFlags;
    } });
    var Amendments_1 = require_Amendments();
    Object.defineProperty(exports, "AMENDMENTS_ID", { enumerable: true, get: function() {
      return Amendments_1.AMENDMENTS_ID;
    } });
    var FeeSettings_1 = require_FeeSettings();
    Object.defineProperty(exports, "FEE_SETTINGS_ID", { enumerable: true, get: function() {
      return FeeSettings_1.FEE_SETTINGS_ID;
    } });
    var Loan_1 = require_Loan();
    Object.defineProperty(exports, "LoanFlags", { enumerable: true, get: function() {
      return Loan_1.LoanFlags;
    } });
    var NegativeUNL_1 = require_NegativeUNL();
    Object.defineProperty(exports, "NEGATIVE_UNL_ID", { enumerable: true, get: function() {
      return NegativeUNL_1.NEGATIVE_UNL_ID;
    } });
    var Offer_1 = require_Offer();
    Object.defineProperty(exports, "OfferFlags", { enumerable: true, get: function() {
      return Offer_1.OfferFlags;
    } });
    var RippleState_1 = require_RippleState();
    Object.defineProperty(exports, "RippleStateFlags", { enumerable: true, get: function() {
      return RippleState_1.RippleStateFlags;
    } });
    var SignerList_1 = require_SignerList();
    Object.defineProperty(exports, "SignerListFlags", { enumerable: true, get: function() {
      return SignerList_1.SignerListFlags;
    } });
    var Vault_1 = require_Vault();
    Object.defineProperty(exports, "VaultFlags", { enumerable: true, get: function() {
      return Vault_1.VaultFlags;
    } });
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/methods/index.js
var require_methods = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/methods/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/index.js
var require_models = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeMPTokenMetadata = exports.decodeMPTokenMetadata = exports.validateMPTokenMetadata = exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = exports.LedgerEntry = void 0;
    exports.LedgerEntry = __importStar(require_ledger());
    var flags_1 = require_flags();
    Object.defineProperty(exports, "parseAccountRootFlags", { enumerable: true, get: function() {
      return flags_1.parseAccountRootFlags;
    } });
    Object.defineProperty(exports, "setTransactionFlagsToNumber", { enumerable: true, get: function() {
      return flags_1.setTransactionFlagsToNumber;
    } });
    Object.defineProperty(exports, "convertTxFlagsToNumber", { enumerable: true, get: function() {
      return flags_1.convertTxFlagsToNumber;
    } });
    Object.defineProperty(exports, "parseTransactionFlags", { enumerable: true, get: function() {
      return flags_1.parseTransactionFlags;
    } });
    var mptokenMetadata_1 = require_mptokenMetadata();
    Object.defineProperty(exports, "validateMPTokenMetadata", { enumerable: true, get: function() {
      return mptokenMetadata_1.validateMPTokenMetadata;
    } });
    Object.defineProperty(exports, "decodeMPTokenMetadata", { enumerable: true, get: function() {
      return mptokenMetadata_1.decodeMPTokenMetadata;
    } });
    Object.defineProperty(exports, "encodeMPTokenMetadata", { enumerable: true, get: function() {
      return mptokenMetadata_1.encodeMPTokenMetadata;
    } });
    __exportStar(require_methods(), exports);
    __exportStar(require_transactions(), exports);
    __exportStar(require_common2(), exports);
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/batchSigner.js
var require_batchSigner = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/batchSigner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineBatchSigners = exports.signMultiBatch = void 0;
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    var errors_1 = require_errors();
    var models_1 = require_models();
    var batch_1 = require_batch();
    var hashes_1 = require_hashes2();
    var utils_1 = require_utils10();
    function constructBatchSignerObject(batchAccount, wallet, signature, multisignAddress = false) {
      let batchSigner;
      if (multisignAddress) {
        batchSigner = {
          BatchSigner: {
            Account: batchAccount,
            Signers: [
              {
                Signer: {
                  Account: multisignAddress,
                  SigningPubKey: wallet.publicKey,
                  TxnSignature: signature
                }
              }
            ]
          }
        };
      } else {
        batchSigner = {
          BatchSigner: {
            Account: batchAccount,
            SigningPubKey: wallet.publicKey,
            TxnSignature: signature
          }
        };
      }
      return batchSigner;
    }
    function signMultiBatch(wallet, transaction, opts = {}) {
      var _a4;
      const batchAccount = (_a4 = opts.batchAccount) !== null && _a4 !== void 0 ? _a4 : wallet.classicAddress;
      let multisignAddress = false;
      if (typeof opts.multisign === "string") {
        multisignAddress = opts.multisign;
      } else if (opts.multisign) {
        multisignAddress = wallet.classicAddress;
      }
      if (transaction.TransactionType !== "Batch") {
        throw new errors_1.ValidationError("Must be a Batch transaction.");
      }
      (0, models_1.validate)(transaction);
      const involvedAccounts = new Set(transaction.RawTransactions.map((raw) => raw.RawTransaction.Account));
      if (!involvedAccounts.has(batchAccount)) {
        throw new errors_1.ValidationError("Must be signing for an address submitting a transaction in the Batch.");
      }
      const fieldsToSign = {
        flags: transaction.Flags,
        txIDs: transaction.RawTransactions.map((rawTx) => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))
      };
      const signature = (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigningBatch)(fieldsToSign), wallet.privateKey);
      transaction.BatchSigners = [
        constructBatchSignerObject(batchAccount, wallet, signature, multisignAddress)
      ];
    }
    exports.signMultiBatch = signMultiBatch;
    function combineBatchSigners(transactions) {
      if (transactions.length === 0) {
        throw new errors_1.ValidationError("There are 0 transactions to combine.");
      }
      const decodedTransactions = transactions.map((txOrBlob) => {
        return (0, utils_1.getDecodedTransaction)(txOrBlob);
      });
      decodedTransactions.forEach((tx) => {
        if (tx.TransactionType !== "Batch") {
          throw new errors_1.ValidationError("TransactionType must be `Batch`.");
        }
        (0, batch_1.validateBatch)(tx);
        if (tx.BatchSigners == null || tx.BatchSigners.length === 0) {
          throw new errors_1.ValidationError("For combining Batch transaction signatures, all transactions must include a BatchSigners field containing an array of signatures.");
        }
        if (tx.TxnSignature != null || tx.Signers != null) {
          throw new errors_1.ValidationError("Batch transaction must be unsigned.");
        }
      });
      const batchTransactions = decodedTransactions;
      validateBatchTransactionEquivalence(batchTransactions);
      return (0, ripple_binary_codec_1.encode)(getTransactionWithAllBatchSigners(batchTransactions));
    }
    exports.combineBatchSigners = combineBatchSigners;
    function validateBatchTransactionEquivalence(transactions) {
      const exampleTransaction = JSON.stringify({
        flags: transactions[0].Flags,
        transactionIDs: transactions[0].RawTransactions.map((rawTx) => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))
      });
      if (transactions.slice(1).some((tx) => JSON.stringify({
        flags: tx.Flags,
        transactionIDs: tx.RawTransactions.map((rawTx) => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))
      }) !== exampleTransaction)) {
        throw new errors_1.ValidationError("Flags and transaction hashes are not the same for all provided transactions.");
      }
    }
    function getTransactionWithAllBatchSigners(transactions) {
      const sortedSigners = transactions.flatMap((tx) => {
        var _a4;
        return (_a4 = tx.BatchSigners) !== null && _a4 !== void 0 ? _a4 : [];
      }).filter((signer) => signer.BatchSigner.Account !== transactions[0].Account).sort((signer1, signer2) => (0, utils_1.compareSigners)(signer1.BatchSigner, signer2.BatchSigner));
      return Object.assign(Object.assign({}, transactions[0]), { BatchSigners: sortedSigners });
    }
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/authorizeChannel.js
var require_authorizeChannel = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/authorizeChannel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizeChannel = void 0;
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    function authorizeChannel(wallet, channelId, amount) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel: channelId,
        amount
      });
      return (0, ripple_keypairs_1.sign)(signingData, wallet.privateKey);
    }
    exports.authorizeChannel = authorizeChannel;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/index.js
var require_Wallet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizeChannel = exports.verifySignature = exports.multisign = exports.combineBatchSigners = exports.signMultiBatch = exports.Wallet = void 0;
    var bip32_1 = require_lib2();
    var bip39_1 = require_bip39();
    var english_1 = require_english();
    var utils_1 = require_browser();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist2();
    var ripple_binary_codec_1 = require_dist3();
    var ripple_keypairs_1 = require_dist4();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    var common_1 = require_common3();
    var utils_2 = require_utils4();
    var utils_3 = require_utils9();
    var collections_1 = require_collections();
    var hashLedger_1 = require_hashLedger();
    var rfc1751_1 = require_rfc1751();
    var signer_1 = require_signer();
    var DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;
    var DEFAULT_DERIVATION_PATH = "m/44'/144'/0'/0/0";
    function validateKey(node) {
      if (!(node.privateKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError("Unable to derive privateKey from mnemonic input");
      }
      if (!(node.publicKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError("Unable to derive publicKey from mnemonic input");
      }
    }
    var Wallet = class _Wallet {
      constructor(publicKey, privateKey, opts = {}) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.classicAddress = opts.masterAddress ? (0, utils_3.ensureClassicAddress)(opts.masterAddress) : (0, ripple_keypairs_1.deriveAddress)(publicKey);
        this.seed = opts.seed;
      }
      get address() {
        return this.classicAddress;
      }
      static generate(algorithm = DEFAULT_ALGORITHM) {
        if (!Object.values(ECDSA_1.default).includes(algorithm)) {
          throw new errors_1.ValidationError("Invalid cryptographic signing algorithm");
        }
        const seed = (0, ripple_keypairs_1.generateSeed)({ algorithm });
        return _Wallet.fromSeed(seed, { algorithm });
      }
      static fromSeed(seed, opts = {}) {
        return _Wallet.deriveWallet(seed, {
          algorithm: opts.algorithm,
          masterAddress: opts.masterAddress
        });
      }
      static fromEntropy(entropy, opts = {}) {
        var _a4;
        const algorithm = (_a4 = opts.algorithm) !== null && _a4 !== void 0 ? _a4 : DEFAULT_ALGORITHM;
        const options = {
          entropy: Uint8Array.from(entropy),
          algorithm
        };
        const seed = (0, ripple_keypairs_1.generateSeed)(options);
        return _Wallet.deriveWallet(seed, {
          algorithm,
          masterAddress: opts.masterAddress
        });
      }
      static fromMnemonic(mnemonic, opts = {}) {
        var _a4;
        if (opts.mnemonicEncoding === "rfc1751") {
          return _Wallet.fromRFC1751Mnemonic(mnemonic, {
            masterAddress: opts.masterAddress,
            algorithm: opts.algorithm
          });
        }
        if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
          throw new errors_1.ValidationError("Unable to parse the given mnemonic using bip39 encoding");
        }
        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
        const masterNode = bip32_1.HDKey.fromMasterSeed(seed);
        const node = masterNode.derive((_a4 = opts.derivationPath) !== null && _a4 !== void 0 ? _a4 : DEFAULT_DERIVATION_PATH);
        validateKey(node);
        const publicKey = (0, utils_1.bytesToHex)(node.publicKey);
        const privateKey = (0, utils_1.bytesToHex)(node.privateKey);
        return new _Wallet(publicKey, `00${privateKey}`, {
          masterAddress: opts.masterAddress
        });
      }
      static fromRFC1751Mnemonic(mnemonic, opts) {
        const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);
        let encodeAlgorithm;
        if (opts.algorithm === ECDSA_1.default.ed25519) {
          encodeAlgorithm = "ed25519";
        } else {
          encodeAlgorithm = "secp256k1";
        }
        const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(seed, encodeAlgorithm);
        return _Wallet.fromSeed(encodedSeed, {
          masterAddress: opts.masterAddress,
          algorithm: opts.algorithm
        });
      }
      static deriveWallet(seed, opts = {}) {
        var _a4;
        const { publicKey, privateKey } = (0, ripple_keypairs_1.deriveKeypair)(seed, {
          algorithm: (_a4 = opts.algorithm) !== null && _a4 !== void 0 ? _a4 : DEFAULT_ALGORITHM
        });
        return new _Wallet(publicKey, privateKey, {
          seed,
          masterAddress: opts.masterAddress
        });
      }
      sign(transaction, multisign) {
        let multisignAddress = false;
        if (typeof multisign === "string") {
          multisignAddress = multisign;
        } else if (multisign) {
          multisignAddress = this.classicAddress;
        }
        const tx = (0, collections_1.omitBy)(Object.assign({}, transaction), (value) => value == null);
        if (tx.TxnSignature || tx.Signers) {
          throw new errors_1.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
        }
        removeTrailingZeros(tx);
        (0, transactions_1.validate)(tx);
        if ((0, utils_2.hasFlag)(tx, common_1.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) {
          throw new errors_1.ValidationError("Cannot sign a Batch inner transaction.");
        }
        const txToSignAndEncode = Object.assign({}, tx);
        if (multisignAddress) {
          txToSignAndEncode.SigningPubKey = "";
          const signer = {
            Account: multisignAddress,
            SigningPubKey: this.publicKey,
            TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress)
          };
          txToSignAndEncode.Signers = [{ Signer: signer }];
        } else {
          txToSignAndEncode.SigningPubKey = this.publicKey;
          txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);
        }
        const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);
        return {
          tx_blob: serialized,
          hash: (0, hashLedger_1.hashSignedTx)(serialized)
        };
      }
      verifyTransaction(signedTransaction) {
        return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);
      }
      getXAddress(tag = false, isTestnet = false) {
        return (0, ripple_address_codec_1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);
      }
    };
    exports.Wallet = Wallet;
    Wallet.fromSecret = Wallet.fromSeed;
    function computeSignature(tx, privateKey, signAs) {
      if (signAs) {
        const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(signAs) ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs).classicAddress : signAs;
        return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress), privateKey);
      }
      return (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigning)(tx), privateKey);
    }
    function removeTrailingZeros(tx) {
      if (tx.TransactionType === "Payment" && typeof tx.Amount !== "string" && tx.Amount.value.includes(".") && tx.Amount.value.endsWith("0")) {
        tx.Amount = Object.assign({}, tx.Amount);
        tx.Amount.value = new bignumber_js_1.default(tx.Amount.value).toString();
      }
    }
    var batchSigner_1 = require_batchSigner();
    Object.defineProperty(exports, "signMultiBatch", { enumerable: true, get: function() {
      return batchSigner_1.signMultiBatch;
    } });
    Object.defineProperty(exports, "combineBatchSigners", { enumerable: true, get: function() {
      return batchSigner_1.combineBatchSigners;
    } });
    var signer_2 = require_signer();
    Object.defineProperty(exports, "multisign", { enumerable: true, get: function() {
      return signer_2.multisign;
    } });
    Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function() {
      return signer_2.verifySignature;
    } });
    var authorizeChannel_1 = require_authorizeChannel();
    Object.defineProperty(exports, "authorizeChannel", { enumerable: true, get: function() {
      return authorizeChannel_1.authorizeChannel;
    } });
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js
var require_defaultFaucets = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFaucetPath = exports.getFaucetHost = exports.faucetNetworkIDs = exports.faucetNetworkPaths = exports.FaucetNetwork = void 0;
    var errors_1 = require_errors();
    var FaucetNetwork;
    (function(FaucetNetwork2) {
      FaucetNetwork2["Testnet"] = "faucet.altnet.rippletest.net";
      FaucetNetwork2["Devnet"] = "faucet.devnet.rippletest.net";
    })(FaucetNetwork || (exports.FaucetNetwork = FaucetNetwork = {}));
    exports.faucetNetworkPaths = {
      [FaucetNetwork.Testnet]: "/accounts",
      [FaucetNetwork.Devnet]: "/accounts"
    };
    exports.faucetNetworkIDs = /* @__PURE__ */ new Map([
      [1, FaucetNetwork.Testnet],
      [2, FaucetNetwork.Devnet]
    ]);
    function getFaucetHost(client) {
      if (client.networkID == null) {
        throw new errors_1.XRPLFaucetError("Cannot create faucet URL without networkID or the faucetHost information");
      }
      if (exports.faucetNetworkIDs.has(client.networkID)) {
        return exports.faucetNetworkIDs.get(client.networkID);
      }
      if (client.networkID === 0) {
        throw new errors_1.XRPLFaucetError("Faucet is not available for mainnet.");
      }
      throw new errors_1.XRPLFaucetError("Faucet URL is not defined or inferrable.");
    }
    exports.getFaucetHost = getFaucetHost;
    function getFaucetPath(hostname) {
      if (hostname === void 0) {
        return "/accounts";
      }
      return exports.faucetNetworkPaths[hostname] || "/accounts";
    }
    exports.getFaucetPath = getFaucetPath;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/fundWallet.js
var require_fundWallet = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/fundWallet.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;
    var ripple_address_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var defaultFaucets_1 = require_defaultFaucets();
    var _1 = require_Wallet();
    var INTERVAL_SECONDS = 1;
    var MAX_ATTEMPTS = 20;
    function generateWalletToFund(wallet) {
      if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {
        return wallet;
      }
      return _1.Wallet.generate();
    }
    exports.generateWalletToFund = generateWalletToFund;
    function getStartingBalance(client, classicAddress) {
      return __awaiter(this, void 0, void 0, function* () {
        let startingBalance = 0;
        try {
          startingBalance = Number(yield client.getXrpBalance(classicAddress));
        } catch (_a4) {
        }
        return startingBalance;
      });
    }
    exports.getStartingBalance = getStartingBalance;
    function requestFunding(options, client, startingBalance, walletToFund, postBody) {
      var _a4, _b, _c;
      return __awaiter(this, void 0, void 0, function* () {
        const hostname = (_a4 = options.faucetHost) !== null && _a4 !== void 0 ? _a4 : (0, defaultFaucets_1.getFaucetHost)(client);
        if (!hostname) {
          throw new errors_1.XRPLFaucetError("No faucet hostname could be derived");
        }
        const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getFaucetPath)(hostname);
        const response = yield fetch(`https://${hostname}${pathname}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(postBody)
        });
        if (response.ok && ((_c = response.headers.get("Content-Type")) === null || _c === void 0 ? void 0 : _c.startsWith("application/json"))) {
          const body = yield response.json();
          const classicAddress = body.account.classicAddress;
          return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);
        }
        return processError(response);
      });
    }
    exports.requestFunding = requestFunding;
    function processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!classicAddress) {
          return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));
        }
        const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);
        if (updatedBalance > startingBalance) {
          return {
            wallet: walletToFund,
            balance: updatedBalance
          };
        }
        throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);
      });
    }
    function processError(response) {
      var _a4;
      return __awaiter(this, void 0, void 0, function* () {
        const errorData = {
          contentType: (_a4 = response.headers.get("Content-Type")) !== null && _a4 !== void 0 ? _a4 : void 0,
          statusCode: response.status
        };
        const clone2 = response.clone();
        try {
          const body = yield response.json();
          errorData.body = body;
        } catch (_b) {
          errorData.body = yield clone2.text();
        }
        return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify(errorData)}`));
      });
    }
    function getUpdatedBalance(client, address, originalBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          let attempts = MAX_ATTEMPTS;
          const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            if (attempts < 0) {
              clearInterval(interval);
              resolve(originalBalance);
            } else {
              attempts -= 1;
            }
            try {
              let newBalance;
              try {
                newBalance = Number(yield client.getXrpBalance(address));
              } catch (_a4) {
              }
              if (newBalance > originalBalance) {
                clearInterval(interval);
                resolve(newBalance);
              }
            } catch (err) {
              clearInterval(interval);
              if (err instanceof Error) {
                reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));
              }
              reject(err);
            }
          }), INTERVAL_SECONDS * 1e3);
        });
      });
    }
  }
});

// node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ws/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventemitter3_1 = require_eventemitter3();
    var WSWrapper = class extends eventemitter3_1.EventEmitter {
      /**
       * Constructs a browser-safe websocket.
       *
       * @param url - URL to connect to.
       * @param _protocols - Not used.
       * @param _websocketOptions - Not used.
       */
      constructor(url, _protocols, _websocketOptions) {
        super();
        this.ws = new WebSocket(url);
        this.ws.onclose = (closeEvent) => {
          let reason;
          if (closeEvent.reason) {
            const enc = new TextEncoder();
            reason = enc.encode(closeEvent.reason);
          }
          this.emit("close", closeEvent.code, reason);
        };
        this.ws.onopen = () => {
          this.emit("open");
        };
        this.ws.onerror = (error) => {
          this.emit("error", error);
        };
        this.ws.onmessage = (message) => {
          this.emit("message", message.data);
        };
      }
      /**
       * Get the ready state of the websocket.
       *
       * @returns The Websocket's ready state.
       */
      get readyState() {
        return this.ws.readyState;
      }
      /**
       * Closes the websocket.
       *
       * @param code - Close code.
       * @param reason - Close reason.
       */
      close(code, reason) {
        if (this.readyState === 1) {
          this.ws.close(code, reason);
        }
      }
      /**
       * Sends a message over the Websocket connection.
       *
       * @param message - Message to send.
       */
      send(message) {
        this.ws.send(message);
      }
    };
    WSWrapper.CONNECTING = 0;
    WSWrapper.OPEN = 1;
    WSWrapper.CLOSING = 2;
    WSWrapper.CLOSED = 3;
    exports.default = WSWrapper;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ConnectionManager.js
var require_ConnectionManager = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ConnectionManager.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConnectionManager = class {
      constructor() {
        this.promisesAwaitingConnection = [];
      }
      resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve }) => resolve());
        this.promisesAwaitingConnection = [];
      }
      rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
      }
      awaitConnection() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingConnection.push({ resolve, reject });
          });
        });
      }
    };
    exports.default = ConnectionManager;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ExponentialBackoff.js
var require_ExponentialBackoff = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ExponentialBackoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_MIN = 100;
    var DEFAULT_MAX = 1e3;
    var ExponentialBackoff = class {
      constructor(opts = {}) {
        var _a4, _b;
        this.factor = 2;
        this.numAttempts = 0;
        this.ms = (_a4 = opts.min) !== null && _a4 !== void 0 ? _a4 : DEFAULT_MIN;
        this.max = (_b = opts.max) !== null && _b !== void 0 ? _b : DEFAULT_MAX;
      }
      get attempts() {
        return this.numAttempts;
      }
      duration() {
        const ms = this.ms * Math.pow(this.factor, this.numAttempts);
        this.numAttempts += 1;
        return Math.floor(Math.min(ms, this.max));
      }
      reset() {
        this.numAttempts = 0;
      }
    };
    exports.default = ExponentialBackoff;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/RequestManager.js
var require_RequestManager = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/RequestManager.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors();
    var RequestManager = class {
      constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = /* @__PURE__ */ new Map();
      }
      addPromise(newId, timer) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingResponse.set(newId, {
              resolve,
              reject,
              timer
            });
          });
        });
      }
      resolve(id, response) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "resolve",
            response
          });
        }
        clearTimeout(promise.timer);
        promise.resolve(response);
        this.deletePromise(id);
      }
      reject(id, error) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "reject",
            error
          });
        }
        clearTimeout(promise.timer);
        promise.reject(error);
        this.deletePromise(id);
      }
      rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_promise, id, _map) => {
          this.reject(id, error);
          this.deletePromise(id);
        });
      }
      createRequest(request, timeout) {
        let newId;
        if (request.id == null) {
          newId = this.nextId;
          this.nextId += 1;
        } else {
          newId = request.id;
        }
        const newRequest = JSON.stringify(Object.assign(Object.assign({}, request), { id: newId }));
        const timer = setTimeout(() => {
          this.reject(newId, new errors_1.TimeoutError(`Timeout for request: ${JSON.stringify(request)} with id ${newId}`, request));
        }, timeout);
        if (timer.unref) {
          ;
          timer.unref();
        }
        if (this.promisesAwaitingResponse.has(newId)) {
          clearTimeout(timer);
          throw new errors_1.XrplError(`Response with id '${newId}' is already pending`, request);
        }
        const newPromise = new Promise((resolve, reject) => {
          this.promisesAwaitingResponse.set(newId, {
            resolve,
            reject,
            timer
          });
        });
        return [newId, newRequest, newPromise];
      }
      handleResponse(response) {
        var _a4, _b, _c;
        if (response.id == null || !(typeof response.id === "string" || typeof response.id === "number")) {
          throw new errors_1.ResponseFormatError("valid id not found in response", response);
        }
        if (!this.promisesAwaitingResponse.has(response.id)) {
          return;
        }
        if (response.status == null) {
          const error = new errors_1.ResponseFormatError("Response has no status");
          this.reject(response.id, error);
        }
        if (response.status === "error") {
          const errorResponse = response;
          const error = new errors_1.RippledError((_b = (_a4 = errorResponse.error_message) !== null && _a4 !== void 0 ? _a4 : errorResponse.error_exception) !== null && _b !== void 0 ? _b : errorResponse.error, errorResponse);
          this.reject(response.id, error);
          return;
        }
        if (response.status !== "success") {
          const error = new errors_1.ResponseFormatError(`unrecognized response.status: ${(_c = response.status) !== null && _c !== void 0 ? _c : ""}`, response);
          this.reject(response.id, error);
          return;
        }
        delete response.status;
        this.resolve(response.id, response);
      }
      deletePromise(id) {
        this.promisesAwaitingResponse.delete(id);
      }
    };
    exports.default = RequestManager;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/connection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = exports.INTENTIONAL_DISCONNECT_CODE = void 0;
    var utils_1 = require_browser();
    var ws_1 = __importDefault(require_browser5());
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var ConnectionManager_1 = __importDefault(require_ConnectionManager());
    var ExponentialBackoff_1 = __importDefault(require_ExponentialBackoff());
    var RequestManager_1 = __importDefault(require_RequestManager());
    var SECONDS_PER_MINUTE = 60;
    var TIMEOUT = 20;
    var CONNECTION_TIMEOUT = 5;
    exports.INTENTIONAL_DISCONNECT_CODE = 4e3;
    function createWebSocket(url, config2) {
      const options = {
        agent: config2.agent
      };
      if (config2.headers) {
        options.headers = config2.headers;
      }
      if (config2.authorization != null) {
        options.headers = Object.assign(Object.assign({}, options.headers), { Authorization: `Basic ${btoa(config2.authorization)}` });
      }
      const websocketOptions = Object.assign({}, options);
      return new ws_1.default(url, websocketOptions);
    }
    function websocketSendAsync(ws, message) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          ws.send(message, (error) => {
            if (error) {
              reject(new errors_1.DisconnectedError(error.message, error));
            } else {
              resolve();
            }
          });
        });
      });
    }
    var Connection = class extends eventemitter3_1.EventEmitter {
      constructor(url, options = {}) {
        super();
        this.ws = null;
        this.reconnectTimeoutID = null;
        this.heartbeatIntervalID = null;
        this.retryConnectionBackoff = new ExponentialBackoff_1.default({
          min: 100,
          max: SECONDS_PER_MINUTE * 1e3
        });
        this.requestManager = new RequestManager_1.default();
        this.connectionManager = new ConnectionManager_1.default();
        this.trace = () => {
        };
        this.url = url;
        this.config = Object.assign({ timeout: TIMEOUT * 1e3, connectionTimeout: CONNECTION_TIMEOUT * 1e3 }, options);
        if (typeof options.trace === "function") {
          this.trace = options.trace;
        } else if (options.trace) {
          this.trace = console.log;
        }
      }
      get state() {
        return this.ws ? this.ws.readyState : ws_1.default.CLOSED;
      }
      get shouldBeConnected() {
        return this.ws !== null;
      }
      isConnected() {
        return this.state === ws_1.default.OPEN;
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.isConnected()) {
            return Promise.resolve();
          }
          if (this.state === ws_1.default.CONNECTING) {
            return this.connectionManager.awaitConnection();
          }
          if (!this.url) {
            return Promise.reject(new errors_1.ConnectionError("Cannot connect because no server was specified"));
          }
          if (this.ws != null) {
            return Promise.reject(new errors_1.XrplError("Websocket connection never cleaned up.", {
              state: this.state
            }));
          }
          const connectionTimeoutID = setTimeout(() => {
            this.onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`));
          }, this.config.connectionTimeout);
          this.ws = createWebSocket(this.url, this.config);
          if (this.ws == null) {
            throw new errors_1.XrplError("Connect: created null websocket");
          }
          this.ws.on("error", (error) => this.onConnectionFailed(error));
          this.ws.on("error", () => clearTimeout(connectionTimeoutID));
          this.ws.on("close", (reason) => this.onConnectionFailed(reason));
          this.ws.on("close", () => clearTimeout(connectionTimeoutID));
          this.ws.once("open", () => {
            void this.onceOpen(connectionTimeoutID);
          });
          return this.connectionManager.awaitConnection();
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.clearHeartbeatInterval();
          if (this.reconnectTimeoutID !== null) {
            clearTimeout(this.reconnectTimeoutID);
            this.reconnectTimeoutID = null;
          }
          if (this.state === ws_1.default.CLOSED) {
            return Promise.resolve(void 0);
          }
          if (this.ws == null) {
            return Promise.resolve(void 0);
          }
          return new Promise((resolve) => {
            if (this.ws == null) {
              resolve(void 0);
            }
            if (this.ws != null) {
              this.ws.once("close", (code) => resolve(code));
            }
            if (this.ws != null && this.state !== ws_1.default.CLOSING) {
              this.ws.close(exports.INTENTIONAL_DISCONNECT_CODE);
            }
          });
        });
      }
      reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.emit("reconnect");
          yield this.disconnect();
          yield this.connect();
        });
      }
      request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.shouldBeConnected || this.ws == null) {
            throw new errors_1.NotConnectedError(JSON.stringify(request), request);
          }
          const [id, message, responsePromise] = this.requestManager.createRequest(request, timeout !== null && timeout !== void 0 ? timeout : this.config.timeout);
          this.trace("send", message);
          websocketSendAsync(this.ws, message).catch((error) => {
            try {
              this.requestManager.reject(id, error);
            } catch (err) {
              if (err instanceof errors_1.XrplError) {
                this.trace("send", `send errored after connection was closed: ${err.toString()}`);
              } else {
                this.trace("send", String(err));
              }
            }
          });
          return responsePromise;
        });
      }
      getUrl() {
        var _a4;
        return (_a4 = this.url) !== null && _a4 !== void 0 ? _a4 : "";
      }
      onMessage(message) {
        this.trace("receive", message);
        let data;
        try {
          data = JSON.parse(message);
        } catch (error) {
          if (error instanceof Error) {
            this.emit("error", "badMessage", error.message, message);
          }
          return;
        }
        if (data.type == null && data.error) {
          this.emit("error", data.error, data.error_message, data);
          return;
        }
        if (data.type) {
          this.emit(data.type, data);
        }
        if (data.type === "response") {
          try {
            this.requestManager.handleResponse(data);
          } catch (error) {
            if (error instanceof Error) {
              this.emit("error", "badMessage", error.message, message);
            } else {
              this.emit("error", "badMessage", error, error);
            }
          }
        }
      }
      onceOpen(connectionTimeoutID) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.ws == null) {
            throw new errors_1.XrplError("onceOpen: ws is null");
          }
          this.ws.removeAllListeners();
          clearTimeout(connectionTimeoutID);
          this.ws.on("message", (message) => this.onMessage(message));
          this.ws.on("error", (error) => this.emit("error", "websocket", error.message, error));
          this.ws.once("close", (code, reason) => {
            if (this.ws == null) {
              throw new errors_1.XrplError("onceClose: ws is null");
            }
            this.clearHeartbeatInterval();
            this.requestManager.rejectAll(new errors_1.DisconnectedError(`websocket was closed, ${reason ? (0, utils_1.hexToString)((0, utils_1.bytesToHex)(reason)) : ""}`));
            this.ws.removeAllListeners();
            this.ws = null;
            if (code === void 0) {
              const internalErrorCode = 1011;
              this.emit("disconnected", internalErrorCode);
            } else {
              this.emit("disconnected", code);
            }
            if (code !== exports.INTENTIONAL_DISCONNECT_CODE && code !== void 0) {
              this.intentionalDisconnect();
            }
          });
          try {
            this.retryConnectionBackoff.reset();
            this.startHeartbeatInterval();
            this.connectionManager.resolveAllAwaiting();
            this.emit("connected");
          } catch (error) {
            if (error instanceof Error) {
              this.connectionManager.rejectAllAwaiting(error);
              yield this.disconnect().catch(() => {
              });
            }
          }
        });
      }
      intentionalDisconnect() {
        const retryTimeout = this.retryConnectionBackoff.duration();
        this.trace("reconnect", `Retrying connection in ${retryTimeout}ms.`);
        this.emit("reconnecting", this.retryConnectionBackoff.attempts);
        this.reconnectTimeoutID = setTimeout(() => {
          this.reconnect().catch((error) => {
            this.emit("error", "reconnect", error.message, error);
          });
        }, retryTimeout);
      }
      clearHeartbeatInterval() {
        if (this.heartbeatIntervalID) {
          clearInterval(this.heartbeatIntervalID);
        }
      }
      startHeartbeatInterval() {
        this.clearHeartbeatInterval();
        this.heartbeatIntervalID = setInterval(() => {
          void this.heartbeat();
        }, this.config.timeout);
      }
      heartbeat() {
        return __awaiter(this, void 0, void 0, function* () {
          this.request({ command: "ping" }).catch(() => __awaiter(this, void 0, void 0, function* () {
            return this.reconnect().catch((error) => {
              this.emit("error", "reconnect", error.message, error);
            });
          }));
        });
      }
      onConnectionFailed(errorOrCode) {
        if (this.ws) {
          this.ws.removeAllListeners();
          this.ws.on("error", () => {
          });
          this.ws.close();
          this.ws = null;
        }
        if (typeof errorOrCode === "number") {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {
            code: errorOrCode
          }));
        } else if (errorOrCode === null || errorOrCode === void 0 ? void 0 : errorOrCode.message) {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));
        } else {
          this.connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError("Connection failed."));
        }
      }
    };
    exports.Connection = Connection;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/partialPayment.js
var require_partialPayment = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/partialPayment.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleStreamPartialPayment = exports.handlePartialPayment = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist3();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils4();
    var WARN_PARTIAL_PAYMENT_CODE = 2001;
    function amountsEqual(amt1, amt2) {
      if (typeof amt1 === "string" && typeof amt2 === "string") {
        return amt1 === amt2;
      }
      if (typeof amt1 === "string" || typeof amt2 === "string") {
        return false;
      }
      if ((0, transactions_1.isMPTAmount)(amt1) && (0, transactions_1.isMPTAmount)(amt2)) {
        const aValue2 = new bignumber_js_1.default(amt1.value);
        const bValue2 = new bignumber_js_1.default(amt2.value);
        return amt1.mpt_issuance_id === amt2.mpt_issuance_id && aValue2.isEqualTo(bValue2);
      }
      if ((0, transactions_1.isMPTAmount)(amt1) || (0, transactions_1.isMPTAmount)(amt2)) {
        return false;
      }
      const aValue = new bignumber_js_1.default(amt1.value);
      const bValue = new bignumber_js_1.default(amt2.value);
      return amt1.currency === amt2.currency && amt1.issuer === amt2.issuer && aValue.isEqualTo(bValue);
    }
    function isPartialPayment(tx, metadata) {
      var _a4, _b;
      if (tx == null || metadata == null || tx.TransactionType !== "Payment") {
        return false;
      }
      let meta2 = metadata;
      if (typeof meta2 === "string") {
        if (meta2 === "unavailable") {
          return false;
        }
        meta2 = (0, ripple_binary_codec_1.decode)(meta2);
      }
      const tfPartial = typeof tx.Flags === "number" ? (0, utils_1.isFlagEnabled)(tx.Flags, transactions_1.PaymentFlags.tfPartialPayment) : (_a4 = tx.Flags) === null || _a4 === void 0 ? void 0 : _a4.tfPartialPayment;
      if (!tfPartial) {
        return false;
      }
      const delivered = meta2.delivered_amount;
      const amount = (_b = tx.DeliverMax) !== null && _b !== void 0 ? _b : tx.Amount;
      if (delivered === void 0) {
        return false;
      }
      return !amountsEqual(delivered, amount);
    }
    function txHasPartialPayment(response) {
      return isPartialPayment(response.result.tx_json, response.result.meta);
    }
    function txEntryHasPartialPayment(response) {
      return isPartialPayment(response.result.tx_json, response.result.metadata);
    }
    function accountTxHasPartialPayment(response) {
      const { transactions } = response.result;
      const foo = transactions.some((tx) => {
        if (tx.tx_json != null) {
          const transaction2 = tx;
          return isPartialPayment(transaction2.tx_json, transaction2.meta);
        }
        const transaction = tx;
        return isPartialPayment(transaction.tx, transaction.meta);
      });
      return foo;
    }
    function hasPartialPayment(command, response) {
      switch (command) {
        case "tx":
          return txHasPartialPayment(response);
        case "transaction_entry":
          return txEntryHasPartialPayment(response);
        case "account_tx":
          return accountTxHasPartialPayment(response);
        default:
          return false;
      }
    }
    function handlePartialPayment(command, response) {
      var _a4;
      if (hasPartialPayment(command, response)) {
        const warnings = (_a4 = response.warnings) !== null && _a4 !== void 0 ? _a4 : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment"
        };
        warnings.push(warning);
        response.warnings = warnings;
      }
    }
    exports.handlePartialPayment = handlePartialPayment;
    function handleStreamPartialPayment(stream, log) {
      var _a4, _b;
      if (isPartialPayment((_a4 = stream.tx_json) !== null && _a4 !== void 0 ? _a4 : stream.transaction, stream.meta)) {
        const warnings = (_b = stream.warnings) !== null && _b !== void 0 ? _b : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment"
        };
        warnings.push(warning);
        stream.warnings = warnings;
        log("Partial payment received", JSON.stringify(stream));
      }
    }
    exports.handleStreamPartialPayment = handleStreamPartialPayment;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/index.js
var require_client2 = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = void 0;
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var common_1 = require_common2();
    var flags_1 = require_flags();
    var sugar_1 = require_sugar();
    var autofill_1 = require_autofill();
    var balances_1 = require_balances();
    var getOrderbook_1 = require_getOrderbook();
    var utils_1 = require_utils8();
    var Wallet_1 = require_Wallet();
    var fundWallet_1 = require_fundWallet();
    var connection_1 = require_connection();
    var partialPayment_1 = require_partialPayment();
    function getCollectKeyFromCommand(command) {
      switch (command) {
        case "account_channels":
          return "channels";
        case "account_lines":
          return "lines";
        case "account_objects":
          return "account_objects";
        case "account_tx":
          return "transactions";
        case "account_offers":
        case "book_offers":
          return "offers";
        case "ledger_data":
          return "state";
        default:
          return null;
      }
    }
    function clamp(value, min, max) {
      if (min > max) {
        throw new Error("Illegal clamp bounds");
      }
      return Math.min(Math.max(value, min), max);
    }
    var DEFAULT_FEE_CUSHION = 1.2;
    var DEFAULT_MAX_FEE_XRP = "2";
    var MIN_LIMIT = 10;
    var MAX_LIMIT = 400;
    var NORMAL_DISCONNECT_CODE = 1e3;
    var Client = class extends eventemitter3_1.EventEmitter {
      constructor(server, options = {}) {
        var _a4, _b;
        super();
        this.apiVersion = common_1.DEFAULT_API_VERSION;
        if (typeof server !== "string" || !/wss?(?:\+unix)?:\/\//u.exec(server)) {
          throw new errors_1.ValidationError("server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.");
        }
        this.feeCushion = (_a4 = options.feeCushion) !== null && _a4 !== void 0 ? _a4 : DEFAULT_FEE_CUSHION;
        this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;
        this.connection = new connection_1.Connection(server, options);
        this.connection.on("error", (errorCode, errorMessage, data) => {
          this.emit("error", errorCode, errorMessage, data);
        });
        this.connection.on("reconnect", () => {
          this.connection.on("connected", () => this.emit("connected"));
        });
        this.connection.on("disconnected", (code) => {
          let finalCode = code;
          if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {
            finalCode = NORMAL_DISCONNECT_CODE;
          }
          this.emit("disconnected", finalCode);
        });
        this.connection.on("ledgerClosed", (ledger) => {
          this.emit("ledgerClosed", ledger);
        });
        this.connection.on("transaction", (tx) => {
          (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);
          this.emit("transaction", tx);
        });
        this.connection.on("validationReceived", (validation) => {
          this.emit("validationReceived", validation);
        });
        this.connection.on("manifestReceived", (manifest) => {
          this.emit("manifestReceived", manifest);
        });
        this.connection.on("peerStatusChange", (status) => {
          this.emit("peerStatusChange", status);
        });
        this.connection.on("consensusPhase", (consensus) => {
          this.emit("consensusPhase", consensus);
        });
        this.connection.on("path_find", (path) => {
          this.emit("path_find", path);
        });
      }
      get url() {
        return this.connection.getUrl();
      }
      request(req) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const request = Object.assign(Object.assign({}, req), { account: typeof req.account === "string" ? (0, sugar_1.ensureClassicAddress)(req.account) : void 0, api_version: (_a4 = req.api_version) !== null && _a4 !== void 0 ? _a4 : this.apiVersion });
          const response = yield this.connection.request(request);
          (0, partialPayment_1.handlePartialPayment)(req.command, response);
          return response;
        });
      }
      requestNextPage(req, resp) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!resp.result.marker) {
            return Promise.reject(new errors_1.NotFoundError("response does not have a next page"));
          }
          const nextPageRequest = Object.assign(Object.assign({}, req), { marker: resp.result.marker });
          return this.request(nextPageRequest);
        });
      }
      on(eventName, listener) {
        return super.on(eventName, listener);
      }
      requestAll(request, collect) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);
          if (!collectKey) {
            throw new errors_1.ValidationError(`no collect key for command ${request.command}`);
          }
          const countTo = (_a4 = request.limit) !== null && _a4 !== void 0 ? _a4 : Infinity;
          let count = 0;
          let marker = request.marker;
          const results = [];
          do {
            const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);
            const repeatProps = Object.assign(Object.assign({}, request), { limit: countRemaining, marker });
            const singleResponse = yield this.connection.request(repeatProps);
            const singleResult = singleResponse.result;
            if (!(collectKey in singleResult)) {
              throw new errors_1.XrplError(`${collectKey} not in result`);
            }
            const collectedData = singleResult[collectKey];
            marker = singleResult.marker;
            results.push(singleResponse);
            if (Array.isArray(collectedData)) {
              count += collectedData.length;
            }
          } while (Boolean(marker) && count < countTo);
          return results;
        });
      }
      getServerInfo() {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const response = yield this.request({
              command: "server_info"
            });
            this.networkID = (_a4 = response.result.info.network_id) !== null && _a4 !== void 0 ? _a4 : void 0;
            this.buildVersion = response.result.info.build_version;
          } catch (error) {
            console.error(error);
          }
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {
            yield this.getServerInfo();
            this.emit("connected");
          }));
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.connection.disconnect();
        });
      }
      isConnected() {
        return this.connection.isConnected();
      }
      autofill(transaction, signersCount) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const tx = Object.assign({}, transaction);
          (0, autofill_1.setValidAddresses)(tx);
          tx.Flags = (0, flags_1.convertTxFlagsToNumber)(tx);
          const promises = [];
          (_a4 = tx.NetworkID) !== null && _a4 !== void 0 ? _a4 : tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : void 0;
          if (tx.Sequence == null) {
            promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));
          }
          if (tx.Fee == null) {
            promises.push((0, autofill_1.getTransactionFee)(this, tx, signersCount));
          }
          if (tx.LastLedgerSequence == null) {
            promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));
          }
          if (tx.TransactionType === "AccountDelete") {
            promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));
          }
          if (tx.TransactionType === "Batch") {
            promises.push((0, autofill_1.autofillBatchTxn)(this, tx));
          }
          if (tx.TransactionType === "Payment" && tx.DeliverMax != null) {
            (0, autofill_1.handleDeliverMax)(tx);
          }
          return Promise.all(promises).then(() => tx);
        });
      }
      simulate(transaction, opts) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const binary = (_a4 = opts === null || opts === void 0 ? void 0 : opts.binary) !== null && _a4 !== void 0 ? _a4 : false;
          const request = typeof transaction === "string" ? { command: "simulate", tx_blob: transaction, binary } : { command: "simulate", tx_json: transaction, binary };
          return this.request(request);
        });
      }
      submit(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
          return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
        });
      }
      submitAndWait(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
          const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);
          if (lastLedger == null) {
            throw new errors_1.ValidationError("Transaction must contain a LastLedgerSequence value for reliable submission.");
          }
          const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
          if (response.result.engine_result.startsWith("tem")) {
            throw new errors_1.XrplError(`Transaction failed, ${response.result.engine_result}: ${response.result.engine_result_message}`);
          }
          const txHash = utils_1.hashes.hashSignedTx(signedTx);
          return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);
        });
      }
      prepareTransaction(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.autofill(transaction, signersCount);
        });
      }
      getXrpBalance(address, options = {}) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const xrpRequest = {
            command: "account_info",
            account: address,
            ledger_index: (_a4 = options.ledger_index) !== null && _a4 !== void 0 ? _a4 : "validated",
            ledger_hash: options.ledger_hash
          };
          const response = yield this.request(xrpRequest);
          return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);
        });
      }
      getBalances(address, options = {}) {
        var _a4;
        return __awaiter(this, void 0, void 0, function* () {
          const balances = [];
          let xrpPromise = Promise.resolve(0);
          if (!options.peer) {
            xrpPromise = this.getXrpBalance(address, {
              ledger_hash: options.ledger_hash,
              ledger_index: options.ledger_index
            });
          }
          const linesRequest = {
            command: "account_lines",
            account: address,
            ledger_index: (_a4 = options.ledger_index) !== null && _a4 !== void 0 ? _a4 : "validated",
            ledger_hash: options.ledger_hash,
            peer: options.peer,
            limit: options.limit
          };
          const linesPromise = this.requestAll(linesRequest);
          yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {
            const accountLinesBalance = linesResponses.flatMap((response) => (0, balances_1.formatBalances)(response.result.lines));
            if (xrpBalance !== 0) {
              balances.push({ currency: "XRP", value: xrpBalance.toString() });
            }
            balances.push(...accountLinesBalance);
          });
          return balances.slice(0, options.limit);
        });
      }
      getOrderbook(currency1, currency2, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          (0, getOrderbook_1.validateOrderbookOptions)(options);
          const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);
          const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);
          const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));
          const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);
          const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);
          const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);
          const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(orders);
          return {
            buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),
            sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit)
          };
        });
      }
      getLedgerIndex() {
        return __awaiter(this, void 0, void 0, function* () {
          const ledgerResponse = yield this.request({
            command: "ledger",
            ledger_index: "validated"
          });
          return ledgerResponse.result.ledger_index;
        });
      }
      fundWallet(wallet, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.isConnected()) {
            throw new errors_1.RippledError("Client not connected, cannot call faucet");
          }
          const existingWallet = Boolean(wallet);
          const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress) ? wallet : Wallet_1.Wallet.generate();
          const postBody = {
            destination: walletToFund.classicAddress,
            xrpAmount: options.amount,
            usageContext: options.usageContext,
            userAgent: "xrpl.js"
          };
          let startingBalance = 0;
          if (existingWallet) {
            try {
              startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));
            } catch (_a4) {
            }
          }
          return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);
        });
      }
    };
    exports.Client = Client;
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/utils/index.js
var require_utils11 = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
    var utils_1 = require_browser();
    function randomEntropy() {
      return (0, utils_1.randomBytes)(16);
    }
    exports.randomEntropy = randomEntropy;
    function calculateChecksum(position, value) {
      return value * (position * 2 + 1) % 9;
    }
    exports.calculateChecksum = calculateChecksum;
    function checkChecksum(position, value, checksum) {
      let normalizedChecksum;
      let normalizedValue;
      if (typeof value === "string") {
        if (value.length !== 6) {
          throw new Error("value must have a length of 6");
        }
        normalizedChecksum = parseInt(value.slice(5), 10);
        normalizedValue = parseInt(value.slice(0, 5), 10);
      } else {
        if (typeof checksum !== "number") {
          throw new Error("checksum must be a number when value is a number");
        }
        normalizedChecksum = checksum;
        normalizedValue = value;
      }
      return normalizedValue * (position * 2 + 1) % 9 === normalizedChecksum;
    }
    exports.checkChecksum = checkChecksum;
    function entropyToSecret(entropy) {
      const len = new Array(Math.ceil(entropy.length / 2));
      const chunks = Array.from(len, (_a4, chunk) => {
        const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);
        const no = parseInt((0, utils_1.bytesToHex)(buffChunk), 16);
        const fill = "0".repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(chunk, no));
      });
      if (chunks.length !== 8) {
        throw new Error("Chucks must have 8 digits");
      }
      return chunks;
    }
    exports.entropyToSecret = entropyToSecret;
    function randomSecret() {
      return entropyToSecret(randomEntropy());
    }
    exports.randomSecret = randomSecret;
    function secretToEntropy(secret) {
      return (0, utils_1.concat)(secret.map((chunk, i) => {
        const no = Number(chunk.slice(0, 5));
        const checksum = Number(chunk.slice(5));
        if (chunk.length !== 6) {
          throw new Error("Invalid secret: number invalid");
        }
        if (!checkChecksum(i, no, checksum)) {
          throw new Error("Invalid secret part: checksum invalid");
        }
        const hex = `0000${no.toString(16)}`.slice(-4);
        return (0, utils_1.hexToBytes)(hex);
      }));
    }
    exports.secretToEntropy = secretToEntropy;
    function parseSecretString(secret) {
      const normalizedSecret = secret.replace(/[^0-9]/gu, "");
      if (normalizedSecret.length !== 48) {
        throw new Error("Invalid secret string (should contain 8 blocks of 6 digits");
      }
      return Array.from(new Array(8), (_a4, index) => {
        return normalizedSecret.slice(index * 6, (index + 1) * 6);
      });
    }
    exports.parseSecretString = parseSecretString;
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/schema/Account.js
var require_Account = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/schema/Account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var ripple_keypairs_1 = require_dist4();
    var utils_1 = require_utils11();
    var Account = class {
      constructor(secretNumbers) {
        this._account = {
          familySeed: "",
          address: "",
          keypair: {
            publicKey: "",
            privateKey: ""
          }
        };
        if (typeof secretNumbers === "string") {
          this._secret = (0, utils_1.parseSecretString)(secretNumbers);
        } else if (Array.isArray(secretNumbers)) {
          this._secret = secretNumbers;
        } else if (secretNumbers instanceof Uint8Array) {
          this._secret = (0, utils_1.entropyToSecret)(secretNumbers);
        } else {
          this._secret = (0, utils_1.randomSecret)();
        }
        validateLengths(this._secret);
        this.derive();
      }
      getSecret() {
        return this._secret;
      }
      getSecretString() {
        return this._secret.join(" ");
      }
      getAddress() {
        return this._account.address;
      }
      getFamilySeed() {
        return this._account.familySeed;
      }
      getKeypair() {
        return this._account.keypair;
      }
      toString() {
        return this.getSecretString();
      }
      derive() {
        try {
          const entropy = (0, utils_1.secretToEntropy)(this._secret);
          this._account.familySeed = (0, ripple_keypairs_1.generateSeed)({ entropy });
          this._account.keypair = (0, ripple_keypairs_1.deriveKeypair)(this._account.familySeed);
          this._account.address = (0, ripple_keypairs_1.deriveAddress)(this._account.keypair.publicKey);
        } catch (error) {
          let message = "Unknown Error";
          if (error instanceof Error) {
            message = error.message;
          }
          throw new Error(message);
        }
      }
    };
    exports.Account = Account;
    function validateLengths(secretNumbers) {
      if (secretNumbers.length !== 8) {
        throw new Error("Secret must have 8 numbers");
      }
      secretNumbers.forEach((num) => {
        if (num.length !== 6) {
          throw new Error("Each secret number must be 6 digits");
        }
      });
    }
  }
});

// node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/.pnpm/@xrplf+secret-numbers@2.0.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Account(), exports);
    __exportStar(require_utils11(), exports);
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js
var require_walletFromSecretNumbers = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletFromSecretNumbers = void 0;
    var secret_numbers_1 = require_dist5();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var _1 = require_Wallet();
    function walletFromSecretNumbers(secretNumbers, opts) {
      var _a4;
      const secret = new secret_numbers_1.Account(secretNumbers).getFamilySeed();
      const updatedOpts = {
        masterAddress: void 0,
        algorithm: void 0
      };
      if (opts === void 0) {
        updatedOpts.algorithm = ECDSA_1.default.secp256k1;
      } else {
        updatedOpts.masterAddress = opts.masterAddress;
        updatedOpts.algorithm = (_a4 = opts.algorithm) !== null && _a4 !== void 0 ? _a4 : ECDSA_1.default.secp256k1;
      }
      return _1.Wallet.fromSecret(secret, updatedOpts);
    }
    exports.walletFromSecretNumbers = walletFromSecretNumbers;
  }
});

// node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/index.js
var require_npm = __commonJS({
  "node_modules/.pnpm/xrpl@4.5.0_bufferutil@4.1.0_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rfc1751MnemonicToKey = exports.keyToRFC1751Mnemonic = exports.walletFromSecretNumbers = exports.ECDSA = exports.Client = void 0;
    var client_1 = require_client2();
    Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    __exportStar(require_models(), exports);
    __exportStar(require_utils8(), exports);
    var ECDSA_1 = require_ECDSA();
    Object.defineProperty(exports, "ECDSA", { enumerable: true, get: function() {
      return __importDefault(ECDSA_1).default;
    } });
    __exportStar(require_errors(), exports);
    __exportStar(require_Wallet(), exports);
    var walletFromSecretNumbers_1 = require_walletFromSecretNumbers();
    Object.defineProperty(exports, "walletFromSecretNumbers", { enumerable: true, get: function() {
      return walletFromSecretNumbers_1.walletFromSecretNumbers;
    } });
    var rfc1751_1 = require_rfc1751();
    Object.defineProperty(exports, "keyToRFC1751Mnemonic", { enumerable: true, get: function() {
      return rfc1751_1.keyToRFC1751Mnemonic;
    } });
    Object.defineProperty(exports, "rfc1751MnemonicToKey", { enumerable: true, get: function() {
      return rfc1751_1.rfc1751MnemonicToKey;
    } });
  }
});

// node_modules/.pnpm/base58-universal@2.0.0/node_modules/base58-universal/lib/baseN.js
var _reverseAlphabets = {};
function encode(input, alphabet2, maxline) {
  if (!(input instanceof Uint8Array)) {
    throw new TypeError('"input" must be a Uint8Array.');
  }
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  if (input.length === 0) {
    return "";
  }
  let output = "";
  let i = 0;
  const base2 = alphabet2.length;
  const first = alphabet2.charAt(0);
  const digits = [0];
  for (i = 0; i < input.length; ++i) {
    let carry = input[i];
    for (let j = 0; j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base2;
      carry = carry / base2 | 0;
    }
    while (carry > 0) {
      digits.push(carry % base2);
      carry = carry / base2 | 0;
    }
  }
  for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
    output += first;
  }
  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet2[digits[i]];
  }
  if (maxline) {
    const regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
}
function decode(input, alphabet2) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet2 !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (input.length === 0) {
    return new Uint8Array();
  }
  let table = _reverseAlphabets[alphabet2];
  if (!table) {
    table = _reverseAlphabets[alphabet2] = [];
    for (let i = 0; i < alphabet2.length; ++i) {
      table[alphabet2.charCodeAt(i)] = i;
    }
  }
  input = input.replace(/\s/g, "");
  const base2 = alphabet2.length;
  const first = alphabet2.charAt(0);
  const bytes = [0];
  for (let i = 0; i < input.length; i++) {
    const value = table[input.charCodeAt(i)];
    if (value === void 0) {
      return;
    }
    let carry = value;
    for (let j = 0; j < bytes.length; ++j) {
      carry += bytes[j] * base2;
      bytes[j] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (let k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }
  return new Uint8Array(bytes.reverse());
}

// node_modules/.pnpm/base58-universal@2.0.0/node_modules/base58-universal/lib/index.js
var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encode2(input, maxline) {
  return encode(input, alphabet, maxline);
}
function decode2(input) {
  return decode(input, alphabet);
}

// node_modules/.pnpm/base64url-universal@2.0.0/node_modules/base64url-universal/lib/index.js
var import_base64url = __toESM(require_base64url2(), 1);
var encode3 = import_base64url.default.encode;
var decode3 = import_base64url.default.toBuffer;

// node_modules/.pnpm/@digitalbazaar+ed25519-verification-key-2020@4.2.0/node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js
function assertKeyBytes({ bytes, expectedLength = 32, code }) {
  if (!(bytes instanceof Uint8Array)) {
    throw new TypeError('"bytes" must be a Uint8Array.');
  }
  if (bytes.length !== expectedLength) {
    const error = new Error(
      `"bytes" must be a ${expectedLength}-byte Uint8Array.`
    );
    error.name = "DataError";
    if (code) {
      error.code = code;
    }
    throw error;
  }
}

// node_modules/.pnpm/@noble+ed25519@1.7.3/node_modules/@noble/ed25519/lib/esm/index.js
import * as nodeCrypto from "crypto";
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class _ExtendedPoint {
  constructor(x, y, z, t) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return _ExtendedPoint.ZERO;
    return new _ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod(X1 * Z2);
    const X2Z1 = mod(X2 * Z1);
    const Y1Z2 = mod(Y1 * Z2);
    const Y2Z1 = mod(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new _ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(_2n * mod(Z1 * Z1));
    const D = mod(a * A);
    const x1y1 = X1 + Y1;
    const E = mod(mod(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new _ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod((Y1 - X1) * (Y2 + X2));
    const B = mod((Y1 + X1) * (Y2 - X2));
    const F = mod(B - A);
    if (F === _0n)
      return this.double();
    const C = mod(Z1 * _2n * T2);
    const D = mod(T1 * _2n * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new _ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base2 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base2 = p;
      points.push(base2);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base2 = base2.add(p);
        points.push(base2);
      }
      p = base2.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(_ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = _ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = _ExtendedPoint.ZERO;
    let f = _ExtendedPoint.BASE;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return _ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar(scalar, CURVE.l, false);
    const G = _ExtendedPoint.BASE;
    const P0 = _ExtendedPoint.ZERO;
    if (n === _0n)
      return P0;
    if (this.equals(P0) || n === _1n)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d = this;
    while (n > _0n) {
      if (n & _1n)
        p = p.add(d);
      d = d.double();
      n >>= _1n;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(_ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let p = this.multiplyUnsafe(CURVE.l / _2n).double();
    if (CURVE.l % _2n)
      p = p.add(this);
    return p.equals(_ExtendedPoint.ZERO);
  }
  toAffine(invZ) {
    const { x, y, z } = this;
    const is0 = this.equals(_ExtendedPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z);
    const ax = mod(x * invZ);
    const ay = mod(y * invZ);
    const zz = mod(z * invZ);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var RistrettoPoint = class _RistrettoPoint {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d } = CURVE;
    const r = mod(SQRT_M1 * r0 * r0);
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod((c - d * r) * mod(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod(s * r0);
    if (!edIsNegative(s_))
      s_ = mod(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod((s + s) * D);
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod(_1n - s2);
    const W3 = mod(_1n + s2);
    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a, d } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
      throw new Error(emsg);
    const s2 = mod(s * s);
    const u1 = mod(_1n + a * s2);
    const u2 = mod(_1n - a * s2);
    const u1_2 = mod(u1 * u1);
    const u2_2 = mod(u2 * u2);
    const v = mod(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod(v * u2_2));
    const Dx = mod(I * u2);
    const Dy = mod(I * Dx * v);
    let x = mod((s + s) * Dx);
    if (edIsNegative(x))
      x = mod(-x);
    const y = mod(u1 * Dy);
    const t = mod(x * y);
    if (!isValid || edIsNegative(t) || y === _0n)
      throw new Error(emsg);
    return new _RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
  }
  toRawBytes() {
    let { x, y, z, t } = this.ep;
    const u1 = mod(mod(z + y) * mod(z - y));
    const u2 = mod(x * y);
    const u2sq = mod(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
    const D1 = mod(invsqrt * u1);
    const D2 = mod(invsqrt * u2);
    const zInv = mod(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod(y * SQRT_M1);
      let _y = mod(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y = mod(-y);
    let s = mod((z - y) * D);
    if (edIsNegative(s))
      s = mod(-s);
    return numberTo32BytesLE(s);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b = other.ep;
    const one = mod(a.x * b.y) === mod(a.y * b.x);
    const two = mod(a.y * b.y) === mod(a.x * b.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class _Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d, P } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = bytesToNumberLE(normed);
    if (strict && y >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y2 = mod(y * y);
    const u = mod(y2 - _1n);
    const v = mod(d * y2 + _1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod(-x);
    }
    return new _Point(x, y);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes = numberTo32BytesLE(this.y);
    bytes[31] |= this.x & _1n ? 128 : 0;
    return bytes;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y } = this;
    const u = mod((_1n + y) * invert(_1n - y));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(mod(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
var Signature = class _Signature {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes = ensureBytes(hex, 64);
    const r = Point.fromHex(bytes.slice(0, 32), false);
    const s = bytesToNumberLE(bytes.slice(32, 64));
    return new _Signature(r, s);
  }
  assertValidity() {
    const { r, s } = this;
    if (!(r instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function numberTo32BytesBE(num) {
  const length = 32;
  const hex = num.toString(16).padStart(length * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes) {
  return mod(bytesToNumberLE(bytes) & MAX_255B);
}
function mod(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
function invert(number3, modulo = CURVE.P) {
  if (number3 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod(acc * tmp[i], p);
    return mod(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number3) {
  return uvRatio(_1n, number3);
}
function modlLE(hash2) {
  return mod(bytesToNumberLE(hash2), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix2 = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix: prefix2, scalar, point, pointBytes };
}
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign(message, privateKey) {
  message = ensureBytes(message);
  const { prefix: prefix2, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix2, message));
  const R = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));
  const s = mod(r + k * scalar, CURVE.l);
  return new Signature(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey) {
  message = ensureBytes(message);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash2) => {
    hash2 = ensureBytes(hash2);
    if (hash2.length < 40 || hash2.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod(bytesToNumberLE(hash2), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes } = crypto2.node;
      return new Uint8Array(randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: async (...messages) => {
    const message = concatBytes(...messages);
    if (crypto2.web) {
      const buffer = await crypto2.web.subtle.digest("SHA-512", message.buffer);
      return new Uint8Array(buffer);
    } else if (crypto2.node) {
      return Uint8Array.from(crypto2.node.createHash("sha512").update(message).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached2 = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached2._setWindowSize(windowSize);
    cached2.multiply(_2n);
    return cached2;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// node_modules/.pnpm/@digitalbazaar+ed25519-verification-key-2020@4.2.0/node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js
var crypto3 = globalThis.crypto;
if (!crypto3.getRandomValues) {
  throw new Error('Browser does not provide "crypto.getRandomValues".');
}
var ed25519_browser_default = {
  async generateKeyPair() {
    const seed = new Uint8Array(32);
    crypto3.getRandomValues(seed);
    const keyPair = await generateKeyPairFromSeed(seed);
    seed.fill(0);
    return keyPair;
  },
  generateKeyPairFromSeed,
  async sign(secretKey, data) {
    return sign(data, secretKey.slice(0, 32));
  },
  async verify(publicKey, data, signature) {
    return verify(signature, data, publicKey);
  },
  async sha256digest({ data }) {
    return crypto3.subtle.digest("SHA-256", data);
  }
};
async function generateKeyPairFromSeed(seed) {
  assertKeyBytes({
    bytes: seed,
    expectedLength: 32
  });
  const publicKey = await getPublicKey(seed);
  const secretKey = new Uint8Array(64);
  secretKey.set(seed);
  secretKey.set(publicKey, seed.length);
  return {
    publicKey,
    secretKey
  };
}

// node_modules/.pnpm/crypto-ld@7.0.0/node_modules/crypto-ld/lib/LDKeyPair.js
var LDKeyPair = class {
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Creates a public/private key pair instance. This is an abstract base class,
   * actual key material and suite-specific methods are handled in the subclass.
   *
   * To generate or import a key pair, use the `cryptoLd` instance.
   *
   * @see CryptoLD.js
   *
   * @param {object} options - The options to use.
   * @param {string} options.id - The key id, typically composed of controller
   *   URL and key fingerprint as hash fragment.
   * @param {string} options.controller - DID/URL of the person/entity
   *   controlling this key.
   * @param {string} [options.revoked] - Timestamp of when the key has been
   *   revoked, in RFC3339 format. If not present, the key itself is
   *   considered not revoked. (Note that this mechanism is slightly different
   *   than DID Document key revocation, where a DID controller can revoke a
   *   key from that DID by removing it from the DID Document.)
   */
  /* eslint-enable */
  constructor({ id, controller, revoked } = {}) {
    this.id = id;
    this.controller = controller;
    this.revoked = revoked;
  }
  /* eslint-disable jsdoc/check-param-names */
  /**
   * Generates a new public/private key pair instance.
   * Note that this method is not typically called directly by client code,
   * but instead is used through a `cryptoLd` instance.
   *
   * @param {object} options - Suite-specific options for the KeyPair. For
   *   common options, see the `LDKeyPair.constructor()` docstring.
   *
   * @returns {Promise<LDKeyPair>} An LDKeyPair instance.
   */
  /* eslint-enable */
  static async generate() {
    throw new Error("Abstract method, must be implemented in subclass.");
  }
  /**
   * Imports a key pair instance from a provided externally fetched key
   * document (fetched via a secure JSON-LD `documentLoader` or via
   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required
   * context.
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.document - Externally fetched key document.
   * @param {boolean} [options.checkContext=true] - Whether to check that the
   *   fetched key document contains the context required by the key's crypto
   *   suite.
   * @param {boolean} [options.checkRevoked=true] - Whether to check the key
   *   object for the presence of the `revoked` timestamp.
   *
   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair
   *   instance.
   */
  static async fromKeyDocument({
    document: document2,
    checkContext = true,
    checkRevoked = true
  } = {}) {
    if (!document2) {
      throw new TypeError('The "document" parameter is required.');
    }
    if (checkContext) {
      const fetchedDocContexts = [].concat(document2["@context"]);
      if (!fetchedDocContexts.includes(this.SUITE_CONTEXT)) {
        throw new Error('Key document does not contain required context "' + this.SUITE_CONTEXT + '".');
      }
    }
    if (checkRevoked && document2.revoked) {
      throw new Error(`Key has been revoked since: "${document2.revoked}".`);
    }
    return this.from(document2);
  }
  /* eslint-disable jsdoc/check-param-names */
  /**
   * Generates a KeyPair from some options.
   *
   * @param {object} options  - Will generate a key pair in multiple different
   *   formats.
   * @example
   * > const options = {
   *    type: 'Ed25519VerificationKey2020'
   *   };
   * > const edKeyPair = await LDKeyPair.from(options);
   *
   * @returns {Promise<LDKeyPair>} A LDKeyPair.
   * @throws Unsupported Key Type.
   */
  /* eslint-enable */
  static async from() {
    throw new Error("Abstract method from() must be implemented in subclass.");
  }
  /**
   * Exports the serialized representation of the KeyPair
   * and other information that json-ld Signatures can use to form a proof.
   *
   * NOTE: Subclasses MUST override this method (and add the exporting of
   * their public and private key material).
   *
   * @param {object} [options={}] - Options hashmap.
   * @param {boolean} [options.publicKey] - Export public key material?
   * @param {boolean} [options.privateKey] - Export private key material?
   *
   * @returns {object} A public key object
   *   information used in verification methods by signatures.
   */
  export({ publicKey = false, privateKey = false } = {}) {
    if (!publicKey && !privateKey) {
      throw new Error(
        'Export requires specifying either "publicKey" or "privateKey".'
      );
    }
    const key = {
      id: this.id,
      type: this.type,
      controller: this.controller
    };
    if (this.revoked) {
      key.revoked = this.revoked;
    }
    return key;
  }
  /**
   * Returns the public key fingerprint, multibase+multicodec encoded. The
   * specific fingerprint method is determined by the key suite, and is often
   * either a hash of the public key material (such as with RSA), or the
   * full encoded public key (for key types with sufficiently short
   * representations, such as ed25519).
   * This is frequently used in initializing the key id, or generating some
   * types of cryptonym DIDs.
   *
   * @returns {string} The fingerprint.
   */
  fingerprint() {
    throw new Error("Abstract method, must be implemented in subclass.");
  }
  /* eslint-disable jsdoc/check-param-names */
  /**
   * Verifies that a given key fingerprint matches the public key material
   * belonging to this key pair.
   *
   * @param {string} fingerprint - Public key fingerprint.
   *
   * @returns {{verified: boolean}} An object with verified flag.
   */
  /* eslint-enable */
  verifyFingerprint() {
    throw new Error("Abstract method, must be implemented in subclass.");
  }
  /* eslint-disable max-len */
  /**
   * Returns a signer object for use with
   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.
   * NOTE: Applies only to verifier type keys (like ed25519).
   *
   * @example
   * > const signer = keyPair.signer();
   * > signer
   * { sign: [AsyncFunction: sign] }
   * > signer.sign({data});
   *
   * @returns {{sign: Function}} A signer for json-ld usage.
   */
  /* eslint-enable */
  signer() {
    return {
      async sign({
        /* data */
      }) {
        throw new Error("Abstract method, must be implemented in subclass.");
      }
    };
  }
  /* eslint-disable max-len */
  /**
   * Returns a verifier object for use with
   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.
   * NOTE: Applies only to verifier type keys (like ed25519).
   *
   * @example
   * > const verifier = keyPair.verifier();
   * > verifier
   * { verify: [AsyncFunction: verify] }
   * > verifier.verify(key);
   *
   * @returns {{verify: Function}} Used to verify jsonld-signatures.
   */
  /* eslint-enable */
  verifier() {
    return {
      async verify({
        /* data, signature */
      }) {
        throw new Error("Abstract method, must be implemented in subclass.");
      }
    };
  }
};
LDKeyPair.SUITE_CONTEXT = "INVALID LDKeyPair CONTEXT";

// node_modules/.pnpm/@digitalbazaar+ed25519-verification-key-2020@4.2.0/node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js
var SUITE_ID = "Ed25519VerificationKey2020";
var MULTIBASE_BASE58BTC_HEADER = "z";
var MULTICODEC_ED25519_PUB_HEADER = new Uint8Array([237, 1]);
var MULTICODEC_ED25519_PRIV_HEADER = new Uint8Array([128, 38]);
var Ed25519VerificationKey2020 = class _Ed25519VerificationKey2020 extends LDKeyPair {
  /**
   * An implementation of the Ed25519VerificationKey2020 spec, for use with
   * Linked Data Proofs.
   *
   * @see https://w3c-ccg.github.io/lds-ed25519-2020/#ed25519verificationkey2020
   * @see https://github.com/digitalbazaar/jsonld-signatures
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.controller - Controller DID or document url.
   * @param {string} [options.id] - The key ID. If not provided, will be
   *   composed of controller and key fingerprint as hash fragment.
   * @param {string} options.publicKeyMultibase - Multibase encoded public key
   *   with a multicodec ed25519-pub varint header [0xed, 0x01].
   * @param {string} [options.privateKeyMultibase] - Multibase private key
   *   with a multicodec ed25519-priv varint header [0x80, 0x26].
   * @param {string} [options.revoked] - Timestamp of when the key has been
   *   revoked, in RFC3339 format. If not present, the key itself is considered
   *   not revoked. Note that this mechanism is slightly different than DID
   *   Document key revocation, where a DID controller can revoke a key from
   *   that DID by removing it from the DID Document.
   */
  constructor(options = {}) {
    super(options);
    this.type = SUITE_ID;
    const { publicKeyMultibase, privateKeyMultibase } = options;
    if (!publicKeyMultibase) {
      throw new TypeError('The "publicKeyMultibase" property is required.');
    }
    if (!publicKeyMultibase || !_isValidKeyHeader(
      publicKeyMultibase,
      MULTICODEC_ED25519_PUB_HEADER
    )) {
      throw new Error(
        `"publicKeyMultibase" has invalid header bytes: "${publicKeyMultibase}".`
      );
    }
    if (privateKeyMultibase && !_isValidKeyHeader(
      privateKeyMultibase,
      MULTICODEC_ED25519_PRIV_HEADER
    )) {
      throw new Error('"privateKeyMultibase" has invalid header bytes.');
    }
    this.publicKeyMultibase = publicKeyMultibase;
    this.privateKeyMultibase = privateKeyMultibase;
    if (this.controller && !this.id) {
      this.id = `${this.controller}#${this.fingerprint()}`;
    }
    assertKeyBytes({
      bytes: this._publicKeyBuffer,
      code: "invalidPublicKeyLength",
      expectedLength: 32
    });
  }
  /**
   * Creates an Ed25519 Key Pair from an existing serialized key pair.
   *
   * @param {object} options - Key pair options (see constructor).
   * @example
   * > const keyPair = await Ed25519VerificationKey2020.from({
   * controller: 'did:ex:1234',
   * type: 'Ed25519VerificationKey2020',
   * publicKeyMultibase,
   * privateKeyMultibase
   * });
   *
   * @returns {Promise<Ed25519VerificationKey2020>} An Ed25519 Key Pair.
   */
  static async from(options) {
    if (options.type === "Ed25519VerificationKey2018") {
      return _Ed25519VerificationKey2020.fromEd25519VerificationKey2018(options);
    }
    if (options.type === "JsonWebKey" || options.type === "JsonWebKey2020") {
      return _Ed25519VerificationKey2020.fromJsonWebKey(options);
    }
    return new _Ed25519VerificationKey2020(options);
  }
  /**
   * Instance creation method for backwards compatibility with the
   * `Ed25519VerificationKey2018` key suite.
   *
   * @see https://github.com/digitalbazaar/ed25519-verification-key-2018
   * @typedef {object} Ed25519VerificationKey2018
   * @param {Ed25519VerificationKey2018} keyPair - Ed25519 2018 suite key pair.
   *
   * @returns {Ed25519VerificationKey2020} - 2020 suite instance.
   */
  static fromEd25519VerificationKey2018({ keyPair } = {}) {
    const publicKeyMultibase = _encodeMbKey(
      MULTICODEC_ED25519_PUB_HEADER,
      decode2(keyPair.publicKeyBase58)
    );
    const keyPair2020 = new _Ed25519VerificationKey2020({
      id: keyPair.id,
      controller: keyPair.controller,
      publicKeyMultibase
    });
    if (keyPair.privateKeyBase58) {
      keyPair2020.privateKeyMultibase = _encodeMbKey(
        MULTICODEC_ED25519_PRIV_HEADER,
        decode2(keyPair.privateKeyBase58)
      );
    }
    return keyPair2020;
  }
  /**
   * Creates a key pair instance (public key only) from a JsonWebKey2020
   * object.
   *
   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.id - Key id.
   * @param {string} options.type - Key suite type.
   * @param {string} options.controller - Key controller.
   * @param {object} options.publicKeyJwk - JWK object.
   *
   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with key pair.
   */
  static fromJsonWebKey2020({ id, type, controller, publicKeyJwk } = {}) {
    if (type !== "JsonWebKey2020") {
      throw new TypeError(`Invalid key type: "${type}".`);
    }
    return _Ed25519VerificationKey2020.fromJsonWebKey({
      id,
      type,
      controller,
      publicKeyJwk
    });
  }
  /**
   * Creates a key pair instance (public key only) from a JsonWebKey object.
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.id - Key id.
   * @param {string} options.type - Key suite type.
   * @param {string} options.controller - Key controller.
   * @param {object} options.publicKeyJwk - JWK object.
   *
   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with key pair.
   */
  static fromJsonWebKey({ id, type, controller, publicKeyJwk } = {}) {
    if (!(type === "JsonWebKey" || type === "JsonWebKey2020")) {
      throw new TypeError(`Invalid key type: "${type}".`);
    }
    if (!publicKeyJwk) {
      throw new TypeError('"publicKeyJwk" property is required.');
    }
    const { kty, crv } = publicKeyJwk;
    if (kty !== "OKP") {
      throw new TypeError('"kty" is required to be "OKP".');
    }
    if (crv !== "Ed25519") {
      throw new TypeError('"crv" is required to be "Ed25519".');
    }
    const { x: publicKeyBase64Url } = publicKeyJwk;
    const publicKeyMultibase = _encodeMbKey(
      MULTICODEC_ED25519_PUB_HEADER,
      decode3(publicKeyBase64Url)
    );
    return _Ed25519VerificationKey2020.from({
      id,
      controller,
      publicKeyMultibase
    });
  }
  /**
   * Generates a KeyPair with an optional deterministic seed.
   *
   * @param {object} [options={}] - Options hashmap.
   * @param {Uint8Array} [options.seed] - A 32-byte array seed for a
   *   deterministic key.
   *
   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with generated
   *   public/private key pair.
   */
  static async generate({ seed, ...keyPairOptions } = {}) {
    let keyObject;
    if (seed) {
      keyObject = await ed25519_browser_default.generateKeyPairFromSeed(seed);
    } else {
      keyObject = await ed25519_browser_default.generateKeyPair();
    }
    const publicKeyMultibase = _encodeMbKey(MULTICODEC_ED25519_PUB_HEADER, keyObject.publicKey);
    const privateKeyMultibase = _encodeMbKey(MULTICODEC_ED25519_PRIV_HEADER, keyObject.secretKey);
    return new _Ed25519VerificationKey2020({
      publicKeyMultibase,
      privateKeyMultibase,
      ...keyPairOptions
    });
  }
  /**
   * Creates an instance of Ed25519VerificationKey2020 from a key fingerprint.
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.fingerprint - Multibase encoded key fingerprint.
   *
   * @returns {Ed25519VerificationKey2020} Returns key pair instance (with
   *   public key only).
   */
  static fromFingerprint({ fingerprint } = {}) {
    return new _Ed25519VerificationKey2020({ publicKeyMultibase: fingerprint });
  }
  /**
   * @returns {Uint8Array} Public key bytes.
   */
  get _publicKeyBuffer() {
    if (!this.publicKeyMultibase) {
      return;
    }
    const publicKeyMulticodec = decode2(this.publicKeyMultibase.substr(1));
    const publicKeyBytes = publicKeyMulticodec.slice(MULTICODEC_ED25519_PUB_HEADER.length);
    return publicKeyBytes;
  }
  /**
   * @returns {Uint8Array} Private key bytes.
   */
  get _privateKeyBuffer() {
    if (!this.privateKeyMultibase) {
      return;
    }
    const privateKeyMulticodec = decode2(this.privateKeyMultibase.substr(1));
    const privateKeyBytes = privateKeyMulticodec.slice(MULTICODEC_ED25519_PRIV_HEADER.length);
    return privateKeyBytes;
  }
  /**
   * Generates and returns a multiformats encoded
   * ed25519 public key fingerprint (for use with cryptonyms, for example).
   *
   * @see https://github.com/multiformats/multicodec
   *
   * @returns {string} The fingerprint.
   */
  fingerprint() {
    return this.publicKeyMultibase;
  }
  /**
   * Exports the serialized representation of the KeyPair
   * and other information that JSON-LD Signatures can use to form a proof.
   *
   * @param {object} [options={}] - Options hashmap.
   * @param {boolean} [options.publicKey] - Export public key material?
   * @param {boolean} [options.privateKey] - Export private key material?
   * @param {boolean} [options.includeContext] - Include JSON-LD context?
   *
   * @returns {object} A plain js object that's ready for serialization
   *   (to JSON, etc), for use in DIDs, Linked Data Proofs, etc.
   */
  export({ publicKey = false, privateKey = false, includeContext = false } = {}) {
    if (!(publicKey || privateKey)) {
      throw new TypeError(
        'Export requires specifying either "publicKey" or "privateKey".'
      );
    }
    const exportedKey = {
      id: this.id,
      type: this.type
    };
    if (includeContext) {
      exportedKey["@context"] = _Ed25519VerificationKey2020.SUITE_CONTEXT;
    }
    if (this.controller) {
      exportedKey.controller = this.controller;
    }
    if (publicKey) {
      exportedKey.publicKeyMultibase = this.publicKeyMultibase;
    }
    if (privateKey) {
      exportedKey.privateKeyMultibase = this.privateKeyMultibase;
    }
    if (this.revoked) {
      exportedKey.revoked = this.revoked;
    }
    return exportedKey;
  }
  /**
   * Returns the JWK representation of this key pair.
   *
   * @see https://datatracker.ietf.org/doc/html/rfc8037
   *
   * @param {object} [options={}] - Options hashmap.
   * @param {boolean} [options.publicKey] - Include public key?
   * @param {boolean} [options.privateKey] - Include private key?
   *
   * @returns {{kty: string, crv: string, x: string, d: string}} JWK
   *   representation.
   */
  toJwk({ publicKey = true, privateKey = false } = {}) {
    if (!(publicKey || privateKey)) {
      throw TypeError('Either a "publicKey" or a "privateKey" is required.');
    }
    const jwk = { crv: "Ed25519", kty: "OKP" };
    if (publicKey) {
      jwk.x = encode3(this._publicKeyBuffer);
    }
    if (privateKey) {
      jwk.d = encode3(this._privateKeyBuffer);
    }
    return jwk;
  }
  /**
   * @see https://datatracker.ietf.org/doc/html/rfc8037#appendix-A.3
   *
   * @returns {Promise<string>} JWK Thumbprint.
   */
  async jwkThumbprint() {
    const publicKey = encode3(this._publicKeyBuffer);
    const serialized = `{"crv":"Ed25519","kty":"OKP","x":"${publicKey}"}`;
    const data = new TextEncoder().encode(serialized);
    return encode3(
      new Uint8Array(await ed25519_browser_default.sha256digest({ data }))
    );
  }
  /**
   * Returns the JsonWebKey representation of this key pair.
   *
   * @returns {Promise<object>} JsonWebKey representation.
   */
  async toJsonWebKey() {
    return {
      "@context": "https://w3id.org/security/jwk/v1",
      id: this.controller + "#" + await this.jwkThumbprint(),
      type: "JsonWebKey",
      controller: this.controller,
      publicKeyJwk: this.toJwk({ publicKey: true })
    };
  }
  /**
   * Returns the JsonWebKey2020 representation of this key pair.
   *
   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020
   *
   * @returns {Promise<object>} JsonWebKey2020 representation.
   */
  async toJsonWebKey2020() {
    return {
      "@context": "https://w3id.org/security/jws/v1",
      id: this.controller + "#" + await this.jwkThumbprint(),
      type: "JsonWebKey2020",
      controller: this.controller,
      publicKeyJwk: this.toJwk({ publicKey: true })
    };
  }
  /**
   * Tests whether the fingerprint was generated from a given key pair.
   *
   * @example
   * > edKeyPair.verifyFingerprint({fingerprint: 'z6Mk2S2Q...6MkaFJewa'});
   * {valid: true};
   *
   * @param {object} options - Options hashmap.
   * @param {string} options.fingerprint - A public key fingerprint.
   *
   * @returns {{valid: boolean, error: *}} Result of verification.
   */
  verifyFingerprint({ fingerprint } = {}) {
    if (!(typeof fingerprint === "string" && fingerprint[0] === MULTIBASE_BASE58BTC_HEADER)) {
      return {
        error: new Error('"fingerprint" must be a multibase encoded string.'),
        valid: false
      };
    }
    let fingerprintBuffer;
    try {
      fingerprintBuffer = decode2(fingerprint.substr(1));
      if (!fingerprintBuffer) {
        throw new TypeError("Invalid encoding of fingerprint.");
      }
    } catch (e) {
      return { error: e, valid: false };
    }
    const buffersEqual = _isEqualBuffer(
      this._publicKeyBuffer,
      fingerprintBuffer.slice(2)
    );
    const valid = fingerprintBuffer[0] === MULTICODEC_ED25519_PUB_HEADER[0] && fingerprintBuffer[1] === MULTICODEC_ED25519_PUB_HEADER[1] && buffersEqual;
    if (!valid) {
      return {
        error: new Error("The fingerprint does not match the public key."),
        valid: false
      };
    }
    return { valid };
  }
  signer() {
    const privateKeyBuffer = this._privateKeyBuffer;
    return {
      async sign({ data }) {
        if (!privateKeyBuffer) {
          throw new Error("A private key is not available for signing.");
        }
        return ed25519_browser_default.sign(privateKeyBuffer, data);
      },
      id: this.id
    };
  }
  verifier() {
    const publicKeyBuffer = this._publicKeyBuffer;
    return {
      async verify({ data, signature }) {
        if (!publicKeyBuffer) {
          throw new Error("A public key is not available for verifying.");
        }
        return ed25519_browser_default.verify(publicKeyBuffer, data, signature);
      },
      id: this.id
    };
  }
};
Ed25519VerificationKey2020.suite = SUITE_ID;
Ed25519VerificationKey2020.SUITE_CONTEXT = "https://w3id.org/security/suites/ed25519-2020/v1";
function _isEqualBuffer(buf1, buf2) {
  if (buf1.length !== buf2.length) {
    return false;
  }
  for (let i = 0; i < buf1.length; i++) {
    if (buf1[i] !== buf2[i]) {
      return false;
    }
  }
  return true;
}
function _isValidKeyHeader(multibaseKey, expectedHeader) {
  if (!(typeof multibaseKey === "string" && multibaseKey[0] === MULTIBASE_BASE58BTC_HEADER)) {
    return false;
  }
  const keyBytes = decode2(multibaseKey.slice(1));
  return expectedHeader.every((val, i) => keyBytes[i] === val);
}
function _encodeMbKey(header, key) {
  const mbKey = new Uint8Array(header.length + key.length);
  mbKey.set(header);
  mbKey.set(key, header.length);
  return MULTIBASE_BASE58BTC_HEADER + encode2(mbKey);
}

// node_modules/.pnpm/@stablelib+base64@2.0.1/node_modules/@stablelib/base64/lib/base64.js
var INVALID_BYTE = 256;
var Coder = class {
  // TODO(dchest): methods to encode chunk-by-chunk.
  constructor(_paddingCharacter = "=") {
    __publicField(this, "_paddingCharacter");
    this._paddingCharacter = _paddingCharacter;
  }
  encodedLength(length) {
    if (!this._paddingCharacter) {
      return (length * 8 + 5) / 6 | 0;
    }
    return (length + 2) / 3 * 4 | 0;
  }
  encode(data) {
    let out = "";
    let i = 0;
    for (; i < data.length - 2; i += 3) {
      let c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      out += this._encodeByte(c >>> 1 * 6 & 63);
      out += this._encodeByte(c >>> 0 * 6 & 63);
    }
    const left = data.length - i;
    if (left > 0) {
      let c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      if (left === 2) {
        out += this._encodeByte(c >>> 1 * 6 & 63);
      } else {
        out += this._paddingCharacter || "";
      }
      out += this._paddingCharacter || "";
    }
    return out;
  }
  maxDecodedLength(length) {
    if (!this._paddingCharacter) {
      return (length * 6 + 7) / 8 | 0;
    }
    return length / 4 * 3 | 0;
  }
  decodedLength(s) {
    return this.maxDecodedLength(s.length - this._getPaddingLength(s));
  }
  decode(s) {
    if (s.length === 0) {
      return new Uint8Array(0);
    }
    const paddingLength = this._getPaddingLength(s);
    const length = s.length - paddingLength;
    const out = new Uint8Array(this.maxDecodedLength(length));
    let op = 0;
    let i = 0;
    let haveBad = 0;
    let v0 = 0, v1 = 0, v2 = 0, v3 = 0;
    for (; i < length - 4; i += 4) {
      v0 = this._decodeChar(s.charCodeAt(i + 0));
      v1 = this._decodeChar(s.charCodeAt(i + 1));
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      v3 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v0 << 2 | v1 >>> 4;
      out[op++] = v1 << 4 | v2 >>> 2;
      out[op++] = v2 << 6 | v3;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v1 & INVALID_BYTE;
      haveBad |= v2 & INVALID_BYTE;
      haveBad |= v3 & INVALID_BYTE;
    }
    if (i < length - 1) {
      v0 = this._decodeChar(s.charCodeAt(i));
      v1 = this._decodeChar(s.charCodeAt(i + 1));
      out[op++] = v0 << 2 | v1 >>> 4;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v1 & INVALID_BYTE;
    }
    if (i < length - 2) {
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      out[op++] = v1 << 4 | v2 >>> 2;
      haveBad |= v2 & INVALID_BYTE;
    }
    if (i < length - 3) {
      v3 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v2 << 6 | v3;
      haveBad |= v3 & INVALID_BYTE;
    }
    if (haveBad !== 0) {
      throw new Error("Base64Coder: incorrect characters for decoding");
    }
    return out;
  }
  // Standard encoding have the following encoded/decoded ranges,
  // which we need to convert between.
  //
  // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /
  // Index:   0 - 25                    26 - 51              52 - 61   62  63
  // ASCII:  65 - 90                    97 - 122             48 - 57   43  47
  //
  // Encode 6 bits in b into a new character.
  _encodeByte(b) {
    let result = b;
    result += 65;
    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
    result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
    result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
    return String.fromCharCode(result);
  }
  // Decode a character code into a byte.
  // Must return 256 if character is out of alphabet range.
  _decodeChar(c) {
    let result = INVALID_BYTE;
    result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
    result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
    return result;
  }
  _getPaddingLength(s) {
    let paddingLength = 0;
    if (this._paddingCharacter) {
      for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== this._paddingCharacter) {
          break;
        }
        paddingLength++;
      }
      if (s.length < 4 || paddingLength > 2) {
        throw new Error("Base64Coder: incorrect padding");
      }
    }
    return paddingLength;
  }
};
var stdCoder = new Coder();
function encode4(data) {
  return stdCoder.encode(data);
}
function decode4(s) {
  return stdCoder.decode(s);
}
var URLSafeCoder = class extends Coder {
  // URL-safe encoding have the following encoded/decoded ranges:
  //
  // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _
  // Index:   0 - 25                    26 - 51              52 - 61   62  63
  // ASCII:  65 - 90                    97 - 122             48 - 57   45  95
  //
  _encodeByte(b) {
    let result = b;
    result += 65;
    result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
    result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
    result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
    result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
    return String.fromCharCode(result);
  }
  _decodeChar(c) {
    let result = INVALID_BYTE;
    result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
    result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
    result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
    return result;
  }
};
var urlSafeCoder = new URLSafeCoder();

// node_modules/.pnpm/@stablelib+hex@2.0.1/node_modules/@stablelib/hex/lib/hex.js
function encodeNibble(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & -48 + 65 - 10;
  return String.fromCharCode(result);
}
function encodeNibbleLower(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & -48 + 97 - 10;
  return String.fromCharCode(result);
}
function encode5(data, lowerCase = false) {
  const enc = lowerCase ? encodeNibbleLower : encodeNibble;
  let s = "";
  for (let i = 0; i < data.length; i++) {
    s += enc(data[i] >>> 4);
    s += enc(data[i] & 15);
  }
  return s;
}

// node_modules/.pnpm/@stablelib+int@2.0.1/node_modules/@stablelib/int/lib/int.js
var isInteger = Number.isInteger;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var isSafeInteger = Number.isSafeInteger;

// node_modules/.pnpm/@stablelib+binary@2.0.1/node_modules/@stablelib/binary/lib/binary.js
function writeUint16BE(value, out = new Uint8Array(2), offset = 0) {
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
function readUint32BE(array2, offset = 0) {
  return (array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3]) >>> 0;
}
function writeUint32BE(value, out = new Uint8Array(4), offset = 0) {
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}

// node_modules/.pnpm/@stablelib+wipe@2.0.1/node_modules/@stablelib/wipe/lib/wipe.js
function wipe(array2) {
  for (let i = 0; i < array2.length; i++) {
    array2[i] = 0;
  }
  return array2;
}

// node_modules/.pnpm/@stablelib+sha256@2.0.1/node_modules/@stablelib/sha256/lib/sha256.js
var DIGEST_LENGTH = 32;
var BLOCK_SIZE = 64;
var SHA256 = class {
  // indicates whether the hash was finalized
  constructor() {
    /** Length of hash output */
    __publicField(this, "digestLength", DIGEST_LENGTH);
    /** Block size */
    __publicField(this, "blockSize", BLOCK_SIZE);
    // Note: Int32Array is used instead of Uint32Array for performance reasons.
    __publicField(this, "_state", new Int32Array(8));
    // hash state
    __publicField(this, "_temp", new Int32Array(64));
    // temporary state
    __publicField(this, "_buffer", new Uint8Array(128));
    // buffer for data to hash
    __publicField(this, "_bufferLength", 0);
    // number of bytes in buffer
    __publicField(this, "_bytesHashed", 0);
    // number of total bytes hashed
    __publicField(this, "_finished", false);
    this.reset();
  }
  _initState() {
    this._state[0] = 1779033703;
    this._state[1] = 3144134277;
    this._state[2] = 1013904242;
    this._state[3] = 2773480762;
    this._state[4] = 1359893119;
    this._state[5] = 2600822924;
    this._state[6] = 528734635;
    this._state[7] = 1541459225;
  }
  /**
   * Resets hash state making it possible
   * to re-use this instance to hash other data.
   */
  reset() {
    this._initState();
    this._bufferLength = 0;
    this._bytesHashed = 0;
    this._finished = false;
    return this;
  }
  /**
   * Cleans internal buffers and resets hash state.
   */
  clean() {
    wipe(this._buffer);
    wipe(this._temp);
    this.reset();
  }
  /**
   * Updates hash state with the given data.
   *
   * Throws error when trying to update already finalized hash:
   * instance must be reset to update it again.
   */
  update(data, dataLength = data.length) {
    if (this._finished) {
      throw new Error("SHA256: can't update because hash was finished.");
    }
    let dataPos = 0;
    this._bytesHashed += dataLength;
    if (this._bufferLength > 0) {
      while (this._bufferLength < this.blockSize && dataLength > 0) {
        this._buffer[this._bufferLength++] = data[dataPos++];
        dataLength--;
      }
      if (this._bufferLength === this.blockSize) {
        hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
        this._bufferLength = 0;
      }
    }
    if (dataLength >= this.blockSize) {
      dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
      dataLength %= this.blockSize;
    }
    while (dataLength > 0) {
      this._buffer[this._bufferLength++] = data[dataPos++];
      dataLength--;
    }
    return this;
  }
  /**
   * Finalizes hash state and puts hash into out.
   * If hash was already finalized, puts the same value.
   */
  finish(out) {
    if (!this._finished) {
      const bytesHashed = this._bytesHashed;
      const left = this._bufferLength;
      const bitLenHi = bytesHashed / 536870912 | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;
      this._buffer[left] = 128;
      for (let i = left + 1; i < padLength - 8; i++) {
        this._buffer[i] = 0;
      }
      writeUint32BE(bitLenHi, this._buffer, padLength - 8);
      writeUint32BE(bitLenLo, this._buffer, padLength - 4);
      hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
      this._finished = true;
    }
    for (let i = 0; i < this.digestLength / 4; i++) {
      writeUint32BE(this._state[i], out, i * 4);
    }
    return this;
  }
  /**
   * Returns the final hash digest.
   */
  digest() {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
  /**
   * Function useful for HMAC/PBKDF2 optimization.
   * Returns hash state to be used with restoreState().
   * Only chain value is saved, not buffers or other
   * state variables.
   */
  saveState() {
    if (this._finished) {
      throw new Error("SHA256: cannot save finished state");
    }
    return {
      state: new Int32Array(this._state),
      buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
      bufferLength: this._bufferLength,
      bytesHashed: this._bytesHashed
    };
  }
  /**
   * Function useful for HMAC/PBKDF2 optimization.
   * Restores state saved by saveState() and sets bytesHashed
   * to the given value.
   */
  restoreState(savedState) {
    this._state.set(savedState.state);
    this._bufferLength = savedState.bufferLength;
    if (savedState.buffer) {
      this._buffer.set(savedState.buffer);
    }
    this._bytesHashed = savedState.bytesHashed;
    this._finished = false;
    return this;
  }
  /**
   * Cleans state returned by saveState().
   */
  cleanSavedState(savedState) {
    wipe(savedState.state);
    if (savedState.buffer) {
      wipe(savedState.buffer);
    }
    savedState.bufferLength = 0;
    savedState.bytesHashed = 0;
  }
};
var K = new Int32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
function hashBlocks(w, v, p, pos, len) {
  while (len >= 64) {
    let a = v[0];
    let b = v[1];
    let c = v[2];
    let d = v[3];
    let e = v[4];
    let f = v[5];
    let g = v[6];
    let h = v[7];
    for (let i = 0; i < 16; i++) {
      let j = pos + i * 4;
      w[i] = readUint32BE(p, j);
    }
    for (let i = 16; i < 64; i++) {
      let u = w[i - 2];
      let t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
      u = w[i - 15];
      let t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
      w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
    }
    for (let i = 0; i < 64; i++) {
      let t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
      let t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    v[0] += a;
    v[1] += b;
    v[2] += c;
    v[3] += d;
    v[4] += e;
    v[5] += f;
    v[6] += g;
    v[7] += h;
    pos += 64;
    len -= 64;
  }
  return pos;
}
function hash(data) {
  const h = new SHA256();
  h.update(data);
  const digest = h.digest();
  h.clean();
  return digest;
}

// node_modules/.pnpm/@stablelib+utf8@2.0.1/node_modules/@stablelib/utf8/lib/utf8.js
var INVALID_UTF16 = "utf8: invalid string";
var INVALID_UTF8 = "utf8: invalid source encoding";
function encode6(s) {
  const arr = new Uint8Array(encodedLength(s));
  let pos = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      c = (c - 55296 << 10) + (s.charCodeAt(++i) - 56320) + 65536;
    }
    if (c < 128) {
      arr[pos++] = c;
    } else if (c < 2048) {
      arr[pos++] = 192 | c >> 6;
      arr[pos++] = 128 | c & 63;
    } else if (c < 65536) {
      arr[pos++] = 224 | c >> 12;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    } else {
      arr[pos++] = 240 | c >> 18;
      arr[pos++] = 128 | c >> 12 & 63;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    }
  }
  return arr;
}
function encodedLength(s) {
  let result = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      if (i === s.length - 1) {
        throw new Error(INVALID_UTF16);
      }
      i++;
      const c2 = s.charCodeAt(i);
      if (c2 < 56320 || c2 > 57343) {
        throw new Error(INVALID_UTF16);
      }
      c = (c - 55296 << 10) + (c2 - 56320) + 65536;
    }
    if (c < 128) {
      result += 1;
    } else if (c < 2048) {
      result += 2;
    } else if (c < 65536) {
      result += 3;
    } else {
      result += 4;
    }
  }
  return result;
}
function decode5(arr) {
  const chars = [];
  for (let i = 0; i < arr.length; i++) {
    let b = arr[i];
    if (b & 128) {
      let min;
      if (b < 224) {
        if (i >= arr.length) {
          throw new Error(INVALID_UTF8);
        }
        const n1 = arr[++i];
        if ((n1 & 192) !== 128) {
          throw new Error(INVALID_UTF8);
        }
        b = (b & 31) << 6 | n1 & 63;
        min = 128;
      } else if (b < 240) {
        if (i >= arr.length - 1) {
          throw new Error(INVALID_UTF8);
        }
        const n1 = arr[++i];
        const n2 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128) {
          throw new Error(INVALID_UTF8);
        }
        b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
        min = 2048;
      } else if (b < 248) {
        if (i >= arr.length - 2) {
          throw new Error(INVALID_UTF8);
        }
        const n1 = arr[++i];
        const n2 = arr[++i];
        const n3 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) {
          throw new Error(INVALID_UTF8);
        }
        b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
        min = 65536;
      } else {
        throw new Error(INVALID_UTF8);
      }
      if (b < min || b >= 55296 && b <= 57343) {
        throw new Error(INVALID_UTF8);
      }
      if (b >= 65536) {
        if (b > 1114111) {
          throw new Error(INVALID_UTF8);
        }
        b -= 65536;
        chars.push(String.fromCharCode(55296 | b >> 10));
        b = 56320 | b & 1023;
      }
    }
    chars.push(String.fromCharCode(b));
  }
  return chars.join("");
}

// node_modules/.pnpm/base-x@5.0.0/node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x = ALPHABET2.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (source[psz]) {
      let carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode10(string3) {
    const buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode10
  };
}
var esm_default = base;

// node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/.pnpm/@stablelib+bytes@2.0.1/node_modules/@stablelib/bytes/lib/bytes.js
function concat(...arrays) {
  let totalLength = 0;
  for (let i = 0; i < arrays.length; i++) {
    totalLength += arrays[i].length;
  }
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const arg = arrays[i];
    result.set(arg, offset);
    offset += arg.length;
  }
  return result;
}

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/types.js
var integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/buffer.js
var EncodeBuffer = (
  /** @class */
  (function() {
    function EncodeBuffer2() {
      this.offset = 0;
      this.buffer_size = 256;
      this.buffer = new ArrayBuffer(this.buffer_size);
      this.view = new DataView(this.buffer);
    }
    EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
      if (this.buffer_size - this.offset < needed_space) {
        this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
        var new_buffer = new ArrayBuffer(this.buffer_size);
        new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
        this.buffer = new_buffer;
        this.view = new DataView(new_buffer);
      }
    };
    EncodeBuffer2.prototype.get_used_buffer = function() {
      return new Uint8Array(this.buffer).slice(0, this.offset);
    };
    EncodeBuffer2.prototype.store_value = function(value, type) {
      var bSize = type.substring(1);
      var size = parseInt(bSize) / 8;
      this.resize_if_necessary(size);
      var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
      this.view[toCall](this.offset, value, true);
      this.offset += size;
    };
    EncodeBuffer2.prototype.store_bytes = function(from) {
      this.resize_if_necessary(from.length);
      new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
      this.offset += from.length;
    };
    return EncodeBuffer2;
  })()
);
var DecodeBuffer = (
  /** @class */
  (function() {
    function DecodeBuffer2(buf) {
      this.offset = 0;
      this.buffer_size = buf.length;
      this.buffer = new ArrayBuffer(buf.length);
      new Uint8Array(this.buffer).set(buf);
      this.view = new DataView(this.buffer);
    }
    DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
      if (this.offset + size > this.buffer.byteLength) {
        throw new Error("Error in schema, the buffer is smaller than expected");
      }
    };
    DecodeBuffer2.prototype.consume_value = function(type) {
      var bSize = type.substring(1);
      var size = parseInt(bSize) / 8;
      this.assert_enough_buffer(size);
      var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
      var ret = this.view[toCall](this.offset, true);
      this.offset += size;
      return ret;
    };
    DecodeBuffer2.prototype.consume_bytes = function(size) {
      this.assert_enough_buffer(size);
      var ret = this.buffer.slice(this.offset, this.offset + size);
      this.offset += size;
      return ret;
    };
    return DecodeBuffer2;
  })()
);

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/utils.js
var __extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
function isArrayLike(value) {
  return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
}
function expect_type(value, type, fieldPath) {
  if (typeof value !== type) {
    throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
  }
}
function expect_bigint(value, fieldPath) {
  var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
  var strObject = typeof value === "object" && value !== null && "toString" in value;
  if (!basicType && !strObject) {
    throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
  }
}
function expect_same_size(length, expected, fieldPath) {
  if (length !== expected) {
    throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
  }
}
function expect_enum(value, fieldPath) {
  if (typeof value !== "object" || value === null) {
    throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
  }
}
var VALID_STRING_TYPES = integers.concat(["bool", "string"]);
var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
var ErrorSchema = (
  /** @class */
  (function(_super) {
    __extends(ErrorSchema2, _super);
    function ErrorSchema2(schema, expected) {
      var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
      return _super.call(this, message) || this;
    }
    return ErrorSchema2;
  })(Error)
);
function validate_schema(schema) {
  if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
    return;
  }
  if (schema && typeof schema === "object") {
    var keys = Object.keys(schema);
    if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
      var key = keys[0];
      if (key === "option")
        return validate_schema(schema[key]);
      if (key === "enum")
        return validate_enum_schema(schema[key]);
      if (key === "array")
        return validate_array_schema(schema[key]);
      if (key === "set")
        return validate_schema(schema[key]);
      if (key === "map")
        return validate_map_schema(schema[key]);
      if (key === "struct")
        return validate_struct_schema(schema[key]);
    }
  }
  throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
}
function validate_enum_schema(schema) {
  if (!Array.isArray(schema))
    throw new ErrorSchema(schema, "Array");
  for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
    var sch = schema_1[_i];
    if (typeof sch !== "object" || !("struct" in sch)) {
      throw new Error('Missing "struct" key in enum schema');
    }
    if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
      throw new Error('The "struct" in each enum must have a single key');
    }
    validate_schema({ struct: sch.struct });
  }
}
function validate_array_schema(schema) {
  if (typeof schema !== "object")
    throw new ErrorSchema(schema, "{ type, len? }");
  if (schema.len && typeof schema.len !== "number") {
    throw new Error("Invalid schema: ".concat(schema));
  }
  if ("type" in schema)
    return validate_schema(schema.type);
  throw new ErrorSchema(schema, "{ type, len? }");
}
function validate_map_schema(schema) {
  if (typeof schema === "object" && "key" in schema && "value" in schema) {
    validate_schema(schema.key);
    validate_schema(schema.value);
  } else {
    throw new ErrorSchema(schema, "{ key, value }");
  }
}
function validate_struct_schema(schema) {
  if (typeof schema !== "object")
    throw new ErrorSchema(schema, "object");
  for (var key in schema) {
    validate_schema(schema[key]);
  }
}

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/serialize.js
var BorshSerializer = (
  /** @class */
  (function() {
    function BorshSerializer2(checkTypes) {
      this.encoded = new EncodeBuffer();
      this.fieldPath = ["value"];
      this.checkTypes = checkTypes;
    }
    BorshSerializer2.prototype.encode = function(value, schema) {
      this.encode_value(value, schema);
      return this.encoded.get_used_buffer();
    };
    BorshSerializer2.prototype.encode_value = function(value, schema) {
      if (typeof schema === "string") {
        if (integers.includes(schema))
          return this.encode_integer(value, schema);
        if (schema === "string")
          return this.encode_string(value);
        if (schema === "bool")
          return this.encode_boolean(value);
      }
      if (typeof schema === "object") {
        if ("option" in schema)
          return this.encode_option(value, schema);
        if ("enum" in schema)
          return this.encode_enum(value, schema);
        if ("array" in schema)
          return this.encode_array(value, schema);
        if ("set" in schema)
          return this.encode_set(value, schema);
        if ("map" in schema)
          return this.encode_map(value, schema);
        if ("struct" in schema)
          return this.encode_struct(value, schema);
      }
    };
    BorshSerializer2.prototype.encode_integer = function(value, schema) {
      var size = parseInt(schema.substring(1));
      if (size <= 32 || schema == "f64") {
        this.checkTypes && expect_type(value, "number", this.fieldPath);
        this.encoded.store_value(value, schema);
      } else {
        this.checkTypes && expect_bigint(value, this.fieldPath);
        this.encode_bigint(BigInt(value), size);
      }
    };
    BorshSerializer2.prototype.encode_bigint = function(value, size) {
      var buffer_len = size / 8;
      var buffer = new Uint8Array(buffer_len);
      for (var i = 0; i < buffer_len; i++) {
        buffer[i] = Number(value & BigInt(255));
        value = value >> BigInt(8);
      }
      this.encoded.store_bytes(new Uint8Array(buffer));
    };
    BorshSerializer2.prototype.encode_string = function(value) {
      this.checkTypes && expect_type(value, "string", this.fieldPath);
      var _value = value;
      var utf8Bytes = [];
      for (var i = 0; i < _value.length; i++) {
        var charCode = _value.charCodeAt(i);
        if (charCode < 128) {
          utf8Bytes.push(charCode);
        } else if (charCode < 2048) {
          utf8Bytes.push(192 | charCode >> 6, 128 | charCode & 63);
        } else if (charCode < 55296 || charCode >= 57344) {
          utf8Bytes.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
        } else {
          i++;
          charCode = 65536 + ((charCode & 1023) << 10 | _value.charCodeAt(i) & 1023);
          utf8Bytes.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
        }
      }
      this.encoded.store_value(utf8Bytes.length, "u32");
      this.encoded.store_bytes(new Uint8Array(utf8Bytes));
    };
    BorshSerializer2.prototype.encode_boolean = function(value) {
      this.checkTypes && expect_type(value, "boolean", this.fieldPath);
      this.encoded.store_value(value ? 1 : 0, "u8");
    };
    BorshSerializer2.prototype.encode_option = function(value, schema) {
      if (value === null || value === void 0) {
        this.encoded.store_value(0, "u8");
      } else {
        this.encoded.store_value(1, "u8");
        this.encode_value(value, schema.option);
      }
    };
    BorshSerializer2.prototype.encode_enum = function(value, schema) {
      this.checkTypes && expect_enum(value, this.fieldPath);
      var valueKey = Object.keys(value)[0];
      for (var i = 0; i < schema["enum"].length; i++) {
        var valueSchema = schema["enum"][i];
        if (valueKey === Object.keys(valueSchema.struct)[0]) {
          this.encoded.store_value(i, "u8");
          return this.encode_struct(value, valueSchema);
        }
      }
      throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
    };
    BorshSerializer2.prototype.encode_array = function(value, schema) {
      if (isArrayLike(value))
        return this.encode_arraylike(value, schema);
      if (value instanceof ArrayBuffer)
        return this.encode_buffer(value, schema);
      throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
    };
    BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
      if (schema.array.len) {
        expect_same_size(value.length, schema.array.len, this.fieldPath);
      } else {
        this.encoded.store_value(value.length, "u32");
      }
      for (var i = 0; i < value.length; i++) {
        this.encode_value(value[i], schema.array.type);
      }
    };
    BorshSerializer2.prototype.encode_buffer = function(value, schema) {
      if (schema.array.len) {
        expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
      } else {
        this.encoded.store_value(value.byteLength, "u32");
      }
      this.encoded.store_bytes(new Uint8Array(value));
    };
    BorshSerializer2.prototype.encode_set = function(value, schema) {
      this.checkTypes && expect_type(value, "object", this.fieldPath);
      var isSet = value instanceof Set;
      var values = isSet ? Array.from(value.values()) : Object.values(value);
      this.encoded.store_value(values.length, "u32");
      for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
        var value_1 = values_1[_i];
        this.encode_value(value_1, schema.set);
      }
    };
    BorshSerializer2.prototype.encode_map = function(value, schema) {
      this.checkTypes && expect_type(value, "object", this.fieldPath);
      var isMap = value instanceof Map;
      var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
      this.encoded.store_value(keys.length, "u32");
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        this.encode_value(key, schema.map.key);
        this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
      }
    };
    BorshSerializer2.prototype.encode_struct = function(value, schema) {
      this.checkTypes && expect_type(value, "object", this.fieldPath);
      for (var _i = 0, _a4 = Object.keys(schema.struct); _i < _a4.length; _i++) {
        var key = _a4[_i];
        this.fieldPath.push(key);
        this.encode_value(value[key], schema.struct[key]);
        this.fieldPath.pop();
      }
    };
    return BorshSerializer2;
  })()
);

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/deserialize.js
var BorshDeserializer = (
  /** @class */
  (function() {
    function BorshDeserializer2(bufferArray) {
      this.buffer = new DecodeBuffer(bufferArray);
    }
    BorshDeserializer2.prototype.decode = function(schema) {
      return this.decode_value(schema);
    };
    BorshDeserializer2.prototype.decode_value = function(schema) {
      if (typeof schema === "string") {
        if (integers.includes(schema))
          return this.decode_integer(schema);
        if (schema === "string")
          return this.decode_string();
        if (schema === "bool")
          return this.decode_boolean();
      }
      if (typeof schema === "object") {
        if ("option" in schema)
          return this.decode_option(schema);
        if ("enum" in schema)
          return this.decode_enum(schema);
        if ("array" in schema)
          return this.decode_array(schema);
        if ("set" in schema)
          return this.decode_set(schema);
        if ("map" in schema)
          return this.decode_map(schema);
        if ("struct" in schema)
          return this.decode_struct(schema);
      }
      throw new Error("Unsupported type: ".concat(schema));
    };
    BorshDeserializer2.prototype.decode_integer = function(schema) {
      var size = parseInt(schema.substring(1));
      if (size <= 32 || schema == "f64") {
        return this.buffer.consume_value(schema);
      }
      return this.decode_bigint(size, schema.startsWith("i"));
    };
    BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
      if (signed === void 0) {
        signed = false;
      }
      var buffer_len = size / 8;
      var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
      var bits = buffer.reduceRight(function(r, x) {
        return r + x.toString(16).padStart(2, "0");
      }, "");
      if (signed && buffer[buffer_len - 1]) {
        return BigInt.asIntN(size, BigInt("0x".concat(bits)));
      }
      return BigInt("0x".concat(bits));
    };
    BorshDeserializer2.prototype.decode_string = function() {
      var len = this.decode_integer("u32");
      var buffer = new Uint8Array(this.buffer.consume_bytes(len));
      var codePoints = [];
      for (var i = 0; i < len; ++i) {
        var byte = buffer[i];
        if (byte < 128) {
          codePoints.push(byte);
        } else if (byte < 224) {
          codePoints.push((byte & 31) << 6 | buffer[++i] & 63);
        } else if (byte < 240) {
          codePoints.push((byte & 15) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63);
        } else {
          var codePoint = (byte & 7) << 18 | (buffer[++i] & 63) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63;
          codePoints.push(codePoint);
        }
      }
      return String.fromCodePoint.apply(String, codePoints);
    };
    BorshDeserializer2.prototype.decode_boolean = function() {
      return this.buffer.consume_value("u8") > 0;
    };
    BorshDeserializer2.prototype.decode_option = function(schema) {
      var option = this.buffer.consume_value("u8");
      if (option === 1) {
        return this.decode_value(schema.option);
      }
      if (option !== 0) {
        throw new Error("Invalid option ".concat(option));
      }
      return null;
    };
    BorshDeserializer2.prototype.decode_enum = function(schema) {
      var _a4;
      var valueIndex = this.buffer.consume_value("u8");
      if (valueIndex > schema["enum"].length) {
        throw new Error("Enum option ".concat(valueIndex, " is not available"));
      }
      var struct = schema["enum"][valueIndex].struct;
      var key = Object.keys(struct)[0];
      return _a4 = {}, _a4[key] = this.decode_value(struct[key]), _a4;
    };
    BorshDeserializer2.prototype.decode_array = function(schema) {
      var result = [];
      var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
      for (var i = 0; i < len; ++i) {
        result.push(this.decode_value(schema.array.type));
      }
      return result;
    };
    BorshDeserializer2.prototype.decode_set = function(schema) {
      var len = this.decode_integer("u32");
      var result = /* @__PURE__ */ new Set();
      for (var i = 0; i < len; ++i) {
        result.add(this.decode_value(schema.set));
      }
      return result;
    };
    BorshDeserializer2.prototype.decode_map = function(schema) {
      var len = this.decode_integer("u32");
      var result = /* @__PURE__ */ new Map();
      for (var i = 0; i < len; ++i) {
        var key = this.decode_value(schema.map.key);
        var value = this.decode_value(schema.map.value);
        result.set(key, value);
      }
      return result;
    };
    BorshDeserializer2.prototype.decode_struct = function(schema) {
      var result = {};
      for (var key in schema.struct) {
        result[key] = this.decode_value(schema.struct[key]);
      }
      return result;
    };
    return BorshDeserializer2;
  })()
);

// node_modules/.pnpm/borsh@2.0.0/node_modules/borsh/lib/esm/index.js
function serialize(schema, value, validate) {
  if (validate === void 0) {
    validate = true;
  }
  if (validate)
    validate_schema(schema);
  var serializer = new BorshSerializer(validate);
  return serializer.encode(value, schema);
}

// packages/utils/dist/codecs/index.mjs
function hexEncodeSha256Hash(data) {
  return encode5(hash(data), true);
}
function bs58Decode(data) {
  return esm_default2.decode(data);
}
function fromBytesToJson(data) {
  return JSON.parse(decode5(data));
}

// packages/credentials/dist/utils/index.mjs
var base85 = __toESM(require_base85(), 1);

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/predicate/isLength.mjs
function isLength(value) {
  return Number.isSafeInteger(value) && value >= 0;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/isArrayLike.mjs
function isArrayLike2(value) {
  return value != null && typeof value !== "function" && isLength(value.length);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/function/identity.mjs
function identity(x) {
  return x;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/_internal/isUnsafeProperty.mjs
function isUnsafeProperty(key) {
  return key === "__proto__";
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/isDeepKey.mjs
function isDeepKey(key) {
  switch (typeof key) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key.includes(".") || key.includes("[") || key.includes("]");
    }
  }
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/toKey.mjs
function toKey(value) {
  if (typeof value === "string" || typeof value === "symbol") {
    return value;
  }
  if (Object.is(value?.valueOf?.(), -0)) {
    return "-0";
  }
  return String(value);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/util/toString.mjs
function toString(value) {
  if (value == null) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(toString).join(",");
  }
  const result = String(value);
  if (result === "0" && Object.is(Number(value), -0)) {
    return "-0";
  }
  return result;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/util/toPath.mjs
function toPath(deepKey) {
  if (Array.isArray(deepKey)) {
    return deepKey.map(toKey);
  }
  if (typeof deepKey === "symbol") {
    return [deepKey];
  }
  deepKey = toString(deepKey);
  const result = [];
  const length = deepKey.length;
  if (length === 0) {
    return result;
  }
  let index = 0;
  let key = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result.push("");
    index++;
  }
  while (index < length) {
    const char = deepKey[index];
    if (quoteChar) {
      if (char === "\\" && index + 1 < length) {
        index++;
        key += deepKey[index];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result.push(key);
        key = "";
      } else {
        key += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key) {
          result.push(key);
          key = "";
        }
      } else if (char === ".") {
        if (key) {
          result.push(key);
          key = "";
        }
      } else {
        key += char;
      }
    }
    index++;
  }
  if (key) {
    result.push(key);
  }
  return result;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/object/get.mjs
function get(object2, path, defaultValue) {
  if (object2 == null) {
    return defaultValue;
  }
  switch (typeof path) {
    case "string": {
      if (isUnsafeProperty(path)) {
        return defaultValue;
      }
      const result = object2[path];
      if (result === void 0) {
        if (isDeepKey(path)) {
          return get(object2, toPath(path), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result;
    }
    case "number":
    case "symbol": {
      if (typeof path === "number") {
        path = toKey(path);
      }
      const result = object2[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
    default: {
      if (Array.isArray(path)) {
        return getWithPath(object2, path, defaultValue);
      }
      if (Object.is(path?.valueOf(), -0)) {
        path = "-0";
      } else {
        path = String(path);
      }
      if (isUnsafeProperty(path)) {
        return defaultValue;
      }
      const result = object2[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
  }
}
function getWithPath(object2, path, defaultValue) {
  if (path.length === 0) {
    return defaultValue;
  }
  let current = object2;
  for (let index = 0; index < path.length; index++) {
    if (current == null) {
      return defaultValue;
    }
    if (isUnsafeProperty(path[index])) {
      return defaultValue;
    }
    current = current[path[index]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/object/property.mjs
function property(path) {
  return function(object2) {
    return get(object2, path);
  };
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/isObject.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/predicate/isPrimitive.mjs
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/isMatchWith.mjs
function isMatchWith(target, source, compare) {
  if (typeof compare !== "function") {
    return isMatchWith(target, source, () => void 0);
  }
  return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object2, source2, stack) {
    const isEqual = compare(objValue, srcValue, key, object2, source2, stack);
    if (isEqual !== void 0) {
      return Boolean(isEqual);
    }
    return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
  }, /* @__PURE__ */ new Map());
}
function isMatchWithInternal(target, source, compare, stack) {
  if (source === target) {
    return true;
  }
  switch (typeof source) {
    case "object": {
      return isObjectMatch(target, source, compare, stack);
    }
    case "function": {
      const sourceKeys = Object.keys(source);
      if (sourceKeys.length > 0) {
        return isMatchWithInternal(target, { ...source }, compare, stack);
      }
      return eq(target, source);
    }
    default: {
      if (!isObject(target)) {
        return eq(target, source);
      }
      if (typeof source === "string") {
        return source === "";
      }
      return true;
    }
  }
}
function isObjectMatch(target, source, compare, stack) {
  if (source == null) {
    return true;
  }
  if (Array.isArray(source)) {
    return isArrayMatch(target, source, compare, stack);
  }
  if (source instanceof Map) {
    return isMapMatch(target, source, compare, stack);
  }
  if (source instanceof Set) {
    return isSetMatch(target, source, compare, stack);
  }
  const keys = Object.keys(source);
  if (target == null || isPrimitive(target)) {
    return keys.length === 0;
  }
  if (keys.length === 0) {
    return true;
  }
  if (stack?.has(source)) {
    return stack.get(source) === target;
  }
  stack?.set(source, target);
  try {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (!isPrimitive(target) && !(key in target)) {
        return false;
      }
      if (source[key] === void 0 && target[key] !== void 0) {
        return false;
      }
      if (source[key] === null && target[key] !== null) {
        return false;
      }
      const isEqual = compare(target[key], source[key], key, target, source, stack);
      if (!isEqual) {
        return false;
      }
    }
    return true;
  } finally {
    stack?.delete(source);
  }
}
function isMapMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Map)) {
    return false;
  }
  for (const [key, sourceValue] of source.entries()) {
    const targetValue = target.get(key);
    const isEqual = compare(targetValue, sourceValue, key, target, source, stack);
    if (isEqual === false) {
      return false;
    }
  }
  return true;
}
function isArrayMatch(target, source, compare, stack) {
  if (source.length === 0) {
    return true;
  }
  if (!Array.isArray(target)) {
    return false;
  }
  const countedIndex = /* @__PURE__ */ new Set();
  for (let i = 0; i < source.length; i++) {
    const sourceItem = source[i];
    let found = false;
    for (let j = 0; j < target.length; j++) {
      if (countedIndex.has(j)) {
        continue;
      }
      const targetItem = target[j];
      let matches2 = false;
      const isEqual = compare(targetItem, sourceItem, i, target, source, stack);
      if (isEqual) {
        matches2 = true;
      }
      if (matches2) {
        countedIndex.add(j);
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function isSetMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Set)) {
    return false;
  }
  return isArrayMatch([...target], [...source], compare, stack);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/isMatch.mjs
function isMatch(target, source) {
  return isMatchWith(target, source, () => void 0);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object2) {
  return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/predicate/isTypedArray.mjs
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs
function cloneDeepWith(obj, cloneValue) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
}
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
  if (cloned !== void 0) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result = new Array(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result.input = valueToClone.input;
    }
    return result;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result = new RegExp(valueToClone.source, valueToClone.flags);
    result.lastIndex = valueToClone.lastIndex;
    return result;
  }
  if (valueToClone instanceof Map) {
    const result = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result);
    for (const [key, value] of valueToClone) {
      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (valueToClone instanceof Set) {
    const result = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result);
    for (const value of valueToClone) {
      result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    return result;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
    const result = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Error) {
    const result = new valueToClone.constructor();
    stack.set(valueToClone, result);
    result.message = valueToClone.message;
    result.name = valueToClone.name;
    result.stack = valueToClone.stack;
    result.cause = valueToClone.cause;
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Boolean) {
    const result = new Boolean(valueToClone.valueOf());
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Number) {
    const result = new Number(valueToClone.valueOf());
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof String) {
    const result = new String(valueToClone.valueOf());
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
  const keys = [...Object.keys(source), ...getSymbols(source)];
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
    }
  }
}
function isCloneableObject(object2) {
  switch (getTag(object2)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/object/cloneDeep.mjs
function cloneDeep(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/matches.mjs
function matches(source) {
  source = cloneDeep(source);
  return (target) => {
    return isMatch(target, source);
  };
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs
function cloneDeepWith2(obj, customizer) {
  return cloneDeepWith(obj, (value, key, object2, stack) => {
    const cloned = customizer?.(value, key, object2, stack);
    if (cloned !== void 0) {
      return cloned;
    }
    if (typeof obj !== "object") {
      return void 0;
    }
    switch (Object.prototype.toString.call(obj)) {
      case numberTag:
      case stringTag:
      case booleanTag: {
        const result = new obj.constructor(obj?.valueOf());
        copyProperties(result, obj);
        return result;
      }
      case argumentsTag: {
        const result = {};
        copyProperties(result, obj);
        result.length = obj.length;
        result[Symbol.iterator] = obj[Symbol.iterator];
        return result;
      }
      default: {
        return void 0;
      }
    }
  });
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs
function cloneDeep2(obj) {
  return cloneDeepWith2(obj);
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/isIndex.mjs
var IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
  switch (typeof value) {
    case "number": {
      return Number.isInteger(value) && value >= 0 && value < length;
    }
    case "symbol": {
      return false;
    }
    case "string": {
      return IS_UNSIGNED_INTEGER.test(value);
    }
  }
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs
function isArguments(value) {
  return value !== null && typeof value === "object" && getTag(value) === "[object Arguments]";
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/object/has.mjs
function has(object2, path) {
  let resolvedPath;
  if (Array.isArray(path)) {
    resolvedPath = path;
  } else if (typeof path === "string" && isDeepKey(path) && object2?.[path] == null) {
    resolvedPath = toPath(path);
  } else {
    resolvedPath = [path];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object2;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key = resolvedPath[i];
    if (current == null || !Object.hasOwn(current, key)) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/predicate/matchesProperty.mjs
function matchesProperty(property2, source) {
  switch (typeof property2) {
    case "object": {
      if (Object.is(property2?.valueOf(), -0)) {
        property2 = "-0";
      }
      break;
    }
    case "number": {
      property2 = toKey(property2);
      break;
    }
  }
  source = cloneDeep2(source);
  return function(target) {
    const result = get(target, property2);
    if (result === void 0) {
      return has(target, property2);
    }
    if (source === void 0) {
      return result === void 0;
    }
    return isMatch(result, source);
  };
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.mjs
function isIterateeCall(value, index, object2) {
  if (!isObject(object2)) {
    return false;
  }
  if (typeof index === "number" && isArrayLike2(object2) && isIndex(index) && index < object2.length || typeof index === "string" && index in object2) {
    return eq(object2[index], value);
  }
  return false;
}

// node_modules/.pnpm/es-toolkit@1.43.0/node_modules/es-toolkit/dist/compat/array/every.mjs
function every(source, doesMatch, guard) {
  if (!source) {
    return true;
  }
  if (guard && isIterateeCall(source, doesMatch, guard)) {
    doesMatch = void 0;
  }
  if (!doesMatch) {
    doesMatch = identity;
  }
  let predicate;
  switch (typeof doesMatch) {
    case "function": {
      predicate = doesMatch;
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        predicate = matchesProperty(key, value);
      } else {
        predicate = matches(doesMatch);
      }
      break;
    }
    case "symbol":
    case "number":
    case "string": {
      predicate = property(doesMatch);
    }
  }
  if (!isArrayLike2(source)) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = source[key];
      if (!predicate(value, key, source)) {
        return false;
      }
    }
    return true;
  }
  for (let i = 0; i < source.length; i++) {
    if (!predicate(source[i], i, source)) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/tiny-invariant@1.3.3/node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// packages/credentials/dist/utils/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
function parseLevel(level) {
  const [base2, ...addons] = level.split("+");
  return {
    base: base2,
    addons
  };
}
function matchLevelOrHigher(level, requiredAddons, currentLevel) {
  const { base: currentBaseLevel, addons: currentAddons } = parseLevel(currentLevel);
  if (level === "plus" && currentBaseLevel !== "plus") return false;
  return requiredAddons.every((addon) => currentAddons.includes(addon));
}
function recordFilter(rec, pick2, omit2) {
  const matchCriteria = (content, criteria) => every(Object.entries(criteria), ([path, targetSet]) => targetSet.includes(get(content, path)));
  if (Object.keys(pick2).length > 0 && !matchCriteria(rec, pick2)) return false;
  if (Object.keys(omit2).length > 0 && matchCriteria(rec, omit2)) return false;
  return true;
}
function buildInsertableIDOSCredential(userId, publicNotes, content, encryptorPublicKey) {
  invariant(encryptorPublicKey, "Missing `encryptorPublicKey`");
  const ephemeralAuthenticationKeyPair = import_tweetnacl.default.sign.keyPair();
  const publicNotesSignature = import_tweetnacl.default.sign.detached(encode6(publicNotes), ephemeralAuthenticationKeyPair.secretKey);
  return {
    user_id: userId,
    content,
    public_notes: publicNotes,
    public_notes_signature: encode4(publicNotesSignature),
    broader_signature: encode4(import_tweetnacl.default.sign.detached(Uint8Array.from([...publicNotesSignature, ...decode4(content)]), ephemeralAuthenticationKeyPair.secretKey)),
    issuer_auth_public_key: encode5(ephemeralAuthenticationKeyPair.publicKey, true),
    encryptor_public_key: encryptorPublicKey
  };
}

// packages/kwil-infra/dist/actions-l1NWOl3s.mjs
var import_kwil_js = __toESM(require_dist(), 1);

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a4;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a4 = inst._zod).deferred ?? (_a4.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a4;
    (_a4 = iss).path ?? (_a4.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base642) {
  const binaryString = atob(base642);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base642 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base642.length % 4) % 4);
  return base64ToUint8Array(base642 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/regexes.js
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url2 = /^[A-Za-z0-9_-]*$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a4;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a4 = inst._zod).onattach ?? (_a4.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a4;
    (_a4 = inst2._zod.bag).multipleOf ?? (_a4.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a4, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a4 = inst._zod).check ?? (_a4.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 4
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a4;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a4 = inst._zod).deferred ?? (_a4.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix2] = parts;
      if (!prefix2)
        throw new Error();
      const prefixNum = Number(prefix2);
      if (`${prefixNum}` !== prefix2)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url2.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url2);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject3 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/registries.js
var _a;
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta2 = _meta[0];
    this._map.set(schema, meta2);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.set(meta2.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta2 = this._map.get(schema);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.delete(meta2.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix2, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix: prefix2
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a4;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a4 = result.schema).default ?? (_a4.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    json.format = formatMap[format] ?? format;
    if (json.format === "")
      delete json.format;
    if (format === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
var neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options;
  } else {
    json.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
};
var nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/classic/iso.js
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode8 = /* @__PURE__ */ _encode(ZodRealError);
var decode8 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/.pnpm/zod@4.3.4/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode8(inst, data, params);
  inst.decode = (data, params) => decode8(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}

// packages/kwil-infra/dist/actions-l1NWOl3s.mjs
var DataType = import_kwil_js.Utils.DataType;
var WALLET_TYPES = [
  "EVM",
  "NEAR",
  "XRPL",
  "Stellar",
  "FaceSign"
];
var walletTypeSchema = _enum(WALLET_TYPES);
var ENCRYPTION_PASSWORD_STORES = ["user", "mpc"];
var encryptionPasswordStoreSchema = _enum(ENCRYPTION_PASSWORD_STORES);
var actionSchema = {
  add_inserter_as_owner: [{
    name: "id",
    type: DataType.Uuid
  }, {
    name: "name",
    type: DataType.Text
  }],
  delete_inserter_as_owner: [{
    name: "id",
    type: DataType.Uuid
  }],
  add_delegate_as_owner: [{
    name: "address",
    type: DataType.Text
  }, {
    name: "inserter_id",
    type: DataType.Uuid
  }],
  delete_delegate_as_owner: [{
    name: "address",
    type: DataType.Text
  }],
  add_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text
    },
    {
      name: "encryption_password_store",
      type: DataType.Text
    }
  ],
  update_user_pub_key_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text
    },
    {
      name: "encryption_password_store",
      type: DataType.Text
    }
  ],
  get_user: [],
  get_user_as_inserter: [{
    name: "id",
    type: DataType.Uuid
  }],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "address",
      type: DataType.Text
    },
    {
      name: "public_key",
      type: DataType.Text
    },
    {
      name: "wallet_type",
      type: DataType.Text
    },
    {
      name: "message",
      type: DataType.Text
    },
    {
      name: "signature",
      type: DataType.Text
    }
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "address",
      type: DataType.Text
    },
    {
      name: "public_key",
      type: DataType.Text
    },
    {
      name: "wallet_type",
      type: DataType.Text
    },
    {
      name: "message",
      type: DataType.Text
    },
    {
      name: "signature",
      type: DataType.Text
    }
  ],
  get_wallets: [],
  remove_wallet: [{
    name: "id",
    type: DataType.Uuid
  }],
  upsert_credential_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    }
  ],
  add_credential: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    }
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [{
    name: "user_id",
    type: DataType.Uuid
  }, {
    name: "original_issuer_auth_public_key",
    type: DataType.Text
  }],
  edit_credential: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    }
  ],
  edit_public_notes_as_issuer: [{
    name: "public_notes_id",
    type: DataType.Text
  }, {
    name: "public_notes",
    type: DataType.Text
  }],
  remove_credential: [{
    name: "id",
    type: DataType.Uuid
  }],
  rescind_shared_credential: [{
    name: "credential_id",
    type: DataType.Uuid
  }],
  share_credential: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "content_hash",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "locked_until",
      type: DataType.Int
    }
  ],
  create_credential_copy: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    }
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "original_encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "original_content",
      type: DataType.Text
    },
    {
      name: "original_public_notes",
      type: DataType.Text
    },
    {
      name: "original_public_notes_signature",
      type: DataType.Text
    },
    {
      name: "original_broader_signature",
      type: DataType.Text
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "copy_credential_id",
      type: DataType.Uuid
    },
    {
      name: "copy_content",
      type: DataType.Text
    },
    {
      name: "copy_public_notes_signature",
      type: DataType.Text
    },
    {
      name: "copy_broader_signature",
      type: DataType.Text
    },
    {
      name: "content_hash",
      type: DataType.Text
    },
    {
      name: "dwg_owner",
      type: DataType.Text
    },
    {
      name: "dwg_grantee",
      type: DataType.Text
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType.Text
    },
    {
      name: "dwg_id",
      type: DataType.Uuid
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType.Text
    },
    {
      name: "dwg_not_before",
      type: DataType.Text
    },
    {
      name: "dwg_not_after",
      type: DataType.Text
    },
    {
      name: "dwg_signature",
      type: DataType.Text
    }
  ],
  credential_exist_as_inserter: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_credential_owned: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_credential_shared: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_sibling_credential_id: [{
    name: "content_hash",
    type: DataType.Text
  }],
  add_attribute_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  add_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  get_attributes: [],
  edit_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  remove_attribute: [{
    name: "id",
    type: DataType.Uuid
  }],
  share_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_attribute_id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  dwg_message: [
    {
      name: "owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "issuer_public_key",
      type: DataType.Text
    },
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "access_grant_timelock",
      type: DataType.Text
    },
    {
      name: "not_usable_before",
      type: DataType.Text
    },
    {
      name: "not_usable_after",
      type: DataType.Text
    }
  ],
  revoke_access_grant: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_access_grants_owned: [],
  get_access_grants_granted: [
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "page",
      type: DataType.Int
    },
    {
      name: "size",
      type: DataType.Int
    }
  ],
  get_access_grants_granted_count: [{
    name: "user_id",
    type: DataType.Uuid
  }],
  has_locked_access_grants: [{
    name: "id",
    type: DataType.Uuid
  }],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType.Int
    },
    {
      name: "dag_content_hash",
      type: DataType.Text
    }
  ],
  create_ag_by_dag_for_copy: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType.Int
    },
    {
      name: "dag_content_hash",
      type: DataType.Text
    },
    {
      name: "dag_signature",
      type: DataType.Text
    }
  ],
  get_access_grants_for_credential: [{
    name: "credential_id",
    type: DataType.Uuid
  }],
  has_profile: [{
    name: "address",
    type: DataType.Text
  }],
  add_passporting_club_as_owner: [{
    name: "id",
    type: DataType.Uuid
  }, {
    name: "name",
    type: DataType.Text
  }],
  delete_passporting_club_as_owner: [{
    name: "id",
    type: DataType.Uuid
  }],
  add_passporting_peer_as_owner: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "name",
      type: DataType.Text
    },
    {
      name: "issuer_public_key",
      type: DataType.Text
    },
    {
      name: "passporting_server_url_base",
      type: DataType.Text
    }
  ],
  delete_passporting_peer_as_owner: [{
    name: "id",
    type: DataType.Uuid
  }],
  update_passporting_peer_as_owner: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "name",
      type: DataType.Text
    },
    {
      name: "issuer_public_key",
      type: DataType.Text
    },
    {
      name: "passporting_server_url_base",
      type: DataType.Text
    }
  ],
  add_peer_to_club_as_owner: [{
    name: "passporting_club_id",
    type: DataType.Uuid
  }, {
    name: "passporting_peer_id",
    type: DataType.Uuid
  }],
  delete_peer_from_club_as_owner: [{
    name: "passporting_club_id",
    type: DataType.Uuid
  }, {
    name: "passporting_peer_id",
    type: DataType.Uuid
  }],
  get_passporting_peers: [],
  check_balance: [{
    name: "address",
    type: DataType.Text
  }, {
    name: "token",
    type: DataType.Text
  }],
  get_wallet_with_balance: [{
    name: "token",
    type: DataType.Text
  }],
  request_withdrawal: [{
    name: "token",
    type: DataType.Text
  }],
  get_allowance: [],
  action_costing_gas: [],
  action_costing_idos_token: [{
    name: "amount",
    type: DataType.Int
  }],
  get_issuer_fee: [{
    name: "credential_id",
    type: DataType.Uuid
  }],
  action_costing_fee: [{
    name: "credential_id",
    type: DataType.Uuid
  }],
  request_balance_withdrawal: [{
    name: "token",
    type: DataType.Text
  }, {
    name: "evm_address_to",
    type: DataType.Text
  }]
};
var AddInserterAsOwnerInputSchema = object({
  id: uuid2(),
  name: string2()
});
var DeleteInserterAsOwnerInputSchema = object({ id: uuid2() });
var AddDelegateAsOwnerInputSchema = object({
  address: string2(),
  inserter_id: uuid2()
});
var DeleteDelegateAsOwnerInputSchema = object({ address: string2() });
var AddUserAsInserterInputSchema = object({
  id: uuid2(),
  recipient_encryption_public_key: string2(),
  encryption_password_store: encryptionPasswordStoreSchema
});
var UpdateUserPubKeyAsInserterInputSchema = object({
  id: uuid2(),
  recipient_encryption_public_key: string2(),
  encryption_password_store: encryptionPasswordStoreSchema
});
var GetUserOutputSchema = object({
  id: uuid2(),
  recipient_encryption_public_key: string2(),
  encryption_password_store: encryptionPasswordStoreSchema
});
async function getUser(kwilClient) {
  return await kwilClient.call({
    name: "get_user",
    inputs: {}
  }).then((result) => result[0]);
}
var GetUserAsInserterInputSchema = object({ id: uuid2() });
var GetUserAsInserterOutputSchema = object({
  id: uuid2(),
  recipient_encryption_public_key: string2(),
  encryption_password_store: encryptionPasswordStoreSchema,
  inserter: string2()
});
var UpsertWalletAsInserterInputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  address: string2(),
  public_key: string2().nullable(),
  wallet_type: walletTypeSchema,
  message: string2(),
  signature: string2()
});
var AddWalletInputSchema = object({
  id: uuid2(),
  address: string2(),
  public_key: string2().nullable(),
  wallet_type: walletTypeSchema,
  message: string2(),
  signature: string2()
});
async function addWallet(kwilClient, params) {
  const inputs = AddWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_wallet",
    inputs,
    description: "Add a wallet to idOS"
  });
}
var GetWalletsOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  address: string2(),
  public_key: string2().nullable(),
  wallet_type: walletTypeSchema,
  message: string2(),
  signature: string2(),
  inserter: string2().nullable()
});
async function getWallets(kwilClient) {
  return await kwilClient.call({
    name: "get_wallets",
    inputs: {}
  });
}
var RemoveWalletInputSchema = object({ id: uuid2() });
async function removeWallet(kwilClient, params) {
  const inputs = RemoveWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_wallet",
    inputs,
    description: "Remove a wallet from idOS"
  });
}
var UpsertCredentialAsInserterInputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  issuer_auth_public_key: string2(),
  encryptor_public_key: string2(),
  content: string2(),
  public_notes: string2(),
  public_notes_signature: string2(),
  broader_signature: string2()
});
var AddCredentialInputSchema = object({
  id: uuid2(),
  issuer_auth_public_key: string2(),
  encryptor_public_key: string2(),
  content: string2(),
  public_notes: string2(),
  public_notes_signature: string2(),
  broader_signature: string2()
});
var GetCredentialsOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  public_notes: string2(),
  issuer_auth_public_key: string2(),
  inserter: string2().nullable(),
  original_id: uuid2().nullable()
});
async function getCredentials(kwilClient) {
  return await kwilClient.call({
    name: "get_credentials",
    inputs: {}
  });
}
var GetCredentialsSharedByUserInputSchema = object({
  user_id: uuid2(),
  original_issuer_auth_public_key: string2().nullable()
});
var GetCredentialsSharedByUserOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  public_notes: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2(),
  inserter: string2().nullable(),
  original_id: uuid2().nullable()
});
var EditCredentialInputSchema = object({
  id: uuid2(),
  public_notes: string2(),
  public_notes_signature: string2(),
  broader_signature: string2(),
  content: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2()
});
var EditPublicNotesAsIssuerInputSchema = object({
  public_notes_id: string2(),
  public_notes: string2()
});
var RemoveCredentialInputSchema = object({ id: uuid2() });
async function removeCredential(kwilClient, params) {
  const inputs = RemoveCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_credential",
    inputs,
    description: "Remove a credential from your idOS profile"
  });
}
var RescindSharedCredentialInputSchema = object({ credential_id: uuid2() });
var ShareCredentialInputSchema = object({
  id: uuid2(),
  original_credential_id: uuid2(),
  public_notes: string2(),
  public_notes_signature: string2(),
  broader_signature: string2(),
  content: string2(),
  content_hash: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2(),
  grantee_wallet_identifier: string2(),
  locked_until: number2()
});
async function shareCredential(kwilClient, params) {
  const inputs = ShareCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "share_credential",
    inputs,
    description: "Share a credential with creating AG"
  });
}
var CreateCredentialCopyInputSchema = object({
  id: uuid2(),
  original_credential_id: uuid2(),
  public_notes: string2(),
  public_notes_signature: string2(),
  broader_signature: string2(),
  content: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2()
});
async function createCredentialCopy(kwilClient, params) {
  const inputs = CreateCredentialCopyInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credential_copy",
    inputs,
    description: "Share a credential without AG (access grant)"
  });
}
var CreateCredentialsByDwgInputSchema = object({
  issuer_auth_public_key: string2(),
  original_encryptor_public_key: string2(),
  original_credential_id: uuid2(),
  original_content: string2(),
  original_public_notes: string2(),
  original_public_notes_signature: string2(),
  original_broader_signature: string2(),
  copy_encryptor_public_key: string2(),
  copy_credential_id: uuid2(),
  copy_content: string2(),
  copy_public_notes_signature: string2(),
  copy_broader_signature: string2(),
  content_hash: string2(),
  dwg_owner: string2(),
  dwg_grantee: string2(),
  dwg_issuer_public_key: string2(),
  dwg_id: uuid2(),
  dwg_access_grant_timelock: string2(),
  dwg_not_before: string2(),
  dwg_not_after: string2(),
  dwg_signature: string2()
});
var CredentialExistAsInserterInputSchema = object({ id: uuid2() });
var CredentialExistAsInserterOutputSchema = object({ credential_exist: boolean2() });
var GetCredentialOwnedInputSchema = object({ id: uuid2() });
var GetCredentialOwnedOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  public_notes: string2(),
  content: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2(),
  inserter: string2().nullable()
});
async function getCredentialOwned(kwilClient, params) {
  const inputs = GetCredentialOwnedInputSchema.parse(params);
  return await kwilClient.call({
    name: "get_credential_owned",
    inputs
  });
}
var GetCredentialSharedInputSchema = object({ id: uuid2() });
var GetCredentialSharedOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  public_notes: string2(),
  content: string2(),
  encryptor_public_key: string2(),
  issuer_auth_public_key: string2(),
  inserter: string2().nullable()
});
async function getCredentialShared(kwilClient, params) {
  const inputs = GetCredentialSharedInputSchema.parse(params);
  return await kwilClient.call({
    name: "get_credential_shared",
    inputs
  });
}
var GetSiblingCredentialIdInputSchema = object({ content_hash: string2() });
var GetSiblingCredentialIdOutputSchema = object({ id: uuid2() });
var AddAttributeAsInserterInputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  attribute_key: string2(),
  value: string2()
});
var AddAttributeInputSchema = object({
  id: uuid2(),
  attribute_key: string2(),
  value: string2()
});
async function addAttribute(kwilClient, params) {
  const inputs = AddAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute",
    inputs,
    description: "Create a new attribute in your idOS profile"
  });
}
var GetAttributesOutputSchema = object({
  id: uuid2(),
  user_id: uuid2(),
  attribute_key: string2(),
  value: string2(),
  original_id: uuid2()
});
async function getAttributes(kwilClient) {
  return await kwilClient.call({
    name: "get_attributes",
    inputs: {}
  });
}
var EditAttributeInputSchema = object({
  id: uuid2(),
  attribute_key: string2(),
  value: string2()
});
var RemoveAttributeInputSchema = object({ id: uuid2() });
var ShareAttributeInputSchema = object({
  id: uuid2(),
  original_attribute_id: uuid2(),
  attribute_key: string2(),
  value: string2()
});
var DwgMessageInputSchema = object({
  owner_wallet_identifier: string2(),
  grantee_wallet_identifier: string2(),
  issuer_public_key: string2(),
  id: uuid2(),
  access_grant_timelock: string2(),
  not_usable_before: string2(),
  not_usable_after: string2()
});
var DwgMessageOutputSchema = object({ message: string2() });
async function dwgMessage(kwilClient, params) {
  const inputs = DwgMessageInputSchema.parse(params);
  return await kwilClient.call({
    name: "dwg_message",
    inputs
  }).then((result) => result[0]);
}
var RevokeAccessGrantInputSchema = object({ id: uuid2() });
async function revokeAccessGrant(kwilClient, params) {
  const inputs = RevokeAccessGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "revoke_access_grant",
    inputs,
    description: "Revoke an Access Grant from idOS"
  });
}
var GetAccessGrantsOwnedOutputSchema = object({
  id: uuid2(),
  ag_owner_user_id: uuid2(),
  ag_grantee_wallet_identifier: string2(),
  data_id: uuid2(),
  locked_until: number2(),
  content_hash: string2().nullable(),
  inserter_type: string2(),
  inserter_id: string2()
});
async function getAccessGrantsOwned(kwilClient) {
  return await kwilClient.call({
    name: "get_access_grants_owned",
    inputs: {}
  });
}
var GetAccessGrantsGrantedInputSchema = object({
  user_id: uuid2().nullable(),
  page: number2(),
  size: number2()
});
var GetAccessGrantsGrantedOutputSchema = object({
  id: uuid2(),
  ag_owner_user_id: uuid2(),
  ag_grantee_wallet_identifier: string2(),
  data_id: uuid2(),
  locked_until: number2(),
  content_hash: string2().nullable(),
  inserter_type: string2(),
  inserter_id: string2()
});
async function getAccessGrantsGranted(kwilClient, params) {
  const inputs = GetAccessGrantsGrantedInputSchema.parse(params);
  return await kwilClient.call({
    name: "get_access_grants_granted",
    inputs
  });
}
var GetAccessGrantsGrantedCountInputSchema = object({ user_id: uuid2().nullable() });
var GetAccessGrantsGrantedCountOutputSchema = object({ count: number2() });
async function getAccessGrantsGrantedCount(kwilClient, params) {
  const inputs = GetAccessGrantsGrantedCountInputSchema.parse(params);
  return await kwilClient.call({
    name: "get_access_grants_granted_count",
    inputs
  }).then((result) => result[0]);
}
var HasLockedAccessGrantsInputSchema = object({ id: uuid2() });
var HasLockedAccessGrantsOutputSchema = object({ has: boolean2() });
var DagMessageInputSchema = object({
  dag_owner_wallet_identifier: string2(),
  dag_grantee_wallet_identifier: string2(),
  dag_data_id: uuid2(),
  dag_locked_until: number2(),
  dag_content_hash: string2()
});
var DagMessageOutputSchema = object({ message: string2() });
async function dagMessage(kwilClient, params) {
  const inputs = DagMessageInputSchema.parse(params);
  return await kwilClient.call({
    name: "dag_message",
    inputs
  }).then((result) => result[0]);
}
var CreateAgByDagForCopyInputSchema = object({
  dag_owner_wallet_identifier: string2(),
  dag_grantee_wallet_identifier: string2(),
  dag_data_id: uuid2(),
  dag_locked_until: number2(),
  dag_content_hash: string2(),
  dag_signature: string2()
});
var GetAccessGrantsForCredentialInputSchema = object({ credential_id: uuid2() });
var GetAccessGrantsForCredentialOutputSchema = object({
  id: uuid2(),
  ag_owner_user_id: uuid2(),
  ag_grantee_wallet_identifier: string2(),
  data_id: uuid2(),
  locked_until: number2(),
  content_hash: string2().nullable(),
  inserter_type: string2(),
  inserter_id: string2()
});
var HasProfileInputSchema = object({ address: string2() });
var HasProfileOutputSchema = object({ has_profile: boolean2() });
async function hasProfile(kwilClient, params) {
  const inputs = HasProfileInputSchema.parse(params);
  return await kwilClient.call({
    name: "has_profile",
    inputs
  }, void 0).then((result) => result[0]);
}
var AddPassportingClubAsOwnerInputSchema = object({
  id: uuid2(),
  name: string2()
});
var DeletePassportingClubAsOwnerInputSchema = object({ id: uuid2() });
var AddPassportingPeerAsOwnerInputSchema = object({
  id: uuid2(),
  name: string2(),
  issuer_public_key: string2(),
  passporting_server_url_base: string2()
});
var DeletePassportingPeerAsOwnerInputSchema = object({ id: uuid2() });
var UpdatePassportingPeerAsOwnerInputSchema = object({
  id: uuid2(),
  name: string2(),
  issuer_public_key: string2(),
  passporting_server_url_base: string2()
});
var AddPeerToClubAsOwnerInputSchema = object({
  passporting_club_id: uuid2(),
  passporting_peer_id: uuid2()
});
var DeletePeerFromClubAsOwnerInputSchema = object({
  passporting_club_id: uuid2(),
  passporting_peer_id: uuid2()
});
var GetPassportingPeersOutputSchema = object({
  id: uuid2(),
  name: string2(),
  issuer_public_key: string2(),
  passporting_server_url_base: string2(),
  club_id: uuid2(),
  club_name: string2()
});
var CheckBalanceInputSchema = object({
  address: string2(),
  token: string2()
});
var CheckBalanceOutputSchema = object({ balance: number2() });
var GetWalletWithBalanceInputSchema = object({ token: string2() });
var GetWalletWithBalanceOutputSchema = object({ wallet_address: string2() });
var RequestWithdrawalInputSchema = object({ token: string2() });
var GetAllowanceOutputSchema = object({ gas_allowance: number2() });
var ActionCostingIdosTokenInputSchema = object({ amount: number2() });
var GetIssuerFeeInputSchema = object({ credential_id: uuid2() });
var GetIssuerFeeOutputSchema = object({ issuer_fee: number2() });
var ActionCostingFeeInputSchema = object({ credential_id: uuid2() });
var RequestBalanceWithdrawalInputSchema = object({
  token: string2(),
  evm_address_to: string2()
});
async function addWallets(kwilClient, wallets) {
  await Promise.all(wallets.map((wallet) => addWallet(kwilClient, wallet)));
}
var GET_GRANTS_DEFAULT_RECORDS_PER_PAGE = 10;
async function getGrants(kwilClient, params = {
  page: 1,
  size: GET_GRANTS_DEFAULT_RECORDS_PER_PAGE,
  user_id: null
}) {
  return getAccessGrantsGranted(kwilClient, {
    page: params.page ?? 1,
    size: params.size ?? 10,
    user_id: params.user_id ?? null
  });
}

// packages/kwil-infra/dist/utils-CVZLwGDb.mjs
var import_xrpl = __toESM(require_npm(), 1);
function createXummPayload(message) {
  const memoData = Buffer.from(message).toString("hex");
  return {
    custom_meta: { instruction: message },
    txjson: {
      TransactionType: "SignIn",
      Memos: [{ Memo: {
        MemoData: memoData,
        MemoType: Buffer.from("idOS").toString("hex")
      } }]
    }
  };
}
function signXummTx(xummInstance, payload) {
  return new Promise((resolve) => {
    xummInstance.payload?.createAndSubscribe(payload, async (event) => {
      if (!event.payload.response.hex) return;
      const hex = event.payload.response.hex;
      resolve(hex);
    });
  });
}
async function getXummPublicKey(wallet) {
  return (0, import_xrpl.decode)(await signXummTx(wallet, createXummPayload("Sign request from idOS"))).SigningPubKey;
}
function signGemWalletTx(gemWalletInstance, message) {
  return gemWalletInstance.signMessage(message).then((response) => response.result?.signedMessage);
}
async function getGemWalletPublicKey(wallet) {
  if ("isInstalled" in wallet) {
    await wallet.isInstalled();
    const { publicKey, address } = await wallet.getPublicKey().then((res) => res.result);
    return {
      address,
      publicKey
    };
  }
}
async function getXrpAddress(wallet) {
  if ("isInstalled" in wallet) {
    await wallet.isInstalled();
    return wallet.getAddress().then((response) => response.result?.address);
  }
  return wallet.user.account;
}
function looksLikeXrpWallet(wallet) {
  return wallet !== null && typeof wallet === "object" && ("authorize" in wallet || "isInstalled" in wallet);
}
async function getXrpWalletType(object2) {
  if ("authorize" in object2) return "Xumm";
  if ("isInstalled" in object2) return "GemWallet";
  throw new Error("Unknown wallet type");
}
async function getXrpTxHash(message, wallet) {
  let messageString;
  const xrpWalletType = await getXrpWalletType(wallet);
  messageString = typeof message === "string" ? message : Buffer.from(message).toString("utf8");
  if (xrpWalletType === "Xumm") {
    const memoData = Buffer.from(messageString).toString("hex");
    const xummTx = await signXummTx(wallet, {
      custom_meta: { instruction: messageString },
      txjson: {
        TransactionType: "SignIn",
        Memos: [{ Memo: {
          MemoData: memoData,
          MemoType: Buffer.from("idOS").toString("hex")
        } }]
      }
    });
    console.log("xummTx", xummTx);
  } else if (xrpWalletType === "GemWallet") {
    const signature = await signGemWalletTx(wallet, messageString);
    if (!signature) throw new Error("Failed to sign transaction with GemWallet");
    return signature;
  }
}
async function getXrpPublicKey(wallet) {
  if (await getXrpWalletType(wallet) === "Xumm") {
    const publicKey = await getXummPublicKey(wallet);
    return {
      address: await getXrpAddress(wallet),
      publicKey
    };
  }
  return getGemWalletPublicKey(wallet);
}

// packages/kwil-infra/dist/index.mjs
var import_kwil_js2 = __toESM(require_dist(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var _KwilActionClient_instances, createActionInputs_fn, actionTypes_fn, _a2;
var KwilActionClient = (_a2 = class {
  constructor(client) {
    __privateAdd(this, _KwilActionClient_instances);
    __publicField(this, "signer");
    __publicField(this, "client");
    this.client = client;
  }
  /**
  * Calls an action on the kwil nodes. This similar to `GET` like request.
  */
  async call(params, signer = this.signer) {
    const action = {
      name: params.name,
      namespace: "main",
      inputs: __privateMethod(this, _KwilActionClient_instances, createActionInputs_fn).call(this, params.name, params.inputs),
      types: __privateMethod(this, _KwilActionClient_instances, actionTypes_fn).call(this, params.name)
    };
    return (await this.client.call(action, signer))?.data?.result;
  }
  /**
  * Executes an action on the kwil nodes. This similar to `POST` like request.
  */
  async execute(params, signer = this.signer, synchronous = true) {
    invariant(signer, "Signer is not set, you must set it before executing an action");
    const action = {
      name: params.name,
      namespace: "main",
      description: params.description,
      inputs: [__privateMethod(this, _KwilActionClient_instances, createActionInputs_fn).call(this, params.name, params.inputs)],
      types: __privateMethod(this, _KwilActionClient_instances, actionTypes_fn).call(this, params.name)
    };
    return (await this.client.execute(action, signer, synchronous)).data?.tx_hash;
  }
  setSigner(signer) {
    this.signer = signer;
  }
}, _KwilActionClient_instances = new WeakSet(), createActionInputs_fn = function(actionName, params = {}) {
  if (!params || !Object.keys(params).length) return [];
  return actionSchema[actionName].map(({ name }) => {
    const value = params[name];
    if (value === "" || value === 0) return value;
    return value ?? null;
  });
}, actionTypes_fn = function(actionName) {
  return actionSchema[actionName].map((arg) => arg.type);
}, _a2);
var DEFAULT_TIMEOUT = 3e4;
var createKwilClient = (Cls) => async ({ nodeUrl: kwilProvider, chainId }) => {
  const _kwil = new Cls({
    kwilProvider,
    chainId: ""
  });
  chainId || (chainId = (await _kwil.chainInfo({ disableWarning: true })).data?.chain_id);
  invariant(chainId, "Can't discover `chainId`. You must pass it explicitly.");
  return new KwilActionClient(new Cls({
    kwilProvider,
    chainId,
    timeout: DEFAULT_TIMEOUT
  }));
};
var createNodeKwilClient = createKwilClient(import_kwil_js2.NodeKwil);
var createWebKwilClient = createKwilClient(import_kwil_js2.WebKwil);
var NEAR_WALLET_TYPES = [
  "browser",
  "injected",
  "instant-link",
  "hardware",
  "bridge"
];
function looksLikeNearWallet(signer) {
  return signer !== null && typeof signer === "object" && "id" in signer && "metadata" in signer && "type" in signer && typeof signer.type === "string" && NEAR_WALLET_TYPES.includes(signer.type);
}
var KwilNonce = class {
  constructor(length = 32) {
    __publicField(this, "bytes");
    this.bytes = crypto.getRandomValues(new Uint8Array(length));
  }
  get clampUTF8() {
    return this.bytes.map((byte) => byte & 127);
  }
};
function createNearWalletSigner(wallet, recipient) {
  return async (message) => {
    const messageString = typeof message === "string" ? message : decode5(message);
    if (!wallet.signMessage) throw new Error("Only wallets with signMessage are supported.");
    const nonceSuggestion = Buffer.from(new KwilNonce(32).bytes);
    const { nonce = nonceSuggestion, signature, callbackUrl } = await wallet.signMessage({
      message: messageString,
      recipient,
      nonce: nonceSuggestion
    });
    const nep413BorshPayload = serialize({ struct: {
      tag: "u32",
      message: "string",
      nonce: { array: {
        type: "u8",
        len: 32
      } },
      recipient: "string",
      callbackUrl: { option: "string" }
    } }, {
      tag: 2147484061,
      message: messageString,
      nonce: Array.from(nonce),
      recipient,
      callbackUrl
    });
    return concat(writeUint16BE(nep413BorshPayload.length), nep413BorshPayload, decode4(signature));
  };
}
function implicitAddressFromPublicKey(publicKey) {
  return encode5(bs58Decode(publicKey.replace(/^ed25519:/, "")));
}
async function signNearMessage(wallet, message, recipient = "idos.network") {
  return encode5(await createNearWalletSigner(wallet, recipient)(message));
}
async function createNearWalletKwilSigner(wallet, currentAddress, store, kwilClient, recipient = "idos.network") {
  if (!wallet.signMessage) throw new Error("Only wallets with signMessage are supported.");
  if (wallet.id === "my-near-wallet") {
    const { accountId, signature, publicKey: publicKey$1, error } = Object.fromEntries(new URLSearchParams(window.location.hash.slice(1)).entries());
    if (signature) {
      await store.set("signer-address", accountId);
      await store.set("signer-public-key", publicKey$1);
    }
    const signMessageOriginal = wallet.signMessage.bind(wallet);
    wallet.signMessage = async ({ message, recipient: recipient$1 }) => {
      if (error) return Promise.reject();
      const lastMessage = await store.get("sign-last-message");
      const lastNonce = await store.get("sign-last-nonce");
      if (signature && message === lastMessage && lastNonce) {
        const nonce$1 = Buffer.from(lastNonce);
        const callbackUrl$1 = await store.get("sign-last-url");
        return Promise.resolve({
          accountId: currentAddress,
          publicKey: publicKey$1,
          signature,
          nonce: nonce$1,
          message,
          callbackUrl: callbackUrl$1
        });
      }
      const callbackUrl = window.location.href;
      const nonce = Buffer.from(new KwilNonce(32).clampUTF8);
      await store.set("sign-last-message", message);
      await store.set("sign-last-nonce", Array.from(nonce));
      await store.set("sign-last-url", callbackUrl);
      signMessageOriginal({
        message,
        nonce,
        recipient: recipient$1,
        callbackUrl
      });
      return new Promise(() => ({}));
    };
  }
  const storedAddress = await store.get("signer-address");
  let publicKey = await store.get("signer-public-key");
  if (storedAddress !== currentAddress || !publicKey) {
    store.reset();
    await kwilClient.client.auth.logoutKGW();
    const message = "idOS authentication";
    const nonce = Buffer.from(new KwilNonce(32).bytes);
    ({ publicKey } = await wallet.signMessage({
      message,
      recipient,
      nonce
    }));
    await store.set("signer-address", currentAddress);
    await store.set("signer-public-key", publicKey);
  }
  return {
    kwilSigner: new import_kwil_js2.KwilSigner(createNearWalletSigner(wallet, recipient), implicitAddressFromPublicKey(publicKey), "nep413"),
    publicKey
  };
}
async function createXrpKwilSigner(wallet, currentAddress, store, kwilClient, walletPublicKey) {
  const storedAddress = await store.get("signer-address");
  const storePublicKey = await store.get("signer-public-key");
  if (storedAddress !== currentAddress || storePublicKey && storePublicKey !== walletPublicKey) try {
    console.log("logoutKGW", kwilClient);
  } catch (error) {
    console.error("Failed to logout KGW:", error);
  }
  await store.set("signer-address", currentAddress);
  await store.set("signer-public-key", walletPublicKey);
  const signer = async (message) => {
    const signature = await getXrpTxHash(message, wallet);
    if (!signature) throw new Error("Failed to sign transaction with XRP");
    return Buffer.from(signature, "hex");
  };
  return new import_kwil_js2.KwilSigner(signer, walletPublicKey, "xrpl");
}
async function createClientKwilSigner(store, kwilClient, wallet) {
  if ("connect" in wallet && "address" in wallet) {
    wallet = wallet;
    const currentAddress = await wallet.getAddress();
    if (await store.get("signer-address") !== currentAddress) {
      store.set("signer-address", currentAddress);
      try {
        await kwilClient.client.auth.logoutKGW();
      } catch (error) {
        console.log("error logoutKGW", error);
      }
    }
    return [
      new import_kwil_js2.KwilSigner(wallet, currentAddress),
      currentAddress,
      void 0,
      "EVM"
    ];
  }
  if (looksLikeNearWallet(wallet)) {
    const accounts = await wallet.getAccounts();
    const { kwilSigner, publicKey } = await createNearWalletKwilSigner(wallet, accounts[0].accountId, store, kwilClient);
    return [
      kwilSigner,
      accounts[0].accountId,
      publicKey,
      "NEAR"
    ];
  }
  if (looksLikeXrpWallet(wallet)) {
    const { address: currentAddress, publicKey: walletPublicKey } = await getXrpPublicKey(wallet);
    if (!currentAddress) throw new Error("Failed to get XRP address");
    return [
      await createXrpKwilSigner(wallet, currentAddress, store, kwilClient, walletPublicKey),
      currentAddress,
      walletPublicKey,
      "XRPL"
    ];
  }
  if ("signatureType" in wallet && "publicAddress" in wallet) return [
    wallet,
    wallet.publicAddress,
    wallet.publicKey,
    "Stellar"
  ];
  return ((_) => {
    throw new Error("Invalid `signer` type");
  })(wallet);
}

// packages/utils/dist/store/index.mjs
var setDuration = (days) => {
  const daysNumber = !days || Number.isNaN(Number(days)) ? void 0 : Number.parseInt(days.toString(), 10);
  if (!daysNumber) return;
  const date3 = /* @__PURE__ */ new Date();
  date3.setTime(date3.getTime() + daysNumber * 24 * 60 * 60 * 1e3);
  return date3;
};
var durationElapsed = (date3) => {
  if (!date3) return false;
  const str = JSON.parse(date3);
  const expires = Date.parse(str);
  if (Number.isNaN(expires)) return false;
  return expires < Date.now();
};
var _LocalStorageStore_instances, setLocalStorage_fn, getLocalStorage_fn, removeLocalStorage_fn, _a3;
var LocalStorageStore = (_a3 = class {
  constructor(storage = window.localStorage, keyPrefix = "idOS-") {
    __privateAdd(this, _LocalStorageStore_instances);
    __publicField(this, "keyPrefix");
    __publicField(this, "storage");
    __publicField(this, "REMEMBER_DURATION_KEY", "storage-expiration");
    this.storage = storage;
    this.keyPrefix = keyPrefix;
    this.checkRememberDurationElapsed();
  }
  pipeCodec({ encode: encode9, decode: decode10 }) {
    const store = Object.create(Object.getPrototypeOf(this));
    Object.assign(store, this);
    store.get = async (key) => {
      const result = await this.get(key);
      if (result) return decode10(result);
    };
    store.set = async (key, value) => {
      await this.set(key, encode9(value));
    };
    return store;
  }
  get(key) {
    const value = __privateMethod(this, _LocalStorageStore_instances, getLocalStorage_fn).call(this, key);
    if (!value) return Promise.resolve(void 0);
    return Promise.resolve(JSON.parse(value));
  }
  setRememberDuration(days) {
    const date3 = setDuration(days);
    if (!date3) __privateMethod(this, _LocalStorageStore_instances, removeLocalStorage_fn).call(this, this.REMEMBER_DURATION_KEY);
    else __privateMethod(this, _LocalStorageStore_instances, setLocalStorage_fn).call(this, this.REMEMBER_DURATION_KEY, JSON.stringify(date3.toISOString()));
    return Promise.resolve();
  }
  async checkRememberDurationElapsed() {
    if (await this.hasRememberDurationElapsed()) await this.reset();
  }
  async hasRememberDurationElapsed() {
    const value = __privateMethod(this, _LocalStorageStore_instances, getLocalStorage_fn).call(this, this.REMEMBER_DURATION_KEY);
    try {
      return durationElapsed(value);
    } catch (_) {
      __privateMethod(this, _LocalStorageStore_instances, removeLocalStorage_fn).call(this, this.REMEMBER_DURATION_KEY);
      return false;
    }
  }
  set(key, value) {
    if (!key || typeof key !== "string") throw new Error(`Bad key: ${key}`);
    if (!value) return Promise.resolve();
    __privateMethod(this, _LocalStorageStore_instances, setLocalStorage_fn).call(this, key, JSON.stringify(value));
    return Promise.resolve();
  }
  delete(key) {
    __privateMethod(this, _LocalStorageStore_instances, removeLocalStorage_fn).call(this, key);
    return Promise.resolve();
  }
  async reset() {
    for (const key of Object.keys(this.storage)) if (key.startsWith(this.keyPrefix)) this.storage.removeItem(key);
  }
}, _LocalStorageStore_instances = new WeakSet(), setLocalStorage_fn = function(key, value) {
  this.storage.setItem(`${this.keyPrefix}${key}`, value);
}, getLocalStorage_fn = function(key) {
  return this.storage.getItem(`${this.keyPrefix}${key}`);
}, removeLocalStorage_fn = function(key) {
  this.storage.removeItem(`${this.keyPrefix}${key}`);
}, _a3);

// packages/enclave/dist/keys-CUGWRx3s.mjs
var BaseProvider = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "_signMethod");
    __publicField(this, "_signMethodType");
    this.options = options;
  }
  /**
  * Sets the signer for the enclave.
  *
  * @param signer - The signer to set, is later used for MPC if allowed.
  */
  setSigner(signer) {
    if (signer.signTypedData) {
      this._signMethod = signer.signTypedData.bind(signer);
      this._signMethodType = "signTypedData";
    } else if (signer.signMessage) {
      this._signMethod = signer.signMessage.bind(signer);
      this._signMethodType = "signMessage";
    } else if (signer.signer) {
      this._signMethod = signer.signer.bind(signer);
      this._signMethodType = "signer";
    } else if (["signMessage", "signer"].some((key) => key in signer)) this._signMethod = signer.signMessage ? signer.signMessage.bind(signer) : signer.signer?.bind(signer);
    else throw new Error("No sign method found in passed signer");
  }
  async signTypedData(domain, types, value) {
    if (!this._signMethod || !this._signMethodType) throw new Error("Signer is not set");
    let signature;
    if (this._signMethodType === "signTypedData") signature = await this._signMethod(domain, types, value);
    else if (this._signMethodType === "signMessage" || this._signMethodType === "signer") {
      const messageString = JSON.stringify(value);
      const response = await this._signMethod(messageString);
      if (typeof response === "string") signature = response;
      else if (response?.result?.signedMessage) signature = response.result.signedMessage;
      else if (response?.signedMessage) signature = response.signedMessage;
      else if (response instanceof Uint8Array && response.length === 64) return encode5(response);
      else throw new Error(`Unexpected response format from ${this._signMethodType}: ${JSON.stringify(response)}`);
    } else throw new Error(`Unknown sign method type: ${this._signMethodType}`);
    return signature;
  }
  /**
  * Helper method to get the user ID.
  *
  * @returns The user ID.
  */
  get userId() {
    if (!this.options.userId) throw new Error("User ID is not present");
    return this.options.userId;
  }
  /**
  * Resets the enclave (storage etc.)
  */
  async reset() {
  }
  /**
  * Reconfigures the enclave (theme etc).
  *
  * @param options - The options to reconfigure.
  */
  async reconfigure(options = {}) {
    Object.assign(this.options, options);
  }
  /**
  * Loads the enclave (create iframe, open connection, etc.)
  */
  async load() {
    await this.reconfigure();
  }
  /**
  * Encrypts a message to a receiver.
  * This method also checks if the user is authorized to use the keys.
  *
  * @param _message - The message to encrypt.
  * @param _receiverPublicKey - The public key of the receiver.
  *
  * @returns The encrypted message.
  */
  async encrypt(_message, _receiverPublicKey) {
    throw new Error("Method 'encrypt' has to be implemented in the subclass.");
  }
  /**
  * Decrypts a message from a sender.
  * This method also checks if the user is authorized to use the keys.
  *
  * @param _message - The message to decrypt.
  * @param _senderPublicKey - The public key of the sender.
  *
  * @returns The decrypted message.
  */
  async decrypt(_message, _senderPublicKey) {
    throw new Error("Method 'decrypt' has to be implemented in the subclass.");
  }
  /**
  * This method is used to confirm the user action.
  *
  * @param _message - The message to confirm.
  *
  * @returns `true` if the user action is confirmed, `false` otherwise.
  */
  async confirm(_message) {
    throw new Error("Method 'confirm' has to be implemented in the subclass.");
  }
  /**
  * This method is used to backup the password context.
  */
  async backupUserEncryptionProfile() {
    throw new Error("Method 'backupUserEncryptionProfile' has to be implemented in the subclass.");
  }
  /**
  * Gets the public encryption profile.
  *
  * @returns The public encryption profile.
  */
  async ensureUserEncryptionProfile() {
    throw new Error("Method 'ensureUserEncryptionProfile' has to be implemented in the subclass.");
  }
  /**
  * This method authorizes the origin in case of enclave
  * to use the keys, without user providing the password or MPC again.
  *
  * @returns `true` if the user action is authorized, `false` otherwise.
  */
  async guardKeys() {
    return true;
  }
  /**
  * Filters the credentials based on the private field filters.
  *
  * @param credentials - The credentials to filter.
  * @param privateFieldFilters - The private field filters.
  *
  * @returns The filtered credentials without the content.
  */
  async filterCredentials(credentials, privateFieldFilters) {
    if (Object.keys(privateFieldFilters.pick).length === 0 && Object.keys(privateFieldFilters.omit).length === 0) return credentials.map((credential) => ({
      ...credential,
      content: ""
    }));
    return (await Promise.all(credentials.map(async (credential) => {
      const content = await this.decrypt(decode4(credential.content), decode4(credential.encryptor_public_key));
      let json;
      try {
        json = fromBytesToJson(content);
      } catch (_e) {
        throw new Error(`Credential ${credential.id} decrypted contents are not valid JSON`);
      }
      return {
        ...credential,
        content: json
      };
    }))).filter(({ content }) => recordFilter(content, privateFieldFilters.pick, privateFieldFilters.omit)).map((credential) => ({
      ...credential,
      content: ""
    }));
  }
  async addAddressMessageToSign(_address, _publicKey, _addressToAddType) {
    throw new Error("Method 'addAddressMessageToSign' has to be implemented in the subclass.");
  }
  async removeAddressMessageToSign(_address, _publicKey, _addressToRemoveType) {
    throw new Error("Method 'removeAddressMessageToSign' has to be implemented in the subclass.");
  }
  async addAddressToMpcSecret(_userId, _message, _signature) {
    throw new Error("Method 'addAddressToMpcSecret' has to be implemented in the subclass.");
  }
  async removeAddressFromMpcSecret(_userId, _message, _signature) {
    throw new Error("Method 'removeAddressFromMpcSecret' has to be implemented in the subclass.");
  }
};

// packages/client/dist/index.js
var IframeEnclave = class extends BaseProvider {
  constructor(options) {
    super(options);
    __publicField(this, "container");
    __publicField(this, "iframe");
    __publicField(this, "hostUrl");
    __publicField(this, "bound", false);
    if (!this.options.container) throw new Error("container is required");
    this.container = this.options.container;
    this.hostUrl = new URL(this.options.url ?? "https://enclave.idos.network");
    this.iframe = document.createElement("iframe");
    this.iframe.id = "idos-enclave-iframe";
  }
  /** @see parent method */
  async load() {
    await this.createAndLoadIframe();
    await this.requestToEnclave("load");
    await this.reconfigure();
    await this.bindMessageListener();
  }
  /** @override parent method to call iframe */
  async reset() {
    this.requestToEnclave("reset");
  }
  /** @override parent method to call iframe */
  async reconfigure(options = {}) {
    super.reconfigure(options);
    await this.requestToEnclave("reconfigure", this.options);
  }
  /** @override parent method to call iframe */
  async confirm(message) {
    this.showEnclave();
    try {
      return await this.requestToEnclave("confirm", message);
    } catch (error) {
      console.error(error);
      return false;
    } finally {
      this.hideEnclave();
    }
  }
  /** @override parent method to call iframe */
  async filterCredentials(credentials, privateFieldFilters) {
    return await this.requestToEnclave("filterCredentials", credentials, privateFieldFilters);
  }
  /** @override parent method to call iframe */
  async encrypt(message, receiverPublicKey) {
    return this.requestToEnclave("encrypt", message, receiverPublicKey);
  }
  /** @override parent method to call iframe */
  async decrypt(message, senderPublicKey) {
    return this.requestToEnclave("decrypt", message, senderPublicKey);
  }
  /** @override parent method to call iframe */
  async backupUserEncryptionProfile() {
    this.showEnclave();
    try {
      await this.requestToEnclave("backupUserEncryptionProfile");
    } catch (error) {
      console.error(error);
    } finally {
      this.hideEnclave();
    }
  }
  /** @override parent method to call iframe */
  async ensureUserEncryptionProfile() {
    this.showEnclave();
    try {
      return await this.requestToEnclave("ensureUserEncryptionProfile");
    } finally {
      this.hideEnclave();
    }
  }
  async addAddressMessageToSign(address, publicKey, addressToAddType) {
    return this.requestToEnclave("addAddressMessageToSign", address, publicKey, addressToAddType);
  }
  async removeAddressMessageToSign(address, publicKey, addressToRemoveType) {
    return this.requestToEnclave("removeAddressMessageToSign", address, publicKey, addressToRemoveType);
  }
  async addAddressToMpcSecret(userId, message, signature) {
    return this.requestToEnclave("addAddressToMpcSecret", userId, message, signature);
  }
  async removeAddressFromMpcSecret(userId, message, signature) {
    return this.requestToEnclave("removeAddressFromMpcSecret", userId, message, signature);
  }
  async createAndLoadIframe() {
    const container = document.querySelector(this.container);
    if (!container) throw new Error(`Can't find container with selector ${this.container}`);
    const permissionsPolicies = ["publickey-credentials-get", "storage-access"];
    const liftedSandboxRestrictions = [
      "forms",
      "modals",
      "popups",
      "popups-to-escape-sandbox",
      "same-origin",
      "scripts"
    ].map((toLift) => `allow-${toLift}`);
    const referrerPolicy = "origin";
    const styles = {
      "aspect-ratio": "4/1",
      "background-color": "transparent",
      border: "none",
      display: "block",
      width: "100%"
    };
    this.iframe.allow = permissionsPolicies.join("; ");
    this.iframe.referrerPolicy = referrerPolicy;
    this.iframe.sandbox.add(...liftedSandboxRestrictions);
    this.iframe.src = this.hostUrl.toString();
    for (const [k, v] of Object.entries(styles)) this.iframe.style.setProperty(k, v);
    let el;
    while (el = document.getElementById(this.iframe.id)) {
      console.log("reinstalling idOS iframe...");
      container.removeChild(el);
    }
    container.appendChild(this.iframe);
    return new Promise((resolve) => this.iframe.addEventListener("load", () => {
      resolve();
    }, { once: true }));
  }
  showEnclave() {
    this.iframe.parentElement.classList.add("visible");
  }
  hideEnclave() {
    this.iframe.parentElement.classList.remove("visible");
  }
  async requestToEnclave(method, ...args) {
    return new Promise((resolve, reject) => {
      const { port1, port2 } = new MessageChannel();
      port1.onmessage = ({ data }) => {
        port1.close();
        data.error ? reject(data.error) : resolve(data.result);
      };
      this.iframe.contentWindow.postMessage({
        method,
        data: args
      }, this.hostUrl.origin, [port2]);
    });
  }
  bindMessageListener() {
    if (!this.bound) window.addEventListener("message", this.onMessage.bind(this));
    this.bound = true;
  }
  async onMessage(message) {
    if (!message || !message.data || typeof message.data !== "object") return;
    if (message.data.type !== "idOS:signTypedData" || message.origin !== this.hostUrl.origin) return;
    const payload = message.data.payload;
    const signature = await this.signTypedData(payload.domain, payload.types, payload.value);
    await this.requestToEnclave("signTypedDataResponse", signature);
  }
};
var idOSClientConfiguration = class {
  constructor(params) {
    __publicField(this, "state");
    __publicField(this, "chainId");
    __publicField(this, "nodeUrl");
    __publicField(this, "enclaveOptions");
    __publicField(this, "store");
    __publicField(this, "enclaveProvider");
    this.state = "configuration";
    this.chainId = params.chainId;
    this.nodeUrl = params.nodeUrl;
    this.enclaveOptions = params.enclaveOptions;
    this.store = params.store ?? new LocalStorageStore();
    if (params.enclaveProvider) this.enclaveProvider = new params.enclaveProvider({
      ...params.enclaveOptions,
      store: this.store
    });
    else this.enclaveProvider = new IframeEnclave(params.enclaveOptions);
  }
  async createClient() {
    return idOSClientIdle.fromConfig(this);
  }
};
var idOSClientIdle = class idOSClientIdle2 {
  constructor(store, kwilClient, enclaveProvider) {
    __publicField(this, "state");
    __publicField(this, "store");
    __publicField(this, "kwilClient");
    __publicField(this, "enclaveProvider");
    this.state = "idle";
    this.store = store;
    this.kwilClient = kwilClient;
    this.enclaveProvider = enclaveProvider;
  }
  static async fromConfig(params) {
    const kwilClient = await createWebKwilClient({
      nodeUrl: params.nodeUrl,
      chainId: params.chainId
    });
    await params.enclaveProvider.load();
    return new idOSClientIdle2(params.store, kwilClient, params.enclaveProvider);
  }
  async addressHasProfile(address) {
    return hasProfile(this.kwilClient, { address }).then((res) => res.has_profile);
  }
  async withUserSigner(_signer) {
    let signer = _signer;
    const [kwilSigner, walletIdentifier, walletPublicKey, walletType] = await createClientKwilSigner(this.store, this.kwilClient, signer);
    this.kwilClient.setSigner(kwilSigner);
    if (walletType === "NEAR") {
      const originalSigner = signer;
      signer = { signMessage: async (message) => {
        return { signedMessage: await signNearMessage(originalSigner, message) };
      } };
    }
    return new idOSClientWithUserSigner(this, signer, kwilSigner, walletIdentifier, walletPublicKey, walletType);
  }
  async logOut() {
    return this;
  }
};
var idOSClientWithUserSigner = class {
  constructor(idOSClientIdle$1, signer, kwilSigner, walletIdentifier, walletPublicKey, walletType) {
    __publicField(this, "state");
    __publicField(this, "store");
    __publicField(this, "kwilClient");
    __publicField(this, "enclaveProvider");
    __publicField(this, "signer");
    __publicField(this, "kwilSigner");
    __publicField(this, "walletIdentifier");
    __publicField(this, "walletPublicKey");
    __publicField(this, "walletType");
    this.state = "with-user-signer";
    this.store = idOSClientIdle$1.store;
    this.kwilClient = idOSClientIdle$1.kwilClient;
    this.enclaveProvider = idOSClientIdle$1.enclaveProvider;
    this.signer = signer;
    this.kwilSigner = kwilSigner;
    this.walletIdentifier = walletIdentifier;
    this.walletPublicKey = walletPublicKey;
    this.walletType = walletType;
    this.enclaveProvider.setSigner(this.signer);
  }
  async logOut() {
    this.kwilClient.setSigner(void 0);
    return new idOSClientIdle(this.store, this.kwilClient, this.enclaveProvider);
  }
  async hasProfile() {
    return hasProfile(this.kwilClient, { address: this.walletIdentifier }).then((x) => x.has_profile);
  }
  async createUserEncryptionProfile(userId) {
    await this.enclaveProvider.reconfigure({
      mode: "new",
      userId,
      walletAddress: this.walletIdentifier,
      walletPublicKey: this.walletPublicKey,
      walletType: this.walletType,
      encryptionPasswordStore: void 0,
      expectedUserEncryptionPublicKey: void 0
    });
    return this.enclaveProvider.ensureUserEncryptionProfile();
  }
  async logIn() {
    if (!await this.hasProfile()) throw new Error("User does not have a profile");
    const kwilUser = await getUser(this.kwilClient);
    await this.enclaveProvider.reconfigure({
      mode: "existing",
      userId: kwilUser.id,
      expectedUserEncryptionPublicKey: kwilUser.recipient_encryption_public_key,
      walletAddress: this.walletIdentifier,
      walletType: this.walletType,
      encryptionPasswordStore: kwilUser.encryption_password_store,
      walletPublicKey: this.walletPublicKey
    });
    return new idOSClientLoggedIn(this, kwilUser);
  }
};
var idOSClientLoggedIn = class {
  constructor(idOSClientWithUserSigner$1, user) {
    __publicField(this, "state");
    __publicField(this, "store");
    __publicField(this, "kwilClient");
    __publicField(this, "enclaveProvider");
    __publicField(this, "signer");
    __publicField(this, "kwilSigner");
    __publicField(this, "walletIdentifier");
    __publicField(this, "walletPublicKey");
    __publicField(this, "walletType");
    __publicField(this, "user");
    this.state = "logged-in";
    this.store = idOSClientWithUserSigner$1.store;
    this.kwilClient = idOSClientWithUserSigner$1.kwilClient;
    this.enclaveProvider = idOSClientWithUserSigner$1.enclaveProvider;
    this.signer = idOSClientWithUserSigner$1.signer;
    this.kwilSigner = idOSClientWithUserSigner$1.kwilSigner;
    this.walletIdentifier = idOSClientWithUserSigner$1.walletIdentifier;
    this.walletPublicKey = idOSClientWithUserSigner$1.walletPublicKey;
    this.walletType = idOSClientWithUserSigner$1.walletType;
    this.user = user;
  }
  async logOut() {
    this.kwilClient.setSigner(void 0);
    return new idOSClientIdle(this.store, this.kwilClient, this.enclaveProvider);
  }
  async requestDWGMessage(params) {
    return dwgMessage(this.kwilClient, params).then((res) => res.message);
  }
  async removeCredential(id) {
    await removeCredential(this.kwilClient, { id });
    return { id };
  }
  async getCredentialById(id) {
    return getCredentialOwned(this.kwilClient, { id }).then((res) => res[0]);
  }
  async shareCredential(credential) {
    await shareCredential(this.kwilClient, credential);
    return credential;
  }
  async getAllCredentials() {
    return getCredentials(this.kwilClient);
  }
  async getAccessGrantsOwned() {
    return getAccessGrantsOwned(this.kwilClient);
  }
  async getAttributes() {
    return getAttributes(this.kwilClient);
  }
  async createAttribute(attribute) {
    await addAttribute(this.kwilClient, attribute);
    return attribute;
  }
  async getCredentialContentSha256Hash(id) {
    const credential = await this.getCredentialById(id);
    invariant(credential, `"idOSCredential" with id ${id} not found`);
    await this.enclaveProvider.ensureUserEncryptionProfile();
    return hexEncodeSha256Hash(await this.enclaveProvider.decrypt(decode4(credential.content), decode4(credential.encryptor_public_key)));
  }
  async getCredentialContent(id) {
    const credential = await this.getCredentialById(id);
    invariant(credential, `"idOSCredential" with id ${id} not found`);
    await this.enclaveProvider.ensureUserEncryptionProfile();
    return await this.enclaveProvider.decrypt(decode4(credential.content), decode4(credential.encryptor_public_key));
  }
  async createCredentialCopy(id, consumerRecipientEncryptionPublicKey, consumerAddress, lockedUntil) {
    const originalCredential = await this.getCredentialById(id);
    invariant(originalCredential, `"idOSCredential" with id ${id} not found`);
    await this.enclaveProvider.ensureUserEncryptionProfile();
    const decryptedContent = await this.enclaveProvider.decrypt(decode4(originalCredential.content), decode4(originalCredential.encryptor_public_key));
    const { content, encryptorPublicKey } = await this.enclaveProvider.encrypt(decryptedContent, decode4(consumerRecipientEncryptionPublicKey));
    const insertableCredential = {
      ...buildInsertableIDOSCredential(originalCredential.user_id, "", encode4(content), encode4(encryptorPublicKey)),
      grantee_wallet_identifier: consumerAddress,
      locked_until: lockedUntil
    };
    const copyId = crypto.randomUUID();
    await createCredentialCopy(this.kwilClient, {
      original_credential_id: originalCredential.id,
      ...originalCredential,
      ...insertableCredential,
      id: copyId
    });
    return { id: copyId };
  }
  async requestDAGMessage(params) {
    return dagMessage(this.kwilClient, params).then((res) => res.message);
  }
  async getGrants(params) {
    return {
      grants: await getGrants(this.kwilClient, params),
      totalCount: await this.getGrantsCount()
    };
  }
  async addWallets(params) {
    await addWallets(this.kwilClient, params);
    return params;
  }
  async getGrantsCount() {
    return getAccessGrantsGrantedCount(this.kwilClient, { user_id: null }).then((res) => res.count);
  }
  async getCredentialShared(id) {
    return getCredentialShared(this.kwilClient, { id }).then((res) => res[0]);
  }
  async revokeAccessGrant(id) {
    await revokeAccessGrant(this.kwilClient, { id });
    return { id };
  }
  async addWallet(params) {
    await addWallet(this.kwilClient, params);
    if (this.user.encryption_password_store !== "mpc") {
      console.log("MPC is not enabled or the user is not using MPC");
      return params;
    }
    if (!params.wallet_type) throw new Error("Wallet type is required for MPC users");
    const messageToSign = await this.enclaveProvider.addAddressMessageToSign(params.address, params.public_key ?? void 0, params.wallet_type);
    const signature = await this.enclaveProvider.signTypedData(messageToSign.domain, messageToSign.types, messageToSign.value);
    const result = await this.enclaveProvider.addAddressToMpcSecret(this.user.id, messageToSign.value, signature);
    if (result !== "success") console.error(`Failed to add wallet to MPC: ${result}`);
    return params;
  }
  async getWallets() {
    return getWallets(this.kwilClient);
  }
  async removeWallet(id) {
    const wallet = (await this.getWallets()).find((wallet$1) => wallet$1.id === id);
    if (!wallet) throw new Error(`Wallet with id ${id} not found`);
    await removeWallet(this.kwilClient, { id });
    if (this.user.encryption_password_store !== "mpc") {
      console.log("MPC is not enabled or the user is not using MPC");
      return { id };
    }
    const messageToSign = await this.enclaveProvider.removeAddressMessageToSign(wallet.address, wallet.public_key ?? void 0, wallet.wallet_type);
    const signature = await this.enclaveProvider.signTypedData(messageToSign.domain, messageToSign.types, messageToSign.value);
    const result = await this.enclaveProvider.removeAddressFromMpcSecret(wallet.user_id, messageToSign.value, signature);
    if (result !== "success") console.error(`Failed to add wallet to MPC: ${result}`);
    return { id };
  }
  async removeWallets(ids) {
    for (const id of ids) await this.removeWallet(id);
    return ids;
  }
  async filterCredentials(requirements) {
    let result = (await this.getAllCredentials()).filter((cred) => !cred.original_id && !!cred.public_notes).filter((cred) => {
      return requirements.acceptedIssuers?.some((issuer) => issuer.authPublicKey === cred.issuer_auth_public_key);
    });
    const publicNotesFieldFilters = requirements.publicNotesFieldFilters;
    const credentialLevelOrHigherFilter = requirements.credentialLevelOrHigherFilter;
    const privateFieldFilters = requirements.privateFieldFilters;
    if (credentialLevelOrHigherFilter) result = result.filter((credential) => {
      let publicNotes;
      try {
        publicNotes = JSON.parse(credential.public_notes);
      } catch (_) {
        throw new Error(`Credential ${credential.id} has non-JSON public notes.`);
      }
      return matchLevelOrHigher(credentialLevelOrHigherFilter.userLevel, credentialLevelOrHigherFilter.requiredAddons, publicNotes.level);
    });
    if (publicNotesFieldFilters && (Object.keys(publicNotesFieldFilters.pick).length > 0 || Object.keys(publicNotesFieldFilters.omit).length > 0)) result = result.filter((credential) => {
      let publicNotes;
      try {
        publicNotes = JSON.parse(credential.public_notes);
      } catch (_) {
        throw new Error(`Credential ${credential.id} has non-JSON public notes.`);
      }
      return recordFilter(publicNotes, publicNotesFieldFilters.pick, publicNotesFieldFilters.omit);
    });
    if (privateFieldFilters && (Object.keys(privateFieldFilters.pick).length > 0 || Object.keys(privateFieldFilters.omit).length > 0)) {
      const fullCredentials = await Promise.all(result.map((credential) => this.getCredentialById(credential.id)));
      invariant(fullCredentials.every((cred) => cred !== void 0), "Some credentials could not be fetched in full form for private field filtering");
      const matches2 = await this.enclaveProvider.filterCredentials(fullCredentials, privateFieldFilters);
      result = result.filter((credential) => matches2.some((matchedCredential) => matchedCredential.id === credential.id));
    }
    return result;
  }
  async requestAccessGrant(credentialId, { consumerEncryptionPublicKey, consumerAuthPublicKey, lockedUntil = 0 }) {
    const credential = await this.getCredentialById(credentialId);
    const contentHash = await this.getCredentialContentSha256Hash(credentialId);
    invariant(credential, `"idOSCredential" with id ${credentialId} not found`);
    const plaintextContent = decode5(await this.enclaveProvider.decrypt(decode4(credential.content), decode4(credential.encryptor_public_key)));
    await this.enclaveProvider.ensureUserEncryptionProfile();
    const { content, encryptorPublicKey } = await this.enclaveProvider.encrypt(encode6(plaintextContent), decode4(consumerEncryptionPublicKey));
    const insertableCredential = {
      ...credential,
      ...buildInsertableIDOSCredential(credential.user_id, "", encode4(content), encode4(encryptorPublicKey)),
      original_credential_id: credential.id,
      id: crypto.randomUUID(),
      grantee_wallet_identifier: consumerAuthPublicKey,
      locked_until: lockedUntil,
      content_hash: contentHash
    };
    await this.shareCredential(insertableCredential);
    return insertableCredential;
  }
};
function createIDOSClient(params) {
  return new idOSClientConfiguration({
    nodeUrl: params.nodeUrl,
    enclaveOptions: params.enclaveOptions
  });
}
export {
  IframeEnclave,
  createIDOSClient,
  idOSClientConfiguration,
  idOSClientIdle,
  idOSClientLoggedIn,
  idOSClientWithUserSigner,
  signNearMessage
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

axios/dist/browser/axios.cjs:
  (*! Axios v1.13.5 Copyright (c) 2026 Matt Zabriskie and contributors *)

long/umd/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

base58-universal/lib/index.js:
  (*!
   * Copyright (c) 2019-2022 Digital Bazaar, Inc. All rights reserved.
   *)

base64url-universal/lib/index.js:
crypto-ld/lib/LDKeyPair.js:
  (*!
   * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalbazaar/ed25519-verification-key-2020/lib/validators.js:
  (*!
   * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
   *)

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js:
crypto-ld/lib/CryptoLD.js:
  (*!
   * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js:
  (*!
   * Copyright (c) 2021-2024 Digital Bazaar, Inc. All rights reserved.
   *)

@digitalbazaar/ed25519-verification-key-2020/lib/index.js:
  (*!
   * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
   *)
*/
